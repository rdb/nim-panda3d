
import std/time_t

when defined(pandaDir):
  const pandaDir {.strdefine.}: string = ""
  when len(pandaDir) < 1:
    {.error: "pandaDir must not be an empty string when defined".}

when defined(vcc):
  {.passC: "/DNOMINMAX".}

  when defined(pandaDir):
    {.passC: "/I\"" & pandaDir & "/include\"".}
    {.passL: "\"" & pandaDir & "/lib/libpandaexpress.lib\"".}
    {.passL: "\"" & pandaDir & "/lib/libpanda.lib\"".}
    {.passL: "\"" & pandaDir & "/lib/libp3dtoolconfig.lib\"".}
    {.passL: "\"" & pandaDir & "/lib/libp3dtool.lib\"".}
  else:
    {.passL: "libpandaexpress.lib libpanda.lib libp3dtoolconfig.lib libp3dtool.lib".}

else:
  {.passL: "-lpandaexpress -lpanda -lp3dtoolconfig -lp3dtool".}

const deconstifyCode = """
#include "pointerTo.h"

template<class T> PT(T) deconstify(CPT(T) value) {
  PT(T) result;
  result.cheat() = (T *)value.p();
  value.cheat() = nullptr;
  return result;
}

template<class T> T *deconstify(const T *value) {
  return (T *)value;
}
""";

const stringConversionCode = """
#include <string>

N_LIB_PRIVATE N_NIMCALL(std::string, nimStringToStdString)(struct NimStringDesc *desc);
N_LIB_PRIVATE N_NIMCALL(struct NimStringDesc*, nimStringFromStdString)(const std::string &s);
""";

type
  std_string {.importcpp: "std::string", header: "string".} = object

type
  std_string_const_ref {.importcpp: "std::string const&", header: "string".} = object

func size(this: std_string_const_ref): int {.importcpp: "size".}

func nimStringFromStdString(s: std_string_const_ref): string {.noinit, exportcpp: "nimStringFromStdString"} =
  result = newString(s.size())
  {.emit: "memcpy(result->data, s.data(), s.size());"}

func nimStringToStdString(desc: string): std_string {.noinit, exportcpp: "nimStringToStdString"} =
  {.emit: "result = std::string(desc->data, desc->len);"}

const wrappedLVecBase2fCode = """
#include "lvecBase2.h"

struct alignas(LVecBase2f) WrappedLVecBase2f {
  float x = 0;
  float y = 0;

  constexpr WrappedLVecBase2f() = default;
  WrappedLVecBase2f(const LVecBase2f &v) : x(v[0]), y(v[1]) { }
  operator const LVecBase2f &() const { return *(const LVecBase2f *)this; }
  operator LVecBase2f &() { return *(LVecBase2f *)this; }
};
""";

const wrappedLVecBase2dCode = """
#include "lvecBase2.h"

struct alignas(LVecBase2d) WrappedLVecBase2d {
  double x = 0;
  double y = 0;

  constexpr WrappedLVecBase2d() = default;
  WrappedLVecBase2d(const LVecBase2d &v) : x(v[0]), y(v[1]) { }
  operator const LVecBase2d &() const { return *(const LVecBase2d *)this; }
  operator LVecBase2d &() { return *(LVecBase2d *)this; }
};
""";

const wrappedLVecBase2iCode = """
#include "lvecBase2.h"

struct alignas(LVecBase2i) WrappedLVecBase2i {
  int x = 0;
  int y = 0;

  constexpr WrappedLVecBase2i() = default;
  WrappedLVecBase2i(const LVecBase2i &v) : x(v[0]), y(v[1]) { }
  operator const LVecBase2i &() const { return *(const LVecBase2i *)this; }
  operator LVecBase2i &() { return *(LVecBase2i *)this; }
};
""";

const wrappedLVecBase3fCode = """
#include "lvecBase3.h"

struct alignas(LVecBase3f) WrappedLVecBase3f {
  float x = 0;
  float y = 0;
  float z = 0;

  constexpr WrappedLVecBase3f() = default;
  WrappedLVecBase3f(float v0, float v1, float v2) : x(v0), y(v1), z(v2) { }
  WrappedLVecBase3f(const LVecBase3f &v) : x(v[0]), y(v[1]), z(v[2]) { }
  operator const LVecBase3f &() const { return *(const LVecBase3f *)this; }
  operator LVecBase3f &() { return *(LVecBase3f *)this; }
};
""";

const wrappedLVecBase3dCode = """
#include "lvecBase3.h"

struct alignas(LVecBase3d) WrappedLVecBase3d {
  double x = 0;
  double y = 0;
  double z = 0;

  constexpr WrappedLVecBase3d() = default;
  WrappedLVecBase3d(const LVecBase3d &v) : x(v[0]), y(v[1]), z(v[2]) { }
  operator const LVecBase3d &() const { return *(const LVecBase3d *)this; }
  operator LVecBase3d &() { return *(LVecBase3d *)this; }
};
""";

const wrappedLVecBase3iCode = """
#include "lvecBase3.h"

struct alignas(LVecBase3i) WrappedLVecBase3i {
  int x = 0;
  int y = 0;
  int z = 0;

  constexpr WrappedLVecBase3i() = default;
  WrappedLVecBase3i(const LVecBase3i &v) : x(v[0]), y(v[1]), z(v[2]) { }
  operator const LVecBase3i &() const { return *(const LVecBase3i *)this; }
  operator LVecBase3i &() { return *(LVecBase3i *)this; }
};
""";

const wrappedLVecBase4fCode = """
#include "lvecBase4.h"

struct alignas(LVecBase4f) WrappedLVecBase4f {
  float x = 0;
  float y = 0;
  float z = 0;
  float w = 0;

  constexpr WrappedLVecBase4f() = default;
  WrappedLVecBase4f(const LVecBase4f &v) : x(v[0]), y(v[1]), z(v[2]), w(v[3]) { }
  WrappedLVecBase4f(const UnalignedLVecBase4f &v) : x(v[0]), y(v[1]), z(v[2]), w(v[3]) { }
  operator const LVecBase4f &() const { return *(const LVecBase4f *)this; }
  operator const UnalignedLVecBase4f &() const { return *(const UnalignedLVecBase4f *)this; }
  operator LVecBase4f &() { return *(LVecBase4f *)this; }
  operator UnalignedLVecBase4f &() { return *(UnalignedLVecBase4f *)this; }
};
"""

const wrappedLVecBase4dCode = """
#include "lvecBase4.h"

struct alignas(LVecBase4d) WrappedLVecBase4d {
  double x = 0;
  double y = 0;
  double z = 0;
  double w = 0;

  constexpr WrappedLVecBase4d() = default;
  WrappedLVecBase4d(const LVecBase4d &v) : x(v[0]), y(v[1]), z(v[2]), w(v[3]) { }
  WrappedLVecBase4d(const UnalignedLVecBase4d &v) : x(v[0]), y(v[1]), z(v[2]), w(v[3]) { }
  operator const LVecBase4d &() const { return *(const LVecBase4d *)this; }
  operator const UnalignedLVecBase4d &() const { return *(const UnalignedLVecBase4d *)this; }
  operator LVecBase4d &() { return *(LVecBase4d *)this; }
  operator UnalignedLVecBase4d &() { return *(UnalignedLVecBase4d *)this; }
};
""";

const wrappedLVecBase4iCode = """
#include "lvecBase4.h"

struct alignas(LVecBase4i) WrappedLVecBase4i {
  int x = 0;
  int y = 0;
  int z = 0;
  int w = 0;

  constexpr WrappedLVecBase4i() = default;
  WrappedLVecBase4i(const LVecBase4i &v) : x(v[0]), y(v[1]), z(v[2]), w(v[3]) { }
  WrappedLVecBase4i(const UnalignedLVecBase4i &v) : x(v[0]), y(v[1]), z(v[2]), w(v[3]) { }
  operator const LVecBase4i &() const { return *(const LVecBase4i *)this; }
  operator const UnalignedLVecBase4i &() const { return *(const UnalignedLVecBase4i *)this; }
  operator LVecBase4i &() { return *(LVecBase4i *)this; }
  operator UnalignedLVecBase4i &() { return *(UnalignedLVecBase4i *)this; }
};
""";

type NeverFreeMemory* {.importcpp: "NeverFreeMemory", pure, inheritable, header: "neverFreeMemory.h".} = object
  ## This class is used to allocate bytes of memory from a pool that is never
  ## intended to be freed.  It is particularly useful to support DeletedChain,
  ## which allocates memory in just such a fashion.
  ##
  ## When it is known that memory will not be freed, it is preferable to use
  ## this instead of the standard malloc() (or global_operator_new()) call,
  ## since this will help reduce fragmentation problems in the dynamic heap.
  ## Also, memory allocated from here will exhibit less wasted space.

type TypeHandle* {.importcpp: "TypeHandle", pure, header: "typeHandle.h".} = object
  ## TypeHandle is the identifier used to differentiate C++ class types.  Any
  ## C++ classes that inherit from some base class, and must be differentiated
  ## at run time, should store a static TypeHandle object that can be queried
  ## through a static member function named get_class_type().  Most of the time,
  ## it is also desirable to inherit from TypedObject, which provides some
  ## virtual functions to return the TypeHandle for a particular instance.
  ##
  ## At its essence, a TypeHandle is simply a unique identifier that is assigned
  ## by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
  ## that ancestry of a particular type may be queried, and the type name may be
  ## retrieved for run-time display.

type TypeRegistry* {.importcpp: "TypeRegistry", pure, inheritable, header: "typeRegistry.h".} = object
  ## The TypeRegistry class maintains all the assigned TypeHandles in a given
  ## system.  There should be only one TypeRegistry class during the lifetime of
  ## the application.  It will be created on the local heap initially, and it
  ## should be migrated to shared memory as soon as shared memory becomes
  ## available.

type TypedObject* {.importcpp: "TypedObject*", bycopy, pure, inheritable, header: "typedObject.h".} = object
  ## This is an abstract class that all classes which use TypeHandle, and also
  ## provide virtual functions to support polymorphism, should inherit from.
  ## Each derived class should define get_type(), which should return the
  ## specific type of the derived class.  Inheriting from this automatically
  ## provides support for is_of_type() and is_exact_type().
  ##
  ## All classes that inherit directly or indirectly from TypedObject should
  ## redefine get_type() and force_init_type(), as shown below.  Some classes
  ## that do not inherit from TypedObject may still declare TypeHandles for
  ## themselves by defining methods called get_class_type() and init_type().
  ## Classes such as these may serve as base classes, but the dynamic type
  ## identification system will be limited.  Classes that do not inherit from
  ## TypedObject need not define the virtual functions get_type() and
  ## force_init_type() (or any other virtual functions).
  ##
  ## There is a specific layout for defining the overrides from this class.
  ## Keeping the definitions formatted just like these examples will allow
  ## someone in the future to use a sed (or similar) script to make global
  ## changes, if necessary.  Avoid rearranging the braces or the order of the
  ## functions unless you're ready to change them in every file all at once.
  ##
  ## What follows are some examples that can be used in new classes that you
  ## create.
  ##
  ## @par In the class definition (.h file):
  ## @code
  ## public:
  ## static TypeHandle get_class_type() {
  ## return _type_handle;
  ## }
  ## static void init_type() {
  ## <<<BaseClassOne>>>::init_type();
  ## <<<BaseClassTwo>>>::init_type();
  ## <<<BaseClassN>>>::init_type();
  ## register_type(_type_handle, "<<<ThisClassStringName>>>",
  ## <<<BaseClassOne>>>::get_class_type(),
  ## <<<BaseClassTwo>>>::get_class_type(),
  ## <<<BaseClassN>>>::get_class_type());
  ## }
  ## virtual TypeHandle get_type() const {
  ## return get_class_type();
  ## }
  ## virtual TypeHandle force_init_type() {init_type(); return get_class_type();}
  ##
  ## private:
  ## static TypeHandle _type_handle;
  ## @endcode
  ##
  ## @par In the class .cxx file:
  ## @code
  ## TypeHandle <<<ThisClassStringName>>>::_type_handle;
  ## @endcode
  ##
  ## @par In the class config_<<<PackageName>>>.cxx file:
  ## @code
  ## ConfigureFn(config_<<<PackageName>>>) {
  ## <<<ClassOne>>>::init_type();
  ## <<<ClassTwo>>>::init_type();
  ## <<<ClassN>>>::init_type();
  ## }
  ## @endcode

converter toTypedObject*(_: type(nil)): TypedObject {.importcpp: "(nullptr)".}
converter toBool*(this: TypedObject): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TypedObject, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TypedObject], obj: TypedObject): TypedObject {.importcpp: "(@)".}

type ios_base* {.importcpp: "ios_base", pure, inheritable, header: "<ios>".} = object
  ## We need to expose one method in each class to force it to publish.
  ## But we'd like to expose some of these methods anyway, so no
  ## problem.

type istream* {.importcpp: "istream", pure, inheritable, header: "<istream>".} = object

type ostream* {.importcpp: "ostream", pure, inheritable, header: "<ostream>".} = object

type iostream* {.importcpp: "iostream", pure, inheritable, header: "<iostream>".} = object of istream

type fstream* {.importcpp: "fstream", pure, inheritable, header: "<fstream>".} = object of iostream

type ifstream* {.importcpp: "ifstream", pure, inheritable, header: "<fstream>".} = object of istream

type ofstream* {.importcpp: "ofstream", pure, inheritable, header: "<fstream>".} = object of ostream

type IFileStream* {.importcpp: "IFileStream", pure, inheritable, header: "pandaFileStream.h".} = object of istream
  ## Implements a C++ stream object suitable for reading from files on disk.
  ## This is similar to ifstream, but it provides low-level support for Panda's
  ## simple-threading implementation (using this interface will block only the
  ## current thread, rather than the entire process, on I/O waits).

type OFileStream* {.importcpp: "OFileStream", pure, inheritable, header: "pandaFileStream.h".} = object of ostream
  ## Implements a C++ stream object suitable for writing to files on disk.  This
  ## is similar to ofstream, but it provides low-level support for Panda's
  ## simple-threading implementation (using this interface will block only the
  ## current thread, rather than the entire process, on I/O waits).

type FileStream* {.importcpp: "FileStream", pure, inheritable, header: "pandaFileStream.h".} = object of iostream
  ## Implements a C++ stream object suitable for reading from and/or writing to
  ## files on disk.  This is similar to fstream, but it provides low-level
  ## support for Panda's simple-threading implementation (using this interface
  ## will block only the current thread, rather than the entire process, on I/O
  ## waits).

type pifstream* = IFileStream

type pofstream* = OFileStream

type pfstream* = FileStream

type TextEncoder* {.importcpp: "TextEncoder*", bycopy, pure, inheritable, header: "textEncoder.h".} = object
  ## This class can be used to convert text between multiple representations,
  ## e.g.  UTF-8 to UTF-16.  You may use it as a static class object, passing
  ## the encoding each time, or you may create an instance and use that object,
  ## which will record the current encoding and retain the current string.
  ##
  ## This class is also a base class of TextNode, which inherits this
  ## functionality.

converter toTextEncoder*(_: type(nil)): TextEncoder {.importcpp: "(nullptr)".}
converter toBool*(this: TextEncoder): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TextEncoder, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type Filename* {.importcpp: "Filename", pure, inheritable, header: "filename.h".} = object
  ## The name of a file, such as a texture file or an Egg file.  Stores the full
  ## pathname, and includes functions for extracting out the directory prefix
  ## part and the file extension and stuff.
  ##
  ## A Filename is also aware of the mapping between the Unix-like filename
  ## convention we use internally, and the local OS's specific filename
  ## convention, and it knows how to perform basic OS-specific I/O, like testing
  ## for file existence and searching a searchpath, as well as the best way to
  ## open an fstream for reading or writing.

type PandaSystem* {.importcpp: "PandaSystem", pure, inheritable, header: "pandaSystem.h".} = object
  ## This class is used as a namespace to group several global properties of
  ## Panda.  Application developers can use this class to query the runtime
  ## version or capabilities of the current Panda environment.

type DSearchPath* {.importcpp: "DSearchPath", pure, inheritable, header: "dSearchPath.h".} = object
  ## This class stores a list of directories that can be searched, in order, to
  ## locate a particular file.  It is normally constructed by passing it a
  ## traditional searchpath-style string, e.g.  a list of directory names
  ## delimited by spaces or colons, but it can also be built up explicitly.

type ExecutionEnvironment* {.importcpp: "ExecutionEnvironment", pure, inheritable, header: "executionEnvironment.h".} = object
  ## Encapsulates access to the environment variables and command-line arguments
  ## at the time of execution.  This is encapsulated to support accessing these
  ## things during static init time, which seems to be risky at best.

type GlobPattern* {.importcpp: "GlobPattern", pure, inheritable, header: "globPattern.h".} = object
  ## This class can be used to test for string matches against standard Unix-
  ## shell filename globbing conventions.  It serves as a portable standin for
  ## the Posix fnmatch() call.
  ##
  ## A GlobPattern is given a pattern string, which can contain operators like
  ## , ?, and [].  Then it can be tested against any number of candidate
  ## strings; for each candidate, it will indicate whether the string matches
  ## the pattern or not.  It can be used, for example, to scan a directory for
  ## all files matching a particular pattern.

type LineStream* {.importcpp: "LineStream", pure, inheritable, header: "lineStream.h".} = object of ostream
  ## This is a special ostream that writes to a memory buffer, like ostrstream.
  ## However, its contents can be continuously extracted as a sequence of lines
  ## of text.
  ##
  ## Unlike ostrstream, which can only be extracted from once (and then the
  ## buffer freezes and it can no longer be written to), the LineStream is not
  ## otherwise affected when a line of text is extracted.  More text can still
  ## be written to it and continuously extracted.

type ConfigFlags* {.importcpp: "ConfigFlags", pure, inheritable, header: "configFlags.h".} = object
  ## This class is the base class of both ConfigVariable and ConfigVariableCore.
  ## It exists only to provide a convenient name scoping for some enumerated
  ## values common to both classes.

type ConfigPage* {.importcpp: "ConfigPage", pure, inheritable, header: "configPage.h".} = object
  ## A page of ConfigDeclarations that may be loaded or unloaded.  Typically
  ## this represents a single .prc file that is read from disk at runtime, but
  ## it may also represent a list of declarations built up by application code
  ## and explicitly loaded.

type ConfigDeclaration* {.importcpp: "ConfigDeclaration", pure, inheritable, header: "configDeclaration.h".} = object of ConfigFlags
  ## A single declaration of a config variable, typically defined as one line in
  ## a .prc file, e.g.  "show-frame-rate-meter 1".  This is really just a
  ## pairing of a string name (actually, a ConfigVariableCore pointer) to a
  ## string value.

type ConfigVariableCore* {.importcpp: "ConfigVariableCore", pure, inheritable, header: "configVariableCore.h".} = object of ConfigFlags
  ## The internal definition of a ConfigVariable.  This object is shared between
  ## all instances of a ConfigVariable that use the same variable name.
  ##
  ## You cannot create a ConfigVariableCore instance directly; instead, use the
  ## make() method, which may return a shared instance.  Once created, these
  ## objects are never destructed.

type NotifySeverity* = enum
  NS_unspecified = 0
  NS_spam = 1
  NS_debug = 2
  NS_info = 3
  NS_warning = 4
  NS_error = 5
  NS_fatal = 6

type Notify* {.importcpp: "Notify", pure, inheritable, header: "pnotify.h".} = object
  ## An object that handles general error reporting to the user.  It contains a
  ## pointer to an ostream, initially cerr, which can be reset at will to point
  ## to different output devices, according to the needs of the application.
  ## All output generated within Panda should vector through the Notify ostream.
  ##
  ## This also includes a collection of Categories and Severities, which may be
  ## independently enabled or disabled, so that error messages may be squelched
  ## or respected according to the wishes of the user.

type ConfigPageManager* {.importcpp: "ConfigPageManager", pure, inheritable, header: "configPageManager.h".} = object of ConfigFlags
  ## A global object that maintains the set of ConfigPages everywhere in the
  ## world, and keeps them in sorted order.

type ConfigVariableManager* {.importcpp: "ConfigVariableManager", pure, inheritable, header: "configVariableManager.h".} = object
  ## A global object that maintains the set of ConfigVariables (actually,
  ## ConfigVariableCores) everywhere in the world, and keeps them in sorted
  ## order.

type ConfigVariableBase* {.importcpp: "ConfigVariableBase", pure, inheritable, header: "configVariableBase.h".} = object of ConfigFlags
  ## This class is the base class for both ConfigVariableList and ConfigVariable
  ## (and hence for all of the ConfigVariableBool, ConfigVaribleString, etc.
  ## classes).  It collects together the common interface for all generic
  ## ConfigVariables.
  ##
  ## Mostly, this class serves as a thin wrapper around ConfigVariableCore
  ## and/or ConfigDeclaration, more or less duplicating the interface presented
  ## there.

type ConfigVariable* {.importcpp: "ConfigVariable", pure, inheritable, header: "configVariable.h".} = object of ConfigVariableBase
  ## This is a generic, untyped ConfigVariable.  It is also the base class for
  ## the typed ConfigVariables, and contains all of the code common to
  ## ConfigVariables of all types (except ConfigVariableList, which is a bit of
  ## a special case).
  ##
  ## Mostly, this class serves as a thin wrapper around ConfigVariableCore
  ## and/or ConfigDeclaration, more or less duplicating the interface presented
  ## there.

type ConfigVariableBool* {.importcpp: "ConfigVariableBool", pure, inheritable, header: "configVariableBool.h".} = object of ConfigVariable
  ## This is a convenience class to specialize ConfigVariable as a boolean type.

type ConfigVariableDouble* {.importcpp: "ConfigVariableDouble", pure, inheritable, header: "configVariableDouble.h".} = object of ConfigVariable
  ## This is a convenience class to specialize ConfigVariable as a floating-
  ## point type.

type ConfigVariableFilename* {.importcpp: "ConfigVariableFilename", pure, inheritable, header: "configVariableFilename.h".} = object of ConfigVariable
  ## This is a convenience class to specialize ConfigVariable as a Filename
  ## type.  It is almost the same thing as ConfigVariableString, except it
  ## handles an implicit Filename::expand_from() operation so that the user may
  ## put OS-specific filenames, or filenames based on environment variables, in
  ## the prc file.

type ConfigVariableInt* {.importcpp: "ConfigVariableInt", pure, inheritable, header: "configVariableInt.h".} = object of ConfigVariable
  ## This is a convenience class to specialize ConfigVariable as an integer
  ## type.

type ConfigVariableInt64* {.importcpp: "ConfigVariableInt64", pure, inheritable, header: "configVariableInt64.h".} = object of ConfigVariable
  ## This is a convenience class to specialize ConfigVariable as a 64-bit
  ## integer type.

type ConfigVariableList* {.importcpp: "ConfigVariableList", pure, inheritable, header: "configVariableList.h".} = object of ConfigVariableBase
  ## This class is similar to ConfigVariable, but it reports its value as a list
  ## of strings.  In this special case, all of the declarations of the variable
  ## are returned as the elements of this list, in order.
  ##
  ## Note that this is different from a normal ConfigVariableString, which just
  ## returns its topmost value, which can optionally be treated as a number of
  ## discrete words by dividing it at the spaces.
  ##
  ## A ConfigVariableList cannot be modified locally.

type ConfigVariableSearchPath* {.importcpp: "ConfigVariableSearchPath", pure, inheritable, header: "configVariableSearchPath.h".} = object of ConfigVariableBase
  ## This is similar to a ConfigVariableList, but it returns its list as a
  ## DSearchPath, as a list of directories.
  ##
  ## You may locally append directories to the end of the search path with the
  ## methods here, or prepend them to the beginning.  Use these methods to make
  ## adjustments to the path; do not attempt to directly modify the const
  ## DSearchPath object returned by get_value().
  ##
  ## Unlike other ConfigVariable types, local changes (made by calling
  ## append_directory() and prepend_directory()) are specific to this particular
  ## instance of the ConfigVariableSearchPath.  A separate instance of the same
  ## variable, created by using the same name to the constructor, will not
  ## reflect the local changes.

type ConfigVariableString* {.importcpp: "ConfigVariableString", pure, inheritable, header: "configVariableString.h".} = object of ConfigVariable
  ## This is a convenience class to specialize ConfigVariable as a string type.

type NotifyCategory* {.importcpp: "NotifyCategory", pure, inheritable, header: "notifyCategory.h".} = object of ConfigFlags
  ## A particular category of error messages.  Typically there will be one of
  ## these per package, so that we can turn on or off error messages at least at
  ## a package level; further nested categories can be created within a package
  ## if a finer grain of control is required.

type IDecryptStream* {.importcpp: "IDecryptStream", pure, inheritable, header: "encryptStream.h".} = object of istream
  ## An input stream object that uses OpenSSL to decrypt the input from another
  ## source stream on-the-fly.
  ##
  ## Attach an IDecryptStream to an existing istream that provides encrypted
  ## data, as generated by an OEncryptStream, and read the corresponding
  ## unencrypted data from the IDecryptStream.
  ##
  ## Seeking is not supported.

type OEncryptStream* {.importcpp: "OEncryptStream", pure, inheritable, header: "encryptStream.h".} = object of ostream
  ## An input stream object that uses OpenSSL to encrypt data to another
  ## destination stream on-the-fly.
  ##
  ## Attach an OEncryptStream to an existing ostream that will accept encrypted
  ## data, and write your unencrypted source data to the OEncryptStream.
  ##
  ## Seeking is not supported.

type StreamReader* {.importcpp: "StreamReader", pure, inheritable, header: "streamReader.h".} = object
  ## A class to read sequential binary data directly from an istream.  Its
  ## interface is similar to DatagramIterator by design; see also StreamWriter.

type StreamWriter* {.importcpp: "StreamWriter", pure, inheritable, header: "streamWriter.h".} = object
  ## A StreamWriter object is used to write sequential binary data directly to
  ## an ostream.  Its interface is very similar to Datagram by design; it's
  ## primarily intended as a convenience to eliminate the overhead of writing
  ## bytes to a Datagram and then writing the Datagram to a stream.

type StreamWrapperBase* {.importcpp: "StreamWrapperBase", pure, inheritable, header: "streamWrapper.h".} = object
  ## The base class for both IStreamWrapper and OStreamWrapper, this provides
  ## the common locking interface.

type IStreamWrapper* {.importcpp: "IStreamWrapper", pure, inheritable, header: "streamWrapper.h".} = object of StreamWrapperBase
  ## This class provides a locking wrapper around an arbitrary istream pointer.
  ## A thread may use this class to perform an atomic seek/read/gcount
  ## operation.

type OStreamWrapper* {.importcpp: "OStreamWrapper", pure, inheritable, header: "streamWrapper.h".} = object of StreamWrapperBase
  ## This class provides a locking wrapper around an arbitrary ostream pointer.
  ## A thread may use this class to perform an atomic seek/write operation.

type StreamWrapper* {.importcpp: "StreamWrapper", pure, inheritable, header: "streamWrapper.h".} = object of IStreamWrapper
  ## This class provides a locking wrapper around a combination ostream/istream
  ## pointer.

type SSReader* {.importcpp: "SSReader*", bycopy, pure, inheritable, header: "socketStream.h".} = object
  ## An internal class for reading from a socket stream.  This serves as a base
  ## class for both ISocketStream and SocketStream; its purpose is to minimize
  ## redundant code between them.  Do not use it directly.

converter toSSReader*(_: type(nil)): SSReader {.importcpp: "(nullptr)".}
converter toBool*(this: SSReader): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SSReader, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type SSWriter* {.importcpp: "SSWriter*", bycopy, pure, inheritable, header: "socketStream.h".} = object
  ## An internal class for writing to a socket stream.  This serves as a base
  ## class for both OSocketStream and SocketStream; its purpose is to minimize
  ## redundant code between them.  Do not use it directly.

converter toSSWriter*(_: type(nil)): SSWriter {.importcpp: "(nullptr)".}
converter toBool*(this: SSWriter): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SSWriter, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type ISocketStream* {.importcpp: "ISocketStream*", bycopy, pure, inheritable, header: "socketStream.h".} = object of istream
  ## This is a base class for istreams implemented in Panda that read from a
  ## (possibly non-blocking) socket.  It adds is_closed(), which can be called
  ## after an eof condition to check whether the socket has been closed, or
  ## whether more data may be available later.

converter toISocketStream*(_: type(nil)): ISocketStream {.importcpp: "(nullptr)".}
converter toBool*(this: ISocketStream): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ISocketStream, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type OSocketStream* {.importcpp: "OSocketStream", pure, inheritable, header: "socketStream.h".} = object of ostream
  ## A base class for ostreams that write to a (possibly non-blocking) socket.
  ## It adds is_closed(), which can be called after any write operation fails to
  ## check whether the socket has been closed, or whether more data may be sent
  ## later.

type SocketStream* {.importcpp: "SocketStream", pure, inheritable, header: "socketStream.h".} = object of iostream
  ## A base class for iostreams that read and write to a (possibly non-blocking)
  ## socket.

type URLSpec* {.importcpp: "URLSpec", pure, inheritable, header: "urlSpec.h".} = object
  ## A container for a URL, e.g.  "http://server:port/path".
  ##
  ## The URLSpec object is similar to a Filename in that it contains logic to
  ## identify the various parts of a URL and return (or modify) them separately.

type HTTPEnum* {.importcpp: "HTTPEnum", pure, inheritable, header: "httpEnum.h".} = object
  ## This class is just used as a namespace wrapper for some of the enumerated
  ## types used by various classes within the HTTPClient family.

type HTTPDate* {.importcpp: "HTTPDate", pure, inheritable, header: "httpDate.h".} = object
  ## A container for an HTTP-legal time/date indication.  This can accept a
  ## string from an HTTP header and will decode it into a C time_t value;
  ## conversely, it can accept a time_t value and encode it for output as a
  ## string.

type HTTPCookie* {.importcpp: "HTTPCookie", pure, inheritable, header: "httpCookie.h".} = object
  ## A cookie sent from an HTTP server to be stored on the client and returned
  ## when the path and/or domain matches.

type ReferenceCount* {.importcpp: "PT(ReferenceCount)", bycopy, pure, inheritable, header: "referenceCount.h".} = object
  ## A base class for all things that want to be reference-counted.
  ## ReferenceCount works in conjunction with PointerTo to automatically delete
  ## objects when the last pointer to them goes away.

converter toReferenceCount*(_: type(nil)): ReferenceCount {.importcpp: "(nullptr)".}
converter toBool*(this: ReferenceCount): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ReferenceCount, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type HTTPClient* {.importcpp: "PT(HTTPClient)", bycopy, pure, inheritable, header: "httpClient.h".} = object of ReferenceCount
  ## Handles contacting an HTTP server and retrieving a document.  Each
  ## HTTPClient object represents a separate context, and stores its own list of
  ## cookies, passwords, and certificates; however, a given HTTPClient is
  ## capable of making multiple simultaneous requests to the same or different
  ## servers.
  ##
  ## It is up to the programmer whether one HTTPClient should be used to
  ## retrieve all documents, or a separate one should be created each time.
  ## There is a default, global HTTPClient available in
  ## HTTPClient::get_global_ptr().

converter toHTTPClient*(_: type(nil)): HTTPClient {.importcpp: "(nullptr)".}
converter toBool*(this: HTTPClient): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: HTTPClient, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[HTTPClient], obj: TypedObject): HTTPClient {.importcpp: "DCAST(HTTPClient, @)".}

type HTTPEntityTag* {.importcpp: "HTTPEntityTag", pure, inheritable, header: "httpEntityTag.h".} = object
  ## A container for an "entity tag" from an HTTP server.  This is used to
  ## identify a particular version of a document or resource, particularly
  ## useful for verifying caches.

type DocumentSpec* {.importcpp: "DocumentSpec", pure, inheritable, header: "documentSpec.h".} = object
  ## A descriptor that refers to a particular version of a document.  This
  ## includes the URL of the document and its identity tag and last-modified
  ## dates.
  ##
  ## The DocumentSpec may also be used to request a newer document than a
  ## particular one if available, for instance to refresh a cached document.

type TypedReferenceCount* {.importcpp: "PT(TypedReferenceCount)", bycopy, pure, inheritable, header: "typedReferenceCount.h".} = object of TypedObject
  ## A base class for things which need to inherit from both TypedObject and
  ## from ReferenceCount.  It's convenient to define this intermediate base
  ## class instead of multiply inheriting from the two classes each time they
  ## are needed, so that we can sensibly pass around pointers to things which
  ## are both TypedObjects and ReferenceCounters.
  ##
  ## See also TypedObject for detailed instructions.

converter toTypedReferenceCount*(_: type(nil)): TypedReferenceCount {.importcpp: "(nullptr)".}
converter toBool*(this: TypedReferenceCount): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TypedReferenceCount, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TypedReferenceCount], obj: TypedObject): TypedReferenceCount {.importcpp: "DCAST(TypedReferenceCount, @)".}

type HTTPChannel* {.importcpp: "PT(HTTPChannel)", bycopy, pure, inheritable, header: "httpChannel.h".} = object of TypedReferenceCount
  ## A single channel of communication from an HTTPClient.  This is similar to
  ## the concept of a 'connection', except that HTTP is technically
  ## connectionless; in fact, a channel may represent one unbroken connection or
  ## it may transparently close and reopen a new connection with each request.
  ##
  ## A channel is conceptually a single thread of I/O. One document at a time
  ## may be requested using a channel; a new document may (in general) not be
  ## requested from the same HTTPChannel until the first document has been fully
  ## retrieved.

converter toHTTPChannel*(_: type(nil)): HTTPChannel {.importcpp: "(nullptr)".}
converter toBool*(this: HTTPChannel): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: HTTPChannel, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[HTTPChannel], obj: TypedObject): HTTPChannel {.importcpp: "DCAST(HTTPChannel, @)".}

type Decompressor* {.importcpp: "Decompressor", pure, inheritable, header: "decompressor.h".} = object
  ## This manages run-time decompression of a zlib-compressed stream, as a
  ## background or foreground task.

type DownloadDb* {.importcpp: "DownloadDb", pure, inheritable, header: "downloadDb.h".} = object
  ## A listing of files within multifiles for management of client-side
  ## synchronization with a server-provided set of files.
  ##
  ## This class manages one copy of the database for the client, representing
  ## the files on the client system, and another copy for the server,
  ## representing the files the server has available.

type Extractor* {.importcpp: "Extractor", pure, inheritable, header: "extractor.h".} = object
  ## This class automatically extracts the contents of a Multifile to the
  ## current directory (or to a specified directory) in the background.
  ##
  ## It is designed to limit its use of system resources and run unobtrusively
  ## in the background.  After specifying the files you wish to extract via
  ## repeated calls to request_subfile(), begin the process by calling run()
  ## repeatedly.  Each call to run() extracts another small portion of the
  ## Multifile.  Call run() whenever you have spare cycles until run() returns
  ## EU_success.

type MultiplexStream* {.importcpp: "MultiplexStream", pure, inheritable, header: "multiplexStream.h".} = object of ostream
  ## This is a special ostream that forwards the data that is written to it to
  ## any number of other sources, for instance other ostreams, or explicitly to
  ## a disk file or to system logging utilities.  It's a very handy thing to set
  ## Notify to refer to when running in batch mode.

type VirtualFile* {.importcpp: "PT(VirtualFile)", bycopy, pure, inheritable, header: "virtualFile.h".} = object of TypedReferenceCount
  ## The abstract base class for a file or directory within the
  ## VirtualFileSystem.

converter toVirtualFile*(_: type(nil)): VirtualFile {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualFile): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualFile, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualFile], obj: TypedObject): VirtualFile {.importcpp: "DCAST(VirtualFile, @)".}

type VirtualFileHTTP* {.importcpp: "PT(VirtualFileHTTP)", bycopy, pure, inheritable, header: "virtualFileHTTP.h".} = object of VirtualFile
  ## This maps a document retrieved from an HTTPClient into the
  ## VirtualFileSystem, allowing models etc.  to be loaded directly from a web
  ## page.

converter toVirtualFileHTTP*(_: type(nil)): VirtualFileHTTP {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualFileHTTP): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualFileHTTP, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualFileHTTP], obj: TypedObject): VirtualFileHTTP {.importcpp: "DCAST(VirtualFileHTTP, @)".}

type VirtualFileMount* {.importcpp: "PT(VirtualFileMount)", bycopy, pure, inheritable, header: "virtualFileMount.h".} = object of TypedReferenceCount
  ## The abstract base class for a mount definition used within a
  ## VirtualFileSystem.  Normally users don't need to monkey with this class
  ## directly.

converter toVirtualFileMount*(_: type(nil)): VirtualFileMount {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualFileMount): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualFileMount, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualFileMount], obj: TypedObject): VirtualFileMount {.importcpp: "DCAST(VirtualFileMount, @)".}

type VirtualFileMountHTTP* {.importcpp: "PT(VirtualFileMountHTTP)", bycopy, pure, inheritable, header: "virtualFileMountHTTP.h".} = object of VirtualFileMount
  ## Maps a web page (URL root) into the VirtualFileSystem.

converter toVirtualFileMountHTTP*(_: type(nil)): VirtualFileMountHTTP {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualFileMountHTTP): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualFileMountHTTP, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualFileMountHTTP], obj: TypedObject): VirtualFileMountHTTP {.importcpp: "DCAST(VirtualFileMountHTTP, @)".}

type Patcher* {.importcpp: "Patcher*", bycopy, pure, inheritable, header: "patcher.h".} = object
  ## Applies a patch synchronously

converter toPatcher*(_: type(nil)): Patcher {.importcpp: "(nullptr)".}
converter toBool*(this: Patcher): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Patcher, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type StringStream* {.importcpp: "StringStream", pure, inheritable, header: "stringStream.h".} = object of iostream
  ## A bi-directional stream object that reads and writes data to an internal
  ## buffer, which can be retrieved and/or set as a string in Python 2 or a
  ## bytes object in Python 3.

type PointerToVoid* {.importcpp: "PointerToVoid", pure, inheritable, header: "pointerToVoid.h".} = object
  ## This is the non-template part of the base class for PointerTo and
  ## ConstPointerTo.  It is necessary so we can keep a pointer to a non-template
  ## class within the ReferenceCount object, to implement weak reference
  ## pointers--we need to have something to clean up when the ReferenceCount
  ## object destructs.
  ##
  ## This is the base class for PointerToBase<T>.

type MemoryUsage* {.importcpp: "MemoryUsage", pure, inheritable, header: "memoryUsage.h".} = object
  ## This class is used strictly for debugging purposes, specifically for
  ## tracking memory leaks of reference-counted objects: it keeps a record of
  ## every such object currently allocated.
  ##
  ## When compiled with NDEBUG set, this entire class does nothing and compiles
  ## to a stub.

type Buffer* {.importcpp: "PT(Buffer)", bycopy, pure, inheritable, header: "buffer.h".} = object of ReferenceCount

converter toBuffer*(_: type(nil)): Buffer {.importcpp: "(nullptr)".}
converter toBool*(this: Buffer): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Buffer, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Buffer], obj: TypedObject): Buffer {.importcpp: "DCAST(Buffer, @)".}

type PStatCollectorForwardBase* {.importcpp: "PT(PStatCollectorForwardBase)", bycopy, pure, inheritable, header: "pStatCollectorForwardBase.h".} = object of ReferenceCount
  ## This class serves as a cheap forward reference to a PStatCollector, which
  ## is defined in the pstatclient module (and is not directly accessible here
  ## in the express module).
  ##
  ## This is subclassed as PStatCollectorForward, which defines the actual
  ## functionality.

converter toPStatCollectorForwardBase*(_: type(nil)): PStatCollectorForwardBase {.importcpp: "(nullptr)".}
converter toBool*(this: PStatCollectorForwardBase): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PStatCollectorForwardBase, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PStatCollectorForwardBase], obj: TypedObject): PStatCollectorForwardBase {.importcpp: "DCAST(PStatCollectorForwardBase, @)".}

type NodeReferenceCount* {.importcpp: "PT(NodeReferenceCount)", bycopy, pure, inheritable, header: "nodeReferenceCount.h".} = object of ReferenceCount
  ## This class specializes ReferenceCount to add an additional counter, called
  ## node_ref_count, for the purposes of counting the number of times the object
  ## is referenced by a "node", whatever that may mean in context.
  ##
  ## The new methods node_ref() and node_unref() automatically increment and
  ## decrement the primary reference count as well.  There also exists a
  ## NodePointerTo<> class to maintain the node_ref counters automatically.
  ##
  ## See also CachedTypedWritableReferenceCount, which is similar in principle,
  ## as well as NodeCachedReferenceCount, which combines both of these.

converter toNodeReferenceCount*(_: type(nil)): NodeReferenceCount {.importcpp: "(nullptr)".}
converter toBool*(this: NodeReferenceCount): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: NodeReferenceCount, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[NodeReferenceCount], obj: TypedObject): NodeReferenceCount {.importcpp: "DCAST(NodeReferenceCount, @)".}

type Datagram* {.importcpp: "Datagram", pure, inheritable, header: "datagram.h".} = object of TypedObject
  ## An ordered list of data elements, formatted in memory for transmission over
  ## a socket or writing to a data file.
  ##
  ## Data elements should be added one at a time, in order, to the Datagram.
  ## The nature and contents of the data elements are totally up to the user.
  ## When a Datagram has been transmitted and received, its data elements may be
  ## extracted using a DatagramIterator; it is up to the caller to know the
  ## correct type of each data element in order.
  ##
  ## A Datagram is itself headerless; it is simply a collection of data
  ## elements.

type DatagramGenerator* {.importcpp: "DatagramGenerator*", bycopy, pure, inheritable, header: "datagramGenerator.h".} = object
  ## This class defines the abstract interace to any source of datagrams,
  ## whether it be from a file or from the net.

converter toDatagramGenerator*(_: type(nil)): DatagramGenerator {.importcpp: "(nullptr)".}
converter toBool*(this: DatagramGenerator): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DatagramGenerator, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type DatagramIterator* {.importcpp: "DatagramIterator", pure, inheritable, header: "datagramIterator.h".} = object
  ## A class to retrieve the individual data elements previously stored in a
  ## Datagram.  Elements may be retrieved one at a time; it is up to the caller
  ## to know the correct type and order of each element.
  ##
  ## Note that it is the responsibility of the caller to ensure that the datagram
  ## object is not destructed while this DatagramIterator is in use.

type DatagramSink* {.importcpp: "DatagramSink*", bycopy, pure, inheritable, header: "datagramSink.h".} = object
  ## This class defines the abstract interface to sending datagrams to any
  ## target, whether it be into a file or across the net

converter toDatagramSink*(_: type(nil)): DatagramSink {.importcpp: "(nullptr)".}
converter toBool*(this: DatagramSink): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DatagramSink, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type FileReference* {.importcpp: "PT(FileReference)", bycopy, pure, inheritable, header: "fileReference.h".} = object of TypedReferenceCount
  ## Keeps a reference-counted pointer to a file on disk.  As long as the
  ## FileReference is held, someone presumably has a use for this file.

converter toFileReference*(_: type(nil)): FileReference {.importcpp: "(nullptr)".}
converter toBool*(this: FileReference): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: FileReference, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[FileReference], obj: TypedObject): FileReference {.importcpp: "DCAST(FileReference, @)".}

type ErrorUtilCode* = enum
  EU_error_zlib = -80
  EU_error_http_proxy_authentication = -73
  EU_error_http_service_unavailable = -72
  EU_error_http_gateway_timeout = -71
  EU_error_http_server_timeout = -70
  EU_error_write_file_rename = -67
  EU_error_write_disk_fault = -66
  EU_error_write_disk_sector_not_found = -65
  EU_error_write_disk_not_found = -64
  EU_error_write_disk_full = -63
  EU_error_write_sharing_violation = -62
  EU_error_write_out_of_memory = -61
  EU_error_write_out_of_files = -60
  EU_error_network_remote_host_no_response = -54
  EU_error_network_remote_host_not_found = -53
  EU_error_network_remote_host_unreachable = -52
  EU_error_network_remote_host_down = -51
  EU_error_network_remote_host_disconnected = -50
  EU_error_network_disk_quota_exceeded = -42
  EU_error_network_buffer_overflow = -41
  EU_error_network_disconnected_locally = -40
  EU_error_network_no_data = -34
  EU_error_network_timeout = -33
  EU_error_network_disconnected = -32
  EU_error_network_unreachable = -31
  EU_error_network_dead = -30
  EU_error_invalid_checksum = -4
  EU_error_file_invalid = -3
  EU_error_file_empty = -2
  EU_error_abort = -1
  EU_success = 1
  EU_ok = 2
  EU_write = 3
  EU_write_ram = 4
  EU_network_no_data = 5
  EU_eof = 6
  EU_http_redirect = 7

type Ramfile* {.importcpp: "Ramfile", pure, inheritable, header: "ramfile.h".} = object
  ## An in-memory buffer specifically designed for downloading files to memory.

type HashVal* {.importcpp: "HashVal", pure, inheritable, header: "hashVal.h".} = object
  ## Stores a 128-bit value that represents the hashed contents (typically MD5)
  ## of a file or buffer.

type MemoryUsagePointers* {.importcpp: "MemoryUsagePointers", pure, inheritable, header: "memoryUsagePointers.h".} = object
  ## This is a list of pointers returned by a MemoryUsage object in response to
  ## some query.
  ##
  ## Warning: once pointers are stored in a MemoryUsagePointers object, they are
  ## reference-counted, and will not be freed until the MemoryUsagePointers
  ## object is freed (or clear() is called on the object).  However, they may
  ## not even be freed then; pointers may leak once they have been added to this
  ## structure.  This is because we don't store enough information in this
  ## structure to correctly free the pointers that have been added.  Since this
  ## is intended primarily as a debugging tool, this is not a major issue.
  ##
  ## This class is just a user interface to talk about pointers stored in a
  ## MemoryUsage object.  It doesn't even exist when compiled with NDEBUG.

type ISubStream* {.importcpp: "ISubStream", pure, inheritable, header: "subStream.h".} = object of istream
  ## An istream object that presents a subwindow into another istream.  The
  ## first character read from this stream will be the "start" character from
  ## the source istream; just before the file pointer reaches the "end"
  ## character, eof is returned.
  ##
  ## The source stream must be one that we can randomly seek within.  The
  ## resulting ISubStream will also support arbitrary seeks.

type OSubStream* {.importcpp: "OSubStream", pure, inheritable, header: "subStream.h".} = object of ostream
  ## An ostream object that presents a subwindow into another ostream.  The
  ## first character written to this stream will be the "start" character in the
  ## dest istream; no characters may be written to character "end" or later
  ## (unless end is zero).
  ##
  ## The dest stream must be one that we can randomly seek within.  The
  ## resulting OSubStream will also support arbitrary seeks.

type SubStream* {.importcpp: "SubStream", pure, inheritable, header: "subStream.h".} = object of iostream
  ## Combined ISubStream and OSubStream for bidirectional I/O.

type Multifile* {.importcpp: "PT(Multifile)", bycopy, pure, inheritable, header: "multifile.h".} = object of ReferenceCount
  ## A file that contains a set of files.

converter toMultifile*(_: type(nil)): Multifile {.importcpp: "(nullptr)".}
converter toBool*(this: Multifile): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Multifile, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Multifile], obj: TypedObject): Multifile {.importcpp: "DCAST(Multifile, @)".}

type Namable* {.importcpp: "Namable*", bycopy, pure, inheritable, header: "namable.h".} = object
  ## A base class for all things which can have a name.  The name is either
  ## empty or nonempty, but it is never NULL.

converter toNamable*(_: type(nil)): Namable {.importcpp: "(nullptr)".}
converter toBool*(this: Namable): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Namable, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type OpenSSLWrapper* {.importcpp: "OpenSSLWrapper", pure, inheritable, header: "openSSLWrapper.h".} = object
  ## Provides an interface wrapper around the OpenSSL library, to ensure that
  ## the library is properly initialized in the application, and to provide some
  ## hooks into global OpenSSL context data.

type SubfileInfo* {.importcpp: "SubfileInfo", pure, inheritable, header: "subfileInfo.h".} = object
  ## This class records a particular byte sub-range within an existing file on
  ## disk.  Generally, the filename is understood as a physical file on disk,
  ## and not to be looked up via the vfs.

type VirtualFileComposite* {.importcpp: "PT(VirtualFileComposite)", bycopy, pure, inheritable, header: "virtualFileComposite.h".} = object of VirtualFile
  ## A composite directory within the VirtualFileSystem: this maps to more than
  ## one directory on different mount points.  The resulting directory appears
  ## to be the union of all the individual simple directories.

converter toVirtualFileComposite*(_: type(nil)): VirtualFileComposite {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualFileComposite): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualFileComposite, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualFileComposite], obj: TypedObject): VirtualFileComposite {.importcpp: "DCAST(VirtualFileComposite, @)".}

type VirtualFileMountMultifile* {.importcpp: "PT(VirtualFileMountMultifile)", bycopy, pure, inheritable, header: "virtualFileMountMultifile.h".} = object of VirtualFileMount
  ## Maps a Multifile's contents into the VirtualFileSystem.

converter toVirtualFileMountMultifile*(_: type(nil)): VirtualFileMountMultifile {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualFileMountMultifile): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualFileMountMultifile, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualFileMountMultifile], obj: TypedObject): VirtualFileMountMultifile {.importcpp: "DCAST(VirtualFileMountMultifile, @)".}

type VirtualFileMountRamdisk* {.importcpp: "PT(VirtualFileMountRamdisk)", bycopy, pure, inheritable, header: "virtualFileMountRamdisk.h".} = object of VirtualFileMount
  ## Simulates an actual directory on disk with in-memory storage.  This is
  ## useful mainly for performing high level functions that expect disk I/O
  ## without actually writing files to disk.  Naturally, there are significant
  ## limits to the size of the files that may be written with this system; and
  ## "files" written here are not automatically persistent between sessions.

converter toVirtualFileMountRamdisk*(_: type(nil)): VirtualFileMountRamdisk {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualFileMountRamdisk): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualFileMountRamdisk, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualFileMountRamdisk], obj: TypedObject): VirtualFileMountRamdisk {.importcpp: "DCAST(VirtualFileMountRamdisk, @)".}

type VirtualFileMountSystem* {.importcpp: "PT(VirtualFileMountSystem)", bycopy, pure, inheritable, header: "virtualFileMountSystem.h".} = object of VirtualFileMount
  ## Maps an actual OS directory into the VirtualFileSystem.

converter toVirtualFileMountSystem*(_: type(nil)): VirtualFileMountSystem {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualFileMountSystem): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualFileMountSystem, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualFileMountSystem], obj: TypedObject): VirtualFileMountSystem {.importcpp: "DCAST(VirtualFileMountSystem, @)".}

type VirtualFileSimple* {.importcpp: "PT(VirtualFileSimple)", bycopy, pure, inheritable, header: "virtualFileSimple.h".} = object of VirtualFile
  ## A simple file or directory within the VirtualFileSystem: this maps to
  ## exactly one file on one mount point.  Most directories, and all regular
  ## files, are of this kind.

converter toVirtualFileSimple*(_: type(nil)): VirtualFileSimple {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualFileSimple): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualFileSimple, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualFileSimple], obj: TypedObject): VirtualFileSimple {.importcpp: "DCAST(VirtualFileSimple, @)".}

type TemporaryFile* {.importcpp: "PT(TemporaryFile)", bycopy, pure, inheritable, header: "temporaryFile.h".} = object of FileReference
  ## This is a special kind of FileReference class that automatically deletes
  ## the file in question when it is deleted.  It is not responsible for
  ## creating, opening, or closing the file, however.

converter toTemporaryFile*(_: type(nil)): TemporaryFile {.importcpp: "(nullptr)".}
converter toBool*(this: TemporaryFile): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TemporaryFile, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TemporaryFile], obj: TypedObject): TemporaryFile {.importcpp: "DCAST(TemporaryFile, @)".}

type IDecompressStream* {.importcpp: "IDecompressStream", pure, inheritable, header: "zStream.h".} = object of istream
  ## An input stream object that uses zlib to decompress (inflate) the input
  ## from another source stream on-the-fly.
  ##
  ## Attach an IDecompressStream to an existing istream that provides compressed
  ## data, and read the corresponding uncompressed data from the
  ## IDecompressStream.
  ##
  ## Seeking is not supported.

type OCompressStream* {.importcpp: "OCompressStream", pure, inheritable, header: "zStream.h".} = object of ostream
  ## An input stream object that uses zlib to compress (deflate) data to another
  ## destination stream on-the-fly.
  ##
  ## Attach an OCompressStream to an existing ostream that will accept
  ## compressed data, and write your uncompressed source data to the
  ## OCompressStream.
  ##
  ## Seeking is not supported.

type VirtualFileList* {.importcpp: "PT(VirtualFileList)", bycopy, pure, inheritable, header: "virtualFileList.h".} = object of ReferenceCount
  ## A list of VirtualFiles, as returned by VirtualFile::scan_directory().

converter toVirtualFileList*(_: type(nil)): VirtualFileList {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualFileList): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualFileList, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualFileList], obj: TypedObject): VirtualFileList {.importcpp: "DCAST(VirtualFileList, @)".}

type VirtualFileSystem* {.importcpp: "VirtualFileSystem", pure, inheritable, header: "virtualFileSystem.h".} = object
  ## A hierarchy of directories and files that appears to be one continuous file
  ## system, even though the files may originate from several different sources
  ## that may not be related to the actual OS's file system.
  ##
  ## For instance, a VirtualFileSystem can transparently mount one or more
  ## Multifiles as their own subdirectory hierarchies.

type TrueClock* {.importcpp: "TrueClock", pure, inheritable, header: "trueClock.h".} = object
  ## An interface to whatever real-time clock we might have available in the
  ## current environment.  There is only one TrueClock in existence, and it
  ## constructs itself.
  ##
  ## The TrueClock returns elapsed real time in seconds since some undefined
  ## epoch.  Since it is not defined at what time precisely the clock indicates
  ## zero, this value can only be meaningfully used to measure elapsed time, by
  ## sampling it at two different times and subtracting.

type Patchfile* {.importcpp: "Patchfile", pure, inheritable, header: "patchfile.h".} = object

type ProfileTimer* {.importcpp: "ProfileTimer", pure, inheritable, header: "profileTimer.h".} = object
  ## ProfileTimer
  ##
  ## HowTo:
  ## Create a ProfileTimer and hold onto it.
  ## Call init() whenever you like (the timer doesn't
  ## start yet).
  ## Call on() to start the timer.
  ## While the timer is on, call mark() at each point of interest,
  ## in the code you are timing.
  ## You can turn the timer off() and on() to skip things you
  ## don't want to time.
  ## When your timing is finished, call printTo() to see the
  ## results (e.g. myTimer.printTo(cerr)).
  ##
  ## Notes:
  ## You should be able to time things down to the millisecond
  ## well enough, but if you call on() and off() within micro-
  ## seconds of each other, I don't think you'll get very good
  ## results.

type WeakPointerToVoid* {.importcpp: "WeakPointerToVoid", pure, inheritable, header: "weakPointerToVoid.h".} = object of PointerToVoid
  ## This is the specialization of PointerToVoid for weak pointers.  It needs an
  ## additional flag to indicate that the pointer has been deleted.

type WindowsRegistry* {.importcpp: "WindowsRegistry", pure, inheritable, header: "windowsRegistry.h".} = object
  ## This class provides a hook to Python to read and write strings and integers
  ## to the windows registry.  It automatically converts strings from utf-8
  ## encoding and stores them in Unicode (and conversely reconverts them on
  ## retrieval).

type RecorderBase* {.importcpp: "RecorderBase*", bycopy, pure, inheritable, header: "recorderBase.h".} = object
  ## This is the base class to a number of objects that record particular kinds
  ## of user input (like a MouseRecorder) to use in conjunction with a
  ## RecorderController to record the user's inputs for a session.
  ##
  ## Note that RecorderBase does not actually inherit from TypedObject, even
  ## though it defines get_type().  The assumption is that the classes that
  ## derive from RecorderBase might also inherit independently from TypedObject.
  ##
  ## It also does not inherit from TypedWritable, but it defines a method called
  ## write_recorder() which is very similar to a TypedWritable's
  ## write_datagram(). Classes that derive from RecorderBase and also inherit
  ## from TypedWritable may choose to remap write_recorder() to do exactly the
  ## same thing as write_datagram(), or they may choose to write something
  ## slightly different.
  ##
  ## Most types of recorders should derive from Recorder, as it derives from
  ## ReferenceCount, except for MouseRecorder, which would otherwise doubly
  ## inherit from ReferenceCount.

converter toRecorderBase*(_: type(nil)): RecorderBase {.importcpp: "(nullptr)".}
converter toBool*(this: RecorderBase): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RecorderBase, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type TypedWritable* {.importcpp: "TypedWritable*", bycopy, pure, inheritable, header: "typedWritable.h".} = object of TypedObject
  ## Base class for objects that can be written to and read from Bam files.
  ##
  ## See also TypedObject for detailed instructions.

converter toTypedWritable*(_: type(nil)): TypedWritable {.importcpp: "(nullptr)".}
converter toBool*(this: TypedWritable): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TypedWritable, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type TypedWritableReferenceCount* {.importcpp: "PT(TypedWritableReferenceCount)", bycopy, pure, inheritable, header: "typedWritableReferenceCount.h".} = object of TypedWritable
  ## A base class for things which need to inherit from both TypedWritable and
  ## from ReferenceCount.  It's convenient to define this intermediate base
  ## class instead of multiply inheriting from the two classes each time they
  ## are needed, so that we can sensibly pass around pointers to things which
  ## are both TypedWritables and ReferenceCounters.
  ##
  ## See also TypedObject for detailed instructions.

converter toTypedWritableReferenceCount*(_: type(nil)): TypedWritableReferenceCount {.importcpp: "(nullptr)".}
converter toBool*(this: TypedWritableReferenceCount): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TypedWritableReferenceCount, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TypedWritableReferenceCount], obj: TypedObject): TypedWritableReferenceCount {.importcpp: "DCAST(TypedWritableReferenceCount, @)".}

type PandaNode* {.importcpp: "PT(PandaNode)", bycopy, pure, inheritable, header: "pandaNode.h".} = object of TypedWritableReferenceCount
  ## A basic node of the scene graph or data graph.  This is the base class of
  ## all specialized nodes, and also serves as a generic node with no special
  ## properties.

converter toPandaNode*(_: type(nil)): PandaNode {.importcpp: "(nullptr)".}
converter toBool*(this: PandaNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PandaNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PandaNode], obj: TypedObject): PandaNode {.importcpp: "DCAST(PandaNode, @)".}

type DataNode* {.importcpp: "PT(DataNode)", bycopy, pure, inheritable, header: "dataNode.h".} = object of PandaNode
  ## The fundamental type of node for the data graph.  The DataNode class is
  ## itself primarily intended as an abstract class; it defines no inputs and no
  ## outputs.  Most kinds of data nodes will derive from this to specify the
  ## inputs and outputs in the constructor.
  ##
  ## DataNode does not attempt to cycle its data with a PipelineCycler.  The
  ## data graph is intended to be used only within a single thread.

converter toDataNode*(_: type(nil)): DataNode {.importcpp: "(nullptr)".}
converter toBool*(this: DataNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DataNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DataNode], obj: TypedObject): DataNode {.importcpp: "DCAST(DataNode, @)".}

type MouseRecorder* {.importcpp: "PT(MouseRecorder)", bycopy, pure, inheritable, header: "mouseRecorder.h".} = object of DataNode
  ## This object records any data generated by a particular MouseAndKeyboard
  ## node on the datagraph for a session for eventual playback via a
  ## DataGraphPlayback (and a PlaybackController).  To use it, make it a child
  ## of the node you wish to record.  It also serves as a pass-through, so that
  ## additional child nodes may be parented directly to it.

converter toMouseRecorder*(_: type(nil)): MouseRecorder {.importcpp: "(nullptr)".}
converter toBool*(this: MouseRecorder): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MouseRecorder, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MouseRecorder], obj: TypedObject): MouseRecorder {.importcpp: "DCAST(MouseRecorder, @)".}

type RecorderController* {.importcpp: "PT(RecorderController)", bycopy, pure, inheritable, header: "recorderController.h".} = object of TypedReferenceCount
  ## This object manages the process of recording the user's runtime inputs to a
  ## bam file so that the session can be recreated later.

converter toRecorderController*(_: type(nil)): RecorderController {.importcpp: "(nullptr)".}
converter toBool*(this: RecorderController): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RecorderController, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[RecorderController], obj: TypedObject): RecorderController {.importcpp: "DCAST(RecorderController, @)".}

type SocketStreamRecorder* {.importcpp: "PT(SocketStreamRecorder)", bycopy, pure, inheritable, header: "socketStreamRecorder.h".} = object of RecorderBase
  ## Records any data received from the indicated socket stream.  On playback,
  ## it will act as if the incoming data is coming over the wire again even if
  ## an actual connection is not available.
  ##
  ## Outbound data will not be recorded, but will be sent straight through to
  ## the socket if it is connected, or silently ignored if it is not.

converter toSocketStreamRecorder*(_: type(nil)): SocketStreamRecorder {.importcpp: "(nullptr)".}
converter toBool*(this: SocketStreamRecorder): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SocketStreamRecorder, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[SocketStreamRecorder], obj: TypedObject): SocketStreamRecorder {.importcpp: "DCAST(SocketStreamRecorder, @)".}

type Light* {.importcpp: "Light*", bycopy, pure, inheritable, header: "light.h".} = object
  ## The abstract interface to all kinds of lights.  The actual light objects
  ## also inherit from PandaNode, and can therefore be added to the scene graph
  ## at some arbitrary point to define the coordinate system of effect.

converter toLight*(_: type(nil)): Light {.importcpp: "(nullptr)".}
converter toBool*(this: Light): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Light, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type LightNode* {.importcpp: "PT(LightNode)", bycopy, pure, inheritable, header: "lightNode.h".} = object of PandaNode
  ## A derivative of Light and of PandaNode.  All kinds of Light except
  ## Spotlight (which must inherit from LensNode instead) inherit from this
  ## class.

converter toLightNode*(_: type(nil)): LightNode {.importcpp: "(nullptr)".}
converter toBool*(this: LightNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: LightNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[LightNode], obj: TypedObject): LightNode {.importcpp: "DCAST(LightNode, @)".}

type AmbientLight* {.importcpp: "PT(AmbientLight)", bycopy, pure, inheritable, header: "ambientLight.h".} = object of LightNode
  ## A light source that seems to illuminate all points in space at once.  This
  ## kind of light need not actually be part of the scene graph, since it has no
  ## meaningful position.

converter toAmbientLight*(_: type(nil)): AmbientLight {.importcpp: "(nullptr)".}
converter toBool*(this: AmbientLight): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AmbientLight, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AmbientLight], obj: TypedObject): AmbientLight {.importcpp: "DCAST(AmbientLight, @)".}

type CallbackNode* {.importcpp: "PT(CallbackNode)", bycopy, pure, inheritable, header: "callbackNode.h".} = object of PandaNode
  ## A special node that can issue arbitrary callbacks to user code, either
  ## during the cull or draw traversals.

converter toCallbackNode*(_: type(nil)): CallbackNode {.importcpp: "(nullptr)".}
converter toBool*(this: CallbackNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CallbackNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CallbackNode], obj: TypedObject): CallbackNode {.importcpp: "DCAST(CallbackNode, @)".}

type ComputeNode* {.importcpp: "PT(ComputeNode)", bycopy, pure, inheritable, header: "computeNode.h".} = object of PandaNode
  ## A special node, the sole purpose of which is to invoke a dispatch operation
  ## on the assigned compute shader.

converter toComputeNode*(_: type(nil)): ComputeNode {.importcpp: "(nullptr)".}
converter toBool*(this: ComputeNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ComputeNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ComputeNode], obj: TypedObject): ComputeNode {.importcpp: "DCAST(ComputeNode, @)".}

type LODNodeType* = enum
  LNT_pop = 0
  LNT_fade = 1

type LensNode* {.importcpp: "PT(LensNode)", bycopy, pure, inheritable, header: "lensNode.h".} = object of PandaNode
  ## A node that contains a Lens.  The most important example of this kind of
  ## node is a Camera, but other kinds of nodes also contain a lens (for
  ## instance, a Spotlight).

converter toLensNode*(_: type(nil)): LensNode {.importcpp: "(nullptr)".}
converter toBool*(this: LensNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: LensNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[LensNode], obj: TypedObject): LensNode {.importcpp: "DCAST(LensNode, @)".}

type Camera* {.importcpp: "PT(Camera)", bycopy, pure, inheritable, header: "camera.h".} = object of LensNode
  ## A node that can be positioned around in the scene graph to represent a
  ## point of view for rendering a scene.

converter toCamera*(_: type(nil)): Camera {.importcpp: "(nullptr)".}
converter toBool*(this: Camera): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Camera, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Camera], obj: TypedObject): Camera {.importcpp: "DCAST(Camera, @)".}

type LightLensNode* {.importcpp: "PT(LightLensNode)", bycopy, pure, inheritable, header: "lightLensNode.h".} = object of Camera
  ## A derivative of Light and of Camera.  The name might be misleading: it does
  ## not directly derive from LensNode, but through the Camera class.  The
  ## Camera serves no purpose unless shadows are enabled.

converter toLightLensNode*(_: type(nil)): LightLensNode {.importcpp: "(nullptr)".}
converter toBool*(this: LightLensNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: LightLensNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[LightLensNode], obj: TypedObject): LightLensNode {.importcpp: "DCAST(LightLensNode, @)".}

type DirectionalLight* {.importcpp: "PT(DirectionalLight)", bycopy, pure, inheritable, header: "directionalLight.h".} = object of LightLensNode
  ## A light shining from infinitely far away in a particular direction, like
  ## sunlight.

converter toDirectionalLight*(_: type(nil)): DirectionalLight {.importcpp: "(nullptr)".}
converter toBool*(this: DirectionalLight): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DirectionalLight, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DirectionalLight], obj: TypedObject): DirectionalLight {.importcpp: "DCAST(DirectionalLight, @)".}

type LODNode* {.importcpp: "PT(LODNode)", bycopy, pure, inheritable, header: "lodNode.h".} = object of PandaNode
  ## A Level-of-Detail node.  This selects only one of its children for
  ## rendering, according to the distance from the camera and the table
  ## indicated in the associated LOD object.

converter toLODNode*(_: type(nil)): LODNode {.importcpp: "(nullptr)".}
converter toBool*(this: LODNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: LODNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[LODNode], obj: TypedObject): LODNode {.importcpp: "DCAST(LODNode, @)".}

type FadeLODNode* {.importcpp: "PT(FadeLODNode)", bycopy, pure, inheritable, header: "fadeLodNode.h".} = object of LODNode
  ## A Level-of-Detail node with alpha based switching.

converter toFadeLODNode*(_: type(nil)): FadeLODNode {.importcpp: "(nullptr)".}
converter toBool*(this: FadeLODNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: FadeLODNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[FadeLODNode], obj: TypedObject): FadeLODNode {.importcpp: "DCAST(FadeLODNode, @)".}

type CallbackData* {.importcpp: "CallbackData", pure, inheritable, header: "callbackData.h".} = object of TypedObject
  ## This is a generic data block that is passed along to a CallbackObject when
  ## a callback is made.  It contains data specific to the particular callback
  ## type in question.
  ##
  ## This is actually an abstract base class and contains no data.
  ## Specializations of this class will contain the actual data relevant to each
  ## callback type.

type NodeCullCallbackData* {.importcpp: "NodeCullCallbackData", pure, inheritable, header: "nodeCullCallbackData.h".} = object of CallbackData
  ## This kind of CallbackData is passed to the CallbackObject added to
  ## CallbackNode:set_cull_callback().

type PointLight* {.importcpp: "PT(PointLight)", bycopy, pure, inheritable, header: "pointLight.h".} = object of LightLensNode
  ## A light originating from a single point in space, and shining in all
  ## directions.

converter toPointLight*(_: type(nil)): PointLight {.importcpp: "(nullptr)".}
converter toBool*(this: PointLight): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PointLight, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PointLight], obj: TypedObject): PointLight {.importcpp: "DCAST(PointLight, @)".}

type RectangleLight* {.importcpp: "PT(RectangleLight)", bycopy, pure, inheritable, header: "rectangleLight.h".} = object of LightLensNode
  ## This is a type of area light that is an axis aligned rectangle, pointing
  ## along the Y axis in the positive direction.
  ##
  ## @since 1.10.0

converter toRectangleLight*(_: type(nil)): RectangleLight {.importcpp: "(nullptr)".}
converter toBool*(this: RectangleLight): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RectangleLight, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[RectangleLight], obj: TypedObject): RectangleLight {.importcpp: "DCAST(RectangleLight, @)".}

type SelectiveChildNode* {.importcpp: "PT(SelectiveChildNode)", bycopy, pure, inheritable, header: "selectiveChildNode.h".} = object of PandaNode
  ## A base class for nodes like LODNode and SequenceNode that select only one
  ## visible child at a time.

converter toSelectiveChildNode*(_: type(nil)): SelectiveChildNode {.importcpp: "(nullptr)".}
converter toBool*(this: SelectiveChildNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SelectiveChildNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[SelectiveChildNode], obj: TypedObject): SelectiveChildNode {.importcpp: "DCAST(SelectiveChildNode, @)".}

type AnimInterface* {.importcpp: "AnimInterface*", bycopy, pure, inheritable, header: "animInterface.h".} = object
  ## This is the fundamental interface for things that have a play/loop/stop
  ## type interface for frame-based animation, such as animated characters.
  ## This is the base class for AnimControl and other, similar classes.

converter toAnimInterface*(_: type(nil)): AnimInterface {.importcpp: "(nullptr)".}
converter toBool*(this: AnimInterface): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimInterface, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type SequenceNode* {.importcpp: "PT(SequenceNode)", bycopy, pure, inheritable, header: "sequenceNode.h".} = object of SelectiveChildNode
  ## A node that automatically cycles through rendering each one of its children
  ## according to its frame rate.

converter toSequenceNode*(_: type(nil)): SequenceNode {.importcpp: "(nullptr)".}
converter toBool*(this: SequenceNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SequenceNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[SequenceNode], obj: TypedObject): SequenceNode {.importcpp: "DCAST(SequenceNode, @)".}

type ShaderGenerator* {.importcpp: "PT(ShaderGenerator)", bycopy, pure, inheritable, header: "shaderGenerator.h".} = object of TypedReferenceCount
  ## The ShaderGenerator is a device that effectively replaces the classic fixed
  ## function pipeline with a 'next-gen' fixed function pipeline.  The next-gen
  ## fixed function pipeline supports features like normal mapping, gloss
  ## mapping, cartoon lighting, and so forth.  It works by automatically
  ## generating a shader from a given RenderState.
  ##
  ## Currently, there is one ShaderGenerator object per GraphicsStateGuardian.
  ## It is our intent that in time, people will write classes that derive from
  ## ShaderGenerator but which yield slightly different results.
  ##
  ## The ShaderGenerator owes its existence to the 'Bamboo Team' at Carnegie
  ## Mellon's Entertainment Technology Center.  This is a group of students who,
  ## as a semester project, decided that next-gen graphics should be accessible
  ## to everyone, even if they don't know shader programming.  The group
  ## consisted of:
  ##
  ## Aaron Lo, Programmer Heegun Lee, Programmer Erin Fernandez, Artist/Tester
  ## Joe Grubb, Artist/Tester Ivan Ortega, Technical Artist/Tester
  ##
  ## Thanks to them!

converter toShaderGenerator*(_: type(nil)): ShaderGenerator {.importcpp: "(nullptr)".}
converter toBool*(this: ShaderGenerator): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ShaderGenerator, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ShaderGenerator], obj: TypedObject): ShaderGenerator {.importcpp: "DCAST(ShaderGenerator, @)".}

type SphereLight* {.importcpp: "PT(SphereLight)", bycopy, pure, inheritable, header: "sphereLight.h".} = object of PointLight
  ## A sphere light is like a point light, except that it represents a sphere
  ## with a radius, rather than being an infinitely thin point in space.
  ##
  ## @since 1.10.0

converter toSphereLight*(_: type(nil)): SphereLight {.importcpp: "(nullptr)".}
converter toBool*(this: SphereLight): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SphereLight, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[SphereLight], obj: TypedObject): SphereLight {.importcpp: "DCAST(SphereLight, @)".}

type Spotlight* {.importcpp: "PT(Spotlight)", bycopy, pure, inheritable, header: "spotlight.h".} = object of LightLensNode
  ## A light originating from a single point in space, and shining in a
  ## particular direction, with a cone-shaped falloff.
  ##
  ## The Spotlight frustum is defined using a Lens, so it can have any of the
  ## properties that a camera lens can have.
  ##
  ## Note that the class is named Spotlight instead of SpotLight, because
  ## "spotlight" is a single English word, instead of two words.

converter toSpotlight*(_: type(nil)): Spotlight {.importcpp: "(nullptr)".}
converter toBool*(this: Spotlight): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Spotlight, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Spotlight], obj: TypedObject): Spotlight {.importcpp: "DCAST(Spotlight, @)".}

type SwitchNode* {.importcpp: "PT(SwitchNode)", bycopy, pure, inheritable, header: "switchNode.h".} = object of SelectiveChildNode
  ## A node that renders only one of its children, according to the user's
  ## indication.

converter toSwitchNode*(_: type(nil)): SwitchNode {.importcpp: "(nullptr)".}
converter toBool*(this: SwitchNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SwitchNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[SwitchNode], obj: TypedObject): SwitchNode {.importcpp: "DCAST(SwitchNode, @)".}

type UvScrollNode* {.importcpp: "PT(UvScrollNode)", bycopy, pure, inheritable, header: "uvScrollNode.h".} = object of PandaNode
  ## This node is placed at key points within the scene graph to animate uvs.

converter toUvScrollNode*(_: type(nil)): UvScrollNode {.importcpp: "(nullptr)".}
converter toBool*(this: UvScrollNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: UvScrollNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[UvScrollNode], obj: TypedObject): UvScrollNode {.importcpp: "DCAST(UvScrollNode, @)".}

type SceneGraphAnalyzer* {.importcpp: "SceneGraphAnalyzer", pure, inheritable, header: "sceneGraphAnalyzer.h".} = object
  ## A handy class that can scrub over a scene graph and collect interesting
  ## statistics on it.

type CachedTypedWritableReferenceCount* {.importcpp: "PT(CachedTypedWritableReferenceCount)", bycopy, pure, inheritable, header: "cachedTypedWritableReferenceCount.h".} = object of TypedWritableReferenceCount
  ## This is a special extension to ReferenceCount that includes dual reference
  ## counts: the standard reference count number, which includes all references
  ## to the object, and a separate number (the cache reference count) that
  ## counts the number of references to the object just within its cache alone.
  ## When get_ref_count() == get_cache_ref_count(), the object is not referenced
  ## outside the cache.
  ##
  ## The cache refs must be explicitly maintained; there is no PointerTo<> class
  ## to maintain the cache reference counts automatically.  The cache reference
  ## count is automatically included in the overall reference count: calling
  ## cache_ref() and cache_unref() automatically calls ref() and unref().

converter toCachedTypedWritableReferenceCount*(_: type(nil)): CachedTypedWritableReferenceCount {.importcpp: "(nullptr)".}
converter toBool*(this: CachedTypedWritableReferenceCount): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CachedTypedWritableReferenceCount, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CachedTypedWritableReferenceCount], obj: TypedObject): CachedTypedWritableReferenceCount {.importcpp: "DCAST(CachedTypedWritableReferenceCount, @)".}

type NodeCachedReferenceCount* {.importcpp: "PT(NodeCachedReferenceCount)", bycopy, pure, inheritable, header: "nodeCachedReferenceCount.h".} = object of CachedTypedWritableReferenceCount
  ## This class further specializes CachedTypedWritableReferenceCount to also
  ## add a node_ref_count, for the purposes of counting the number of times the
  ## object is referenced by a "node", presumably a PandaNode.
  ##
  ## This essentially combines the functionality of NodeReferenceCount and
  ## CachedTypedWritableReferenceCount, so that a derivative of this object
  ## actually has three counters: the standard reference count, the "cache"
  ## reference count, and the "node" reference count.  Rather than multiply
  ## inheriting from the two reference count classes, we inherit only from
  ## CachedTypedWritableReferenceCount and simply duplicate the functionality of
  ## NodeReferenceCount, to avoid all of the problems associated with multiple
  ## inheritance.
  ##
  ## The intended design is to use this as a base class for RenderState and
  ## TransformState, both of which are held by PandaNodes, and also have caches
  ## which are independently maintained.  By keeping track of how many nodes
  ## hold a pointer to a particular object, we can classify each object into
  ## node-referenced, cache-referenced, or other, which is primarily useful for
  ## PStats reporting.
  ##
  ## As with CachedTypedWritableReferenceCount's cache_ref() and cache_unref(),
  ## the new methods node_ref() and node_unref() automatically increment and
  ## decrement the primary reference count as well.  In this case, however,
  ## there does exist a NodePointerTo<> class to maintain the node_ref counters
  ## automatically.

converter toNodeCachedReferenceCount*(_: type(nil)): NodeCachedReferenceCount {.importcpp: "(nullptr)".}
converter toBool*(this: NodeCachedReferenceCount): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: NodeCachedReferenceCount, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[NodeCachedReferenceCount], obj: TypedObject): NodeCachedReferenceCount {.importcpp: "DCAST(NodeCachedReferenceCount, @)".}

type TransformState* {.importcpp: "PT(TransformState)", bycopy, pure, header: "transformState.h".} = object of NodeCachedReferenceCount
  ## Indicates a coordinate-system transform on vertices.  TransformStates are
  ## the primary means for storing transformations on the scene graph.
  ##
  ## Transforms may be specified in one of two ways: componentwise, with a pos-
  ## hpr-scale, or with an arbitrary transform matrix.  If you specify a
  ## transform componentwise, it will remember its original components.
  ##
  ## TransformState objects are managed very much like RenderState objects.
  ## They are immutable and reference-counted automatically.
  ##
  ## You should not attempt to create or modify a TransformState object
  ## directly.  Instead, call one of the make() functions to create one for you.
  ## And instead of modifying a TransformState object, create a new one.

converter toTransformState*(_: type(nil)): TransformState {.importcpp: "(nullptr)".}
converter toBool*(this: TransformState): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TransformState, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TransformState], obj: TypedObject): TransformState {.importcpp: "DCAST(TransformState, @)".}

type RenderAttribRegistry* {.importcpp: "RenderAttribRegistry", pure, inheritable, header: "renderAttribRegistry.h".} = object
  ## This class is used to associate each RenderAttrib with a different slot
  ## index at runtime, so we can store a list of RenderAttribs in the
  ## RenderState object, and very quickly look them up by type.

type RenderAttrib* {.importcpp: "PT(RenderAttrib)", bycopy, pure, inheritable, header: "renderAttrib.h".} = object of TypedWritableReferenceCount
  ## This is the base class for a number of render attributes (other than
  ## transform) that may be set on scene graph nodes to control the appearance
  ## of geometry.  This includes TextureAttrib, ColorAttrib, etc.
  ##
  ## RenderAttrib represents render attributes that always propagate down to the
  ## leaves without regard to the particular node they are assigned to.  A
  ## RenderAttrib will have the same effect on a leaf node whether it is
  ## assigned to the graph at the leaf or several nodes above.  This is
  ## different from RenderEffect, which represents a particular render property
  ## that is applied immediately to the node on which it is encountered, like
  ## billboarding or decaling.
  ##
  ## You should not attempt to create or modify a RenderAttrib directly;
  ## instead, use the make() method of the appropriate kind of attrib you want.
  ## This will allocate and return a new RenderAttrib of the appropriate type,
  ## and it may share pointers if possible.  Do not modify the new RenderAttrib
  ## if you wish to change its properties; instead, create a new one.

converter toRenderAttrib*(_: type(nil)): RenderAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: RenderAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RenderAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[RenderAttrib], obj: TypedObject): RenderAttrib {.importcpp: "DCAST(RenderAttrib, @)".}

type RenderModeAttrib* {.importcpp: "PT(RenderModeAttrib)", bycopy, pure, inheritable, header: "renderModeAttrib.h".} = object of RenderAttrib
  ## Specifies how polygons are to be drawn.

converter toRenderModeAttrib*(_: type(nil)): RenderModeAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: RenderModeAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RenderModeAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[RenderModeAttrib], obj: TypedObject): RenderModeAttrib {.importcpp: "DCAST(RenderModeAttrib, @)".}

type TexMatrixAttrib* {.importcpp: "PT(TexMatrixAttrib)", bycopy, pure, inheritable, header: "texMatrixAttrib.h".} = object of RenderAttrib
  ## Applies a transform matrix to UV's before they are rendered.

converter toTexMatrixAttrib*(_: type(nil)): TexMatrixAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: TexMatrixAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TexMatrixAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TexMatrixAttrib], obj: TypedObject): TexMatrixAttrib {.importcpp: "DCAST(TexMatrixAttrib, @)".}

type RenderState* {.importcpp: "PT(RenderState)", bycopy, pure, inheritable, header: "renderState.h".} = object of NodeCachedReferenceCount
  ## This represents a unique collection of RenderAttrib objects that correspond
  ## to a particular renderable state.
  ##
  ## You should not attempt to create or modify a RenderState object directly.
  ## Instead, call one of the make() functions to create one for you.  And
  ## instead of modifying a RenderState object, create a new one.

converter toRenderState*(_: type(nil)): RenderState {.importcpp: "(nullptr)".}
converter toBool*(this: RenderState): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RenderState, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[RenderState], obj: TypedObject): RenderState {.importcpp: "DCAST(RenderState, @)".}

type AlphaTestAttrib* {.importcpp: "PT(AlphaTestAttrib)", bycopy, pure, inheritable, header: "alphaTestAttrib.h".} = object of RenderAttrib
  ## Enables or disables writing of pixel to framebuffer based on its alpha
  ## value relative to a reference alpha value

converter toAlphaTestAttrib*(_: type(nil)): AlphaTestAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: AlphaTestAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AlphaTestAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AlphaTestAttrib], obj: TypedObject): AlphaTestAttrib {.importcpp: "DCAST(AlphaTestAttrib, @)".}

type AntialiasAttrib* {.importcpp: "PT(AntialiasAttrib)", bycopy, pure, inheritable, header: "antialiasAttrib.h".} = object of RenderAttrib
  ## Specifies whether or how to enable antialiasing, if supported by the
  ## backend renderer.

converter toAntialiasAttrib*(_: type(nil)): AntialiasAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: AntialiasAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AntialiasAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AntialiasAttrib], obj: TypedObject): AntialiasAttrib {.importcpp: "DCAST(AntialiasAttrib, @)".}

type RenderEffect* {.importcpp: "PT(RenderEffect)", bycopy, pure, inheritable, header: "renderEffect.h".} = object of TypedWritableReferenceCount
  ## This is the base class for a number of special render effects that may be
  ## set on scene graph nodes to change the way they render.  This includes
  ## BillboardEffect, DecalEffect, etc.
  ##
  ## RenderEffect represents render properties that must be applied as soon as
  ## they are encountered in the scene graph, rather than propagating down to
  ## the leaves.  This is different from RenderAttrib, which represents
  ## properties like color and texture that don't do anything until they
  ## propagate down to a GeomNode.
  ##
  ## You should not attempt to create or modify a RenderEffect directly;
  ## instead, use the make() method of the appropriate kind of effect you want.
  ## This will allocate and return a new RenderEffect of the appropriate type,
  ## and it may share pointers if possible.  Do not modify the new RenderEffect
  ## if you wish to change its properties; instead, create a new one.

converter toRenderEffect*(_: type(nil)): RenderEffect {.importcpp: "(nullptr)".}
converter toBool*(this: RenderEffect): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RenderEffect, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[RenderEffect], obj: TypedObject): RenderEffect {.importcpp: "DCAST(RenderEffect, @)".}

type RenderEffects* {.importcpp: "PT(RenderEffects)", bycopy, pure, inheritable, header: "renderEffects.h".} = object of TypedWritableReferenceCount
  ## This represents a unique collection of RenderEffect objects that correspond
  ## to a particular renderable state.
  ##
  ## You should not attempt to create or modify a RenderEffects object directly.
  ## Instead, call one of the make() functions to create one for you.  And
  ## instead of modifying a RenderEffects object, create a new one.

converter toRenderEffects*(_: type(nil)): RenderEffects {.importcpp: "(nullptr)".}
converter toBool*(this: RenderEffects): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RenderEffects, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[RenderEffects], obj: TypedObject): RenderEffects {.importcpp: "DCAST(RenderEffects, @)".}

type TransparencyAttrib* {.importcpp: "PT(TransparencyAttrib)", bycopy, pure, inheritable, header: "transparencyAttrib.h".} = object of RenderAttrib
  ## This controls the enabling of transparency.  Simply setting an alpha
  ## component to non-1 does not in itself make an object transparent; you must
  ## also enable transparency mode with a suitable TransparencyAttrib.
  ## Similarly, it is wasteful to render an object with a TransparencyAttrib in
  ## effect unless you actually want it to be at least partially transparent
  ## (and it has alpha components less than 1).

converter toTransparencyAttrib*(_: type(nil)): TransparencyAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: TransparencyAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TransparencyAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TransparencyAttrib], obj: TypedObject): TransparencyAttrib {.importcpp: "DCAST(TransparencyAttrib, @)".}

type LogicOpAttrib* {.importcpp: "PT(LogicOpAttrib)", bycopy, pure, inheritable, header: "logicOpAttrib.h".} = object of RenderAttrib
  ## If enabled, specifies that a custom logical operation be performed instead
  ## of any color blending.  Setting it to a value other than M_none will cause
  ## color blending to be disabled and the given logic operation to be performed.
  ##
  ## @since 1.10.0

converter toLogicOpAttrib*(_: type(nil)): LogicOpAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: LogicOpAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: LogicOpAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[LogicOpAttrib], obj: TypedObject): LogicOpAttrib {.importcpp: "DCAST(LogicOpAttrib, @)".}

type ShaderInput* {.importcpp: "ShaderInput", pure, inheritable, header: "shaderInput.h".} = object
  ## This is a small container class that can hold any one of the value types
  ## that can be passed as input to a shader.

type InternalNameCollection* {.importcpp: "InternalNameCollection", pure, inheritable, header: "internalNameCollection.h".} = object

type MaterialCollection* {.importcpp: "MaterialCollection", pure, inheritable, header: "materialCollection.h".} = object

type TextureStageCollection* {.importcpp: "TextureStageCollection", pure, inheritable, header: "textureStageCollection.h".} = object

type NodePath* {.importcpp: "NodePath", pure, inheritable, header: "nodePath.h".} = object
  ## NodePath is the fundamental system for disambiguating instances, and also
  ## provides a higher-level interface for manipulating the scene graph.
  ##
  ## A NodePath is a list of connected nodes from the root of the graph to any
  ## sub-node.  Each NodePath therefore uniquely describes one instance of a
  ## node.
  ##
  ## NodePaths themselves are lightweight objects that may easily be copied and
  ## passed by value.  Their data is stored as a series of NodePathComponents
  ## that are stored on the nodes.  Holding a NodePath will keep a reference
  ## count to all the nodes in the path.  However, if any node in the path is
  ## removed or reparented (perhaps through a different NodePath), the NodePath
  ## will automatically be updated to reflect the changes.

type NodePathCollection* {.importcpp: "NodePathCollection", pure, inheritable, header: "nodePathCollection.h".} = object
  ## This is a set of zero or more NodePaths.  It's handy for returning from
  ## functions that need to return multiple NodePaths (for instance,
  ## NodePaths::get_children).

type AttribNodeRegistry* {.importcpp: "AttribNodeRegistry", pure, inheritable, header: "attribNodeRegistry.h".} = object
  ## This global object records NodePaths that are referenced by scene graph
  ## attribs, such as ClipPlaneAttribs and LightAttribs.
  ##
  ## Its primary purpose is to unify attribs that are loaded in from bam files.
  ## Attrib nodes are identified by name and type; when a bam file that contains
  ## references to some attrib nodes is loaded, those nodes are first looked up
  ## here in the AttribNodeRegistry.  If there is a match (by name and node
  ## type), the identified node is used instead of the node referenced within
  ## the bam file itself.

type AudioVolumeAttrib* {.importcpp: "PT(AudioVolumeAttrib)", bycopy, pure, inheritable, header: "audioVolumeAttrib.h".} = object of RenderAttrib
  ## Applies a scale to audio volume for positional sounds in the scene graph.

converter toAudioVolumeAttrib*(_: type(nil)): AudioVolumeAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: AudioVolumeAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AudioVolumeAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AudioVolumeAttrib], obj: TypedObject): AudioVolumeAttrib {.importcpp: "DCAST(AudioVolumeAttrib, @)".}

type AuxBitplaneAttrib* {.importcpp: "PT(AuxBitplaneAttrib)", bycopy, pure, inheritable, header: "auxBitplaneAttrib.h".} = object of RenderAttrib
  ## Modern frame buffers can have 'aux' bitplanes, which are additional
  ## bitplanes above and beyond the standard depth and color.  This attrib
  ## controls what gets rendered into those additional bitplanes.  It can also
  ## affect what goes into the alpha channel of the primary color buffer.
  ##
  ## ABO_glow: copy the glow map into the alpha channel of the primary frame
  ## buffer.  If there is no glow map, set it to zero.  Caveat: it is not
  ## possible to write glow or depth values to the framebuffer alpha channel at
  ## the same time as using alpha blending or alpha testing.  Any attempt to use
  ## transparency, blending, or alpha testing will cause this flag to be
  ## overridden.
  ##
  ## ABO_aux_normal: put the camera-space normal into the into the R,G
  ## components of the first auxiliary bitplane.
  ##
  ## ABO_aux_modelz: put the clip-space Z coordinate of the center of the model
  ## (after perspective divide) into the B channel of the first auxiliary
  ## bitplane.
  ##
  ## ABO_aux_glow: put a copy of the glow map into the alpha channel of the
  ## first auxiliary bitplane.  If there is no glow map, set it to zero.
  ##
  ## AuxBitplaneAttrib is relevant only when shader generation is enabled.
  ## Otherwise, it has no effect.

converter toAuxBitplaneAttrib*(_: type(nil)): AuxBitplaneAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: AuxBitplaneAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AuxBitplaneAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AuxBitplaneAttrib], obj: TypedObject): AuxBitplaneAttrib {.importcpp: "DCAST(AuxBitplaneAttrib, @)".}

type AuxSceneData* {.importcpp: "PT(AuxSceneData)", bycopy, pure, inheritable, header: "auxSceneData.h".} = object of TypedReferenceCount
  ## This is a base class for a generic data structure that can be attached per-
  ## instance to the camera, to store per-instance data that must be preserved
  ## over multiple frames.
  ##
  ## In particular, this is used to implement the FadeLODNode, which must
  ## remember during traversal at what point it is in the fade, separately for
  ## each instance and for each camera.

converter toAuxSceneData*(_: type(nil)): AuxSceneData {.importcpp: "(nullptr)".}
converter toBool*(this: AuxSceneData): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AuxSceneData, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AuxSceneData], obj: TypedObject): AuxSceneData {.importcpp: "DCAST(AuxSceneData, @)".}

type BamEnums* {.importcpp: "BamEnums", pure, inheritable, header: "bamEnums.h".} = object
  ## This class exists just to provide scoping for the enums shared by BamReader
  ## and BamWriter.

type BamFile* {.importcpp: "BamFile", pure, inheritable, header: "bamFile.h".} = object of BamEnums
  ## The principle public interface to reading and writing Bam disk files.  See
  ## also BamReader and BamWriter, the more general implementation of this
  ## class.
  ##
  ## Bam files are most often used to store scene graphs or subgraphs, and by
  ## convention they are given filenames ending in the extension ".bam" when
  ## they are used for this purpose.  However, a Bam file may store any
  ## arbitrary list of TypedWritable objects; in this more general usage, they
  ## are given filenames ending in ".boo" to differentiate them from the more
  ## common scene graph files.

type BillboardEffect* {.importcpp: "PT(BillboardEffect)", bycopy, pure, inheritable, header: "billboardEffect.h".} = object of RenderEffect
  ## Indicates that geometry at this node should automatically rotate to face
  ## the camera, or any other arbitrary node.

converter toBillboardEffect*(_: type(nil)): BillboardEffect {.importcpp: "(nullptr)".}
converter toBool*(this: BillboardEffect): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: BillboardEffect, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[BillboardEffect], obj: TypedObject): BillboardEffect {.importcpp: "DCAST(BillboardEffect, @)".}

type WeakNodePath* {.importcpp: "WeakNodePath", pure, inheritable, header: "weakNodePath.h".} = object
  ## This class is a wrapper around a NodePath that, unlike the actual NodePath
  ## class, doesn't hold a reference count to the node.  Thus the node may be
  ## detached from the scene graph and destructed at any time.
  ##
  ## You can call is_valid() or was_deleted() at any time to determine whether
  ## the node is still around; if it is, get_node_path() will return the
  ## associated NodePath.

type PlaneNode* {.importcpp: "PT(PlaneNode)", bycopy, pure, inheritable, header: "planeNode.h".} = object of PandaNode
  ## A node that contains a plane.  This is most often used as a clipping plane,
  ## but it can serve other purposes as well; whenever a plane is needed to be
  ## defined in some coordinate space in the world.

converter toPlaneNode*(_: type(nil)): PlaneNode {.importcpp: "(nullptr)".}
converter toBool*(this: PlaneNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PlaneNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PlaneNode], obj: TypedObject): PlaneNode {.importcpp: "DCAST(PlaneNode, @)".}

type ClipPlaneAttrib* {.importcpp: "PT(ClipPlaneAttrib)", bycopy, pure, inheritable, header: "clipPlaneAttrib.h".} = object of RenderAttrib
  ## This functions similarly to a LightAttrib.  It indicates the set of
  ## clipping planes that modify the geometry at this level and below.  A
  ## ClipPlaneAttrib can either add planes or remove planes from the total set
  ## of clipping planes in effect.

converter toClipPlaneAttrib*(_: type(nil)): ClipPlaneAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: ClipPlaneAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ClipPlaneAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ClipPlaneAttrib], obj: TypedObject): ClipPlaneAttrib {.importcpp: "DCAST(ClipPlaneAttrib, @)".}

type ColorAttrib* {.importcpp: "PT(ColorAttrib)", bycopy, pure, inheritable, header: "colorAttrib.h".} = object of RenderAttrib
  ## Indicates what color should be applied to renderable geometry.

converter toColorAttrib*(_: type(nil)): ColorAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: ColorAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ColorAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ColorAttrib], obj: TypedObject): ColorAttrib {.importcpp: "DCAST(ColorAttrib, @)".}

type ColorBlendAttrib* {.importcpp: "PT(ColorBlendAttrib)", bycopy, pure, inheritable, header: "colorBlendAttrib.h".} = object of RenderAttrib
  ## This specifies how colors are blended into the frame buffer, for special
  ## effects.  This overrides transparency if transparency is also specified.

converter toColorBlendAttrib*(_: type(nil)): ColorBlendAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: ColorBlendAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ColorBlendAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ColorBlendAttrib], obj: TypedObject): ColorBlendAttrib {.importcpp: "DCAST(ColorBlendAttrib, @)".}

type ColorScaleAttrib* {.importcpp: "PT(ColorScaleAttrib)", bycopy, pure, inheritable, header: "colorScaleAttrib.h".} = object of RenderAttrib
  ## Applies a scale to colors in the scene graph and on vertices.

converter toColorScaleAttrib*(_: type(nil)): ColorScaleAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: ColorScaleAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ColorScaleAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ColorScaleAttrib], obj: TypedObject): ColorScaleAttrib {.importcpp: "DCAST(ColorScaleAttrib, @)".}

type ColorWriteAttrib* {.importcpp: "PT(ColorWriteAttrib)", bycopy, pure, inheritable, header: "colorWriteAttrib.h".} = object of RenderAttrib
  ## Enables or disables writing to the color buffer.  This is primarily useful
  ## for certain special effects in which it is important to write to the depth
  ## buffer without affecting the color buffer.

converter toColorWriteAttrib*(_: type(nil)): ColorWriteAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: ColorWriteAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ColorWriteAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ColorWriteAttrib], obj: TypedObject): ColorWriteAttrib {.importcpp: "DCAST(ColorWriteAttrib, @)".}

type CompassEffect* {.importcpp: "PT(CompassEffect)", bycopy, pure, inheritable, header: "compassEffect.h".} = object of RenderEffect
  ## A CompassEffect causes a node to inherit its rotation (or pos or scale, if
  ## specified) from some other reference node in the graph, or more often from
  ## the root.
  ##
  ## In its purest form, a CompassEffect is used to keep the node's rotation
  ## fixed relative to the top of the scene graph, despite other transforms that
  ## may exist above the node.  Hence the name: the node behaves like a magnetic
  ## compass, always pointing in the same direction.
  ##
  ## As an couple of generalizing extensions, the CompassEffect may also be set
  ## up to always orient its node according to some other reference node than
  ## the root of the scene graph.  Furthermore, it may optionally adjust any of
  ## pos, rotation, or scale, instead of necessarily rotation; and it may adjust
  ## individual pos and scale components.  (Rotation may not be adjusted on an
  ## individual component basis; that's just asking for trouble.)
  ##
  ## Be careful when using the pos and scale modes.  In these modes, it's
  ## possible for the CompassEffect to move its node far from its normal
  ## bounding volume, causing culling to fail.  If this is an issue, you may
  ## need to explicitly set a large (or infinite) bounding volume on the effect
  ## node.

converter toCompassEffect*(_: type(nil)): CompassEffect {.importcpp: "(nullptr)".}
converter toBool*(this: CompassEffect): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CompassEffect, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CompassEffect], obj: TypedObject): CompassEffect {.importcpp: "DCAST(CompassEffect, @)".}

type CullBinEnums* {.importcpp: "CullBinEnums", pure, inheritable, header: "cullBinEnums.h".} = object
  ## Provides scoping for the enumerated type shared by CullBin and
  ## CullBinManager.

type GeomNode* {.importcpp: "PT(GeomNode)", bycopy, pure, inheritable, header: "geomNode.h".} = object of PandaNode
  ## A node that holds Geom objects, renderable pieces of geometry.  This is the
  ## primary kind of leaf node in the scene graph; almost all visible objects
  ## will be contained in a GeomNode somewhere.

converter toGeomNode*(_: type(nil)): GeomNode {.importcpp: "(nullptr)".}
converter toBool*(this: GeomNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomNode], obj: TypedObject): GeomNode {.importcpp: "DCAST(GeomNode, @)".}

type CullBinAttrib* {.importcpp: "PT(CullBinAttrib)", bycopy, pure, inheritable, header: "cullBinAttrib.h".} = object of RenderAttrib
  ## Assigns geometry to a particular bin by name.  The bins must be created
  ## separately via the CullBinManager interface.

converter toCullBinAttrib*(_: type(nil)): CullBinAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: CullBinAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CullBinAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CullBinAttrib], obj: TypedObject): CullBinAttrib {.importcpp: "DCAST(CullBinAttrib, @)".}

type CullBinManager* {.importcpp: "CullBinManager", pure, inheritable, header: "cullBinManager.h".} = object of CullBinEnums
  ## This is a global object that maintains the collection of named CullBins in
  ## the world.

type CullFaceAttrib* {.importcpp: "PT(CullFaceAttrib)", bycopy, pure, inheritable, header: "cullFaceAttrib.h".} = object of RenderAttrib
  ## Indicates which faces should be culled based on their vertex ordering.

converter toCullFaceAttrib*(_: type(nil)): CullFaceAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: CullFaceAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CullFaceAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CullFaceAttrib], obj: TypedObject): CullFaceAttrib {.importcpp: "DCAST(CullFaceAttrib, @)".}

type WorkingNodePath* {.importcpp: "WorkingNodePath", pure, inheritable, header: "workingNodePath.h".} = object
  ## This is a class designed to support low-overhead traversals of the complete
  ## scene graph, with a memory of the complete path through the graph at any
  ## given point.
  ##
  ## You could just use a regular NodePath to do this, but since the NodePath
  ## requires storing NodePathComponents on each node as it is constructed, and
  ## then removing them when it destructs, there is considerable overhead in
  ## that approach.
  ##
  ## The WorkingNodePath eliminates this overhead (but does not guarantee
  ## consistency if the scene graph changes while the path is held).
  ##
  ## At any given point, you may ask the WorkingNodePath for its actual
  ## NodePath, and it will construct and return a new NodePath representing the
  ## complete generated chain.

type CullTraverserData* {.importcpp: "CullTraverserData", pure, inheritable, header: "cullTraverserData.h".} = object
  ## This collects together the pieces of data that are accumulated for each
  ## node while walking the scene graph during the cull traversal.
  ##
  ## Having this as a separate object simplifies the parameter list to
  ## CullTraverser::r_traverse(), as well as to other functions like
  ## PandaNode::cull_callback().  It also makes it easier to add cull
  ## parameters, and provides a place to abstract out some of the cull behavior
  ## (like view-frustum culling).

type SceneSetup* {.importcpp: "PT(SceneSetup)", bycopy, pure, inheritable, header: "sceneSetup.h".} = object of TypedReferenceCount
  ## This object holds the camera position, etc., and other general setup
  ## information for rendering a particular scene.

converter toSceneSetup*(_: type(nil)): SceneSetup {.importcpp: "(nullptr)".}
converter toBool*(this: SceneSetup): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SceneSetup, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[SceneSetup], obj: TypedObject): SceneSetup {.importcpp: "DCAST(SceneSetup, @)".}

type Fog* {.importcpp: "PT(Fog)", bycopy, pure, inheritable, header: "fog.h".} = object of PandaNode
  ## Specifies how atmospheric fog effects are applied to geometry.  The Fog
  ## object is now a PandaNode, which means it can be used similarly to a Light
  ## to define effects relative to a particular coordinate system within the
  ## scene graph.
  ##
  ## In exponential mode, the fog effects are always camera-relative, and it
  ## does not matter where the Fog node is parented.  However, in linear mode,
  ## the onset and opaque distances are defined as offsets along the local
  ## forward axis (e.g.  the Y axis).  This allows the fog effect to be
  ## localized to a particular region in space, rather than always camera-
  ## relative.  If the fog object is not parented to any node, it is used to
  ## generate traditonal camera-relative fog, as if it were parented to the
  ## camera.

converter toFog*(_: type(nil)): Fog {.importcpp: "(nullptr)".}
converter toBool*(this: Fog): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Fog, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Fog], obj: TypedObject): Fog {.importcpp: "DCAST(Fog, @)".}

type FogAttrib* {.importcpp: "PT(FogAttrib)", bycopy, pure, inheritable, header: "fogAttrib.h".} = object of RenderAttrib
  ## Applies a Fog to the geometry at and below this node.

converter toFogAttrib*(_: type(nil)): FogAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: FogAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: FogAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[FogAttrib], obj: TypedObject): FogAttrib {.importcpp: "DCAST(FogAttrib, @)".}

type CullTraverser* {.importcpp: "PT(CullTraverser)", bycopy, pure, inheritable, header: "cullTraverser.h".} = object of TypedReferenceCount
  ## This object performs a depth-first traversal of the scene graph, with
  ## optional view-frustum culling, collecting CullState and searching for
  ## GeomNodes.  Each renderable Geom encountered is passed along with its
  ## associated RenderState to the CullHandler object.

converter toCullTraverser*(_: type(nil)): CullTraverser {.importcpp: "(nullptr)".}
converter toBool*(this: CullTraverser): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CullTraverser, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CullTraverser], obj: TypedObject): CullTraverser {.importcpp: "DCAST(CullTraverser, @)".}

type GeomDrawCallbackData* {.importcpp: "GeomDrawCallbackData", pure, inheritable, header: "geomDrawCallbackData.h".} = object of CallbackData
  ## This specialization on CallbackData is passed when the callback is
  ## initiated from deep within the draw traversal, for a particular Geom.

type RescaleNormalAttrib* {.importcpp: "PT(RescaleNormalAttrib)", bycopy, pure, inheritable, header: "rescaleNormalAttrib.h".} = object of RenderAttrib
  ## Specifies how polygons are to be drawn.

converter toRescaleNormalAttrib*(_: type(nil)): RescaleNormalAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: RescaleNormalAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RescaleNormalAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[RescaleNormalAttrib], obj: TypedObject): RescaleNormalAttrib {.importcpp: "DCAST(RescaleNormalAttrib, @)".}

type CullResult* {.importcpp: "PT(CullResult)", bycopy, pure, inheritable, header: "cullResult.h".} = object of ReferenceCount
  ## This stores the result of a BinCullHandler traversal: an ordered collection
  ## of CullBins, each of which holds a number of Geoms and RenderStates to be
  ## rendered in some defined order.
  ##
  ## This is also used to keep the results of last frame's cull traversal around
  ## to make next frame's traversal of the same scene a little easier.

converter toCullResult*(_: type(nil)): CullResult {.importcpp: "(nullptr)".}
converter toBool*(this: CullResult): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CullResult, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CullResult], obj: TypedObject): CullResult {.importcpp: "DCAST(CullResult, @)".}

type DecalEffect* {.importcpp: "PT(DecalEffect)", bycopy, pure, inheritable, header: "decalEffect.h".} = object of RenderEffect
  ## Applied to a GeomNode to indicate that the children of this GeomNode are
  ## coplanar and should be drawn as decals (eliminating Z-fighting).

converter toDecalEffect*(_: type(nil)): DecalEffect {.importcpp: "(nullptr)".}
converter toBool*(this: DecalEffect): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DecalEffect, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DecalEffect], obj: TypedObject): DecalEffect {.importcpp: "DCAST(DecalEffect, @)".}

type DepthOffsetAttrib* {.importcpp: "PT(DepthOffsetAttrib)", bycopy, pure, inheritable, header: "depthOffsetAttrib.h".} = object of RenderAttrib
  ## This is a special kind of attribute that instructs the graphics driver to
  ## apply an offset or bias to the generated depth values for rendered
  ## polygons, before they are written to the depth buffer.
  ##
  ## This can be used to shift polygons forward slightly, to resolve depth
  ## conflicts.  The cull traverser may optionally use this, for instance, to
  ## implement decals.  However, driver support for this feature seems to be
  ## spotty, so use with caution.
  ##
  ## The bias is always an integer number, and each integer increment represents
  ## the smallest possible increment in Z that is sufficient to completely
  ## resolve two coplanar polygons.  Positive numbers are closer towards the
  ## camera.
  ##
  ## Nested DepthOffsetAttrib values accumulate; that is, a DepthOffsetAttrib
  ## with a value of 1 beneath another DepthOffsetAttrib with a value of 2
  ## presents a net offset of 3.  (A DepthOffsetAttrib will not, however,
  ## combine with any other DepthOffsetAttribs with a lower override parameter.)
  ## The net value should probably not exceed 16 or drop below 0 for maximum
  ## portability.
  ##
  ## Also, and only tangentially related, the DepthOffsetAttrib can be used to
  ## constrain the Z output value to a subset of the usual [0, 1] range (or
  ## reversing its direction) by specifying a new min_value and max_value.

converter toDepthOffsetAttrib*(_: type(nil)): DepthOffsetAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: DepthOffsetAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DepthOffsetAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DepthOffsetAttrib], obj: TypedObject): DepthOffsetAttrib {.importcpp: "DCAST(DepthOffsetAttrib, @)".}

type DepthTestAttrib* {.importcpp: "PT(DepthTestAttrib)", bycopy, pure, inheritable, header: "depthTestAttrib.h".} = object of RenderAttrib
  ## Enables or disables writing to the depth buffer.

converter toDepthTestAttrib*(_: type(nil)): DepthTestAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: DepthTestAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DepthTestAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DepthTestAttrib], obj: TypedObject): DepthTestAttrib {.importcpp: "DCAST(DepthTestAttrib, @)".}

type DepthWriteAttrib* {.importcpp: "PT(DepthWriteAttrib)", bycopy, pure, inheritable, header: "depthWriteAttrib.h".} = object of RenderAttrib
  ## Enables or disables writing to the depth buffer.

converter toDepthWriteAttrib*(_: type(nil)): DepthWriteAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: DepthWriteAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DepthWriteAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DepthWriteAttrib], obj: TypedObject): DepthWriteAttrib {.importcpp: "DCAST(DepthWriteAttrib, @)".}

type LightAttrib* {.importcpp: "PT(LightAttrib)", bycopy, pure, inheritable, header: "lightAttrib.h".} = object of RenderAttrib
  ## Indicates which set of lights should be considered "on" to illuminate
  ## geometry at this level and below.  A LightAttrib can either add lights or
  ## remove lights from the total set of "on" lights.

converter toLightAttrib*(_: type(nil)): LightAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: LightAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: LightAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[LightAttrib], obj: TypedObject): LightAttrib {.importcpp: "DCAST(LightAttrib, @)".}

type LightRampAttrib* {.importcpp: "PT(LightRampAttrib)", bycopy, pure, inheritable, header: "lightRampAttrib.h".} = object of RenderAttrib
  ## A Light Ramp is any unary operator that takes a rendered pixel as input,
  ## and adjusts the brightness of that pixel.  For example, gamma correction is
  ## a kind of light ramp.  So is HDR tone mapping.  So is cartoon shading.  See
  ## the constructors for an explanation of each kind of ramp.

converter toLightRampAttrib*(_: type(nil)): LightRampAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: LightRampAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: LightRampAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[LightRampAttrib], obj: TypedObject): LightRampAttrib {.importcpp: "DCAST(LightRampAttrib, @)".}

type Loader* {.importcpp: "PT(Loader)", bycopy, pure, inheritable, header: "loader.h".} = object of TypedReferenceCount
  ## A convenient class for loading models from disk, in bam or egg format (or
  ## any of a number of other formats implemented by a LoaderFileType, such as
  ## ptloader).
  ##
  ## This class supports synchronous as well as asynchronous loading.  In
  ## asynchronous loading, the model is loaded in the background by a thread,
  ## and an event will be generated when the model is available.  If threading
  ## is not available, the asynchronous loading interface may be used, but it
  ## loads synchronously.

converter toLoader*(_: type(nil)): Loader {.importcpp: "(nullptr)".}
converter toBool*(this: Loader): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Loader, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Loader], obj: TypedObject): Loader {.importcpp: "DCAST(Loader, @)".}

type LoaderFileType* {.importcpp: "LoaderFileType", pure, inheritable, header: "loaderFileType.h".} = object of TypedObject
  ## This is the base class for a family of scene-graph file types that the
  ## Loader supports.  Each kind of loader that's available should define a
  ## corresponding LoaderFileType object and register itself.

type LoaderFileTypeRegistry* {.importcpp: "LoaderFileTypeRegistry", pure, inheritable, header: "loaderFileTypeRegistry.h".} = object
  ## This class maintains the set of all known LoaderFileTypes in the universe.

type MaterialAttrib* {.importcpp: "PT(MaterialAttrib)", bycopy, pure, inheritable, header: "materialAttrib.h".} = object of RenderAttrib
  ## Indicates which, if any, material should be applied to geometry.  The
  ## material is used primarily to control lighting effects, and isn't necessary
  ## (or useful) in the absence of lighting.

converter toMaterialAttrib*(_: type(nil)): MaterialAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: MaterialAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MaterialAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MaterialAttrib], obj: TypedObject): MaterialAttrib {.importcpp: "DCAST(MaterialAttrib, @)".}

type AsyncFuture* {.importcpp: "PT(AsyncFuture)", bycopy, pure, inheritable, header: "asyncFuture.h".} = object of TypedReferenceCount
  ## This class represents a thread-safe handle to a promised future result of
  ## an asynchronous operation, providing methods to query its status and result
  ## as well as register callbacks for this future's completion.
  ##
  ## An AsyncFuture can be awaited from within a coroutine or task.  It keeps
  ## track of tasks waiting for this future and automatically reactivates them
  ## upon this future's completion.
  ##
  ## A task itself is also a subclass of AsyncFuture.  Other subclasses are
  ## not generally necessary, except to override the function of `cancel()`.
  ##
  ## Until the future is done, it is "owned" by the resolver thread, though it's
  ## still legal for other threads to query its state.  When the resolver thread
  ## resolves this future using `set_result()`, or any thread calls `cancel()`,
  ## it instantly enters the "done" state, after which the result becomes a
  ## read-only field that all threads can access.
  ##
  ## When the future returns true for done(), a thread can use cancelled() to
  ## determine whether the future was cancelled or get_result() to access the
  ## result of the operation.  Not all operations define a meaningful result
  ## value, so some will always return nullptr.
  ##
  ## In Python, the `cancelled()`, `wait()` and `get_result()` methods are
  ## wrapped up into a single `result()` method which waits for the future to
  ## complete before either returning the result or throwing an exception if the
  ## future was cancelled.
  ## However, it is preferable to use the `await` keyword when running from a
  ## coroutine, which only suspends the current task and not the entire thread.
  ##
  ## This API aims to mirror and be compatible with Python's Future class.
  ##
  ## @since 1.10.0

converter toAsyncFuture*(_: type(nil)): AsyncFuture {.importcpp: "(nullptr)".}
converter toBool*(this: AsyncFuture): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AsyncFuture, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AsyncFuture], obj: TypedObject): AsyncFuture {.importcpp: "DCAST(AsyncFuture, @)".}

type AsyncTask* {.importcpp: "PT(AsyncTask)", bycopy, pure, inheritable, header: "asyncTask.h".} = object of AsyncFuture
  ## This class represents a concrete task performed by an AsyncManager.
  ## Normally, you would subclass from this class, and override do_task(), to
  ## define the functionality you wish to have the task perform.

converter toAsyncTask*(_: type(nil)): AsyncTask {.importcpp: "(nullptr)".}
converter toBool*(this: AsyncTask): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AsyncTask, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AsyncTask], obj: TypedObject): AsyncTask {.importcpp: "DCAST(AsyncTask, @)".}

type ModelFlattenRequest* {.importcpp: "PT(ModelFlattenRequest)", bycopy, pure, inheritable, header: "modelFlattenRequest.h".} = object of AsyncTask
  ## This class object manages a single asynchronous request to flatten a model.
  ## The model will be duplicated and flattened in a sub-thread (if threading is
  ## available), without affecting the original model; and when the result is
  ## done it may be retrieved from this object.

converter toModelFlattenRequest*(_: type(nil)): ModelFlattenRequest {.importcpp: "(nullptr)".}
converter toBool*(this: ModelFlattenRequest): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ModelFlattenRequest, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ModelFlattenRequest], obj: TypedObject): ModelFlattenRequest {.importcpp: "DCAST(ModelFlattenRequest, @)".}

type ModelLoadRequest* {.importcpp: "PT(ModelLoadRequest)", bycopy, pure, inheritable, header: "modelLoadRequest.h".} = object of AsyncTask
  ## A class object that manages a single asynchronous model load request.
  ## Create a new ModelLoadRequest, and add it to the loader via load_async(),
  ## to begin an asynchronous load.

converter toModelLoadRequest*(_: type(nil)): ModelLoadRequest {.importcpp: "(nullptr)".}
converter toBool*(this: ModelLoadRequest): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ModelLoadRequest, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ModelLoadRequest], obj: TypedObject): ModelLoadRequest {.importcpp: "DCAST(ModelLoadRequest, @)".}

type ModelNode* {.importcpp: "PT(ModelNode)", bycopy, pure, inheritable, header: "modelNode.h".} = object of PandaNode
  ## This node is placed at key points within the scene graph to indicate the
  ## roots of "models": subtrees that are conceptually to be treated as a single
  ## unit, like a car or a room, for instance.  It doesn't affect rendering or
  ## any other operations; it's primarily useful as a high-level model
  ## indication.
  ##
  ## ModelNodes are created in response to a <Model> { 1 } flag within an egg
  ## file.

converter toModelNode*(_: type(nil)): ModelNode {.importcpp: "(nullptr)".}
converter toBool*(this: ModelNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ModelNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ModelNode], obj: TypedObject): ModelNode {.importcpp: "DCAST(ModelNode, @)".}

type ModelRoot* {.importcpp: "PT(ModelRoot)", bycopy, pure, inheritable, header: "modelRoot.h".} = object of ModelNode
  ## A node of this type is created automatically at the root of each model file
  ## that is loaded.  It may eventually contain some information about the
  ## contents of the model; at the moment, it contains no special information,
  ## but can be used as a flag to indicate the presence of a loaded model file.

converter toModelRoot*(_: type(nil)): ModelRoot {.importcpp: "(nullptr)".}
converter toBool*(this: ModelRoot): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ModelRoot, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ModelRoot], obj: TypedObject): ModelRoot {.importcpp: "DCAST(ModelRoot, @)".}

type ModelPool* {.importcpp: "ModelPool", pure, inheritable, header: "modelPool.h".} = object
  ## This class unifies all references to the same filename, so that multiple
  ## attempts to load the same model will return the same pointer.  Note that
  ## the default behavior is thus to make instances: use with caution.  Use the
  ## copy_subgraph() method on Node (or use NodePath::copy_to) to make
  ## modifiable copies of the node.
  ##
  ## Unlike TexturePool, this class does not automatically resolve the model
  ## filenames before loading, so a relative path and an absolute path to the
  ## same model will appear to be different filenames.
  ##
  ## However, see the Loader class, which is now the preferred interface for
  ## loading models.  The Loader class can resolve filenames, supports threaded
  ## loading, and can automatically consult the ModelPool, according to the
  ## supplied LoaderOptions.

type ModelSaveRequest* {.importcpp: "PT(ModelSaveRequest)", bycopy, pure, inheritable, header: "modelSaveRequest.h".} = object of AsyncTask
  ## A class object that manages a single asynchronous model save request.
  ## Create a new ModelSaveRequest, and add it to the loader via save_async(),
  ## to begin an asynchronous save.

converter toModelSaveRequest*(_: type(nil)): ModelSaveRequest {.importcpp: "(nullptr)".}
converter toBool*(this: ModelSaveRequest): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ModelSaveRequest, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ModelSaveRequest], obj: TypedObject): ModelSaveRequest {.importcpp: "DCAST(ModelSaveRequest, @)".}

type TextureAttrib* {.importcpp: "PT(TextureAttrib)", bycopy, pure, inheritable, header: "textureAttrib.h".} = object of RenderAttrib
  ## Indicates the set of TextureStages and their associated Textures that
  ## should be applied to (or removed from) a node.

converter toTextureAttrib*(_: type(nil)): TextureAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: TextureAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TextureAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TextureAttrib], obj: TypedObject): TextureAttrib {.importcpp: "DCAST(TextureAttrib, @)".}

type TexGenAttrib* {.importcpp: "PT(TexGenAttrib)", bycopy, pure, inheritable, header: "texGenAttrib.h".} = object of RenderAttrib
  ## Computes texture coordinates for geometry automatically based on vertex
  ## position and/or normal.  This can be used to implement reflection and/or
  ## refraction maps, for instance to make shiny surfaces, as well as other
  ## special effects such as projective texturing.

converter toTexGenAttrib*(_: type(nil)): TexGenAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: TexGenAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TexGenAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TexGenAttrib], obj: TypedObject): TexGenAttrib {.importcpp: "DCAST(TexGenAttrib, @)".}

type OccluderNode* {.importcpp: "PT(OccluderNode)", bycopy, pure, inheritable, header: "occluderNode.h".} = object of PandaNode
  ## A node in the scene graph that can hold an occluder polygon, which must be
  ## a rectangle.  When the occluder is activated with something like
  ## render.set_occluder(), then objects whose bouding volume lies entirely
  ## behind the occluder will not be rendered.

converter toOccluderNode*(_: type(nil)): OccluderNode {.importcpp: "(nullptr)".}
converter toBool*(this: OccluderNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: OccluderNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[OccluderNode], obj: TypedObject): OccluderNode {.importcpp: "DCAST(OccluderNode, @)".}

type OccluderEffect* {.importcpp: "PT(OccluderEffect)", bycopy, pure, inheritable, header: "occluderEffect.h".} = object of RenderEffect
  ## This functions similarly to a LightAttrib or ClipPlaneAttrib.  It indicates
  ## the set of occluders that modify the geometry at this level and below.
  ## Unlike a ClipPlaneAttrib, an OccluderEffect takes effect immediately when
  ## it is encountered during traversal, and thus can only add occluders; it may
  ## not remove them.

converter toOccluderEffect*(_: type(nil)): OccluderEffect {.importcpp: "(nullptr)".}
converter toBool*(this: OccluderEffect): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: OccluderEffect, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[OccluderEffect], obj: TypedObject): OccluderEffect {.importcpp: "DCAST(OccluderEffect, @)".}

type PolylightNode* {.importcpp: "PT(PolylightNode)", bycopy, pure, inheritable, header: "polylightNode.h".} = object of PandaNode
  ## A PolylightNode

converter toPolylightNode*(_: type(nil)): PolylightNode {.importcpp: "(nullptr)".}
converter toBool*(this: PolylightNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PolylightNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PolylightNode], obj: TypedObject): PolylightNode {.importcpp: "DCAST(PolylightNode, @)".}

type PolylightEffect* {.importcpp: "PT(PolylightEffect)", bycopy, pure, inheritable, header: "polylightEffect.h".} = object of RenderEffect
  ## A PolylightEffect can be used on a node to define a LightGroup  for that
  ## node.  A LightGroup contains PolylightNodes which are essentially nodes
  ## that add color to the polygons of a model based on distance.  PolylightNode
  ## is a cheap way to get lighting effects specially for night scenes

converter toPolylightEffect*(_: type(nil)): PolylightEffect {.importcpp: "(nullptr)".}
converter toBool*(this: PolylightEffect): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PolylightEffect, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PolylightEffect], obj: TypedObject): PolylightEffect {.importcpp: "DCAST(PolylightEffect, @)".}

type ShaderAttrib* {.importcpp: "PT(ShaderAttrib)", bycopy, pure, inheritable, header: "shaderAttrib.h".} = object of RenderAttrib

converter toShaderAttrib*(_: type(nil)): ShaderAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: ShaderAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ShaderAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ShaderAttrib], obj: TypedObject): ShaderAttrib {.importcpp: "DCAST(ShaderAttrib, @)".}

type ShowBoundsEffect* {.importcpp: "PT(ShowBoundsEffect)", bycopy, pure, inheritable, header: "showBoundsEffect.h".} = object of RenderEffect
  ## Applied to a GeomNode to cause a visible bounding volume to be drawn for
  ## this node.  This is generally used only during development to help identify
  ## bounding volume issues.

converter toShowBoundsEffect*(_: type(nil)): ShowBoundsEffect {.importcpp: "(nullptr)".}
converter toBool*(this: ShowBoundsEffect): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ShowBoundsEffect, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ShowBoundsEffect], obj: TypedObject): ShowBoundsEffect {.importcpp: "DCAST(ShowBoundsEffect, @)".}

type TexProjectorEffect* {.importcpp: "PT(TexProjectorEffect)", bycopy, pure, inheritable, header: "texProjectorEffect.h".} = object of RenderEffect
  ## This effect automatically applies a computed texture matrix to the
  ## specified texture stage, according to the relative position of two
  ## specified nodes.
  ##
  ## The relative transform from the "from" node to the "to" node is applied
  ## directly to the texture matrix each frame.  If the "to" node happens to be
  ## a LensNode, its lens projection matrix is applied as well.
  ##
  ## This can be used to apply a number of special effects.  Fundamentally, it
  ## may simply be used to provide a separate PandaNode that may be adjusted
  ## (e.g.  via a LerpInterval) in order to easily apply a linear transformation
  ## to an object's texture coordinates (rather than having to explicitly call
  ## NodePath.set_tex_transform() each frame).
  ##
  ## In a more sophisticated case, the TexProjectorEffect is particularly useful
  ## in conjunction with a TexGenAttrib that specifies a mode of
  ## M_world_position (which copies the world position of each vertex to the
  ## texture coordinates).  Then the TexProjector can be used to convert these
  ## world coordinates to the relative coordinates of a particular node, causing
  ## (for instance) a texture to appear to follow a node around as it moves
  ## through the world.  With a LensNode, you can project a texture onto the
  ## walls, for instance to apply a flashlight effect or an image-based shadow.

converter toTexProjectorEffect*(_: type(nil)): TexProjectorEffect {.importcpp: "(nullptr)".}
converter toBool*(this: TexProjectorEffect): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TexProjectorEffect, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TexProjectorEffect], obj: TypedObject): TexProjectorEffect {.importcpp: "DCAST(TexProjectorEffect, @)".}

type ScissorEffect* {.importcpp: "PT(ScissorEffect)", bycopy, pure, inheritable, header: "scissorEffect.h".} = object of RenderEffect
  ## This provides a higher-level wrapper around ScissorAttrib.  It allows for
  ## the scissor region to be defined via points relative to the current node,
  ## and also performs culling based on the scissor region.

converter toScissorEffect*(_: type(nil)): ScissorEffect {.importcpp: "(nullptr)".}
converter toBool*(this: ScissorEffect): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ScissorEffect, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ScissorEffect], obj: TypedObject): ScissorEffect {.importcpp: "DCAST(ScissorEffect, @)".}

type SceneGraphReducer* {.importcpp: "SceneGraphReducer", pure, inheritable, header: "sceneGraphReducer.h".} = object
  ## An interface for simplifying ("flattening") scene graphs by eliminating
  ## unneeded nodes and collapsing out unneeded state changes and transforms.
  ##
  ## This class is designed so that it may be inherited from and specialized, if
  ## needed, to fine-tune the flattening behavior, but normally the default
  ## behavior is sufficient.

type PortalNode* {.importcpp: "PT(PortalNode)", bycopy, pure, inheritable, header: "portalNode.h".} = object of PandaNode
  ## A node in the scene graph that can hold a Portal Polygon, which is a
  ## rectangle.  Other types of polygons are not supported for now.  It also
  ## holds a PT(PandaNode) Cell that this portal is connected to

converter toPortalNode*(_: type(nil)): PortalNode {.importcpp: "(nullptr)".}
converter toBool*(this: PortalNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PortalNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PortalNode], obj: TypedObject): PortalNode {.importcpp: "DCAST(PortalNode, @)".}

type ScissorAttrib* {.importcpp: "PT(ScissorAttrib)", bycopy, pure, inheritable, header: "scissorAttrib.h".} = object of RenderAttrib
  ## This restricts rendering to within a rectangular region of the scene,
  ## without otherwise affecting the viewport or lens properties.  Geometry that
  ## falls outside the scissor region is not rendered.  It is akin to the OpenGL
  ## glScissor() function.
  ##
  ## The ScissorAttrib always specifies its region relative to its enclosing
  ## DisplayRegion, in screen space, and performs no culling.
  ##
  ## See ScissorEffect if you wish to define a region relative to 2-D or 3-D
  ## coordinates in the scene graph, with culling.

converter toScissorAttrib*(_: type(nil)): ScissorAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: ScissorAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ScissorAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ScissorAttrib], obj: TypedObject): ScissorAttrib {.importcpp: "DCAST(ScissorAttrib, @)".}

type ShadeModelAttrib* {.importcpp: "PT(ShadeModelAttrib)", bycopy, pure, inheritable, header: "shadeModelAttrib.h".} = object of RenderAttrib
  ## Specifies whether flat shading (per-polygon) or smooth shading (per-vertex)
  ## is in effect.

converter toShadeModelAttrib*(_: type(nil)): ShadeModelAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: ShadeModelAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ShadeModelAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ShadeModelAttrib], obj: TypedObject): ShadeModelAttrib {.importcpp: "DCAST(ShadeModelAttrib, @)".}

type StencilAttrib* {.importcpp: "PT(StencilAttrib)", bycopy, pure, inheritable, header: "stencilAttrib.h".} = object of RenderAttrib
  ## A StencilAttrib is a collection of all stencil render states.  The render
  ## states in a StencilAttrib are read-only.  A StencilAttrib is created with
  ## make or make_2_sided.  To determine if two sided stencil is supported, call
  ## the function GraphicsStateGuardian:: get_supports_two_sided_stencil.

converter toStencilAttrib*(_: type(nil)): StencilAttrib {.importcpp: "(nullptr)".}
converter toBool*(this: StencilAttrib): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: StencilAttrib, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[StencilAttrib], obj: TypedObject): StencilAttrib {.importcpp: "DCAST(StencilAttrib, @)".}

type ShaderPool* {.importcpp: "ShaderPool", pure, inheritable, header: "shaderPool.h".} = object
  ## This is the preferred interface for loading shaders for the TextNode
  ## system.  It is similar to ModelPool and TexturePool in that it unifies
  ## references to the same filename.

type MovieAudio* {.importcpp: "PT(MovieAudio)", bycopy, pure, inheritable, header: "movieAudio.h".} = object of TypedWritableReferenceCount
  ## A MovieAudio is actually any source that provides a sequence of audio
  ## samples.  That could include an AVI file, a microphone, or an internet TV
  ## station.
  ##
  ## The difference between a MovieAudio and a MovieAudioCursor is like the
  ## difference between a filename and a file handle.  The MovieAudio just
  ## indicates a particular movie.  The MovieAudioCursor is what allows access.

converter toMovieAudio*(_: type(nil)): MovieAudio {.importcpp: "(nullptr)".}
converter toBool*(this: MovieAudio): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MovieAudio, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MovieAudio], obj: TypedObject): MovieAudio {.importcpp: "DCAST(MovieAudio, @)".}

type FlacAudio* {.importcpp: "PT(FlacAudio)", bycopy, pure, inheritable, header: "flacAudio.h".} = object of MovieAudio
  ## Reads FLAC audio files.  Ogg-encapsulated FLAC files are not supported.
  ##
  ## @since 1.10.0

converter toFlacAudio*(_: type(nil)): FlacAudio {.importcpp: "(nullptr)".}
converter toBool*(this: FlacAudio): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: FlacAudio, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[FlacAudio], obj: TypedObject): FlacAudio {.importcpp: "DCAST(FlacAudio, @)".}

type MovieAudioCursor* {.importcpp: "PT(MovieAudioCursor)", bycopy, pure, inheritable, header: "movieAudioCursor.h".} = object of TypedWritableReferenceCount
  ## A MovieAudio is actually any source that provides a sequence of audio
  ## samples.  That could include an AVI file, a microphone, or an internet TV
  ## station.  A MovieAudioCursor is a handle that lets you read data
  ## sequentially from a MovieAudio.
  ##
  ## Thread safety: each individual MovieAudioCursor must be owned and accessed
  ## by a single thread.  It is OK for two different threads to open the same
  ## file at the same time, as long as they use separate MovieAudioCursor
  ## objects.

converter toMovieAudioCursor*(_: type(nil)): MovieAudioCursor {.importcpp: "(nullptr)".}
converter toBool*(this: MovieAudioCursor): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MovieAudioCursor, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MovieAudioCursor], obj: TypedObject): MovieAudioCursor {.importcpp: "DCAST(MovieAudioCursor, @)".}

type FlacAudioCursor* {.importcpp: "PT(FlacAudioCursor)", bycopy, pure, inheritable, header: "flacAudioCursor.h".} = object of MovieAudioCursor
  ## Implements decoding of FLAC audio files.
  ##
  ## @see FlacAudio
  ## @since 1.10.0

converter toFlacAudioCursor*(_: type(nil)): FlacAudioCursor {.importcpp: "(nullptr)".}
converter toBool*(this: FlacAudioCursor): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: FlacAudioCursor, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[FlacAudioCursor], obj: TypedObject): FlacAudioCursor {.importcpp: "DCAST(FlacAudioCursor, @)".}

type MovieVideo* {.importcpp: "PT(MovieVideo)", bycopy, pure, inheritable, header: "movieVideo.h".} = object of TypedWritableReferenceCount
  ## A MovieVideo is actually any source that provides a sequence of video
  ## frames.  That could include an AVI file, a digital camera, or an internet
  ## TV station.
  ##
  ## The difference between a MovieVideo and a MovieVideoCursor is like the
  ## difference between a filename and a file handle.  The MovieVideo just
  ## indicates a particular movie.  The MovieVideoCursor is what allows access.

converter toMovieVideo*(_: type(nil)): MovieVideo {.importcpp: "(nullptr)".}
converter toBool*(this: MovieVideo): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MovieVideo, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MovieVideo], obj: TypedObject): MovieVideo {.importcpp: "DCAST(MovieVideo, @)".}

type InkblotVideo* {.importcpp: "PT(InkblotVideo)", bycopy, pure, inheritable, header: "inkblotVideo.h".} = object of MovieVideo
  ## A cellular automaton that generates an amusing pattern of swirling colors.

converter toInkblotVideo*(_: type(nil)): InkblotVideo {.importcpp: "(nullptr)".}
converter toBool*(this: InkblotVideo): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: InkblotVideo, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[InkblotVideo], obj: TypedObject): InkblotVideo {.importcpp: "DCAST(InkblotVideo, @)".}

type MovieVideoCursor* {.importcpp: "PT(MovieVideoCursor)", bycopy, pure, inheritable, header: "movieVideoCursor.h".} = object of TypedWritableReferenceCount
  ## A MovieVideo is actually any source that provides a sequence of video
  ## frames.  That could include an AVI file, a digital camera, or an internet
  ## TV station.  A MovieVideoCursor is a handle that lets you read data
  ## sequentially from a MovieVideo.
  ##
  ## Thread safety: each individual MovieVideoCursor must be owned and accessed
  ## by a single thread.  It is OK for two different threads to open the same
  ## file at the same time, as long as they use separate MovieVideoCursor
  ## objects.

converter toMovieVideoCursor*(_: type(nil)): MovieVideoCursor {.importcpp: "(nullptr)".}
converter toBool*(this: MovieVideoCursor): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MovieVideoCursor, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MovieVideoCursor], obj: TypedObject): MovieVideoCursor {.importcpp: "DCAST(MovieVideoCursor, @)".}

type InkblotVideoCursor* {.importcpp: "PT(InkblotVideoCursor)", bycopy, pure, inheritable, header: "inkblotVideoCursor.h".} = object of MovieVideoCursor
  ## A cellular automaton that generates an amusing pattern of swirling colors.

converter toInkblotVideoCursor*(_: type(nil)): InkblotVideoCursor {.importcpp: "(nullptr)".}
converter toBool*(this: InkblotVideoCursor): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: InkblotVideoCursor, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[InkblotVideoCursor], obj: TypedObject): InkblotVideoCursor {.importcpp: "DCAST(InkblotVideoCursor, @)".}

type MicrophoneAudio* {.importcpp: "PT(MicrophoneAudio)", bycopy, pure, inheritable, header: "microphoneAudio.h".} = object of MovieAudio
  ## Class MicrophoneAudio provides the means to read raw audio samples from a
  ## microphone.

converter toMicrophoneAudio*(_: type(nil)): MicrophoneAudio {.importcpp: "(nullptr)".}
converter toBool*(this: MicrophoneAudio): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MicrophoneAudio, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MicrophoneAudio], obj: TypedObject): MicrophoneAudio {.importcpp: "DCAST(MicrophoneAudio, @)".}

type OpusAudio* {.importcpp: "PT(OpusAudio)", bycopy, pure, inheritable, header: "opusAudio.h".} = object of MovieAudio
  ## Interfaces with the libopusfile library to implement decoding of Opus
  ## audio files.
  ##
  ## @since 1.10.0

converter toOpusAudio*(_: type(nil)): OpusAudio {.importcpp: "(nullptr)".}
converter toBool*(this: OpusAudio): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: OpusAudio, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[OpusAudio], obj: TypedObject): OpusAudio {.importcpp: "DCAST(OpusAudio, @)".}

type OpusAudioCursor* {.importcpp: "PT(OpusAudioCursor)", bycopy, pure, inheritable, header: "opusAudioCursor.h".} = object of MovieAudioCursor
  ## Interfaces with the libopusfile library to implement decoding of Opus
  ## audio files.
  ##
  ## @see OpusAudio
  ## @since 1.10.0

converter toOpusAudioCursor*(_: type(nil)): OpusAudioCursor {.importcpp: "(nullptr)".}
converter toBool*(this: OpusAudioCursor): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: OpusAudioCursor, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[OpusAudioCursor], obj: TypedObject): OpusAudioCursor {.importcpp: "DCAST(OpusAudioCursor, @)".}

type UserDataAudio* {.importcpp: "PT(UserDataAudio)", bycopy, pure, inheritable, header: "userDataAudio.h".} = object of MovieAudio
  ## A UserDataAudio is a way for the user to manually supply raw audio samples.
  ## remove_after_read means the data will be removed if read once.  Else data
  ## will be stored (enable looping and seeking). Expects data as 16 bit signed
  ## (word); Example for stereo: 1.word = 1.channel,2.word = 2.channel, 3.word =
  ## 1.channel,4.word = 2.channel, etc.

converter toUserDataAudio*(_: type(nil)): UserDataAudio {.importcpp: "(nullptr)".}
converter toBool*(this: UserDataAudio): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: UserDataAudio, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[UserDataAudio], obj: TypedObject): UserDataAudio {.importcpp: "DCAST(UserDataAudio, @)".}

type UserDataAudioCursor* {.importcpp: "PT(UserDataAudioCursor)", bycopy, pure, inheritable, header: "userDataAudioCursor.h".} = object of MovieAudioCursor
  ## A UserDataAudioCursor is a means to manually supply a sequence of raw audio
  ## samples.

converter toUserDataAudioCursor*(_: type(nil)): UserDataAudioCursor {.importcpp: "(nullptr)".}
converter toBool*(this: UserDataAudioCursor): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: UserDataAudioCursor, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[UserDataAudioCursor], obj: TypedObject): UserDataAudioCursor {.importcpp: "DCAST(UserDataAudioCursor, @)".}

type VorbisAudio* {.importcpp: "PT(VorbisAudio)", bycopy, pure, inheritable, header: "vorbisAudio.h".} = object of MovieAudio
  ## Interfaces with the libvorbisfile library to implement decoding of Ogg
  ## Vorbis audio files.

converter toVorbisAudio*(_: type(nil)): VorbisAudio {.importcpp: "(nullptr)".}
converter toBool*(this: VorbisAudio): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VorbisAudio, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VorbisAudio], obj: TypedObject): VorbisAudio {.importcpp: "DCAST(VorbisAudio, @)".}

type VorbisAudioCursor* {.importcpp: "PT(VorbisAudioCursor)", bycopy, pure, inheritable, header: "vorbisAudioCursor.h".} = object of MovieAudioCursor
  ## Interfaces with the libvorbisfile library to implement decoding of Ogg
  ## Vorbis audio files.

converter toVorbisAudioCursor*(_: type(nil)): VorbisAudioCursor {.importcpp: "(nullptr)".}
converter toBool*(this: VorbisAudioCursor): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VorbisAudioCursor, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VorbisAudioCursor], obj: TypedObject): VorbisAudioCursor {.importcpp: "DCAST(VorbisAudioCursor, @)".}

type WavAudio* {.importcpp: "PT(WavAudio)", bycopy, pure, inheritable, header: "wavAudio.h".} = object of MovieAudio
  ## A native PCM .wav loader.  Supported formats are linear PCM, IEEE float,
  ## A-law and mu-law.

converter toWavAudio*(_: type(nil)): WavAudio {.importcpp: "(nullptr)".}
converter toBool*(this: WavAudio): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: WavAudio, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[WavAudio], obj: TypedObject): WavAudio {.importcpp: "DCAST(WavAudio, @)".}

type WavAudioCursor* {.importcpp: "PT(WavAudioCursor)", bycopy, pure, inheritable, header: "wavAudioCursor.h".} = object of MovieAudioCursor
  ## Used for reading PCM .wav files.  Supported formats are linear PCM, IEEE
  ## float, A-law and mu-law.

converter toWavAudioCursor*(_: type(nil)): WavAudioCursor {.importcpp: "(nullptr)".}
converter toBool*(this: WavAudioCursor): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: WavAudioCursor, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[WavAudioCursor], obj: TypedObject): WavAudioCursor {.importcpp: "DCAST(WavAudioCursor, @)".}

type CardMaker* {.importcpp: "CardMaker", pure, inheritable, header: "cardMaker.h".} = object of Namable
  ## This class generates 2-d "cards", that is, rectangular polygons,
  ## particularly useful for showing textures etc.  in the 2-d scene graph.

type FisheyeMaker* {.importcpp: "FisheyeMaker", pure, inheritable, header: "fisheyeMaker.h".} = object of Namable
  ## This class is similar to CardMaker, but instead of generating ordinary
  ## cards, it generates a circular rose that represents the projection of a 3-D
  ## scene through a fisheye lens.  The texture coordinates of the rose are
  ## defined so that each 2-D vertex has a 3-D UVW that reflects the
  ## corresponding position in 3-D space of that particular vertex.
  ##
  ## This class is particularly suited for converting cube maps to sphere maps.

type TextProperties* {.importcpp: "TextProperties", pure, inheritable, header: "textProperties.h".} = object
  ## This defines the set of visual properties that may be assigned to the
  ## individual characters of the text.  (Properties which affect the overall
  ## block of text can only be specified on the TextNode directly).
  ##
  ## Typically, there is just one set of properties on a given block of text,
  ## which is set directly on the TextNode (TextNode inherits from
  ## TextProperties). That makes all of the text within a particular block have
  ## the same appearance.
  ##
  ## This separate class exists in order to implement multiple different kinds
  ## of text appearing within one block.  The text string itself may reference a
  ## TextProperties structure by name using the \1 and \2 tokens embedded within
  ## the string; each nested TextProperties structure modifies the appearance of
  ## subsequent text within the block.

type TextNode* {.importcpp: "PT(TextNode)", bycopy, pure, inheritable, header: "textNode.h".} = object of PandaNode
  ## The primary interface to this module.  This class does basic text assembly;
  ## given a string of text and a TextFont object, it creates a piece of
  ## geometry that may be placed in the 3-d or 2-d world to represent the
  ## indicated text.
  ##
  ## The TextNode may be used in one of two ways.  Naively, it may simply be
  ## parented directly into the scene graph and rendered as if it were a
  ## GeomNode; in this mode, the actual polygon geometry that renders the text
  ## is not directly visible or accessible, but remains hidden within the
  ## TextNode.
  ##
  ## The second way TextNode may be used is as a text generator.  To use it in
  ## this way, do not parent the TextNode to the scene graph; instead, set the
  ## properties of the text and call generate() to return an ordinary node,
  ## containing ordinary geometry, which you may use however you like.  Each
  ## time you call generate() a new node is returned.

converter toTextNode*(_: type(nil)): TextNode {.importcpp: "(nullptr)".}
converter toBool*(this: TextNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TextNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TextNode], obj: TypedObject): TextNode {.importcpp: "DCAST(TextNode, @)".}

type FrameRateMeter* {.importcpp: "PT(FrameRateMeter)", bycopy, pure, inheritable, header: "frameRateMeter.h".} = object of TextNode
  ## This is a special TextNode that automatically updates itself with the
  ## current frame rate.  It can be placed anywhere in the world where you'd
  ## like to see the frame rate.
  ##
  ## It also has a special mode in which it may be attached directly to a
  ## channel or window.  If this is done, it creates a DisplayRegion for itself
  ## and renders itself in the upper-right-hand corner.

converter toFrameRateMeter*(_: type(nil)): FrameRateMeter {.importcpp: "(nullptr)".}
converter toBool*(this: FrameRateMeter): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: FrameRateMeter, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[FrameRateMeter], obj: TypedObject): FrameRateMeter {.importcpp: "DCAST(FrameRateMeter, @)".}

type GeoMipTerrain* {.importcpp: "GeoMipTerrain", pure, inheritable, header: "geoMipTerrain.h".} = object of TypedObject
  ## GeoMipTerrain, meaning Panda3D GeoMipMapping, can convert a heightfield
  ## image into a 3D terrain, consisting of several GeomNodes.  It uses the
  ## GeoMipMapping algorithm, or Geometrical MipMapping, based on the LOD (Level
  ## of Detail) algorithm.  For more information about the GeoMipMapping
  ## algoritm, see this paper, written by Willem H. de Boer:
  ## https://flipcode.com/articles/article_geomipmaps.pdf

type HeightfieldTesselator* {.importcpp: "HeightfieldTesselator", pure, inheritable, header: "heightfieldTesselator.h".} = object of Namable

type LineSegs* {.importcpp: "LineSegs", pure, inheritable, header: "lineSegs.h".} = object of Namable
  ## Encapsulates creation of a series of connected or disconnected line
  ## segments or points, for drawing paths or rays.  This class doesn't attempt
  ## to be the smartest it could possibly be; it's intended primarily as a
  ## visualization and editing tool.

type MeshDrawer* {.importcpp: "MeshDrawer", pure, inheritable, header: "meshDrawer.h".} = object of TypedObject
  ## Mesh drawer creates a single geom object that can be shaped with different
  ## draw commands.  This is an efficient way to render bunch of billboards,
  ## particles, fast changing triangles.  Its implemented by recycling same geom
  ## over and over again.  Max budget specifies how many triangles are allowed.
  ## Some uses of this class can be : particle system, radar icons, health bars,
  ## 2d icons, 2d ui, bullets, missile trails.  Any that can be drawn with
  ## triangles can be drawn with this class.  At the low level this uses the
  ## GeomVertexRewriter's.  The internal geom consists of vertex, normal, uv and
  ## color channels.

type MeshDrawer2D* {.importcpp: "MeshDrawer2D", pure, inheritable, header: "meshDrawer2D.h".} = object of TypedObject
  ## This class allows the drawing of 2D objects - mainly based on quads and
  ## rectangles.  It allows clipping and several high level UI theme functions.

type Texture* {.importcpp: "PT(Texture)", bycopy, pure, inheritable, header: "texture.h".} = object of TypedWritableReferenceCount
  ## Represents a texture object, which is typically a single 2-d image but may
  ## also represent a 1-d or 3-d texture image, or the six 2-d faces of a cube
  ## map texture.
  ##
  ## A texture's image data might be stored in system RAM (see get_ram_image())
  ## or its image may be represented in texture memory on one or more
  ## GraphicsStateGuardians (see prepare()), or both.  The typical usage pattern
  ## is that a texture is loaded from an image file on disk, which copies its
  ## image data into system RAM; then the first time the texture is rendered its
  ## image data is copied to texture memory (actually, to the graphics API), and
  ## the system RAM image is automatically freed.

converter toTexture*(_: type(nil)): Texture {.importcpp: "(nullptr)".}
converter toBool*(this: Texture): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Texture, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Texture], obj: TypedObject): Texture {.importcpp: "DCAST(Texture, @)".}

type MovieTexture* {.importcpp: "PT(MovieTexture)", bycopy, pure, inheritable, header: "movieTexture.h".} = object of Texture
  ## A texture that fetches video frames from an underlying object of class
  ## Movie.

converter toMovieTexture*(_: type(nil)): MovieTexture {.importcpp: "(nullptr)".}
converter toBool*(this: MovieTexture): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MovieTexture, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MovieTexture], obj: TypedObject): MovieTexture {.importcpp: "DCAST(MovieTexture, @)".}

type MultitexReducer* {.importcpp: "MultitexReducer", pure, inheritable, header: "multitexReducer.h".} = object
  ## This object presents an interface for generating new texture images that
  ## represent the combined images from one or more individual textures,
  ## reproducing certain kinds of multitexture effects without depending on
  ## multitexture support in the hardware.
  ##
  ## This also flattens out texture matrices and removes extra texture
  ## coordinates from the Geoms.  It is thus not a complete substitute for true
  ## multitexturing, because it does not lend itself well to dynamic animation
  ## of the textures once they have been flattened.  It is, however, useful for
  ## "baking in" a particular multitexture effect.

type VertexTransform* {.importcpp: "PT(VertexTransform)", bycopy, pure, inheritable, header: "vertexTransform.h".} = object of TypedWritableReferenceCount
  ## This is an abstract base class that holds a pointer to some transform,
  ## computed in some arbitrary way, that is to be applied to vertices during
  ## rendering.  This is used to implement soft-skinned and animated vertices.
  ## Derived classes will define how the transform is actually computed.

converter toVertexTransform*(_: type(nil)): VertexTransform {.importcpp: "(nullptr)".}
converter toBool*(this: VertexTransform): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VertexTransform, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VertexTransform], obj: TypedObject): VertexTransform {.importcpp: "DCAST(VertexTransform, @)".}

type NodeVertexTransform* {.importcpp: "PT(NodeVertexTransform)", bycopy, pure, inheritable, header: "nodeVertexTransform.h".} = object of VertexTransform
  ## This VertexTransform gets its matrix from the Transform stored on a node.
  ## It can also compose its node's transform with another VertexTransform,
  ## allowing you to build up a chain of NodeVertexTransforms that represent a
  ## list of composed matrices.

converter toNodeVertexTransform*(_: type(nil)): NodeVertexTransform {.importcpp: "(nullptr)".}
converter toBool*(this: NodeVertexTransform): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: NodeVertexTransform, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[NodeVertexTransform], obj: TypedObject): NodeVertexTransform {.importcpp: "DCAST(NodeVertexTransform, @)".}

type ShaderTerrainMesh* {.importcpp: "PT(ShaderTerrainMesh)", bycopy, pure, inheritable, header: "shaderTerrainMesh.h".} = object of PandaNode
  ## @brief Terrain Renderer class utilizing the GPU
  ## @details This class provides functionality to render heightfields of large
  ## sizes utilizing the GPU. Internally a quadtree is used to generate the LODs.
  ## The final terrain is then rendered using instancing on the GPU. This makes
  ## it possible to use very large heightfields (8192+) with very reasonable
  ## performance. The terrain provides options to control the LOD using a
  ## target triangle width, see ShaderTerrainMesh::set_target_triangle_width().
  ##
  ## Because the Terrain is rendered entirely on the GPU, it needs a special
  ## vertex shader. There is a default vertex shader available, which you can
  ## use in your own shaders. IMPORTANT: If you don't set an appropriate shader
  ## on the terrain, nothing will be visible.

converter toShaderTerrainMesh*(_: type(nil)): ShaderTerrainMesh {.importcpp: "(nullptr)".}
converter toBool*(this: ShaderTerrainMesh): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ShaderTerrainMesh, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ShaderTerrainMesh], obj: TypedObject): ShaderTerrainMesh {.importcpp: "DCAST(ShaderTerrainMesh, @)".}

type SceneGraphAnalyzerMeter* {.importcpp: "PT(SceneGraphAnalyzerMeter)", bycopy, pure, inheritable, header: "sceneGraphAnalyzerMeter.h".} = object of TextNode
  ## This is a special TextNode that automatically updates itself with output
  ## from a SceneGraphAnalyzer instance.  It can be placed anywhere in the world
  ## where you'd like to see the output from SceneGraphAnalyzer.
  ##
  ## It also has a special mode in which it may be attached directly to a
  ## channel or window.  If this is done, it creates a DisplayRegion for itself
  ## and renders itself in the upper-right-hand corner.

converter toSceneGraphAnalyzerMeter*(_: type(nil)): SceneGraphAnalyzerMeter {.importcpp: "(nullptr)".}
converter toBool*(this: SceneGraphAnalyzerMeter): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SceneGraphAnalyzerMeter, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[SceneGraphAnalyzerMeter], obj: TypedObject): SceneGraphAnalyzerMeter {.importcpp: "DCAST(SceneGraphAnalyzerMeter, @)".}

type RigidBodyCombiner* {.importcpp: "PT(RigidBodyCombiner)", bycopy, pure, inheritable, header: "rigidBodyCombiner.h".} = object of PandaNode
  ## This is a special node that combines multiple independently-moving rigid
  ## nodes into one Geom internally (or as few Geoms as possible), for the
  ## purposes of improving rendering performance.
  ##
  ## To use it, parent a number of moving objects to this node and call
  ## collect().  A child node is identified as "moving" if (a) it has a non-
  ## identity transform initially, or (b) it is a ModelNode with the
  ## preserve_transform flag set.  Any other nodes will be considered static,
  ## and later transforms applied to them will not be identified.
  ##
  ## You should call collect() only at startup or if you change the set of
  ## children; it is a relatively expensive call.
  ##
  ## Once you call collect(), you may change the transforms on the child nodes
  ## freely without having to call collect() again.
  ##
  ## RenderEffects such as Billboards are not supported below this node.

converter toRigidBodyCombiner*(_: type(nil)): RigidBodyCombiner {.importcpp: "(nullptr)".}
converter toBool*(this: RigidBodyCombiner): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RigidBodyCombiner, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[RigidBodyCombiner], obj: TypedObject): RigidBodyCombiner {.importcpp: "DCAST(RigidBodyCombiner, @)".}

type PipeOcclusionCullTraverser* {.importcpp: "PT(PipeOcclusionCullTraverser)", bycopy, pure, inheritable, header: "pipeOcclusionCullTraverser.h".} = object of CullTraverser
  ## This specialization of CullTraverser uses the graphics pipe itself to
  ## perform occlusion culling.  As such, it's likely to be inefficient (since
  ## it interferes with the pipe's normal mode of rendering), and is mainly
  ## useful to test other, CPU-based occlusion algorithms.
  ##
  ## This cannot be used in a multithreaded pipeline environment where cull and
  ## draw are operating simultaneously.
  ##
  ## It can't be defined in the cull subdirectory, because it needs access to
  ## GraphicsPipe and DisplayRegion and other classes in display.  So we put it
  ## in grutil instead, for lack of any better ideas.

converter toPipeOcclusionCullTraverser*(_: type(nil)): PipeOcclusionCullTraverser {.importcpp: "(nullptr)".}
converter toBool*(this: PipeOcclusionCullTraverser): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PipeOcclusionCullTraverser, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PipeOcclusionCullTraverser], obj: TypedObject): PipeOcclusionCullTraverser {.importcpp: "DCAST(PipeOcclusionCullTraverser, @)".}

type PfmVizzer* {.importcpp: "PfmVizzer", pure, inheritable, header: "pfmVizzer.h".} = object
  ## This class aids in the visualization and manipulation of PfmFile objects.

type AnimGroup* {.importcpp: "PT(AnimGroup)", bycopy, pure, inheritable, header: "animGroup.h".} = object of TypedWritableReferenceCount
  ## This is the base class for AnimChannel and AnimBundle.  It implements a
  ## hierarchy of AnimChannels.  The root of the hierarchy must be an
  ## AnimBundle.

converter toAnimGroup*(_: type(nil)): AnimGroup {.importcpp: "(nullptr)".}
converter toBool*(this: AnimGroup): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimGroup, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimGroup], obj: TypedObject): AnimGroup {.importcpp: "DCAST(AnimGroup, @)".}

type AnimBundle* {.importcpp: "PT(AnimBundle)", bycopy, pure, inheritable, header: "animBundle.h".} = object of AnimGroup
  ## This is the root of an AnimChannel hierarchy.  It knows the frame rate and
  ## number of frames of all the channels in the hierarchy (which must all
  ## match).

converter toAnimBundle*(_: type(nil)): AnimBundle {.importcpp: "(nullptr)".}
converter toBool*(this: AnimBundle): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimBundle, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimBundle], obj: TypedObject): AnimBundle {.importcpp: "DCAST(AnimBundle, @)".}

type AnimBundleNode* {.importcpp: "PT(AnimBundleNode)", bycopy, pure, inheritable, header: "animBundleNode.h".} = object of PandaNode
  ## This is a node that contains a pointer to an AnimBundle.  Like
  ## PartBundleNode, it exists solely to make it easy to store AnimBundles in
  ## the scene graph.

converter toAnimBundleNode*(_: type(nil)): AnimBundleNode {.importcpp: "(nullptr)".}
converter toBool*(this: AnimBundleNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimBundleNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimBundleNode], obj: TypedObject): AnimBundleNode {.importcpp: "DCAST(AnimBundleNode, @)".}

type PartGroup* {.importcpp: "PT(PartGroup)", bycopy, pure, inheritable, header: "partGroup.h".} = object of TypedWritableReferenceCount
  ## This is the base class for PartRoot and MovingPart.  It defines a hierarchy
  ## of MovingParts.

converter toPartGroup*(_: type(nil)): PartGroup {.importcpp: "(nullptr)".}
converter toBool*(this: PartGroup): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PartGroup, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PartGroup], obj: TypedObject): PartGroup {.importcpp: "DCAST(PartGroup, @)".}

type AnimControl* {.importcpp: "PT(AnimControl)", bycopy, pure, inheritable, header: "animControl.h".} = object of TypedReferenceCount
  ## Controls the timing of a character animation.  An AnimControl object is
  ## created for each character/bundle binding and manages the state of the
  ## animation: whether started, stopped, or looping, and the current frame
  ## number and play rate.

converter toAnimControl*(_: type(nil)): AnimControl {.importcpp: "(nullptr)".}
converter toBool*(this: AnimControl): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimControl, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimControl], obj: TypedObject): AnimControl {.importcpp: "DCAST(AnimControl, @)".}

type AnimChannelBase* {.importcpp: "PT(AnimChannelBase)", bycopy, pure, inheritable, header: "animChannelBase.h".} = object of AnimGroup
  ## Parent class for all animation channels.  An AnimChannel is an arbitrary
  ## function that changes over time (actually, over frames), usually defined by
  ## a table read from an egg file (but possibly computed or generated in any
  ## other way).

converter toAnimChannelBase*(_: type(nil)): AnimChannelBase {.importcpp: "(nullptr)".}
converter toBool*(this: AnimChannelBase): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimChannelBase, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimChannelBase], obj: TypedObject): AnimChannelBase {.importcpp: "DCAST(AnimChannelBase, @)".}

type AnimChannelMatrixDynamic* {.importcpp: "PT(AnimChannelMatrixDynamic)", bycopy, pure, inheritable, header: "animChannelMatrixDynamic.h".} = object
  ## An animation channel that accepts a matrix each frame from some dynamic
  ## input provided by code.
  ##
  ## This object operates in two modes: in explicit mode, the programmer should
  ## call set_value() each frame to indicate the new value; in implicit mode,
  ## the programmer should call set_value_node() to indicate the node whose
  ## transform will be copied to the joint each frame.

converter toAnimChannelMatrixDynamic*(_: type(nil)): AnimChannelMatrixDynamic {.importcpp: "(nullptr)".}
converter toBool*(this: AnimChannelMatrixDynamic): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimChannelMatrixDynamic, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimChannelMatrixDynamic], obj: TypedObject): AnimChannelMatrixDynamic {.importcpp: "DCAST(AnimChannelMatrixDynamic, @)".}

type AnimChannelMatrixXfmTable* {.importcpp: "PT(AnimChannelMatrixXfmTable)", bycopy, pure, inheritable, header: "animChannelMatrixXfmTable.h".} = object
  ## An animation channel that issues a matrix each frame, read from a table
  ## such as might have been read from an egg file.  The table actually consists
  ## of nine sub-tables, each representing one component of the transform:
  ## scale, rotate, translate.

converter toAnimChannelMatrixXfmTable*(_: type(nil)): AnimChannelMatrixXfmTable {.importcpp: "(nullptr)".}
converter toBool*(this: AnimChannelMatrixXfmTable): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimChannelMatrixXfmTable, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimChannelMatrixXfmTable], obj: TypedObject): AnimChannelMatrixXfmTable {.importcpp: "DCAST(AnimChannelMatrixXfmTable, @)".}

type AnimChannelScalarDynamic* {.importcpp: "PT(AnimChannelScalarDynamic)", bycopy, pure, inheritable, header: "animChannelScalarDynamic.h".} = object
  ## An animation channel that accepts a scalar each frame from some dynamic
  ## input provided by code.
  ##
  ## This object operates in two modes: in explicit mode, the programmer should
  ## call set_value() each frame to indicate the new value; in implicit mode,
  ## the programmer should call set_value_node() to indicate the node whose X
  ## component will be copied to the scalar each frame.

converter toAnimChannelScalarDynamic*(_: type(nil)): AnimChannelScalarDynamic {.importcpp: "(nullptr)".}
converter toBool*(this: AnimChannelScalarDynamic): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimChannelScalarDynamic, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimChannelScalarDynamic], obj: TypedObject): AnimChannelScalarDynamic {.importcpp: "DCAST(AnimChannelScalarDynamic, @)".}

type AnimChannelScalarTable* {.importcpp: "PT(AnimChannelScalarTable)", bycopy, pure, inheritable, header: "animChannelScalarTable.h".} = object
  ## An animation channel that issues a scalar each frame, read from a table
  ## such as might have been read from an egg file.

converter toAnimChannelScalarTable*(_: type(nil)): AnimChannelScalarTable {.importcpp: "(nullptr)".}
converter toBool*(this: AnimChannelScalarTable): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimChannelScalarTable, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimChannelScalarTable], obj: TypedObject): AnimChannelScalarTable {.importcpp: "DCAST(AnimChannelScalarTable, @)".}

type AnimControlCollection* {.importcpp: "AnimControlCollection", pure, inheritable, header: "animControlCollection.h".} = object
  ## This is a named collection of AnimControl pointers.  An AnimControl may be
  ## added to the collection by name.  While an AnimControl is associated, its
  ## reference count is maintained; associating a new AnimControl with the same
  ## name will decrement the previous control's reference count (and possibly
  ## delete it, unbinding its animation).

type CopyOnWriteObject* {.importcpp: "PT(CopyOnWriteObject)", bycopy, pure, inheritable, header: "copyOnWriteObject.h".} = object of CachedTypedWritableReferenceCount
  ## This base class provides basic reference counting, but also can be used
  ## with a CopyOnWritePointer to provide get_read_pointer() and
  ## get_write_pointer().

converter toCopyOnWriteObject*(_: type(nil)): CopyOnWriteObject {.importcpp: "(nullptr)".}
converter toBool*(this: CopyOnWriteObject): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CopyOnWriteObject, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CopyOnWriteObject], obj: TypedObject): CopyOnWriteObject {.importcpp: "DCAST(CopyOnWriteObject, @)".}

type AnimPreloadTable* {.importcpp: "PT(AnimPreloadTable)", bycopy, pure, inheritable, header: "animPreloadTable.h".} = object of CopyOnWriteObject
  ## This table records data about a list of animations for a particular model,
  ## such as number of frames and frame rate.  It's used for implementating
  ## asynchronous binding.
  ##
  ## This table is normally built by an offline tool, such as egg-optchar.

converter toAnimPreloadTable*(_: type(nil)): AnimPreloadTable {.importcpp: "(nullptr)".}
converter toBool*(this: AnimPreloadTable): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimPreloadTable, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimPreloadTable], obj: TypedObject): AnimPreloadTable {.importcpp: "DCAST(AnimPreloadTable, @)".}

type PartSubset* {.importcpp: "PartSubset", pure, inheritable, header: "partSubset.h".} = object
  ## This class is used to define a subset of part names to apply to the
  ## PartBundle::bind_anim() operation.  Only those part names within the subset
  ## will be included in the bind.

type BindAnimRequest* {.importcpp: "PT(BindAnimRequest)", bycopy, pure, inheritable, header: "bindAnimRequest.h".} = object of ModelLoadRequest
  ## This class object manages an asynchronous load-and-bind animation request,
  ## as issued through PartBundle::load_bind_anim().

converter toBindAnimRequest*(_: type(nil)): BindAnimRequest {.importcpp: "(nullptr)".}
converter toBool*(this: BindAnimRequest): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: BindAnimRequest, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[BindAnimRequest], obj: TypedObject): BindAnimRequest {.importcpp: "DCAST(BindAnimRequest, @)".}

type PartBundle* {.importcpp: "PT(PartBundle)", bycopy, pure, inheritable, header: "partBundle.h".} = object of PartGroup
  ## This is the root of a MovingPart hierarchy.  It defines the hierarchy of
  ## moving parts that make up an animatable object.

converter toPartBundle*(_: type(nil)): PartBundle {.importcpp: "(nullptr)".}
converter toBool*(this: PartBundle): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PartBundle, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PartBundle], obj: TypedObject): PartBundle {.importcpp: "DCAST(PartBundle, @)".}

type PartBundleNode* {.importcpp: "PT(PartBundleNode)", bycopy, pure, inheritable, header: "partBundleNode.h".} = object of PandaNode
  ## This is a node that contains a pointer to an PartBundle.  Like
  ## AnimBundleNode, it exists to make it easy to store PartBundles in the scene
  ## graph.
  ##
  ## (Unlike AnimBundleNode, however, PartBundleNode has an additional function:
  ## it is also the base class of the Character node type, which adds additional
  ## functionality.)

converter toPartBundleNode*(_: type(nil)): PartBundleNode {.importcpp: "(nullptr)".}
converter toBool*(this: PartBundleNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PartBundleNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PartBundleNode], obj: TypedObject): PartBundleNode {.importcpp: "DCAST(PartBundleNode, @)".}

type PartBundleHandle* {.importcpp: "PT(PartBundleHandle)", bycopy, pure, inheritable, header: "partBundleHandle.h".} = object of ReferenceCount
  ## This is a trivial class returned by PartBundleNode::get_bundle().  Its
  ## purpose is to hold the actual PartBundle pointer contained within the
  ## PartBundleNode, so that scene graph flatten operations can safely combine
  ## or duplicate PartBundles as necessary without affecting high-level bundle
  ## operations.
  ##
  ## The high-level Actor class defined in direct/src/actor, for instance, will
  ## store a list of PartBundleHandles instead of on actual PartBundles, so that
  ## it will be immune to changes from these flatten operations.

converter toPartBundleHandle*(_: type(nil)): PartBundleHandle {.importcpp: "(nullptr)".}
converter toBool*(this: PartBundleHandle): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PartBundleHandle, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PartBundleHandle], obj: TypedObject): PartBundleHandle {.importcpp: "DCAST(PartBundleHandle, @)".}

type MovingPartBase* {.importcpp: "PT(MovingPartBase)", bycopy, pure, inheritable, header: "movingPartBase.h".} = object of PartGroup
  ## This is the base class for a single animatable piece that may be bound to
  ## one channel (or more, if blending is in effect).  It corresponds to, for
  ## instance, a single joint or slider of a character.
  ##
  ## MovingPartBase does not have a particular value type.  See the derived
  ## template class, MovingPart, for this.

converter toMovingPartBase*(_: type(nil)): MovingPartBase {.importcpp: "(nullptr)".}
converter toBool*(this: MovingPartBase): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MovingPartBase, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MovingPartBase], obj: TypedObject): MovingPartBase {.importcpp: "DCAST(MovingPartBase, @)".}

type MovingPartMatrix* {.importcpp: "PT(MovingPartMatrix)", bycopy, pure, inheritable, header: "movingPartMatrix.h".} = object
  ## This is a particular kind of MovingPart that accepts a matrix each frame.

converter toMovingPartMatrix*(_: type(nil)): MovingPartMatrix {.importcpp: "(nullptr)".}
converter toBool*(this: MovingPartMatrix): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MovingPartMatrix, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MovingPartMatrix], obj: TypedObject): MovingPartMatrix {.importcpp: "DCAST(MovingPartMatrix, @)".}

type MovingPartScalar* {.importcpp: "PT(MovingPartScalar)", bycopy, pure, inheritable, header: "movingPartScalar.h".} = object
  ## This is a particular kind of MovingPart that accepts a scalar each frame.

converter toMovingPartScalar*(_: type(nil)): MovingPartScalar {.importcpp: "(nullptr)".}
converter toBool*(this: MovingPartScalar): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MovingPartScalar, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MovingPartScalar], obj: TypedObject): MovingPartScalar {.importcpp: "DCAST(MovingPartScalar, @)".}

type PStatClient* {.importcpp: "PStatClient", pure, inheritable, header: "pStatClient.h".} = object

type PStatCollector* {.importcpp: "PStatCollector", pure, inheritable, header: "pStatCollector.h".} = object
  ## A lightweight class that represents a single element that may be timed
  ## and/or counted via stats.
  ##
  ## Collectors can be used to measure two different kinds of values: elapsed
  ## time, and "other".
  ##
  ## To measure elapsed time, call start() and stop() as appropriate to bracket
  ## the section of code you want to time (or use a PStatTimer to do this
  ## automatically).
  ##
  ## To measure anything else, call set_level() and/or add_level() to set the
  ## "level" value associated with this collector.  The meaning of the value set
  ## for the "level" is entirely up to the user; it may represent the number of
  ## triangles rendered or the kilobytes of texture memory consumed, for
  ## instance.  The level set will remain fixed across multiple frames until it
  ## is reset via another set_level() or adjusted via a call to add_level().  It
  ## may also be completely removed via clear_level().

type PStatThread* {.importcpp: "PStatThread", pure, inheritable, header: "pStatThread.h".} = object
  ## A lightweight class that represents a single thread of execution to PStats.
  ## It corresponds one-to-one with Panda's Thread instance.

type PStatCollectorForward* {.importcpp: "PT(PStatCollectorForward)", bycopy, pure, inheritable, header: "pStatCollectorForward.h".} = object of PStatCollectorForwardBase
  ## This class serves as a cheap forward reference to a PStatCollector, so that
  ## classes that are defined before the pstats module may access the
  ## PStatCollector.

converter toPStatCollectorForward*(_: type(nil)): PStatCollectorForward {.importcpp: "(nullptr)".}
converter toBool*(this: PStatCollectorForward): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PStatCollectorForward, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PStatCollectorForward], obj: TypedObject): PStatCollectorForward {.importcpp: "DCAST(PStatCollectorForward, @)".}

type CharacterJoint* {.importcpp: "PT(CharacterJoint)", bycopy, pure, inheritable, header: "characterJoint.h".} = object of MovingPartMatrix
  ## This represents one joint of the character's animation, containing an
  ## animating transform matrix.

converter toCharacterJoint*(_: type(nil)): CharacterJoint {.importcpp: "(nullptr)".}
converter toBool*(this: CharacterJoint): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CharacterJoint, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CharacterJoint], obj: TypedObject): CharacterJoint {.importcpp: "DCAST(CharacterJoint, @)".}

type CharacterSlider* {.importcpp: "PT(CharacterSlider)", bycopy, pure, inheritable, header: "characterSlider.h".} = object of MovingPartScalar
  ## This is a morph slider within the character.  It's simply a single
  ## floating-point value that animates generally between 0 and 1, that controls
  ## the effects of one or more morphs within the character.

converter toCharacterSlider*(_: type(nil)): CharacterSlider {.importcpp: "(nullptr)".}
converter toBool*(this: CharacterSlider): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CharacterSlider, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CharacterSlider], obj: TypedObject): CharacterSlider {.importcpp: "DCAST(CharacterSlider, @)".}

type VertexSlider* {.importcpp: "PT(VertexSlider)", bycopy, pure, inheritable, header: "vertexSlider.h".} = object of TypedWritableReferenceCount
  ## This is an abstract base class that retains some slider value, which is a
  ## linear value that typically ranges from 0.0 to 1.0, and is used to control
  ## the animation of morphs (blend shapes).
  ##
  ## It is similar to VertexTransform, which keeps a full 4x4 transform matrix,
  ## but the VertexSlider only keeps a single float value.

converter toVertexSlider*(_: type(nil)): VertexSlider {.importcpp: "(nullptr)".}
converter toBool*(this: VertexSlider): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VertexSlider, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VertexSlider], obj: TypedObject): VertexSlider {.importcpp: "DCAST(VertexSlider, @)".}

type CharacterVertexSlider* {.importcpp: "PT(CharacterVertexSlider)", bycopy, pure, inheritable, header: "characterVertexSlider.h".} = object of VertexSlider
  ## This is a specialization on VertexSlider that returns the slider value
  ## associated with a particular CharacterSlider object.

converter toCharacterVertexSlider*(_: type(nil)): CharacterVertexSlider {.importcpp: "(nullptr)".}
converter toBool*(this: CharacterVertexSlider): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CharacterVertexSlider, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CharacterVertexSlider], obj: TypedObject): CharacterVertexSlider {.importcpp: "DCAST(CharacterVertexSlider, @)".}

type JointVertexTransform* {.importcpp: "PT(JointVertexTransform)", bycopy, pure, inheritable, header: "jointVertexTransform.h".} = object of VertexTransform
  ## This is a specialization on VertexTransform that returns the transform
  ## necessary to move vertices as if they were assigned to the indicated joint.
  ## The geometry itself should be parented to the scene graph at the level of
  ## the character's root joint; that is, it should not be parented under a node
  ## directly animated by any joints.
  ##
  ## Multiple combinations of these with different weights are used to implement
  ## soft-skinned vertices for an animated character.

converter toJointVertexTransform*(_: type(nil)): JointVertexTransform {.importcpp: "(nullptr)".}
converter toBool*(this: JointVertexTransform): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: JointVertexTransform, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[JointVertexTransform], obj: TypedObject): JointVertexTransform {.importcpp: "DCAST(JointVertexTransform, @)".}

type Character* {.importcpp: "PT(Character)", bycopy, pure, inheritable, header: "character.h".} = object of PartBundleNode
  ## An animated character, with skeleton-morph animation and either soft-
  ## skinned or hard-skinned vertices.

converter toCharacter*(_: type(nil)): Character {.importcpp: "(nullptr)".}
converter toBool*(this: Character): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Character, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Character], obj: TypedObject): Character {.importcpp: "DCAST(Character, @)".}

type CharacterJointBundle* {.importcpp: "PT(CharacterJointBundle)", bycopy, pure, inheritable, header: "characterJointBundle.h".} = object of PartBundle
  ## The collection of all the joints and sliders in the character.

converter toCharacterJointBundle*(_: type(nil)): CharacterJointBundle {.importcpp: "(nullptr)".}
converter toBool*(this: CharacterJointBundle): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CharacterJointBundle, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CharacterJointBundle], obj: TypedObject): CharacterJointBundle {.importcpp: "DCAST(CharacterJointBundle, @)".}

type CharacterJointEffect* {.importcpp: "PT(CharacterJointEffect)", bycopy, pure, inheritable, header: "characterJointEffect.h".} = object of RenderEffect
  ## This effect will be added automatically to a node by
  ## CharacterJoint::add_net_transform() and
  ## CharacterJoint::add_local_transform().
  ##
  ## The effect binds the node back to the character, so that querying the
  ## relative transform of the affected node will automatically force the
  ## indicated character to be updated first.

converter toCharacterJointEffect*(_: type(nil)): CharacterJointEffect {.importcpp: "(nullptr)".}
converter toBool*(this: CharacterJointEffect): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CharacterJointEffect, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CharacterJointEffect], obj: TypedObject): CharacterJointEffect {.importcpp: "DCAST(CharacterJointEffect, @)".}

type CollisionSolid* {.importcpp: "PT(CollisionSolid)", bycopy, pure, inheritable, header: "collisionSolid.h".} = object of CopyOnWriteObject
  ## The abstract base class for all things that can collide with other things
  ## in the world, and all the things they can collide with (except geometry).
  ##
  ## This class and its derivatives really work very similarly to the way
  ## BoundingVolume and all of its derivatives work.  There's a different
  ## subclass for each basic shape of solid, and double-dispatch function calls
  ## handle the subset of the N\*N intersection tests that we care about.

converter toCollisionSolid*(_: type(nil)): CollisionSolid {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionSolid): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionSolid, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionSolid], obj: TypedObject): CollisionSolid {.importcpp: "DCAST(CollisionSolid, @)".}

type CollisionBox* {.importcpp: "PT(CollisionBox)", bycopy, pure, inheritable, header: "collisionBox.h".} = object of CollisionSolid
  ## A cuboid collision volume or object.

converter toCollisionBox*(_: type(nil)): CollisionBox {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionBox): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionBox, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionBox], obj: TypedObject): CollisionBox {.importcpp: "DCAST(CollisionBox, @)".}

type CollisionCapsule* {.importcpp: "PT(CollisionCapsule)", bycopy, pure, inheritable, header: "collisionCapsule.h".} = object of CollisionSolid
  ## This implements a solid consisting of a cylinder with hemispherical endcaps,
  ## also known as a capsule or a spherocylinder.
  ##
  ## This shape was previously erroneously called CollisionTube.

converter toCollisionCapsule*(_: type(nil)): CollisionCapsule {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionCapsule): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionCapsule, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionCapsule], obj: TypedObject): CollisionCapsule {.importcpp: "DCAST(CollisionCapsule, @)".}

type CollisionHandler* {.importcpp: "PT(CollisionHandler)", bycopy, pure, inheritable, header: "collisionHandler.h".} = object of TypedReferenceCount
  ## The abstract interface to a number of classes that decide what to do when a
  ## collision is detected.  One of these must be assigned to the
  ## CollisionTraverser that is processing collisions in order to specify how to
  ## dispatch detected collisions.

converter toCollisionHandler*(_: type(nil)): CollisionHandler {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionHandler): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionHandler, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionHandler], obj: TypedObject): CollisionHandler {.importcpp: "DCAST(CollisionHandler, @)".}

type CollisionNode* {.importcpp: "PT(CollisionNode)", bycopy, pure, inheritable, header: "collisionNode.h".} = object of PandaNode
  ## A node in the scene graph that can hold any number of CollisionSolids.
  ## This may either represent a bit of static geometry in the scene that things
  ## will collide with, or an animated object twirling around in the world and
  ## running into things.

converter toCollisionNode*(_: type(nil)): CollisionNode {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionNode], obj: TypedObject): CollisionNode {.importcpp: "DCAST(CollisionNode, @)".}

type CollisionTraverser* {.importcpp: "CollisionTraverser", pure, inheritable, header: "collisionTraverser.h".} = object of Namable
  ## This class manages the traversal through the scene graph to detect
  ## collisions.  It holds ownership of a number of collider objects, each of
  ## which is a CollisionNode and an associated CollisionHandler.
  ##
  ## When traverse() is called, it begins at the indicated root and detects all
  ## collisions with any of its collider objects against nodes at or below the
  ## indicated root, calling the appropriate CollisionHandler for each detected
  ## collision.

type CollisionRecorder* {.importcpp: "CollisionRecorder", pure, inheritable, header: "collisionRecorder.h".} = object of TypedObject
  ## This class is used to help debug the work the collisions system is doing.
  ## It is a virtual base class that just provides an interface for recording
  ## collisions tested and detected each frame.

type CollisionEntry* {.importcpp: "PT(CollisionEntry)", bycopy, pure, inheritable, header: "collisionEntry.h".} = object of TypedWritableReferenceCount
  ## Defines a single collision event.  One of these is created for each
  ## collision detected by a CollisionTraverser, to be dealt with by the
  ## CollisionHandler.
  ##
  ## A CollisionEntry provides slots for a number of data values (such as
  ## intersection point and normal) that might or might not be known for each
  ## collision.  It is up to the handler to determine what information is known
  ## and to do the right thing with it.

converter toCollisionEntry*(_: type(nil)): CollisionEntry {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionEntry): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionEntry, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionEntry], obj: TypedObject): CollisionEntry {.importcpp: "DCAST(CollisionEntry, @)".}

type CollisionPlane* {.importcpp: "PT(CollisionPlane)", bycopy, pure, inheritable, header: "collisionPlane.h".} = object of CollisionSolid

converter toCollisionPlane*(_: type(nil)): CollisionPlane {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionPlane): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionPlane, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionPlane], obj: TypedObject): CollisionPlane {.importcpp: "DCAST(CollisionPlane, @)".}

type CollisionFloorMesh* {.importcpp: "PT(CollisionFloorMesh)", bycopy, pure, inheritable, header: "collisionFloorMesh.h".} = object of CollisionSolid
  ## This object represents a solid made entirely of triangles, which will only
  ## be tested again z axis aligned rays

converter toCollisionFloorMesh*(_: type(nil)): CollisionFloorMesh {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionFloorMesh): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionFloorMesh, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionFloorMesh], obj: TypedObject): CollisionFloorMesh {.importcpp: "DCAST(CollisionFloorMesh, @)".}

type CollisionPolygon* {.importcpp: "PT(CollisionPolygon)", bycopy, pure, inheritable, header: "collisionPolygon.h".} = object of CollisionPlane

converter toCollisionPolygon*(_: type(nil)): CollisionPolygon {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionPolygon): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionPolygon, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionPolygon], obj: TypedObject): CollisionPolygon {.importcpp: "DCAST(CollisionPolygon, @)".}

type CollisionHandlerEvent* {.importcpp: "PT(CollisionHandlerEvent)", bycopy, pure, inheritable, header: "collisionHandlerEvent.h".} = object of CollisionHandler
  ## A specialized kind of CollisionHandler that throws an event for each
  ## collision detected.  The event thrown may be based on the name of the
  ## moving object or the struck object, or both.  The first parameter of the
  ## event will be a pointer to the CollisionEntry that triggered it.

converter toCollisionHandlerEvent*(_: type(nil)): CollisionHandlerEvent {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionHandlerEvent): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionHandlerEvent, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionHandlerEvent], obj: TypedObject): CollisionHandlerEvent {.importcpp: "DCAST(CollisionHandlerEvent, @)".}

type CollisionHandlerPhysical* {.importcpp: "PT(CollisionHandlerPhysical)", bycopy, pure, inheritable, header: "collisionHandlerPhysical.h".} = object of CollisionHandlerEvent
  ## The abstract base class for a number of CollisionHandlers that have some
  ## physical effect on their moving bodies: they need to update the nodes'
  ## positions based on the effects of the collision.

converter toCollisionHandlerPhysical*(_: type(nil)): CollisionHandlerPhysical {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionHandlerPhysical): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionHandlerPhysical, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionHandlerPhysical], obj: TypedObject): CollisionHandlerPhysical {.importcpp: "DCAST(CollisionHandlerPhysical, @)".}

type CollisionHandlerFloor* {.importcpp: "PT(CollisionHandlerFloor)", bycopy, pure, inheritable, header: "collisionHandlerFloor.h".} = object of CollisionHandlerPhysical
  ## A specialized kind of CollisionHandler that sets the Z height of the
  ## collider to a fixed linear offset from the highest detected collision point
  ## each frame.  It's intended to implement walking around on a floor of
  ## varying height by casting a ray down from the avatar's head.

converter toCollisionHandlerFloor*(_: type(nil)): CollisionHandlerFloor {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionHandlerFloor): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionHandlerFloor, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionHandlerFloor], obj: TypedObject): CollisionHandlerFloor {.importcpp: "DCAST(CollisionHandlerFloor, @)".}

type CollisionHandlerPusher* {.importcpp: "PT(CollisionHandlerPusher)", bycopy, pure, inheritable, header: "collisionHandlerPusher.h".} = object of CollisionHandlerPhysical
  ## A specialized kind of CollisionHandler that simply pushes back on things
  ## that attempt to move into solid walls.  This is the simplest kind of "real-
  ## world" collisions you can have.

converter toCollisionHandlerPusher*(_: type(nil)): CollisionHandlerPusher {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionHandlerPusher): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionHandlerPusher, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionHandlerPusher], obj: TypedObject): CollisionHandlerPusher {.importcpp: "DCAST(CollisionHandlerPusher, @)".}

type CollisionHandlerFluidPusher* {.importcpp: "PT(CollisionHandlerFluidPusher)", bycopy, pure, inheritable, header: "collisionHandlerFluidPusher.h".} = object of CollisionHandlerPusher
  ## A CollisionHandlerPusher that makes use of timing and spatial information
  ## from fluid collisions to improve collision response

converter toCollisionHandlerFluidPusher*(_: type(nil)): CollisionHandlerFluidPusher {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionHandlerFluidPusher): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionHandlerFluidPusher, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionHandlerFluidPusher], obj: TypedObject): CollisionHandlerFluidPusher {.importcpp: "DCAST(CollisionHandlerFluidPusher, @)".}

type CollisionHandlerGravity* {.importcpp: "PT(CollisionHandlerGravity)", bycopy, pure, inheritable, header: "collisionHandlerGravity.h".} = object of CollisionHandlerPhysical
  ## A specialized kind of CollisionHandler that sets the Z height of the
  ## collider to a fixed linear offset from the highest detected collision point
  ## each frame.  It's intended to implement walking around on a floor of
  ## varying height by casting a ray down from the avatar's head.

converter toCollisionHandlerGravity*(_: type(nil)): CollisionHandlerGravity {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionHandlerGravity): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionHandlerGravity, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionHandlerGravity], obj: TypedObject): CollisionHandlerGravity {.importcpp: "DCAST(CollisionHandlerGravity, @)".}

type CollisionHandlerHighestEvent* {.importcpp: "PT(CollisionHandlerHighestEvent)", bycopy, pure, inheritable, header: "collisionHandlerHighestEvent.h".} = object of CollisionHandlerEvent
  ## A specialized kind of CollisionHandler that throws an event for each
  ## collision detected.  The event thrown may be based on the name of the
  ## moving object or the struck object, or both.  The first parameter of the
  ## event will be a pointer to the CollisionEntry that triggered it.

converter toCollisionHandlerHighestEvent*(_: type(nil)): CollisionHandlerHighestEvent {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionHandlerHighestEvent): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionHandlerHighestEvent, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionHandlerHighestEvent], obj: TypedObject): CollisionHandlerHighestEvent {.importcpp: "DCAST(CollisionHandlerHighestEvent, @)".}

type CollisionHandlerQueue* {.importcpp: "PT(CollisionHandlerQueue)", bycopy, pure, inheritable, header: "collisionHandlerQueue.h".} = object of CollisionHandler
  ## A special kind of CollisionHandler that does nothing except remember the
  ## CollisionEntries detected the last pass.  This set of CollisionEntries may
  ## then be queried by the calling function.  It's primarily useful when a
  ## simple intersection test is being made, e.g.  for picking from the window.

converter toCollisionHandlerQueue*(_: type(nil)): CollisionHandlerQueue {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionHandlerQueue): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionHandlerQueue, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionHandlerQueue], obj: TypedObject): CollisionHandlerQueue {.importcpp: "DCAST(CollisionHandlerQueue, @)".}

type CollisionSphere* {.importcpp: "PT(CollisionSphere)", bycopy, pure, inheritable, header: "collisionSphere.h".} = object of CollisionSolid
  ## A spherical collision volume or object.

converter toCollisionSphere*(_: type(nil)): CollisionSphere {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionSphere): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionSphere, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionSphere], obj: TypedObject): CollisionSphere {.importcpp: "DCAST(CollisionSphere, @)".}

type CollisionInvSphere* {.importcpp: "PT(CollisionInvSphere)", bycopy, pure, inheritable, header: "collisionInvSphere.h".} = object of CollisionSphere
  ## An inverted sphere: this is a sphere whose collision surface is the inside
  ## surface of the sphere.  Everything outside the sphere is solid matter;
  ## everything inside is empty space.  Useful for constraining objects to
  ## remain within a spherical perimeter.

converter toCollisionInvSphere*(_: type(nil)): CollisionInvSphere {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionInvSphere): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionInvSphere, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionInvSphere], obj: TypedObject): CollisionInvSphere {.importcpp: "DCAST(CollisionInvSphere, @)".}

type CollisionRay* {.importcpp: "PT(CollisionRay)", bycopy, pure, inheritable, header: "collisionRay.h".} = object of CollisionSolid
  ## An infinite ray, with a specific origin and direction.  It begins at its
  ## origin and continues in one direction to infinity, and it has no radius.
  ## Useful for picking from a window, or for gravity effects.

converter toCollisionRay*(_: type(nil)): CollisionRay {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionRay): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionRay, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionRay], obj: TypedObject): CollisionRay {.importcpp: "DCAST(CollisionRay, @)".}

type CollisionLine* {.importcpp: "PT(CollisionLine)", bycopy, pure, inheritable, header: "collisionLine.h".} = object of CollisionRay
  ## An infinite line, similar to a CollisionRay, except that it extends in both
  ## directions.  It is, however, directional.

converter toCollisionLine*(_: type(nil)): CollisionLine {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionLine): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionLine, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionLine], obj: TypedObject): CollisionLine {.importcpp: "DCAST(CollisionLine, @)".}

type CollisionParabola* {.importcpp: "PT(CollisionParabola)", bycopy, pure, inheritable, header: "collisionParabola.h".} = object of CollisionSolid
  ## This defines a parabolic arc, or subset of an arc, similar to the path of a
  ## projectile or falling object.  It is finite, having a specific beginning
  ## and end, but it is infinitely thin.
  ##
  ## Think of it as a wire bending from point t1 to point t2 along the path of a
  ## pre-defined parabola.

converter toCollisionParabola*(_: type(nil)): CollisionParabola {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionParabola): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionParabola, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionParabola], obj: TypedObject): CollisionParabola {.importcpp: "DCAST(CollisionParabola, @)".}

type CollisionSegment* {.importcpp: "PT(CollisionSegment)", bycopy, pure, inheritable, header: "collisionSegment.h".} = object of CollisionSolid
  ## A finite line segment, with two specific endpoints but no thickness.  It's
  ## similar to a CollisionRay, except it does not continue to infinity.
  ##
  ## It does have an ordering, from point A to point B. If more than a single
  ## point of the segment is intersecting a solid, the reported intersection
  ## point is generally the closest on the segment to point A.

converter toCollisionSegment*(_: type(nil)): CollisionSegment {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionSegment): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionSegment, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionSegment], obj: TypedObject): CollisionSegment {.importcpp: "DCAST(CollisionSegment, @)".}

type CollisionTube* = CollisionCapsule

type CollisionVisualizer* {.importcpp: "PT(CollisionVisualizer)", bycopy, pure, inheritable, header: "collisionVisualizer.h".} = object of PandaNode
  ## This class is used to help debug the work the collisions system is doing.
  ## It shows the polygons that are detected as collisions, as well as those
  ## that are simply considered for collisions.
  ##
  ## It may be parented anywhere in the scene graph where it will be rendered to
  ## achieve this.

converter toCollisionVisualizer*(_: type(nil)): CollisionVisualizer {.importcpp: "(nullptr)".}
converter toBool*(this: CollisionVisualizer): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CollisionVisualizer, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CollisionVisualizer], obj: TypedObject): CollisionVisualizer {.importcpp: "DCAST(CollisionVisualizer, @)".}

type TrackerData* {.importcpp: "TrackerData", pure, inheritable, header: "trackerData.h".} = object
  ## Stores the kinds of data that a tracker might output.

type InputDevice* {.importcpp: "PT(InputDevice)", bycopy, pure, inheritable, header: "inputDevice.h".} = object of TypedReferenceCount
  ## This is a structure representing a single input device.  Input devices may
  ## have zero or more buttons, pointers, or axes associated with them, and
  ## optionally a motion tracker.
  ##
  ## These devices are brought under a common interface because there is such a
  ## large range of devices out there that may support any number of these types
  ## of axes, we couldn't even begin to cover them with type-specific
  ## subclasses.
  ##
  ## Use the various has_() and get_num_() methods to determine information about
  ## the device capabilities. For instance, has_keyboard() will give an
  ## indication that you can receive keystroke events from this device, and
  ## get_num_buttons() will tell you that the device may send button events.
  ##
  ## There is the DeviceType enumeration, however, which will (if known) contain
  ## identification of the general category of devices this fits in, such as
  ## keyboard, mouse, gamepad, or flight stick.
  ##
  ## @since 1.10.0

converter toInputDevice*(_: type(nil)): InputDevice {.importcpp: "(nullptr)".}
converter toBool*(this: InputDevice): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: InputDevice, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[InputDevice], obj: TypedObject): InputDevice {.importcpp: "DCAST(InputDevice, @)".}

type ClientBase* {.importcpp: "PT(ClientBase)", bycopy, pure, inheritable, header: "clientBase.h".} = object of TypedReferenceCount
  ## An abstract base class for a family of client device interfaces--including
  ## trackers, buttons, dials, and other analog inputs.
  ##
  ## This provides a common interface to connect to such devices and extract
  ## their data; it is used by TrackerNode etc.  to put these devices in the
  ## data graph.

converter toClientBase*(_: type(nil)): ClientBase {.importcpp: "(nullptr)".}
converter toBool*(this: ClientBase): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ClientBase, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ClientBase], obj: TypedObject): ClientBase {.importcpp: "DCAST(ClientBase, @)".}

type AnalogNode* {.importcpp: "PT(AnalogNode)", bycopy, pure, inheritable, header: "analogNode.h".} = object of DataNode
  ## This is the primary interface to analog controls like sliders and joysticks
  ## associated with a ClientBase.  This creates a node that connects to the
  ## named analog device, if it exists, and provides hooks to the user to read
  ## the state of any of the sequentially numbered controls associated with that
  ## device.
  ##
  ## Each control can return a value ranging from -1 to 1, reflecting the
  ## current position of the control within its total range of motion.
  ##
  ## The user may choose up to two analog controls to place on the data graph as
  ## the two channels of an xy datagram, similarly to the way a mouse places its
  ## position data.  In this way, an AnalogNode may be used in place of a mouse.

converter toAnalogNode*(_: type(nil)): AnalogNode {.importcpp: "(nullptr)".}
converter toBool*(this: AnalogNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnalogNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnalogNode], obj: TypedObject): AnalogNode {.importcpp: "DCAST(AnalogNode, @)".}

type ButtonNode* {.importcpp: "PT(ButtonNode)", bycopy, pure, inheritable, header: "buttonNode.h".} = object of DataNode
  ## This is the primary interface to on/off button devices associated with a
  ## ClientBase.  This creates a node that connects to the named button device,
  ## if it exists, and provides hooks to the user to read the state of any of
  ## the sequentially numbered buttons associated with that device.
  ##
  ## It also can associate an arbitrary ButtonHandle with each button; when
  ## buttons are associated with ButtonHandles, this node will put appropriate
  ## up and down events on the data graph for each button state change.

converter toButtonNode*(_: type(nil)): ButtonNode {.importcpp: "(nullptr)".}
converter toBool*(this: ButtonNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ButtonNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ButtonNode], obj: TypedObject): ButtonNode {.importcpp: "DCAST(ButtonNode, @)".}

type DialNode* {.importcpp: "PT(DialNode)", bycopy, pure, inheritable, header: "dialNode.h".} = object of DataNode
  ## This is the primary interface to infinite dial type devices associated with
  ## a ClientBase.  This creates a node that connects to the named dial device,
  ## if it exists, and provides hooks to the user to read the state of any of
  ## the sequentially numbered dial controls associated with that device.
  ##
  ## A dial is a rotating device that does not have stops--it can keep rotating
  ## any number of times.  Therefore it does not have a specific position at any
  ## given time, unlike an AnalogDevice.

converter toDialNode*(_: type(nil)): DialNode {.importcpp: "(nullptr)".}
converter toBool*(this: DialNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DialNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DialNode], obj: TypedObject): DialNode {.importcpp: "DCAST(DialNode, @)".}

type InputDeviceSet* {.importcpp: "InputDeviceSet", pure, inheritable, header: "inputDeviceSet.h".} = object
  ## Manages a list of InputDevice objects, as returned by various
  ## InputDeviceManager methods.  This is implemented like a set, meaning the
  ## same device cannot occur more than once.

type InputDeviceManager* {.importcpp: "InputDeviceManager", pure, inheritable, header: "inputDeviceManager.h".} = object
  ## This class keeps track of all the devices on a system, and sends out events
  ## when a device has been hot-plugged.
  ##
  ## @since 1.10.0

type InputDeviceNode* {.importcpp: "PT(InputDeviceNode)", bycopy, pure, inheritable, header: "inputDeviceNode.h".} = object of DataNode
  ## Reads the controller data sent from the InputDeviceManager, and transmits
  ## it down the data graph.
  ##
  ## This is intended to only be accessed from the app thread.

converter toInputDeviceNode*(_: type(nil)): InputDeviceNode {.importcpp: "(nullptr)".}
converter toBool*(this: InputDeviceNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: InputDeviceNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[InputDeviceNode], obj: TypedObject): InputDeviceNode {.importcpp: "DCAST(InputDeviceNode, @)".}

type TrackerNode* {.importcpp: "PT(TrackerNode)", bycopy, pure, inheritable, header: "trackerNode.h".} = object of DataNode
  ## This class reads the position and orientation information from a tracker
  ## device and makes it available as a transformation on the data graph.
  ## It is also the primary interface to a Tracker object associated with a
  ## ClientBase.

converter toTrackerNode*(_: type(nil)): TrackerNode {.importcpp: "(nullptr)".}
converter toBool*(this: TrackerNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TrackerNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TrackerNode], obj: TypedObject): TrackerNode {.importcpp: "DCAST(TrackerNode, @)".}

type VirtualMouse* {.importcpp: "PT(VirtualMouse)", bycopy, pure, inheritable, header: "virtualMouse.h".} = object of DataNode
  ## Poses as a MouseAndKeyboard object in the datagraph, but accepts input from
  ## user calls, rather than reading the actual mouse and keyboard from an input
  ## device.  The user can write high-level code to put the mouse wherever
  ## he/she wants, and to insert keypresses on demand.

converter toVirtualMouse*(_: type(nil)): VirtualMouse {.importcpp: "(nullptr)".}
converter toBool*(this: VirtualMouse): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VirtualMouse, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VirtualMouse], obj: TypedObject): VirtualMouse {.importcpp: "DCAST(VirtualMouse, @)".}

type DataGraphTraverser* {.importcpp: "DataGraphTraverser", pure, inheritable, header: "dataGraphTraverser.h".} = object
  ## This object supervises the traversal of the data graph and the moving of
  ## data from one DataNode to its children.  The data graph is used to manage
  ## data from input devices, etc.  See the overview of the data graph in
  ## dataNode.h.

type GraphicsDevice* {.importcpp: "PT(GraphicsDevice)", bycopy, pure, inheritable, header: "graphicsDevice.h".} = object of TypedReferenceCount
  ## An abstract device object that is part of Graphics Pipe.  This device is
  ## set to NULL for OpenGL. But DirectX uses it to take control of multiple
  ## windows under single device or multiple devices (i.e.  more than one
  ## adapters in the machine).

converter toGraphicsDevice*(_: type(nil)): GraphicsDevice {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsDevice): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsDevice, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GraphicsDevice], obj: TypedObject): GraphicsDevice {.importcpp: "DCAST(GraphicsDevice, @)".}

type GraphicsPipe* {.importcpp: "PT(GraphicsPipe)", bycopy, pure, inheritable, header: "graphicsPipe.h".} = object of TypedReferenceCount
  ## An object to create GraphicsOutputs that share a particular 3-D API.
  ## Normally, there will only be one GraphicsPipe in an application, although
  ## it is possible to have multiple of these at once if there are multiple
  ## different API's available in the same machine.
  ##
  ## Often, the GraphicsPipe corresponds to a physical output device, hence the
  ## term "pipe", but this is not necessarily the case.
  ##
  ## The GraphicsPipe is used by the GraphicsEngine object to create and destroy
  ## windows; it keeps ownership of the windows it creates.
  ##
  ## M. Asad added new/interim functionality where GraphicsPipe now contains a
  ## device interface to directx/opengl which will be used to handle multiple
  ## windows from same device.

converter toGraphicsPipe*(_: type(nil)): GraphicsPipe {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsPipe): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsPipe, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GraphicsPipe], obj: TypedObject): GraphicsPipe {.importcpp: "DCAST(GraphicsPipe, @)".}

type DisplayInformation* {.importcpp: "DisplayInformation", pure, inheritable, header: "displayInformation.h".} = object
  ## This class contains various display information.

type DrawableRegion* {.importcpp: "DrawableRegion*", bycopy, pure, inheritable, header: "drawableRegion.h".} = object
  ## This is a base class for GraphicsWindow (actually, GraphicsOutput) and
  ## DisplayRegion, both of which are conceptually rectangular regions into
  ## which drawing commands may be issued.  Sometimes you want to deal with a
  ## single display region, and sometimes you want to deal with the whole window
  ## at once, particularly for issuing clear commands and capturing screenshots.

converter toDrawableRegion*(_: type(nil)): DrawableRegion {.importcpp: "(nullptr)".}
converter toBool*(this: DrawableRegion): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DrawableRegion, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type WindowHandle* {.importcpp: "PT(WindowHandle)", bycopy, pure, inheritable, header: "windowHandle.h".} = object of TypedReferenceCount
  ## This object represents a window on the desktop, not necessarily a Panda
  ## window.  This structure can be assigned to a WindowProperties to indicate a
  ## parent window.
  ##
  ## It also has callbacks so the Panda window can communicate with its parent
  ## window, which is particularly important when running embedded in a browser.
  ##
  ## To create a WindowHandle, you would usually call one of the
  ## NativeWindowHandle::make_\*() methods, depending on the kind of native
  ## window handle object you already have.

converter toWindowHandle*(_: type(nil)): WindowHandle {.importcpp: "(nullptr)".}
converter toBool*(this: WindowHandle): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: WindowHandle, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[WindowHandle], obj: TypedObject): WindowHandle {.importcpp: "DCAST(WindowHandle, @)".}

type WindowProperties* {.importcpp: "WindowProperties", pure, inheritable, header: "windowProperties.h".} = object
  ## A container for the various kinds of properties we might ask to have on a
  ## graphics window before we open it.  This also serves to hold the current
  ## properties for a window after it has been opened.

type DisplayRegion* {.importcpp: "PT(DisplayRegion)", bycopy, pure, inheritable, header: "displayRegion.h".} = object of TypedReferenceCount
  ## A rectangular subregion within a window for rendering into.  Typically,
  ## there is one DisplayRegion that covers the whole window, but you may also
  ## create smaller DisplayRegions for having different regions within the
  ## window that represent different scenes.  You may also stack up
  ## DisplayRegions like panes of glass, usually for layering 2-d interfaces on
  ## top of a 3-d scene.

converter toDisplayRegion*(_: type(nil)): DisplayRegion {.importcpp: "(nullptr)".}
converter toBool*(this: DisplayRegion): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DisplayRegion, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DisplayRegion], obj: TypedObject): DisplayRegion {.importcpp: "DCAST(DisplayRegion, @)".}

type GraphicsOutputBase* {.importcpp: "PT(GraphicsOutputBase)", bycopy, pure, inheritable, header: "graphicsOutputBase.h".} = object of TypedWritableReferenceCount
  ## An abstract base class for GraphicsOutput, for all the usual reasons.

converter toGraphicsOutputBase*(_: type(nil)): GraphicsOutputBase {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsOutputBase): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsOutputBase, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GraphicsOutputBase], obj: TypedObject): GraphicsOutputBase {.importcpp: "DCAST(GraphicsOutputBase, @)".}

type GraphicsOutput* {.importcpp: "PT(GraphicsOutput)", bycopy, pure, inheritable, header: "graphicsOutput.h".} = object of GraphicsOutputBase
  ## This is a base class for the various different classes that represent the
  ## result of a frame of rendering.  The most common kind of GraphicsOutput is
  ## a GraphicsWindow, which is a real-time window on the desktop, but another
  ## example is GraphicsBuffer, which is an offscreen buffer.
  ##
  ## The actual rendering, and anything associated with the graphics context
  ## itself, is managed by the associated GraphicsStateGuardian (which might
  ## output to multiple GraphicsOutput objects).
  ##
  ## GraphicsOutputs are not actually writable to bam files, of course, but they
  ## may be passed as event parameters, so they inherit from
  ## TypedWritableReferenceCount instead of TypedReferenceCount for that
  ## convenience.

converter toGraphicsOutput*(_: type(nil)): GraphicsOutput {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsOutput): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsOutput, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GraphicsOutput], obj: TypedObject): GraphicsOutput {.importcpp: "DCAST(GraphicsOutput, @)".}

type GraphicsStateGuardianBase* {.importcpp: "PT(GraphicsStateGuardianBase)", bycopy, pure, inheritable, header: "graphicsStateGuardianBase.h".} = object of TypedWritableReferenceCount
  ## This is a base class for the GraphicsStateGuardian class, which is itself a
  ## base class for the various GSG's for different platforms.  This class
  ## contains all the function prototypes to support the double-dispatch of GSG
  ## to geoms, transitions, etc.  It lives in a separate class in its own
  ## package so we can avoid circular build dependency problems.
  ##
  ## GraphicsStateGuardians are not actually writable to bam files, of course,
  ## but they may be passed as event parameters, so they inherit from
  ## TypedWritableReferenceCount instead of TypedReferenceCount for that
  ## convenience.

converter toGraphicsStateGuardianBase*(_: type(nil)): GraphicsStateGuardianBase {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsStateGuardianBase): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsStateGuardianBase, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GraphicsStateGuardianBase], obj: TypedObject): GraphicsStateGuardianBase {.importcpp: "DCAST(GraphicsStateGuardianBase, @)".}

type GraphicsStateGuardian* {.importcpp: "PT(GraphicsStateGuardian)", bycopy, pure, inheritable, header: "graphicsStateGuardian.h".} = object of GraphicsStateGuardianBase
  ## Encapsulates all the communication with a particular instance of a given
  ## rendering backend.  Tries to guarantee that redundant state-change requests
  ## are not issued (hence "state guardian").
  ##
  ## There will be one of these objects for each different graphics context
  ## active in the system.

converter toGraphicsStateGuardian*(_: type(nil)): GraphicsStateGuardian {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsStateGuardian): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsStateGuardian, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GraphicsStateGuardian], obj: TypedObject): GraphicsStateGuardian {.importcpp: "DCAST(GraphicsStateGuardian, @)".}

type GraphicsEngine* {.importcpp: "PT(GraphicsEngine)", bycopy, pure, inheritable, header: "graphicsEngine.h".} = object of ReferenceCount
  ## This class is the main interface to controlling the render process.  There
  ## is typically only one GraphicsEngine in an application, and it synchronizes
  ## rendering to all all of the active windows; although it is possible to have
  ## multiple GraphicsEngine objects if multiple synchronicity groups are
  ## required.
  ##
  ## The GraphicsEngine is responsible for managing the various cull and draw
  ## threads.  The application simply calls engine->render_frame() and considers
  ## it done.

converter toGraphicsEngine*(_: type(nil)): GraphicsEngine {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsEngine): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsEngine, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GraphicsEngine], obj: TypedObject): GraphicsEngine {.importcpp: "DCAST(GraphicsEngine, @)".}

type GraphicsThreadingModel* {.importcpp: "GraphicsThreadingModel", pure, inheritable, header: "graphicsThreadingModel.h".} = object
  ## This represents the user's specification of how a particular frame is
  ## handled by the various threads.

type StereoDisplayRegion* {.importcpp: "PT(StereoDisplayRegion)", bycopy, pure, inheritable, header: "stereoDisplayRegion.h".} = object of DisplayRegion
  ## This is a special DisplayRegion wrapper that actually includes a pair of
  ## DisplayRegions internally: the left and right eyes.  The DisplayRegion
  ## represented here does not have a physical association with the window, but
  ## it pretends it does.  Instead, it maintains a pointer to the left and right
  ## DisplayRegions separately.
  ##
  ## Operations on the StereoDisplayRegion object affect both left and right
  ## eyes together.  To access the left or right eyes independently, use
  ## get_left_eye() and get_right_eye().

converter toStereoDisplayRegion*(_: type(nil)): StereoDisplayRegion {.importcpp: "(nullptr)".}
converter toBool*(this: StereoDisplayRegion): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: StereoDisplayRegion, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[StereoDisplayRegion], obj: TypedObject): StereoDisplayRegion {.importcpp: "DCAST(StereoDisplayRegion, @)".}

type FrameBufferProperties* {.importcpp: "FrameBufferProperties", pure, inheritable, header: "frameBufferProperties.h".} = object
  ## A container for the various kinds of properties we might ask to have on a
  ## graphics frameBuffer before we create a GSG.

type GraphicsWindowInputDevice* {.importcpp: "PT(GraphicsWindowInputDevice)", bycopy, pure, inheritable, header: "graphicsWindowInputDevice.h".} = object of InputDevice
  ## This is a virtual input device that represents the keyboard and mouse pair
  ## that is associated with a particular window.  It collects mouse and
  ## keyboard events from the windowing system while the window is in focus.

converter toGraphicsWindowInputDevice*(_: type(nil)): GraphicsWindowInputDevice {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsWindowInputDevice): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsWindowInputDevice, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GraphicsWindowInputDevice], obj: TypedObject): GraphicsWindowInputDevice {.importcpp: "DCAST(GraphicsWindowInputDevice, @)".}

type TouchInfo* {.importcpp: "TouchInfo", pure, inheritable, header: "touchInfo.h".} = object
  ## Stores information for a single touch event.

type GraphicsWindowProcCallbackData* {.importcpp: "GraphicsWindowProcCallbackData", pure, inheritable, header: "graphicsWindowProcCallbackData.h".} = object of CallbackData
  ## This specialization on CallbackData is passed when the callback is
  ## initiated from from an implementation of the GraphicsWindowProc class, such
  ## as PythonGraphicsWindowProc.

type GraphicsWindow* {.importcpp: "PT(GraphicsWindow)", bycopy, pure, inheritable, header: "graphicsWindow.h".} = object of GraphicsOutput
  ## A window, fullscreen or on a desktop, into which a graphics device sends
  ## its output for interactive display.

converter toGraphicsWindow*(_: type(nil)): GraphicsWindow {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsWindow): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsWindow, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GraphicsWindow], obj: TypedObject): GraphicsWindow {.importcpp: "DCAST(GraphicsWindow, @)".}

type CallbackGraphicsWindow* {.importcpp: "PT(CallbackGraphicsWindow)", bycopy, pure, inheritable, header: "callbackGraphicsWindow.h".} = object of GraphicsWindow
  ## This special window object doesn't represent a window in its own right, but
  ## instead hooks into some third-party API for creating and rendering to
  ## windows via callbacks.  This can be used to allow Panda to render into an
  ## already-created OpenGL context, for instance.

converter toCallbackGraphicsWindow*(_: type(nil)): CallbackGraphicsWindow {.importcpp: "(nullptr)".}
converter toBool*(this: CallbackGraphicsWindow): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CallbackGraphicsWindow, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CallbackGraphicsWindow], obj: TypedObject): CallbackGraphicsWindow {.importcpp: "DCAST(CallbackGraphicsWindow, @)".}

type DisplayMode* {.importcpp: "DisplayMode", pure, inheritable, header: "displayInformation.h".} = object

type DisplayRegionCullCallbackData* {.importcpp: "DisplayRegionCullCallbackData", pure, inheritable, header: "displayRegionCullCallbackData.h".} = object of CallbackData
  ## This specialization on CallbackData is passed when the callback is
  ## initiated from the cull traversal, for a DisplayRegion.

type DisplayRegionDrawCallbackData* {.importcpp: "DisplayRegionDrawCallbackData", pure, inheritable, header: "displayRegionDrawCallbackData.h".} = object of CallbackData
  ## This specialization on CallbackData is passed when the callback is
  ## initiated from the draw traversal, for a DisplayRegion.

type DisplaySearchParameters* {.importcpp: "DisplaySearchParameters", pure, inheritable, header: "displaySearchParameters.h".} = object
  ## Parameters used for searching display capabilities.

type GraphicsBuffer* {.importcpp: "PT(GraphicsBuffer)", bycopy, pure, inheritable, header: "graphicsBuffer.h".} = object of GraphicsOutput
  ## An offscreen buffer for rendering into.  This is similar in function to a
  ## GraphicsWindow, except that the output is not visible to the user.

converter toGraphicsBuffer*(_: type(nil)): GraphicsBuffer {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsBuffer): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsBuffer, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GraphicsBuffer], obj: TypedObject): GraphicsBuffer {.importcpp: "DCAST(GraphicsBuffer, @)".}

type GraphicsPipeSelection* {.importcpp: "GraphicsPipeSelection*", bycopy, pure, inheritable, header: "graphicsPipeSelection.h".} = object
  ## This maintains a list of GraphicsPipes by type that are available for
  ## creation.  Normally there is one default interactive GraphicsPipe, and
  ## possibly other types available as well.

converter toGraphicsPipeSelection*(_: type(nil)): GraphicsPipeSelection {.importcpp: "(nullptr)".}
converter toBool*(this: GraphicsPipeSelection): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GraphicsPipeSelection, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type MouseAndKeyboard* {.importcpp: "PT(MouseAndKeyboard)", bycopy, pure, inheritable, header: "mouseAndKeyboard.h".} = object of DataNode
  ## Reads the mouse and/or keyboard data sent from a GraphicsWindow, and
  ## transmits it down the data graph.
  ##
  ## The mouse and keyboard devices are bundled together into one device here,
  ## because they interrelate so much.  A mouse might be constrained by the
  ## holding down of the shift key, for instance, or the clicking of the mouse
  ## button might be handled in much the same way as a keyboard key.
  ##
  ## Mouse data is sent down the data graph as an x,y position as well as the
  ## set of buttons currently being held down; keyboard data is sent down as a
  ## set of keypress events in an EventDataTransition.  To throw these events to
  ## the system, you must attach an EventThrower to the MouseAndKeyboard object;
  ## otherwise, the events will be discarded.

converter toMouseAndKeyboard*(_: type(nil)): MouseAndKeyboard {.importcpp: "(nullptr)".}
converter toBool*(this: MouseAndKeyboard): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MouseAndKeyboard, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MouseAndKeyboard], obj: TypedObject): MouseAndKeyboard {.importcpp: "DCAST(MouseAndKeyboard, @)".}

type NativeWindowHandle* {.importcpp: "PT(NativeWindowHandle)", bycopy, pure, header: "nativeWindowHandle.h".} = object of WindowHandle
  ## This subclass of WindowHandle exists to allow simple creation of a
  ## WindowHandle of the appropriate type to the current OS.
  ##
  ## This class exists for name scoping only.  Don't use the constructor
  ## directly; use one of the make_\* methods.

converter toNativeWindowHandle*(_: type(nil)): NativeWindowHandle {.importcpp: "(nullptr)".}
converter toBool*(this: NativeWindowHandle): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: NativeWindowHandle, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[NativeWindowHandle], obj: TypedObject): NativeWindowHandle {.importcpp: "DCAST(NativeWindowHandle, @)".}

type ParasiteBuffer* {.importcpp: "PT(ParasiteBuffer)", bycopy, pure, inheritable, header: "parasiteBuffer.h".} = object of GraphicsOutput
  ## This is a special GraphicsOutput type that acts a lot like a
  ## GraphicsBuffer, effectively allowing rendering to an offscreen buffer,
  ## except it does not create any framebuffer space for itself.  Instead, it
  ## renders into the framebuffer owned by some other GraphicsOutput.
  ##
  ## The x_size and y_size must therefore fit within the bounds of the source
  ## GraphicsOutput.
  ##
  ## Since the framebuffer will be subsequently cleared when the actual owner
  ## draws in it later, this only makes sense if we are going to copy the
  ## contents of the framebuffer to a texture immediately after we draw it.
  ## Thus, has_texture() is implicitly true for a ParasiteBuffer.
  ##
  ## This class is useful to render offscreen to a texture while preventing the
  ## waste of framebuffer memory for API's that are unable to render directly
  ## into a texture (and must render into a separate framebuffer first and then
  ## copy to texture).  It is also the only way to render to a texture on API's
  ## that do not support offscreen rendering.

converter toParasiteBuffer*(_: type(nil)): ParasiteBuffer {.importcpp: "(nullptr)".}
converter toBool*(this: ParasiteBuffer): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ParasiteBuffer, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ParasiteBuffer], obj: TypedObject): ParasiteBuffer {.importcpp: "DCAST(ParasiteBuffer, @)".}

type ThreadPriority* = enum
  ## An enumerated type used by Thread to specify a suggested relative priority
  ## for a particular thread.
  TP_low = 0
  TP_normal = 1
  TP_high = 2
  TP_urgent = 3

type Thread* {.importcpp: "PT(Thread)", bycopy, pure, inheritable, header: "thread.h".} = object of TypedReferenceCount
  ## A thread; that is, a lightweight process.  This is an abstract base class;
  ## to use it, you must subclass from it and redefine thread_main().
  ##
  ## The thread itself will keep a reference count on the Thread object while it
  ## is running; when the thread returns from its root function, the Thread
  ## object will automatically be destructed if no other pointers are
  ## referencing it.

converter toThread*(_: type(nil)): Thread {.importcpp: "(nullptr)".}
converter toBool*(this: Thread): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Thread, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Thread], obj: TypedObject): Thread {.importcpp: "DCAST(Thread, @)".}

type MutexDirect* {.importcpp: "MutexDirect", pure, inheritable, header: "mutexDirect.h".} = object
  ## This class implements a standard mutex by making direct calls to the
  ## underlying implementation layer.  It doesn't perform any debugging
  ## operations.

type Mutex* {.importcpp: "Mutex", pure, inheritable, header: "pmutex.h".} = object of MutexDirect

type ConditionVarDirect* {.importcpp: "ConditionVarDirect", pure, inheritable, header: "conditionVarDirect.h".} = object
  ## A condition variable, usually used to communicate information about
  ## changing state to a thread that is waiting for something to happen.  A
  ## condition variable can be used to "wake up" a thread when some arbitrary
  ## condition has changed.
  ##
  ## A condition variable is associated with a single mutex, and several
  ## condition variables may share the same mutex.

type ConditionVar* {.importcpp: "ConditionVar", pure, inheritable, header: "conditionVar.h".} = object of ConditionVarDirect

type ConditionVarFullDirect* {.importcpp: "ConditionVarFullDirect", pure, inheritable, header: "conditionVarFullDirect.h".} = object
  ## A condition variable, usually used to communicate information about
  ## changing state to a thread that is waiting for something to happen.  A
  ## condition variable can be used to "wake up" a thread when some arbitrary
  ## condition has changed.
  ##
  ## A condition variable is associated with a single mutex, and several
  ## condition variables may share the same mutex.

type ConditionVarFull* {.importcpp: "ConditionVarFull", pure, inheritable, header: "conditionVarFull.h".} = object of ConditionVarFullDirect

type ReMutexDirect* {.importcpp: "ReMutexDirect", pure, inheritable, header: "reMutexDirect.h".} = object
  ## This class implements a standard reMutex by making direct calls to the
  ## underlying implementation layer.  It doesn't perform any debugging
  ## operations.

type ReMutex* {.importcpp: "ReMutex", pure, inheritable, header: "reMutex.h".} = object of ReMutexDirect

type ExternalThread* {.importcpp: "PT(ExternalThread)", bycopy, pure, inheritable, header: "externalThread.h".} = object of Thread
  ## The special "external thread" class.  There is one instance of these in the
  ## world, and it is returned by Thread::get_external_thread().

converter toExternalThread*(_: type(nil)): ExternalThread {.importcpp: "(nullptr)".}
converter toBool*(this: ExternalThread): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ExternalThread, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ExternalThread], obj: TypedObject): ExternalThread {.importcpp: "DCAST(ExternalThread, @)".}

type LightMutexDirect* {.importcpp: "LightMutexDirect", pure, inheritable, header: "lightMutexDirect.h".} = object
  ## This class implements a lightweight Mutex by making direct calls to the
  ## underlying implementation layer.  It doesn't perform any debugging
  ## operations.

type LightMutex* {.importcpp: "LightMutex", pure, inheritable, header: "lightMutex.h".} = object of LightMutexDirect

type LightReMutexDirect* {.importcpp: "LightReMutexDirect", pure, inheritable, header: "lightReMutexDirect.h".} = object
  ## This class implements a standard lightReMutex by making direct calls to the
  ## underlying implementation layer.  It doesn't perform any debugging
  ## operations.

type LightReMutex* {.importcpp: "LightReMutex", pure, inheritable, header: "lightReMutex.h".} = object of LightReMutexDirect

type MainThread* {.importcpp: "PT(MainThread)", bycopy, pure, inheritable, header: "mainThread.h".} = object of Thread
  ## The special "main thread" class.  There is one instance of these in the
  ## world, and it is returned by Thread::get_main_thread().

converter toMainThread*(_: type(nil)): MainThread {.importcpp: "(nullptr)".}
converter toBool*(this: MainThread): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MainThread, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MainThread], obj: TypedObject): MainThread {.importcpp: "DCAST(MainThread, @)".}

type Semaphore* {.importcpp: "Semaphore", pure, inheritable, header: "psemaphore.h".} = object
  ## A classic semaphore synchronization primitive.
  ##
  ## A semaphore manages an internal counter which is decremented by each
  ## acquire() call and incremented by each release() call.  The counter can
  ## never go below zero; when acquire() finds that it is zero, it blocks,
  ## waiting until some other thread calls release().

type PythonThread* {.importcpp: "PT(PythonThread)", bycopy, pure, inheritable, header: "pythonThread.h".} = object of Thread
  ## This class is exposed to Python to allow creation of a Panda thread from
  ## the Python level.  It will spawn a thread that executes an arbitrary Python
  ## functor.

converter toPythonThread*(_: type(nil)): PythonThread {.importcpp: "(nullptr)".}
converter toBool*(this: PythonThread): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PythonThread, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PythonThread], obj: TypedObject): PythonThread {.importcpp: "DCAST(PythonThread, @)".}

type EventParameter* {.importcpp: "EventParameter", pure, inheritable, header: "eventParameter.h".} = object
  ## An optional parameter associated with an event.  Each event may have zero
  ## or more of these.  Each parameter stores a pointer to a
  ## TypedWritableReferenceCount object, which of course could be pretty much
  ## anything.  To store a simple value like a double or a string, the
  ## EventParameter constructors transparently use the ParamValue template class
  ## from paramValue.h.

type AsyncTaskManager* {.importcpp: "PT(AsyncTaskManager)", bycopy, pure, inheritable, header: "asyncTaskManager.h".} = object of TypedReferenceCount
  ## A class to manage a loose queue of isolated tasks, which can be performed
  ## either synchronously (in the foreground thread) or asynchronously (by a
  ## background thread).
  ##
  ## The AsyncTaskManager is actually a collection of AsyncTaskChains, each of
  ## which maintains a list of tasks.  Each chain can be either foreground or
  ## background (it may run only in the main thread, or it may be serviced by
  ## one or more background threads). See AsyncTaskChain for more information.
  ##
  ## If you do not require background processing, it is perfectly acceptable to
  ## create only one AsyncTaskChain, which runs in the main thread.  This is a
  ## common configuration.

converter toAsyncTaskManager*(_: type(nil)): AsyncTaskManager {.importcpp: "(nullptr)".}
converter toBool*(this: AsyncTaskManager): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AsyncTaskManager, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AsyncTaskManager], obj: TypedObject): AsyncTaskManager {.importcpp: "DCAST(AsyncTaskManager, @)".}

type AsyncTaskCollection* {.importcpp: "AsyncTaskCollection", pure, inheritable, header: "asyncTaskCollection.h".} = object
  ## A list of tasks, for instance as returned by some of the AsyncTaskManager
  ## query functions.  This also serves to define an AsyncTaskSequence.
  ##
  ## TODO: None of this is thread-safe yet.

type AsyncTaskChain* {.importcpp: "PT(AsyncTaskChain)", bycopy, pure, inheritable, header: "asyncTaskChain.h".} = object of TypedReferenceCount
  ## The AsyncTaskChain is a subset of the AsyncTaskManager.  Each chain
  ## maintains a separate list of tasks, and will execute them with its own set
  ## of threads.  Each chain may thereby operate independently of the other
  ## chains.
  ##
  ## The AsyncTaskChain will spawn a specified number of threads (possibly 0) to
  ## serve the tasks.  If there are no threads, you must call poll() from time
  ## to time to serve the tasks in the main thread.  Normally this is done by
  ## calling AsyncTaskManager::poll().
  ##
  ## Each task will run exactly once each epoch.  Beyond that, the tasks' sort
  ## and priority values control the order in which they are run: tasks are run
  ## in increasing order by sort value, and within the same sort value, they are
  ## run roughly in decreasing order by priority value, with some exceptions for
  ## parallelism.  Tasks with different sort values are never run in parallel
  ## together, but tasks with different priority values might be (if there is
  ## more than one thread).

converter toAsyncTaskChain*(_: type(nil)): AsyncTaskChain {.importcpp: "(nullptr)".}
converter toBool*(this: AsyncTaskChain): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AsyncTaskChain, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AsyncTaskChain], obj: TypedObject): AsyncTaskChain {.importcpp: "DCAST(AsyncTaskChain, @)".}

type AsyncTaskPause* {.importcpp: "PT(AsyncTaskPause)", bycopy, pure, inheritable, header: "asyncTaskPause.h".} = object of AsyncTask
  ## A special kind of task that simple returns DS_pause, to pause for a
  ## specified number of seconds and then finish.  It's intended to be used
  ## within an AsyncTaskSequence.

converter toAsyncTaskPause*(_: type(nil)): AsyncTaskPause {.importcpp: "(nullptr)".}
converter toBool*(this: AsyncTaskPause): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AsyncTaskPause, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AsyncTaskPause], obj: TypedObject): AsyncTaskPause {.importcpp: "DCAST(AsyncTaskPause, @)".}

type AsyncTaskSequence* {.importcpp: "PT(AsyncTaskSequence)", bycopy, pure, inheritable, header: "asyncTaskSequence.h".} = object of AsyncTask
  ## A special kind of task that serves as a list of tasks internally.  Each
  ## task on the list is executed in sequence, one per epoch.
  ##
  ## This is similar to a Sequence interval, though it has some slightly
  ## different abilities.  For instance, although you can't start at any
  ## arbitrary point in the sequence, you can construct a task sequence whose
  ## duration changes during playback.

converter toAsyncTaskSequence*(_: type(nil)): AsyncTaskSequence {.importcpp: "(nullptr)".}
converter toBool*(this: AsyncTaskSequence): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AsyncTaskSequence, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AsyncTaskSequence], obj: TypedObject): AsyncTaskSequence {.importcpp: "DCAST(AsyncTaskSequence, @)".}

type ButtonEvent* {.importcpp: "ButtonEvent", pure, inheritable, header: "buttonEvent.h".} = object
  ## Records a button event of some kind.  This is either a keyboard or mouse
  ## button (or some other kind of button) changing state from up to down, or
  ## vice-versa, or it is a single "keystroke".
  ##
  ## A keystroke is different than a button event in that (a) it does not
  ## necessarily correspond to a physical button on a keyboard, but might be the
  ## result of a combination of buttons (e.g.  "A" is the result of shift +
  ## "a"); and (b) it does not manage separate "up" and "down" events, but is
  ## itself an instantaneous event.
  ##
  ## Normal up/down button events can be used to track the state of a particular
  ## button on the keyboard, while keystroke events are best used to monitor
  ## what a user is attempting to type.
  ##
  ## Button up/down events are defined across all the physical keys on the
  ## keyboard (and other buttons for which there is a corresponding ButtonHandle
  ## object), while keystroke events are defined across the entire Unicode
  ## character set.
  ##
  ## This API should not be considered stable and may change in a future version
  ## of Panda3D.

type ParamValueBase* {.importcpp: "PT(ParamValueBase)", bycopy, pure, inheritable, header: "paramValue.h".} = object of TypedWritableReferenceCount
  ## A non-template base class of ParamValue (below), which serves mainly to
  ## define the placeholder for the virtual output function.

converter toParamValueBase*(_: type(nil)): ParamValueBase {.importcpp: "(nullptr)".}
converter toBool*(this: ParamValueBase): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ParamValueBase, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ParamValueBase], obj: TypedObject): ParamValueBase {.importcpp: "DCAST(ParamValueBase, @)".}

type ButtonEventList* {.importcpp: "PT(ButtonEventList)", bycopy, pure, inheritable, header: "buttonEventList.h".} = object of ParamValueBase
  ## Records a set of button events that happened recently.  This class is
  ## usually used only in the data graph, to transmit the recent button presses,
  ## but it may be used anywhere a list of ButtonEvents is desired.

converter toButtonEventList*(_: type(nil)): ButtonEventList {.importcpp: "(nullptr)".}
converter toBool*(this: ButtonEventList): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ButtonEventList, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ButtonEventList], obj: TypedObject): ButtonEventList {.importcpp: "DCAST(ButtonEventList, @)".}

type Event* {.importcpp: "PT(Event)", bycopy, pure, inheritable, header: "event.h".} = object of TypedReferenceCount
  ## A named event, possibly with parameters.  Anyone in any thread may throw an
  ## event at any time; there will be one process responsible for reading and
  ## dispacting on the events (but not necessarily immediately).
  ##
  ## This function use to inherit from Namable, but that makes it too expensive
  ## to get its name the Python code.  Now it just copies the Namable interface
  ## in.

converter toEvent*(_: type(nil)): Event {.importcpp: "(nullptr)".}
converter toBool*(this: Event): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Event, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Event], obj: TypedObject): Event {.importcpp: "DCAST(Event, @)".}

type EventHandler* {.importcpp: "EventHandler", pure, inheritable, header: "eventHandler.h".} = object of TypedObject
  ## A class to monitor events from the C++ side of things.  It maintains a set
  ## of "hooks", function pointers assigned to event names, and calls the
  ## appropriate hooks when the matching event is detected.
  ##
  ## This class is not necessary when the hooks are detected and processed
  ## entirely by the scripting language, e.g.  via Scheme hooks or the messenger
  ## in Python.

type EventQueue* {.importcpp: "EventQueue*", bycopy, pure, inheritable, header: "eventQueue.h".} = object
  ## A queue of pending events.  As events are thrown, they are added to this
  ## queue; eventually, they will be extracted out again by an EventHandler and
  ## processed.

converter toEventQueue*(_: type(nil)): EventQueue {.importcpp: "(nullptr)".}
converter toBool*(this: EventQueue): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: EventQueue, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type PointerEventList* {.importcpp: "PT(PointerEventList)", bycopy, pure, inheritable, header: "pointerEventList.h".} = object of ParamValueBase
  ## Records a set of pointer events that happened recently.  This class is
  ## usually used only in the data graph, to transmit the recent pointer
  ## presses, but it may be used anywhere a list of PointerEvents is desired.

converter toPointerEventList*(_: type(nil)): PointerEventList {.importcpp: "(nullptr)".}
converter toBool*(this: PointerEventList): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PointerEventList, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PointerEventList], obj: TypedObject): PointerEventList {.importcpp: "DCAST(PointerEventList, @)".}

type PythonTask* {.importcpp: "PT(PythonTask)", bycopy, pure, header: "pythonTask.h".} = object of AsyncTask
  ## This class exists to allow association of a Python function or coroutine
  ## with the AsyncTaskManager.

converter toPythonTask*(_: type(nil)): PythonTask {.importcpp: "(nullptr)".}
converter toBool*(this: PythonTask): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PythonTask, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PythonTask], obj: TypedObject): PythonTask {.importcpp: "DCAST(PythonTask, @)".}

type AdaptiveLru* {.importcpp: "AdaptiveLru", pure, inheritable, header: "adaptiveLru.h".} = object of Namable
  ## A basic LRU-type algorithm, except that it is adaptive and attempts to
  ## avoid evicting pages that have been used more frequently (even if less
  ## recently) than other pages.
  ##
  ## The interface is designed to be identical to that for SimpleLru, so that it
  ## may be used as a drop-in replacement.

type AdaptiveLruPage* {.importcpp: "AdaptiveLruPage*", bycopy, pure, inheritable, header: "adaptiveLru.h".} = object
  ## One atomic piece that may be managed by a AdaptiveLru chain.  To use this
  ## class, inherit from it and override evict_lru().
  ##
  ## This class multiply inherits from two classes which in turn both inherit
  ## from LinkedListNode.  This is just a sneaky C++ trick to allow this class
  ## to inherit from LinkedListNode twice, so that pages can be stored on two
  ## different linked lists simultaneously.  The AdaptiveLru class depends on
  ## this; it maintains its pages in two different lists, one grouped by
  ## priority, and one in order by next partial update needs.

converter toAdaptiveLruPage*(_: type(nil)): AdaptiveLruPage {.importcpp: "(nullptr)".}
converter toBool*(this: AdaptiveLruPage): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AdaptiveLruPage, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type GeomEnums* {.importcpp: "GeomEnums", pure, inheritable, header: "geomEnums.h".} = object
  ## This class exists just to provide scoping for the various enumerated types
  ## used by Geom, GeomVertexData, GeomVertexArrayData, GeomPrimitive, and other
  ## related classes.

type GeomVertexAnimationSpec* {.importcpp: "GeomVertexAnimationSpec", pure, inheritable, header: "geomVertexAnimationSpec.h".} = object of GeomEnums
  ## This object describes how the vertex animation, if any, represented in a
  ## GeomVertexData is encoded.
  ##
  ## Vertex animation includes soft-skinned skeleton animation and morphs (blend
  ## shapes), and might be performed on the CPU by Panda, or passed down to the
  ## graphics backed to be performed on the hardware (depending on the
  ## hardware's advertised capabilities).
  ##
  ## Changing this setting doesn't by itself change the way the animation is
  ## actually performed; this just specifies how the vertices are set up to be
  ## animated.

type InternalName* {.importcpp: "PT(InternalName)", bycopy, pure, header: "internalName.h".} = object of TypedWritableReferenceCount
  ## Encodes a string name in a hash table, mapping it to a pointer.  This is
  ## used to tokenify names so they may be used efficiently in low-level Panda
  ## structures, for instance to differentiate the multiple sets of texture
  ## coordinates that might be stored on a Geom.
  ##
  ## InternalNames are hierarchical, with the '.' used by convention as a
  ## separator character.  You can construct a single InternalName as a
  ## composition of one or more other names, or by giving it a source string
  ## directly.

converter toInternalName*(_: type(nil)): InternalName {.importcpp: "(nullptr)".}
converter toBool*(this: InternalName): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: InternalName, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[InternalName], obj: TypedObject): InternalName {.importcpp: "DCAST(InternalName, @)".}

type GeomVertexColumn* {.importcpp: "GeomVertexColumn", pure, inheritable, header: "geomVertexColumn.h".} = object of GeomEnums
  ## This defines how a single column is interleaved within a vertex array
  ## stored within a Geom.  The GeomVertexArrayFormat class maintains a list of
  ## these to completely define a particular array structure.

type GeomVertexArrayFormat* {.importcpp: "PT(GeomVertexArrayFormat)", bycopy, pure, header: "geomVertexArrayFormat.h".} = object of TypedWritableReferenceCount
  ## This describes the structure of a single array within a Geom data.  See
  ## GeomVertexFormat for the parent class which collects together all of the
  ## individual GeomVertexArrayFormat objects.
  ##
  ## A particular array may include any number of standard or user-defined
  ## columns.  All columns consist of a sequence of one or more numeric values,
  ## packed in any of a variety of formats; the semantic meaning of each column
  ## is defined in general with its contents member, and in particular by its
  ## name.  The standard array types used most often are named "vertex",
  ## "normal", "texcoord", and "color"; other kinds of data may be piggybacked
  ## into the data record simply by choosing a unique name.

converter toGeomVertexArrayFormat*(_: type(nil)): GeomVertexArrayFormat {.importcpp: "(nullptr)".}
converter toBool*(this: GeomVertexArrayFormat): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomVertexArrayFormat, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomVertexArrayFormat], obj: TypedObject): GeomVertexArrayFormat {.importcpp: "DCAST(GeomVertexArrayFormat, @)".}

type GeomVertexFormat* {.importcpp: "PT(GeomVertexFormat)", bycopy, pure, header: "geomVertexFormat.h".} = object of TypedWritableReferenceCount
  ## This class defines the physical layout of the vertex data stored within a
  ## Geom.  The layout consists of a list of named columns, each of which has a
  ## numeric type and a size.
  ##
  ## The columns are typically interleaved within a single array, but they may
  ## also be distributed among multiple different arrays; at the extreme, each
  ## column may be alone within its own array (which amounts to a parallel-array
  ## definition).
  ##
  ## Thus, a GeomVertexFormat is really a list of GeomVertexArrayFormats, each
  ## of which contains a list of columns.  However, a particular column name
  ## should not appear more than once in the format, even between different
  ## arrays.
  ##
  ## There are a handful of standard pre-defined GeomVertexFormat objects, or
  ## you may define your own as needed.  You may record any combination of
  ## standard and/or user-defined columns in your custom GeomVertexFormat
  ## constructions.

converter toGeomVertexFormat*(_: type(nil)): GeomVertexFormat {.importcpp: "(nullptr)".}
converter toBool*(this: GeomVertexFormat): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomVertexFormat, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomVertexFormat], obj: TypedObject): GeomVertexFormat {.importcpp: "DCAST(GeomVertexFormat, @)".}

type SimpleLru* {.importcpp: "SimpleLru", pure, inheritable, header: "simpleLru.h".} = object of Namable
  ## An implementation of a very simple LRU algorithm.  Also see AdaptiveLru.

type SimpleLruPage* {.importcpp: "SimpleLruPage*", bycopy, pure, inheritable, header: "simpleLru.h".} = object
  ## One atomic piece that may be managed by a SimpleLru chain.  To use this
  ## class, inherit from it and override evict_lru().

converter toSimpleLruPage*(_: type(nil)): SimpleLruPage {.importcpp: "(nullptr)".}
converter toBool*(this: SimpleLruPage): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SimpleLruPage, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type SimpleAllocator* {.importcpp: "SimpleAllocator*", bycopy, pure, inheritable, header: "simpleAllocator.h".} = object
  ## An implementation of a very simple block allocator.  This class can
  ## allocate ranges of nonnegative integers within a specified upper limit; it
  ## uses a simple first-fit algorithm to find the next available space.

converter toSimpleAllocator*(_: type(nil)): SimpleAllocator {.importcpp: "(nullptr)".}
converter toBool*(this: SimpleAllocator): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SimpleAllocator, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type SimpleAllocatorBlock* {.importcpp: "SimpleAllocatorBlock*", bycopy, pure, inheritable, header: "simpleAllocator.h".} = object
  ## A single block as returned from SimpleAllocator::alloc().

converter toSimpleAllocatorBlock*(_: type(nil)): SimpleAllocatorBlock {.importcpp: "(nullptr)".}
converter toBool*(this: SimpleAllocatorBlock): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SimpleAllocatorBlock, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type VertexDataSaveFile* {.importcpp: "VertexDataSaveFile*", bycopy, pure, inheritable, header: "vertexDataSaveFile.h".} = object of SimpleAllocator
  ## A temporary file to hold the vertex data that has been evicted from memory
  ## and written to disk.  All vertex data arrays are written into one large
  ## flat file.

converter toVertexDataSaveFile*(_: type(nil)): VertexDataSaveFile {.importcpp: "(nullptr)".}
converter toBool*(this: VertexDataSaveFile): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VertexDataSaveFile, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type VertexDataPage* {.importcpp: "VertexDataPage", pure, inheritable, header: "vertexDataPage.h".} = object of SimpleAllocator
  ## A block of bytes that holds one or more VertexDataBlocks.  The entire page
  ## may be paged out, in the form of in-memory compression or to an on-disk
  ## cache file, if necessary.

type VertexDataBook* {.importcpp: "VertexDataBook", pure, inheritable, header: "vertexDataBook.h".} = object
  ## A collection of VertexDataPages, which can be used to allocate new
  ## VertexDataBlock objects.

type VertexDataBlock* {.importcpp: "PT(VertexDataBlock)", bycopy, pure, inheritable, header: "vertexDataBlock.h".} = object of SimpleAllocatorBlock
  ## A block of bytes that stores the actual raw vertex data referenced by a
  ## GeomVertexArrayData object.

converter toVertexDataBlock*(_: type(nil)): VertexDataBlock {.importcpp: "(nullptr)".}
converter toBool*(this: VertexDataBlock): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VertexDataBlock, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VertexDataBlock], obj: TypedObject): VertexDataBlock {.importcpp: "DCAST(VertexDataBlock, @)".}

type GeomVertexArrayData* {.importcpp: "PT(GeomVertexArrayData)", bycopy, pure, inheritable, header: "geomVertexArrayData.h".} = object of CopyOnWriteObject
  ## This is the data for one array of a GeomVertexData structure.  Many
  ## GeomVertexData structures will only define one array, with all data
  ## elements interleaved (DirectX 8.0 and before insisted on this format); some
  ## will define multiple arrays.
  ##
  ## DirectX calls this concept of one array a "stream". It also closely
  ## correlates with the concept of a vertex buffer.
  ##
  ## This object is just a block of data.  In general, you should not be
  ## directly messing with this object from application code.  See
  ## GeomVertexData for the organizing structure, and see
  ## GeomVertexReader/Writer/Rewriter for high-level tools to manipulate the
  ## actual vertex data.

converter toGeomVertexArrayData*(_: type(nil)): GeomVertexArrayData {.importcpp: "(nullptr)".}
converter toBool*(this: GeomVertexArrayData): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomVertexArrayData, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomVertexArrayData], obj: TypedObject): GeomVertexArrayData {.importcpp: "DCAST(GeomVertexArrayData, @)".}

type GeomVertexArrayDataHandle* {.importcpp: "PT(GeomVertexArrayDataHandle)", bycopy, pure, inheritable, header: "geomVertexArrayData.h".} = object of ReferenceCount
  ## This data object is returned by GeomVertexArrayData::get_handle() or
  ## modify_handle(). As long as it exists, the data is locked; when the last of
  ## these destructs, the data is unlocked.
  ##
  ## Only one thread at a time may lock the data; other threads attempting to
  ## lock the data will block.  A given thread may simultaneously lock the data
  ## multiple times.
  ##
  ## This class serves in lieu of a pair of GeomVertexArrayDataPipelineReader
  ## and GeomVertexArrayDataPipelineWriter classes

converter toGeomVertexArrayDataHandle*(_: type(nil)): GeomVertexArrayDataHandle {.importcpp: "(nullptr)".}
converter toBool*(this: GeomVertexArrayDataHandle): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomVertexArrayDataHandle, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomVertexArrayDataHandle], obj: TypedObject): GeomVertexArrayDataHandle {.importcpp: "DCAST(GeomVertexArrayDataHandle, @)".}

type GeomCacheManager* {.importcpp: "GeomCacheManager", pure, inheritable, header: "geomCacheManager.h".} = object
  ## This is used to keep track of, and limit the size of, the cache of munged
  ## vertices, which would otherwise be distributed through all of the
  ## GeomVertexData objects in the system.
  ##
  ## The actual data in the cache is not stored here, but rather it is
  ## distributed among the various GeomVertexData source objects.  This allows
  ## the cache data to propagate through the multiprocess pipeline.
  ##
  ## This structure actually caches any of a number of different types of
  ## pointers, and mixes them all up in the same LRU cache list.  Some of them
  ## (such as GeomMunger) are reference-counted here in the cache; most are not.

type TransformTable* {.importcpp: "PT(TransformTable)", bycopy, pure, inheritable, header: "transformTable.h".} = object of TypedWritableReferenceCount
  ## Stores the total set of VertexTransforms that the vertices in a particular
  ## GeomVertexData object might depend on.
  ##
  ## This structure is used for a GeomVertexData set up to compute its dynamic
  ## vertices on the graphics card.  See TransformBlendTable for one set up to
  ## compute its dynamic vertices on the CPU.

converter toTransformTable*(_: type(nil)): TransformTable {.importcpp: "(nullptr)".}
converter toBool*(this: TransformTable): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TransformTable, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TransformTable], obj: TypedObject): TransformTable {.importcpp: "DCAST(TransformTable, @)".}

type TransformBlend* {.importcpp: "TransformBlend", pure, inheritable, header: "transformBlend.h".} = object
  ## This defines a single entry in a TransformBlendTable.  It represents a
  ## unique combination of VertexTransform pointers and blend amounts.

type TransformBlendTable* {.importcpp: "PT(TransformBlendTable)", bycopy, pure, inheritable, header: "transformBlendTable.h".} = object of CopyOnWriteObject
  ## This structure collects together the different combinations of transforms
  ## and blend amounts used by a GeomVertexData, to facilitate computing dynamic
  ## vertices on the CPU at runtime.  Each vertex has a pointer to exactly one
  ## of the entries in this table, and each entry defines a number of
  ## transform/blend combinations.
  ##
  ## This structure is used for a GeomVertexData set up to compute its dynamic
  ## vertices on the CPU.  See TransformTable for one set up to compute its
  ## dynamic vertices on the graphics card.

converter toTransformBlendTable*(_: type(nil)): TransformBlendTable {.importcpp: "(nullptr)".}
converter toBool*(this: TransformBlendTable): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TransformBlendTable, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TransformBlendTable], obj: TypedObject): TransformBlendTable {.importcpp: "DCAST(TransformBlendTable, @)".}

type SliderTable* {.importcpp: "PT(SliderTable)", bycopy, pure, inheritable, header: "sliderTable.h".} = object of TypedWritableReferenceCount
  ## Stores the total set of VertexSliders that the vertices in a particular
  ## GeomVertexData object might depend on.
  ##
  ## This is similar to a TransformTable, but it stores VertexSliders instead of
  ## VertexTransforms, and it stores them by name instead of by index number.
  ## Also, it is only used when animating vertices on the CPU, since GPU's don't
  ## support morphs at this point in time.

converter toSliderTable*(_: type(nil)): SliderTable {.importcpp: "(nullptr)".}
converter toBool*(this: SliderTable): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SliderTable, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[SliderTable], obj: TypedObject): SliderTable {.importcpp: "DCAST(SliderTable, @)".}

type GeomVertexData* {.importcpp: "PT(GeomVertexData)", bycopy, pure, inheritable, header: "geomVertexData.h".} = object of CopyOnWriteObject
  ## This defines the actual numeric vertex data stored in a Geom, in the
  ## structure defined by a particular GeomVertexFormat object.
  ##
  ## The data consists of one or more arrays, each of which in turn consists of
  ## a series of rows, one per vertex.  All arrays should have the same number
  ## of rows; each vertex is defined by the column data from a particular row
  ## across all arrays.
  ##
  ## Often, there will be only one array per Geom, and the various columns
  ## defined in the GeomVertexFormat will be interleaved within that array.
  ## However, it is also possible to have multiple different arrays, with a
  ## certain subset of the total columns defined in each array.
  ##
  ## However the data is distributed, the effect is of a single table of
  ## vertices, where each vertex is represented by one row of the table.
  ##
  ## In general, application code should not attempt to directly manipulate the
  ## vertex data through this structure; instead, use the GeomVertexReader,
  ## GeomVertexWriter, and GeomVertexRewriter objects to read and write vertex
  ## data at a high level.

converter toGeomVertexData*(_: type(nil)): GeomVertexData {.importcpp: "(nullptr)".}
converter toBool*(this: GeomVertexData): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomVertexData, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomVertexData], obj: TypedObject): GeomVertexData {.importcpp: "DCAST(GeomVertexData, @)".}

type AnimateVerticesRequest* {.importcpp: "PT(AnimateVerticesRequest)", bycopy, pure, inheritable, header: "animateVerticesRequest.h".} = object of AsyncTask
  ## This class object manages a single asynchronous request to animate vertices
  ## on a GeomVertexData object.  animate_vertices will be called with
  ## force=true (i.e.  blocking) in a sub-thread (if threading is available).
  ## No result is stored or returned from this object.  It is expected that the
  ## result will be cached and available for immediate use later during
  ## rendering.  Thus it is important that the main thread block while these
  ## requests are being run (presumably on multiple CPUs/cores), to ensure that
  ## the data has been computed by the time it's needed.

converter toAnimateVerticesRequest*(_: type(nil)): AnimateVerticesRequest {.importcpp: "(nullptr)".}
converter toBool*(this: AnimateVerticesRequest): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AnimateVerticesRequest, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AnimateVerticesRequest], obj: TypedObject): AnimateVerticesRequest {.importcpp: "DCAST(AnimateVerticesRequest, @)".}

type SavedContext* {.importcpp: "SavedContext*", bycopy, pure, inheritable, header: "savedContext.h".} = object of TypedObject
  ## This is the base class for all GSG-specific context objects, such as
  ## TextureContext and GeomContext.  It exists mainly to provide some
  ## structural organization.

converter toSavedContext*(_: type(nil)): SavedContext {.importcpp: "(nullptr)".}
converter toBool*(this: SavedContext): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SavedContext, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type BufferContext* {.importcpp: "BufferContext*", bycopy, pure, inheritable, header: "bufferContext.h".} = object of SavedContext
  ## This is a base class for those kinds of SavedContexts that occupy an
  ## easily-measured (and substantial) number of bytes in the video card's frame
  ## buffer memory or AGP memory.  At the present, this includes most of the
  ## SavedContext types: VertexBufferContext and IndexBufferContext, as well as
  ## TextureContext.
  ##
  ## This class provides methods for tracking the video memory utilization, as
  ## well as residency of each object, via PStats.

converter toBufferContext*(_: type(nil)): BufferContext {.importcpp: "(nullptr)".}
converter toBool*(this: BufferContext): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: BufferContext, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type GeomPrimitive* {.importcpp: "PT(GeomPrimitive)", bycopy, pure, inheritable, header: "geomPrimitive.h".} = object of CopyOnWriteObject
  ## This is an abstract base class for a family of classes that represent the
  ## fundamental geometry primitives that may be stored in a Geom.
  ##
  ## They all have in common the fact that they are defined by tables of vertex
  ## data stored in a GeomVertexData object.  Each GeomPrimitive object contains
  ## an ordered list of integers, which index into the vertex array defined by
  ## the GeomVertexData and define the particular vertices of the GeomVertexData
  ## that are used for this primitive.
  ##
  ## The meaning of a given arrangement of vertices is defined by each
  ## individual primitive type; for instance, a GeomTriangle renders a triangle
  ## from each three consecutive vertices, while a GeomTriangleStrip renders a
  ## strip of (n - 2) connected triangles from each sequence of n vertices.

converter toGeomPrimitive*(_: type(nil)): GeomPrimitive {.importcpp: "(nullptr)".}
converter toBool*(this: GeomPrimitive): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomPrimitive, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomPrimitive], obj: TypedObject): GeomPrimitive {.importcpp: "DCAST(GeomPrimitive, @)".}

type TextureStage* {.importcpp: "PT(TextureStage)", bycopy, pure, inheritable, header: "textureStage.h".} = object of TypedWritableReferenceCount
  ## Defines the properties of a named stage of the multitexture pipeline.  The
  ## TextureAttrib will associated a number of these stages with Texture
  ## objects, and the GSG will render geometry by sorting all of the currently
  ## active TextureStages in order and then issuing the appropriate rendering
  ## calls to activate them.

converter toTextureStage*(_: type(nil)): TextureStage {.importcpp: "(nullptr)".}
converter toBool*(this: TextureStage): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TextureStage, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TextureStage], obj: TypedObject): TextureStage {.importcpp: "DCAST(TextureStage, @)".}

type Geom* {.importcpp: "PT(Geom)", bycopy, pure, inheritable, header: "geom.h".} = object of CopyOnWriteObject
  ## A container for geometry primitives.  This class associates one or more
  ## GeomPrimitive objects with a table of vertices defined by a GeomVertexData
  ## object.  All of the primitives stored in a particular Geom are drawn from
  ## the same set of vertices (each primitive uses a subset of all of the
  ## vertices in the table), and all of them must be rendered at the same time,
  ## in the same graphics state.

converter toGeom*(_: type(nil)): Geom {.importcpp: "(nullptr)".}
converter toBool*(this: Geom): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Geom, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Geom], obj: TypedObject): Geom {.importcpp: "DCAST(Geom, @)".}

type GeomContext* {.importcpp: "GeomContext", pure, inheritable, header: "geomContext.h".} = object of SavedContext
  ## This is a special class object that holds all the information returned by a
  ## particular GSG to indicate the geom's internal context identifier.
  ##
  ## Geoms typically have an immediate-mode and a retained-mode operation.  When
  ## using geoms in retained-mode (in response to Geom::prepare()), the GSG will
  ## create some internal handle for the geom and store it here.  The geom
  ## stores all of these handles internally.
  ##
  ## In the case of OpenGL, for example, a GeomContext corresponds to a display
  ## list identifier.

type GeomLines* {.importcpp: "PT(GeomLines)", bycopy, pure, inheritable, header: "geomLines.h".} = object of GeomPrimitive
  ## Defines a series of disconnected line segments.

converter toGeomLines*(_: type(nil)): GeomLines {.importcpp: "(nullptr)".}
converter toBool*(this: GeomLines): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomLines, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomLines], obj: TypedObject): GeomLines {.importcpp: "DCAST(GeomLines, @)".}

type GeomLinesAdjacency* {.importcpp: "PT(GeomLinesAdjacency)", bycopy, pure, inheritable, header: "geomLinesAdjacency.h".} = object of GeomPrimitive
  ## Defines a series of disconnected line segments with adjacency information,
  ## for use with geometry shaders.
  ##
  ## @since 1.10.0

converter toGeomLinesAdjacency*(_: type(nil)): GeomLinesAdjacency {.importcpp: "(nullptr)".}
converter toBool*(this: GeomLinesAdjacency): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomLinesAdjacency, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomLinesAdjacency], obj: TypedObject): GeomLinesAdjacency {.importcpp: "DCAST(GeomLinesAdjacency, @)".}

type GeomLinestrips* {.importcpp: "PT(GeomLinestrips)", bycopy, pure, inheritable, header: "geomLinestrips.h".} = object of GeomPrimitive
  ## Defines a series of line strips.

converter toGeomLinestrips*(_: type(nil)): GeomLinestrips {.importcpp: "(nullptr)".}
converter toBool*(this: GeomLinestrips): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomLinestrips, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomLinestrips], obj: TypedObject): GeomLinestrips {.importcpp: "DCAST(GeomLinestrips, @)".}

type GeomLinestripsAdjacency* {.importcpp: "PT(GeomLinestripsAdjacency)", bycopy, pure, inheritable, header: "geomLinestripsAdjacency.h".} = object of GeomPrimitive
  ## Defines a series of line strips with adjacency information.
  ##
  ## @since 1.10.0

converter toGeomLinestripsAdjacency*(_: type(nil)): GeomLinestripsAdjacency {.importcpp: "(nullptr)".}
converter toBool*(this: GeomLinestripsAdjacency): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomLinestripsAdjacency, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomLinestripsAdjacency], obj: TypedObject): GeomLinestripsAdjacency {.importcpp: "DCAST(GeomLinestripsAdjacency, @)".}

type GeomPatches* {.importcpp: "PT(GeomPatches)", bycopy, pure, inheritable, header: "geomPatches.h".} = object of GeomPrimitive
  ## Defines a series of "patches", fixed-size groupings of vertices that must
  ## be processed by a tessellation shader.

converter toGeomPatches*(_: type(nil)): GeomPatches {.importcpp: "(nullptr)".}
converter toBool*(this: GeomPatches): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomPatches, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomPatches], obj: TypedObject): GeomPatches {.importcpp: "DCAST(GeomPatches, @)".}

type GeomPoints* {.importcpp: "PT(GeomPoints)", bycopy, pure, inheritable, header: "geomPoints.h".} = object of GeomPrimitive
  ## Defines a series of disconnected points.

converter toGeomPoints*(_: type(nil)): GeomPoints {.importcpp: "(nullptr)".}
converter toBool*(this: GeomPoints): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomPoints, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomPoints], obj: TypedObject): GeomPoints {.importcpp: "DCAST(GeomPoints, @)".}

type GeomTriangles* {.importcpp: "PT(GeomTriangles)", bycopy, pure, inheritable, header: "geomTriangles.h".} = object of GeomPrimitive
  ## Defines a series of disconnected triangles.

converter toGeomTriangles*(_: type(nil)): GeomTriangles {.importcpp: "(nullptr)".}
converter toBool*(this: GeomTriangles): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomTriangles, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomTriangles], obj: TypedObject): GeomTriangles {.importcpp: "DCAST(GeomTriangles, @)".}

type GeomTrianglesAdjacency* {.importcpp: "PT(GeomTrianglesAdjacency)", bycopy, pure, inheritable, header: "geomTrianglesAdjacency.h".} = object of GeomPrimitive
  ## Defines a series of disconnected triangles, with adjacency information.
  ##
  ## @since 1.10.0

converter toGeomTrianglesAdjacency*(_: type(nil)): GeomTrianglesAdjacency {.importcpp: "(nullptr)".}
converter toBool*(this: GeomTrianglesAdjacency): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomTrianglesAdjacency, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomTrianglesAdjacency], obj: TypedObject): GeomTrianglesAdjacency {.importcpp: "DCAST(GeomTrianglesAdjacency, @)".}

type GeomTrifans* {.importcpp: "PT(GeomTrifans)", bycopy, pure, inheritable, header: "geomTrifans.h".} = object of GeomPrimitive
  ## Defines a series of triangle fans.

converter toGeomTrifans*(_: type(nil)): GeomTrifans {.importcpp: "(nullptr)".}
converter toBool*(this: GeomTrifans): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomTrifans, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomTrifans], obj: TypedObject): GeomTrifans {.importcpp: "DCAST(GeomTrifans, @)".}

type GeomTristrips* {.importcpp: "PT(GeomTristrips)", bycopy, pure, inheritable, header: "geomTristrips.h".} = object of GeomPrimitive
  ## Defines a series of triangle strips.

converter toGeomTristrips*(_: type(nil)): GeomTristrips {.importcpp: "(nullptr)".}
converter toBool*(this: GeomTristrips): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomTristrips, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomTristrips], obj: TypedObject): GeomTristrips {.importcpp: "DCAST(GeomTristrips, @)".}

type GeomTristripsAdjacency* {.importcpp: "PT(GeomTristripsAdjacency)", bycopy, pure, inheritable, header: "geomTristripsAdjacency.h".} = object of GeomPrimitive
  ## Defines a series of triangle strips with adjacency information.
  ##
  ## @since 1.10.0

converter toGeomTristripsAdjacency*(_: type(nil)): GeomTristripsAdjacency {.importcpp: "(nullptr)".}
converter toBool*(this: GeomTristripsAdjacency): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomTristripsAdjacency, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomTristripsAdjacency], obj: TypedObject): GeomTristripsAdjacency {.importcpp: "DCAST(GeomTristripsAdjacency, @)".}

type GeomVertexReader* {.importcpp: "GeomVertexReader", pure, inheritable, header: "geomVertexReader.h".} = object of GeomEnums
  ## This object provides a high-level interface for quickly reading a sequence
  ## of numeric values from a vertex table.
  ##
  ## It is particularly optimized for reading a single column of data values for
  ## a series of vertices, without changing columns between each number.
  ## Although you can also use one GeomVertexReader to read across the columns
  ## if it is convenient, by calling set_column() repeatedly at each vertex, it
  ## is faster to read down the columns, and to use a different GeomVertexReader
  ## for each column.
  ##
  ## Note that a GeomVertexReader does not keep a reference count to the actual
  ## vertex data buffer (it grabs the current data buffer from the
  ## GeomVertexData whenever set_column() is called).  This means that it is
  ## important not to keep a GeomVertexReader object around over a long period
  ## of time in which the data buffer is likely to be deallocated; it is
  ## intended for making a quick pass over the data in one session.
  ##
  ## It also means that you should create any GeomVertexWriters \*before\*
  ## creating GeomVertexReaders on the same data, since the writer itself might
  ## cause the vertex buffer to be deallocated.  Better yet, use a
  ## GeomVertexRewriter if you are going to create both of them anyway.

type GeomVertexWriter* {.importcpp: "GeomVertexWriter", pure, inheritable, header: "geomVertexWriter.h".} = object of GeomEnums
  ## This object provides a high-level interface for quickly writing a sequence
  ## of numeric values from a vertex table.
  ##
  ## This object can be used both to replace existing vertices in the table, or
  ## to extend the table with new vertices.  The set_data\*() family of methods
  ## can only be used to replace existing data; it is an error to allow these to
  ## run past the end of the data.  The add_data\*() family of methods, on the
  ## other hand, can be used to replace existing data or add new data; if you
  ## call set_row() into the middle of existing data the add_data\*() methods
  ## will behave like the corresponding set_data\*(), but if they run past the
  ## end of existing data they will quietly add new vertices.
  ##
  ## Like GeomVertexReader, the writer is particularly optimized for writing a
  ## single column of data values for a series of vertices, without changing
  ## columns between each number.  Although you can also use one
  ## GeomVertexWriter to write across the columns if it is convenient, by
  ## calling set_column() repeatedly at each vertex, it is faster to write down
  ## the columns, and to use a different GeomVertexWriter for each column.
  ##
  ## Note that, like a GeomVertexReader, a GeomVertexWriter does not keep a
  ## reference count to the actual vertex data buffer.  This means that it is
  ## important not to keep a GeomVertexWriter object around over a long period
  ## of time in which the data buffer is likely to be deallocated; it is
  ## intended for making a quick pass over the data in one session.
  ##
  ## It also means that you should create any GeomVertexWriters \*before\*
  ## creating GeomVertexReaders on the same data, since the writer itself might
  ## cause the vertex buffer to be deallocated.  Better yet, use a
  ## GeomVertexRewriter if you are going to create both of them anyway.

type GeomVertexRewriter* {.importcpp: "GeomVertexRewriter", pure, inheritable, header: "geomVertexRewriter.h".} = object of GeomVertexWriter
  ## This object provides the functionality of both a GeomVertexReader and a
  ## GeomVertexWriter, combined together into one convenient package.  It is
  ## designed for making a single pass over a GeomVertexData object, modifying
  ## rows as it goes.
  ##
  ## Although it doesn't provide any real performance benefit over using a
  ## separate reader and writer on the same data, it should probably be used in
  ## preference to a separate reader and writer, because it makes an effort to
  ## manage the reference counts properly between the reader and the writer to
  ## avoid accidentally dereferencing either array while recopying.

type SamplerState* {.importcpp: "SamplerState", pure, inheritable, header: "samplerState.h".} = object
  ## Represents a set of settings that indicate how a texture is sampled.  This
  ## can be used to sample the same texture using different settings in
  ## different places.

type Shader* {.importcpp: "PT(Shader)", bycopy, pure, inheritable, header: "shader.h".} = object of TypedWritableReferenceCount

converter toShader*(_: type(nil)): Shader {.importcpp: "(nullptr)".}
converter toBool*(this: Shader): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Shader, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Shader], obj: TypedObject): Shader {.importcpp: "DCAST(Shader, @)".}

type ShaderBuffer* {.importcpp: "PT(ShaderBuffer)", bycopy, pure, inheritable, header: "shaderBuffer.h".} = object of TypedWritableReferenceCount
  ## This is a generic buffer object that lives in graphics memory.
  ##
  ## @since 1.10.0

converter toShaderBuffer*(_: type(nil)): ShaderBuffer {.importcpp: "(nullptr)".}
converter toBool*(this: ShaderBuffer): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ShaderBuffer, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ShaderBuffer], obj: TypedObject): ShaderBuffer {.importcpp: "DCAST(ShaderBuffer, @)".}

type PreparedGraphicsObjects* {.importcpp: "PT(PreparedGraphicsObjects)", bycopy, pure, inheritable, header: "preparedGraphicsObjects.h".} = object of ReferenceCount
  ## A table of objects that are saved within the graphics context for reference
  ## by handle later.  Generally, this represents things like OpenGL texture
  ## objects or display lists (or their equivalent on other platforms).
  ##
  ## This object simply records the pointers to the context objects created by
  ## the individual GSG's; these context objects will contain enough information
  ## to reference or release the actual object stored within the graphics
  ## context.
  ##
  ## These tables may potentially be shared between related graphics contexts,
  ## hence their storage here in a separate object rather than as a part of the
  ## GraphicsStateGuardian.

converter toPreparedGraphicsObjects*(_: type(nil)): PreparedGraphicsObjects {.importcpp: "(nullptr)".}
converter toBool*(this: PreparedGraphicsObjects): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PreparedGraphicsObjects, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PreparedGraphicsObjects], obj: TypedObject): PreparedGraphicsObjects {.importcpp: "DCAST(PreparedGraphicsObjects, @)".}

type IndexBufferContext* {.importcpp: "IndexBufferContext", pure, inheritable, header: "indexBufferContext.h".} = object of BufferContext
  ## This is a special class object that holds all the information returned by a
  ## particular GSG to indicate the vertex data array's internal context
  ## identifier.
  ##
  ## This allows the GSG to cache the vertex data array in whatever way makes
  ## sense.  For instance, DirectX can allocate a vertex buffer for the array.
  ## OpenGL can create a buffer object.

type Lens* {.importcpp: "PT(Lens)", bycopy, pure, inheritable, header: "lens.h".} = object of TypedWritableReferenceCount
  ## A base class for any number of different kinds of lenses, linear and
  ## otherwise.  Presently, this includes perspective and orthographic lenses.
  ##
  ## A Lens object is the main part of a Camera node, which defines the
  ## fundamental interface to point-of-view for rendering.  Lenses are also used
  ## in other contexts, however; for instance, a Spotlight is also defined using
  ## a lens.

converter toLens*(_: type(nil)): Lens {.importcpp: "(nullptr)".}
converter toBool*(this: Lens): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Lens, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Lens], obj: TypedObject): Lens {.importcpp: "DCAST(Lens, @)".}

type Material* {.importcpp: "PT(Material)", bycopy, pure, inheritable, header: "material.h".} = object of TypedWritableReferenceCount
  ## Defines the way an object appears in the presence of lighting.  A material
  ## is only necessary if lighting is to be enabled; otherwise, the material
  ## isn't used.
  ##
  ## There are two workflows that are supported: the "classic" workflow of
  ## providing separate ambient, diffuse and specular colors, and the
  ## "metalness" workflow, in which a base color is specified along with a
  ## "metallic" value that indicates whether the material is a metal or a
  ## dielectric.
  ##
  ## The size of the specular highlight can be specified by either specifying
  ## the specular exponent (shininess) or by specifying a roughness value that
  ## in perceptually linear in the range of 0-1.

converter toMaterial*(_: type(nil)): Material {.importcpp: "(nullptr)".}
converter toBool*(this: Material): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Material, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Material], obj: TypedObject): Material {.importcpp: "DCAST(Material, @)".}

type MaterialPool* {.importcpp: "MaterialPool", pure, inheritable, header: "materialPool.h".} = object
  ## The MaterialPool (there is only one in the universe) serves to unify
  ## different pointers to the same Material, so we do not (a) waste memory with
  ## many different Material objects that are all equivalent, and (b) waste time
  ## switching the graphics engine between different Material states that are
  ## really the same thing.
  ##
  ## The idea is to create a temporary Material representing the lighting state
  ## you want to apply, then call get_material(), passing in your temporary
  ## Material.  The return value will either be a new Material object, or it may
  ## be the the same object you supplied; in either case, it will have the same
  ## value.

type MatrixLens* {.importcpp: "PT(MatrixLens)", bycopy, pure, inheritable, header: "matrixLens.h".} = object of Lens
  ## A completely generic linear lens.  This is provided for the benefit of low-
  ## level code that wants to specify a perspective or orthographic frustum via
  ## an explicit projection matrix, but not mess around with fov's or focal
  ## lengths or any of that nonsense.

converter toMatrixLens*(_: type(nil)): MatrixLens {.importcpp: "(nullptr)".}
converter toBool*(this: MatrixLens): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MatrixLens, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MatrixLens], obj: TypedObject): MatrixLens {.importcpp: "DCAST(MatrixLens, @)".}

type OrthographicLens* {.importcpp: "PT(OrthographicLens)", bycopy, pure, inheritable, header: "orthographicLens.h".} = object of Lens
  ## An orthographic lens.  Although this kind of lens is linear, like a
  ## PerspectiveLens, it doesn't respect field-of-view or focal length
  ## parameters, and adjusting these will have no effect.  Instead, its field of
  ## view is controlled by adjusting the film_size; the orthographic lens
  ## represents a planar projection onto its imaginary film of the specified
  ## size, hanging in space.

converter toOrthographicLens*(_: type(nil)): OrthographicLens {.importcpp: "(nullptr)".}
converter toBool*(this: OrthographicLens): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: OrthographicLens, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[OrthographicLens], obj: TypedObject): OrthographicLens {.importcpp: "DCAST(OrthographicLens, @)".}

type ParamTextureSampler* {.importcpp: "PT(ParamTextureSampler)", bycopy, pure, inheritable, header: "paramTexture.h".} = object of ParamValueBase
  ## A class object for storing a pointer to a Texture along with a sampler
  ## state that indicates how to to sample the given texture.

converter toParamTextureSampler*(_: type(nil)): ParamTextureSampler {.importcpp: "(nullptr)".}
converter toBool*(this: ParamTextureSampler): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ParamTextureSampler, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ParamTextureSampler], obj: TypedObject): ParamTextureSampler {.importcpp: "DCAST(ParamTextureSampler, @)".}

type ParamTextureImage* {.importcpp: "PT(ParamTextureImage)", bycopy, pure, inheritable, header: "paramTexture.h".} = object of ParamValueBase
  ## A class object for storing a pointer to a Texture along with a set of
  ## properties that indicates which image to bind to a shader input.
  ##
  ## This class is useful for binding texture images to a shader, which is a
  ## fairly esoteric feature.

converter toParamTextureImage*(_: type(nil)): ParamTextureImage {.importcpp: "(nullptr)".}
converter toBool*(this: ParamTextureImage): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ParamTextureImage, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ParamTextureImage], obj: TypedObject): ParamTextureImage {.importcpp: "DCAST(ParamTextureImage, @)".}

type PerspectiveLens* {.importcpp: "PT(PerspectiveLens)", bycopy, pure, inheritable, header: "perspectiveLens.h".} = object of Lens
  ## A perspective-type lens: a normal camera.

converter toPerspectiveLens*(_: type(nil)): PerspectiveLens {.importcpp: "(nullptr)".}
converter toBool*(this: PerspectiveLens): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PerspectiveLens, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PerspectiveLens], obj: TypedObject): PerspectiveLens {.importcpp: "DCAST(PerspectiveLens, @)".}

type TextureReloadRequest* {.importcpp: "PT(TextureReloadRequest)", bycopy, pure, inheritable, header: "textureReloadRequest.h".} = object of AsyncTask
  ## This loader request will call Texture::get_ram_image() in a sub-thread, to
  ## force the texture's image to be re-read from disk.  It is used by
  ## GraphicsStateGuardian::async_reload_texture(), when get_incomplete_render()
  ## is true.

converter toTextureReloadRequest*(_: type(nil)): TextureReloadRequest {.importcpp: "(nullptr)".}
converter toBool*(this: TextureReloadRequest): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TextureReloadRequest, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TextureReloadRequest], obj: TypedObject): TextureReloadRequest {.importcpp: "DCAST(TextureReloadRequest, @)".}

type TextureContext* {.importcpp: "TextureContext", pure, inheritable, header: "textureContext.h".} = object of BufferContext
  ## This is a special class object that holds all the information returned by a
  ## particular GSG to indicate the texture's internal context identifier.
  ##
  ## Textures typically have an immediate-mode and a retained-mode operation.
  ## When using textures in retained-mode (in response to Texture::prepare()),
  ## the GSG will create some internal handle for the texture and store it here.
  ## The texture stores all of these handles internally.

type ShaderContext* {.importcpp: "ShaderContext", pure, inheritable, header: "shaderContext.h".} = object of SavedContext

type UserVertexSlider* {.importcpp: "PT(UserVertexSlider)", bycopy, pure, inheritable, header: "userVertexSlider.h".} = object of VertexSlider
  ## This is a specialization on VertexSlider that allows the user to specify
  ## any arbitrary slider valie he likes.  This is rarely used except for
  ## testing.

converter toUserVertexSlider*(_: type(nil)): UserVertexSlider {.importcpp: "(nullptr)".}
converter toBool*(this: UserVertexSlider): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: UserVertexSlider, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[UserVertexSlider], obj: TypedObject): UserVertexSlider {.importcpp: "DCAST(UserVertexSlider, @)".}

type UserVertexTransform* {.importcpp: "PT(UserVertexTransform)", bycopy, pure, inheritable, header: "userVertexTransform.h".} = object of VertexTransform
  ## This is a specialization on VertexTransform that allows the user to specify
  ## any arbitrary transform matrix he likes.  This is rarely used except for
  ## testing.

converter toUserVertexTransform*(_: type(nil)): UserVertexTransform {.importcpp: "(nullptr)".}
converter toBool*(this: UserVertexTransform): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: UserVertexTransform, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[UserVertexTransform], obj: TypedObject): UserVertexTransform {.importcpp: "DCAST(UserVertexTransform, @)".}

type VideoTexture* {.importcpp: "PT(VideoTexture)", bycopy, pure, inheritable, header: "videoTexture.h".} = object of Texture
  ## The base class for a family of animated Textures that take their input from
  ## a video source, such as a movie file.  These Textures may be stopped,
  ## started, etc.  using the AnimInterface controls, similar to an animated
  ## character.

converter toVideoTexture*(_: type(nil)): VideoTexture {.importcpp: "(nullptr)".}
converter toBool*(this: VideoTexture): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: VideoTexture, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[VideoTexture], obj: TypedObject): VideoTexture {.importcpp: "DCAST(VideoTexture, @)".}

type VertexBufferContext* {.importcpp: "VertexBufferContext", pure, inheritable, header: "vertexBufferContext.h".} = object of BufferContext
  ## This is a special class object that holds all the information returned by a
  ## particular GSG to indicate the vertex data array's internal context
  ## identifier.
  ##
  ## This allows the GSG to cache the vertex data array in whatever way makes
  ## sense.  For instance, DirectX can allocate a vertex buffer for the array.
  ## OpenGL can create a buffer object.

type TextureCollection* {.importcpp: "TextureCollection", pure, inheritable, header: "textureCollection.h".} = object
  ## Manages a list of Texture objects, as returned by
  ## TexturePool::find_all_textures().

type TexturePool* {.importcpp: "TexturePool", pure, inheritable, header: "texturePool.h".} = object
  ## This is the preferred interface for loading textures from image files.  It
  ## unifies all references to the same filename, so that multiple models that
  ## reference the same textures don't waste texture memory unnecessarily.

type TexturePeeker* {.importcpp: "PT(TexturePeeker)", bycopy, pure, inheritable, header: "texturePeeker.h".} = object of ReferenceCount
  ## An instance of this object is returned by Texture::peek().  This object
  ## allows quick and easy inspection of a texture's texels by (u, v)
  ## coordinates.

converter toTexturePeeker*(_: type(nil)): TexturePeeker {.importcpp: "(nullptr)".}
converter toBool*(this: TexturePeeker): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TexturePeeker, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TexturePeeker], obj: TypedObject): TexturePeeker {.importcpp: "DCAST(TexturePeeker, @)".}

type TextureStagePool* {.importcpp: "TextureStagePool", pure, inheritable, header: "textureStagePool.h".} = object
  ## The TextureStagePool (there is only one in the universe) serves to unify
  ## different pointers to the same TextureStage, mainly to help developers use
  ## a common pointer to access things that are loaded from different model
  ## files.
  ##
  ## It runs in one of three different modes, according to set_mode().  See that
  ## method for more information.

type MathNumbers* {.importcpp: "MathNumbers", pure, inheritable, header: "mathNumbers.h".} = object

type LVecBase2f* {.importcpp: "WrappedLVecBase2f", header: wrappedLVecBase2fCode, pure, inheritable.} = object
  ## This is the base class for all two-component vectors and points.
  x*: float32
  y*: float32

type LVecBase2d* {.importcpp: "WrappedLVecBase2d", header: wrappedLVecBase2dCode, pure, inheritable.} = object
  ## This is the base class for all two-component vectors and points.
  x*: float64
  y*: float64

type LVecBase2i* {.importcpp: "WrappedLVecBase2i", header: wrappedLVecBase2iCode, pure, inheritable.} = object
  ## This is the base class for all two-component vectors and points.
  x*: int32
  y*: int32

type LVector2f* {.importcpp: "LVector2f", pure, inheritable, header: "lvector2.h".} = object of LVecBase2f
  ## This is a two-component vector offset.

type LVector2d* {.importcpp: "LVector2d", pure, inheritable, header: "lvector2.h".} = object of LVecBase2d
  ## This is a two-component vector offset.

type LVector2i* {.importcpp: "LVector2i", pure, inheritable, header: "lvector2.h".} = object of LVecBase2i
  ## This is a two-component vector offset.

type LPoint2f* {.importcpp: "LPoint2f", pure, inheritable, header: "lpoint2.h".} = object of LVecBase2f
  ## This is a two-component point in space.

type LPoint2d* {.importcpp: "LPoint2d", pure, inheritable, header: "lpoint2.h".} = object of LVecBase2d
  ## This is a two-component point in space.

type LPoint2i* {.importcpp: "LPoint2i", pure, inheritable, header: "lpoint2.h".} = object of LVecBase2i
  ## This is a two-component point in space.

type LVecBase3f* {.importcpp: "WrappedLVecBase3f", header: wrappedLVecBase3fCode, pure, inheritable.} = object
  ## This is the base class for all three-component vectors and points.
  x*: float32
  y*: float32
  z*: float32

type LVecBase3d* {.importcpp: "WrappedLVecBase3d", header: wrappedLVecBase3dCode, pure, inheritable.} = object
  ## This is the base class for all three-component vectors and points.
  x*: float64
  y*: float64
  z*: float64

type LVecBase3i* {.importcpp: "WrappedLVecBase3i", header: wrappedLVecBase3iCode, pure, inheritable.} = object
  ## This is the base class for all three-component vectors and points.
  x*: int32
  y*: int32
  z*: int32

type CoordinateSystem* = enum
  CS_default = 0
  CS_zup_right = 1
  CS_yup_right = 2
  CS_zup_left = 3
  CS_yup_left = 4
  CS_invalid = 5

type LVector3f* {.importcpp: "LVector3f", pure, inheritable, header: "lvector3.h".} = object of LVecBase3f
  ## This is a three-component vector distance (as opposed to a three-component
  ## point, which represents a particular point in space).  Some of the methods
  ## are slightly different between LPoint3 and LVector3; in particular,
  ## subtraction of two points yields a vector, while addition of a vector and a
  ## point yields a point.

type LVector3d* {.importcpp: "LVector3d", pure, inheritable, header: "lvector3.h".} = object of LVecBase3d
  ## This is a three-component vector distance (as opposed to a three-component
  ## point, which represents a particular point in space).  Some of the methods
  ## are slightly different between LPoint3 and LVector3; in particular,
  ## subtraction of two points yields a vector, while addition of a vector and a
  ## point yields a point.

type LVector3i* {.importcpp: "LVector3i", pure, inheritable, header: "lvector3.h".} = object of LVecBase3i
  ## This is a three-component vector distance (as opposed to a three-component
  ## point, which represents a particular point in space).  Some of the methods
  ## are slightly different between LPoint3 and LVector3; in particular,
  ## subtraction of two points yields a vector, while addition of a vector and a
  ## point yields a point.

type LPoint3f* {.importcpp: "LPoint3f", pure, inheritable, header: "lpoint3.h".} = object of LVecBase3f
  ## This is a three-component point in space (as opposed to a three-component
  ## vector, which represents a direction and a distance).  Some of the methods
  ## are slightly different between LPoint3 and LVector3; in particular,
  ## subtraction of two points yields a vector, while addition of a vector and a
  ## point yields a point.

type LPoint3d* {.importcpp: "LPoint3d", pure, inheritable, header: "lpoint3.h".} = object of LVecBase3d
  ## This is a three-component point in space (as opposed to a three-component
  ## vector, which represents a direction and a distance).  Some of the methods
  ## are slightly different between LPoint3 and LVector3; in particular,
  ## subtraction of two points yields a vector, while addition of a vector and a
  ## point yields a point.

type LPoint3i* {.importcpp: "LPoint3i", pure, inheritable, header: "lpoint3.h".} = object of LVecBase3i
  ## This is a three-component point in space (as opposed to a three-component
  ## vector, which represents a direction and a distance).  Some of the methods
  ## are slightly different between LPoint3 and LVector3; in particular,
  ## subtraction of two points yields a vector, while addition of a vector and a
  ## point yields a point.

type LVecBase4f* {.importcpp: "WrappedLVecBase4f", header: wrappedLVecBase4fCode, pure, inheritable.} = object
  ## This is the base class for all three-component vectors and points.
  x*: float32
  y*: float32
  z*: float32
  w*: float32

type UnalignedLVecBase4f* {.importcpp: "WrappedLVecBase4f", header: wrappedLVecBase4fCode, pure, inheritable.} = object
  ## This is an "unaligned" LVecBase4.  It has no functionality other than to
  ## store numbers, and it will pack them in as tightly as possible, avoiding
  ## any SSE2 alignment requirements shared by the primary LVecBase4 class.
  ##
  ## Use it only when you need to pack numbers tightly without respect to
  ## alignment, and then copy it to a proper LVecBase4 to get actual use from
  ## it.
  x*: float32
  y*: float32
  z*: float32
  w*: float32

type LVecBase4d* {.importcpp: "WrappedLVecBase4d", header: wrappedLVecBase4dCode, pure, inheritable.} = object
  ## This is the base class for all three-component vectors and points.
  x*: float64
  y*: float64
  z*: float64
  w*: float64

type UnalignedLVecBase4d* {.importcpp: "WrappedLVecBase4d", header: wrappedLVecBase4dCode, pure, inheritable.} = object
  ## This is an "unaligned" LVecBase4.  It has no functionality other than to
  ## store numbers, and it will pack them in as tightly as possible, avoiding
  ## any SSE2 alignment requirements shared by the primary LVecBase4 class.
  ##
  ## Use it only when you need to pack numbers tightly without respect to
  ## alignment, and then copy it to a proper LVecBase4 to get actual use from
  ## it.
  x*: float64
  y*: float64
  z*: float64
  w*: float64

type LVecBase4i* {.importcpp: "WrappedLVecBase4i", header: wrappedLVecBase4iCode, pure, inheritable.} = object
  ## This is the base class for all three-component vectors and points.
  x*: int32
  y*: int32
  z*: int32
  w*: int32

type UnalignedLVecBase4i* {.importcpp: "WrappedLVecBase4i", header: wrappedLVecBase4iCode, pure, inheritable.} = object
  ## This is an "unaligned" LVecBase4.  It has no functionality other than to
  ## store numbers, and it will pack them in as tightly as possible, avoiding
  ## any SSE2 alignment requirements shared by the primary LVecBase4 class.
  ##
  ## Use it only when you need to pack numbers tightly without respect to
  ## alignment, and then copy it to a proper LVecBase4 to get actual use from
  ## it.
  x*: int32
  y*: int32
  z*: int32
  w*: int32

type LVector4f* {.importcpp: "LVector4f", pure, inheritable, header: "lvector4.h".} = object of LVecBase4f
  ## This is a four-component vector distance.

type LVector4d* {.importcpp: "LVector4d", pure, inheritable, header: "lvector4.h".} = object of LVecBase4d
  ## This is a four-component vector distance.

type LVector4i* {.importcpp: "LVector4i", pure, inheritable, header: "lvector4.h".} = object of LVecBase4i
  ## This is a four-component vector distance.

type LPoint4f* {.importcpp: "LPoint4f", pure, inheritable, header: "lpoint4.h".} = object of LVecBase4f
  ## This is a four-component point in space.

type LPoint4d* {.importcpp: "LPoint4d", pure, inheritable, header: "lpoint4.h".} = object of LVecBase4d
  ## This is a four-component point in space.

type LPoint4i* {.importcpp: "LPoint4i", pure, inheritable, header: "lpoint4.h".} = object of LVecBase4i
  ## This is a four-component point in space.

type LMatrix3f* {.importcpp: "LMatrix3f", pure, inheritable, header: "lmatrix.h".} = object
  ## This is a 3-by-3 transform matrix.  It typically will represent either a
  ## rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
  ## (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.

type LMatrix4f* {.importcpp: "LMatrix4f", pure, inheritable, header: "lmatrix.h".} = object
  ## This is a 4-by-4 transform matrix.

type UnalignedLMatrix4f* {.importcpp: "UnalignedLMatrix4f", pure, inheritable, header: "lmatrix.h".} = object
  ## This is an "unaligned" LMatrix4.  It has no functionality other than to
  ## store numbers, and it will pack them in as tightly as possible, avoiding
  ## any SSE2 alignment requirements shared by the primary LMatrix4 class.
  ##
  ## Use it only when you need to pack numbers tightly without respect to
  ## alignment, and then copy it to a proper LMatrix4 to get actual use from it.

type LMatrix3d* {.importcpp: "LMatrix3d", pure, inheritable, header: "lmatrix.h".} = object
  ## This is a 3-by-3 transform matrix.  It typically will represent either a
  ## rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
  ## (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.

type LMatrix4d* {.importcpp: "LMatrix4d", pure, inheritable, header: "lmatrix.h".} = object
  ## This is a 4-by-4 transform matrix.

type UnalignedLMatrix4d* {.importcpp: "UnalignedLMatrix4d", pure, inheritable, header: "lmatrix.h".} = object
  ## This is an "unaligned" LMatrix4.  It has no functionality other than to
  ## store numbers, and it will pack them in as tightly as possible, avoiding
  ## any SSE2 alignment requirements shared by the primary LMatrix4 class.
  ##
  ## Use it only when you need to pack numbers tightly without respect to
  ## alignment, and then copy it to a proper LMatrix4 to get actual use from it.

type LQuaternionf* {.importcpp: "LQuaternionf", pure, inheritable, header: "lquaternion.h".} = object of LVecBase4f
  ## This is the base quaternion class

type LQuaterniond* {.importcpp: "LQuaterniond", pure, inheritable, header: "lquaternion.h".} = object of LVecBase4d
  ## This is the base quaternion class

type LRotationf* {.importcpp: "LRotationf", pure, inheritable, header: "lrotation.h".} = object of LQuaternionf
  ## This is a unit quaternion representing a rotation.

type LRotationd* {.importcpp: "LRotationd", pure, inheritable, header: "lrotation.h".} = object of LQuaterniond
  ## This is a unit quaternion representing a rotation.

type LOrientationf* {.importcpp: "LOrientationf", pure, inheritable, header: "lorientation.h".} = object of LQuaternionf
  ## This is a unit quaternion representing an orientation.

type LOrientationd* {.importcpp: "LOrientationd", pure, inheritable, header: "lorientation.h".} = object of LQuaterniond
  ## This is a unit quaternion representing an orientation.

type LVertexf* = LPoint3f

type LNormalf* = LVector3f

type LTexCoordf* = LPoint2f

type LTexCoord3f* = LPoint3f

type LColorf* = LVecBase4f

type LRGBColorf* = LVecBase3f

type LVertexd* = LPoint3d

type LNormald* = LVector3d

type LTexCoordd* = LPoint2d

type LTexCoord3d* = LPoint3d

type LColord* = LVecBase4d

type LRGBColord* = LVecBase3d

type Mat4F* = LMatrix4f

type Mat3F* = LMatrix3f

type VBase4F* = LVecBase4f

type Vec4F* = LVector4f

type Point4F* = LPoint4f

type VBase3F* = LVecBase3f

type Vec3F* = LVector3f

type Point3F* = LPoint3f

type VBase2F* = LVecBase2f

type Vec2F* = LVector2f

type Point2F* = LPoint2f

type QuatF* = LQuaternionf

type Mat4D* = LMatrix4d

type Mat3D* = LMatrix3d

type VBase4D* = LVecBase4d

type Vec4D* = LVector4d

type Point4D* = LPoint4d

type VBase3D* = LVecBase3d

type Vec3D* = LVector3d

type Point3D* = LPoint3d

type VBase2D* = LVecBase2d

type Vec2D* = LVector2d

type Point2D* = LPoint2d

type QuatD* = LQuaterniond

type LVecBase2* = LVecBase2f

type LPoint2* = LPoint2f

type LVector2* = LVector2f

type LVecBase3* = LVecBase3f

type LPoint3* = LPoint3f

type LVector3* = LVector3f

type LVecBase4* = LVecBase4f

type LPoint4* = LPoint4f

type LVector4* = LVector4f

type LQuaternion* = LQuaternionf

type LRotation* = LRotationf

type LOrientation* = LOrientationf

type LMatrix3* = LMatrix3f

type LMatrix4* = LMatrix4f

type LVertex* = LVertexf

type LNormal* = LNormalf

type LTexCoord* = LTexCoordf

type LTexCoord3* = LTexCoord3f

type LColor* = LColorf

type LRGBColor* = LRGBColorf

type UnalignedLVecBase4* = UnalignedLVecBase4f

type UnalignedLMatrix4* = UnalignedLMatrix4f

type Mat4* = LMatrix4f

type Mat3* = LMatrix3f

type VBase4* = LVecBase4f

type Vec4* = LVector4f

type Point4* = LPoint4f

type VBase3* = LVecBase3f

type Vec3* = LVector3f

type Point3* = LPoint3f

type VBase2* = LVecBase2f

type Vec2* = LVector2f

type Point2* = LPoint2f

type Quat* = LQuaternionf

type ConfigVariableColor* {.importcpp: "ConfigVariableColor", pure, inheritable, header: "configVariableColor.h".} = object of ConfigVariable
  ## This is a convenience class to specialize ConfigVariable as a set of
  ## floating-point types representing a color value.
  ##
  ## It interprets the color differently depending on how many words were
  ## specified: if only one, it is interpreted as a shade of gray with alpha 1.
  ## If two values were specified, a grayscale and alpha pair.  If three, a set
  ## of R, G, B values with alpha 1, and if four, a complete RGBA color.
  ##
  ## This isn't defined in dtool because it relies on the LColor class, which is
  ## defined in linmath.

type BoundingVolume* {.importcpp: "PT(BoundingVolume)", bycopy, pure, inheritable, header: "boundingVolume.h".} = object of TypedReferenceCount
  ## This is an abstract class for any volume in any sense which can be said to
  ## define the locality of reference of a node in a graph, along with all of
  ## its descendants.  It is not necessarily a geometric volume (although see
  ## GeometricBoundingVolume); this is simply an abstract interface for bounds
  ## of any sort.

converter toBoundingVolume*(_: type(nil)): BoundingVolume {.importcpp: "(nullptr)".}
converter toBool*(this: BoundingVolume): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: BoundingVolume, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[BoundingVolume], obj: TypedObject): BoundingVolume {.importcpp: "DCAST(BoundingVolume, @)".}

type GeometricBoundingVolume* {.importcpp: "PT(GeometricBoundingVolume)", bycopy, pure, inheritable, header: "geometricBoundingVolume.h".} = object of BoundingVolume
  ## This is another abstract class, for a general class of bounding volumes
  ## that actually enclose points in 3-d space, such as BSP's and bounding
  ## spheres.

converter toGeometricBoundingVolume*(_: type(nil)): GeometricBoundingVolume {.importcpp: "(nullptr)".}
converter toBool*(this: GeometricBoundingVolume): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeometricBoundingVolume, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeometricBoundingVolume], obj: TypedObject): GeometricBoundingVolume {.importcpp: "DCAST(GeometricBoundingVolume, @)".}

type FiniteBoundingVolume* {.importcpp: "PT(FiniteBoundingVolume)", bycopy, pure, inheritable, header: "finiteBoundingVolume.h".} = object of GeometricBoundingVolume
  ## A special kind of GeometricBoundingVolume that is known to be finite.  It
  ## is possible to query this kind of volume for its minimum and maximum
  ## extents.

converter toFiniteBoundingVolume*(_: type(nil)): FiniteBoundingVolume {.importcpp: "(nullptr)".}
converter toBool*(this: FiniteBoundingVolume): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: FiniteBoundingVolume, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[FiniteBoundingVolume], obj: TypedObject): FiniteBoundingVolume {.importcpp: "DCAST(FiniteBoundingVolume, @)".}

type LParabolaf* {.importcpp: "LParabolaf", pure, inheritable, header: "parabola.h".} = object
  ## An abstract mathematical description of a parabola, particularly useful for
  ## describing arcs of projectiles.
  ##
  ## The parabolic equation, given parametrically here, is P = At^2 + Bt + C.

type LParabolad* {.importcpp: "LParabolad", pure, inheritable, header: "parabola.h".} = object
  ## An abstract mathematical description of a parabola, particularly useful for
  ## describing arcs of projectiles.
  ##
  ## The parabolic equation, given parametrically here, is P = At^2 + Bt + C.

type LParabola* = LParabolaf

type LPlanef* {.importcpp: "LPlanef", pure, inheritable, header: "plane.h".} = object of LVecBase4f
  ## An abstract mathematical description of a plane.  A plane is defined by the
  ## equation Ax + By + Cz + D = 0.

type LPlaned* {.importcpp: "LPlaned", pure, inheritable, header: "plane.h".} = object of LVecBase4d
  ## An abstract mathematical description of a plane.  A plane is defined by the
  ## equation Ax + By + Cz + D = 0.

type LPlane* = LPlanef

type PlaneF* = LPlanef

type PlaneD* = LPlaned

type Plane* = LPlanef

type BoundingBox* {.importcpp: "PT(BoundingBox)", bycopy, pure, inheritable, header: "boundingBox.h".} = object of FiniteBoundingVolume
  ## An axis-aligned bounding box; that is, a minimum and maximum coordinate
  ## triple.
  ##
  ## This box is always axis-aligned.  If you need a more general bounding box,
  ## try BoundingHexahedron.

converter toBoundingBox*(_: type(nil)): BoundingBox {.importcpp: "(nullptr)".}
converter toBool*(this: BoundingBox): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: BoundingBox, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[BoundingBox], obj: TypedObject): BoundingBox {.importcpp: "DCAST(BoundingBox, @)".}

type LFrustumf* {.importcpp: "LFrustumf", pure, inheritable, header: "frustum.h".} = object

type LFrustumd* {.importcpp: "LFrustumd", pure, inheritable, header: "frustum.h".} = object

type LFrustum* = LFrustumf

type FrustumF* = LFrustumf

type FrustumD* = LFrustumd

type Frustum* = LFrustumf

type BoundingHexahedron* {.importcpp: "PT(BoundingHexahedron)", bycopy, pure, inheritable, header: "boundingHexahedron.h".} = object of FiniteBoundingVolume
  ## This defines a bounding convex hexahedron.  It is typically used to
  ## represent a frustum, but may represent any enclosing convex hexahedron,
  ## including simple boxes.  However, if all you want is an axis-aligned
  ## bounding box, you may be better off with the simpler BoundingBox class.

converter toBoundingHexahedron*(_: type(nil)): BoundingHexahedron {.importcpp: "(nullptr)".}
converter toBool*(this: BoundingHexahedron): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: BoundingHexahedron, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[BoundingHexahedron], obj: TypedObject): BoundingHexahedron {.importcpp: "DCAST(BoundingHexahedron, @)".}

type BoundingLine* {.importcpp: "PT(BoundingLine)", bycopy, pure, inheritable, header: "boundingLine.h".} = object of GeometricBoundingVolume
  ## This funny bounding volume is an infinite line with no thickness and
  ## extending to infinity in both directions.
  ##
  ## Note that it \*always\* extends in both directions, despite the fact that you
  ## specify two points to the constructor.  These are not endpoints, they are
  ## two arbitrary points on the line.

converter toBoundingLine*(_: type(nil)): BoundingLine {.importcpp: "(nullptr)".}
converter toBool*(this: BoundingLine): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: BoundingLine, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[BoundingLine], obj: TypedObject): BoundingLine {.importcpp: "DCAST(BoundingLine, @)".}

type BoundingPlane* {.importcpp: "PT(BoundingPlane)", bycopy, pure, inheritable, header: "boundingPlane.h".} = object of GeometricBoundingVolume
  ## This funny bounding volume is an infinite plane that divides space into two
  ## regions: the part behind the normal, which is "inside" the bounding volume,
  ## and the part in front of the normal, which is "outside" the bounding
  ## volume.

converter toBoundingPlane*(_: type(nil)): BoundingPlane {.importcpp: "(nullptr)".}
converter toBool*(this: BoundingPlane): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: BoundingPlane, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[BoundingPlane], obj: TypedObject): BoundingPlane {.importcpp: "DCAST(BoundingPlane, @)".}

type BoundingSphere* {.importcpp: "PT(BoundingSphere)", bycopy, pure, inheritable, header: "boundingSphere.h".} = object of FiniteBoundingVolume
  ## This defines a bounding sphere, consisting of a center and a radius.  It is
  ## always a sphere, and never an ellipsoid or other quadric.

converter toBoundingSphere*(_: type(nil)): BoundingSphere {.importcpp: "(nullptr)".}
converter toBool*(this: BoundingSphere): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: BoundingSphere, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[BoundingSphere], obj: TypedObject): BoundingSphere {.importcpp: "DCAST(BoundingSphere, @)".}

type IntersectionBoundingVolume* {.importcpp: "PT(IntersectionBoundingVolume)", bycopy, pure, inheritable, header: "intersectionBoundingVolume.h".} = object of GeometricBoundingVolume
  ## This special bounding volume is the intersection of all of its constituent
  ## bounding volumes.
  ##
  ## A point is defined to be within an IntersectionBoundingVolume if it is
  ## within all of its component bounding volumes.

converter toIntersectionBoundingVolume*(_: type(nil)): IntersectionBoundingVolume {.importcpp: "(nullptr)".}
converter toBool*(this: IntersectionBoundingVolume): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: IntersectionBoundingVolume, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[IntersectionBoundingVolume], obj: TypedObject): IntersectionBoundingVolume {.importcpp: "DCAST(IntersectionBoundingVolume, @)".}

type Mersenne* {.importcpp: "Mersenne", pure, inheritable, header: "mersenne.h".} = object

type OmniBoundingVolume* {.importcpp: "PT(OmniBoundingVolume)", bycopy, pure, inheritable, header: "omniBoundingVolume.h".} = object of GeometricBoundingVolume
  ## This is a special kind of GeometricBoundingVolume that fills all of space.

converter toOmniBoundingVolume*(_: type(nil)): OmniBoundingVolume {.importcpp: "(nullptr)".}
converter toBool*(this: OmniBoundingVolume): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: OmniBoundingVolume, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[OmniBoundingVolume], obj: TypedObject): OmniBoundingVolume {.importcpp: "DCAST(OmniBoundingVolume, @)".}

type UnionBoundingVolume* {.importcpp: "PT(UnionBoundingVolume)", bycopy, pure, inheritable, header: "unionBoundingVolume.h".} = object of GeometricBoundingVolume
  ## This special bounding volume is the union of all of its constituent
  ## bounding volumes.
  ##
  ## A point is defined to be within a UnionBoundingVolume if it is within any
  ## one or more of its component bounding volumes.

converter toUnionBoundingVolume*(_: type(nil)): UnionBoundingVolume {.importcpp: "(nullptr)".}
converter toBool*(this: UnionBoundingVolume): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: UnionBoundingVolume, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[UnionBoundingVolume], obj: TypedObject): UnionBoundingVolume {.importcpp: "DCAST(UnionBoundingVolume, @)".}

type Randomizer* {.importcpp: "Randomizer", pure, inheritable, header: "randomizer.h".} = object
  ## A handy class to return random numbers.

type PerlinNoise* {.importcpp: "PerlinNoise", pure, inheritable, header: "perlinNoise.h".} = object
  ## This is the base class for PerlinNoise2 and PerlinNoise3, different
  ## dimensions of Perlin noise implementation.  The base class just collects
  ## the common functionality.

type PerlinNoise2* {.importcpp: "PerlinNoise2", pure, inheritable, header: "perlinNoise2.h".} = object of PerlinNoise
  ## This class provides an implementation of Perlin noise for 2 variables.
  ## This code is loosely based on the reference implementation at
  ## https://mrl.nyu.edu/~perlin/noise/ .

type PerlinNoise3* {.importcpp: "PerlinNoise3", pure, inheritable, header: "perlinNoise3.h".} = object of PerlinNoise
  ## This class provides an implementation of Perlin noise for 3 variables.
  ## This code is loosely based on the reference implementation at
  ## http://mrl.nyu.edu/~perlin/noise/ .

type StackedPerlinNoise2* {.importcpp: "StackedPerlinNoise2", pure, inheritable, header: "stackedPerlinNoise2.h".} = object
  ## Implements a multi-layer PerlinNoise, with one or more high-frequency noise
  ## functions added to a lower-frequency base noise function.

type StackedPerlinNoise3* {.importcpp: "StackedPerlinNoise3", pure, inheritable, header: "stackedPerlinNoise3.h".} = object
  ## Implements a multi-layer PerlinNoise, with one or more high-frequency noise
  ## functions added to a lower-frequency base noise function.

type Triangulator* {.importcpp: "Triangulator", pure, inheritable, header: "triangulator.h".} = object
  ## This class can triangulate a convex or concave polygon, even one with
  ## holes.  It is adapted from an algorithm published as:
  ##
  ## Narkhede A. and Manocha D., Fast polygon triangulation algorithm based on
  ## Seidel's Algorithm, UNC-CH, 1994.
  ##
  ## http://www.cs.unc.edu/~dm/CODE/GEM/chapter.html
  ##
  ## It works strictly on 2-d points.  See Triangulator3 for 3-d points.

type Triangulator3* {.importcpp: "Triangulator3", pure, inheritable, header: "triangulator3.h".} = object of Triangulator
  ## This is an extension of Triangulator to handle polygons with three-
  ## dimensional points.  It assumes all of the points lie in a single plane,
  ## and internally projects the supplied points into 2-D for passing to the
  ## underlying Triangulator object.

type ParametricCurve* {.importcpp: "PT(ParametricCurve)", bycopy, pure, inheritable, header: "parametricCurve.h".} = object of PandaNode
  ## A virtual base class for parametric curves.  This encapsulates all curves
  ## in 3-d space defined for a single parameter t in the range [0,get_max_t()].

converter toParametricCurve*(_: type(nil)): ParametricCurve {.importcpp: "(nullptr)".}
converter toBool*(this: ParametricCurve): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ParametricCurve, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ParametricCurve], obj: TypedObject): ParametricCurve {.importcpp: "DCAST(ParametricCurve, @)".}

type CubicCurveseg* {.importcpp: "PT(CubicCurveseg)", bycopy, pure, inheritable, header: "cubicCurveseg.h".} = object of ParametricCurve
  ## A CubicCurveseg is any curve that can be completely described by four
  ## 4-valued basis vectors, one for each dimension in three-space, and one for
  ## the homogeneous coordinate.  This includes Beziers, Hermites, and NURBS.
  ##
  ## This class encapsulates a single curve segment of the cubic curve.
  ## Normally, when we think of Bezier and Hermite curves, we think of a
  ## piecewise collection of such segments.
  ##
  ## Although this class includes methods such as hermite_basis() and
  ## nurbs_basis(), to generate a Hermite and NURBS curve segment, respectively,
  ## only the final basis vectors are stored: the product of the basis matrix of
  ## the corresponding curve type, and its geometry vectors.  This is the
  ## minimum information needed to evaluate the curve.  However, the individual
  ## CV's that were used to compute these basis vectors are not retained; this
  ## might be handled in a subclass (for instance, HermiteCurve).

converter toCubicCurveseg*(_: type(nil)): CubicCurveseg {.importcpp: "(nullptr)".}
converter toBool*(this: CubicCurveseg): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CubicCurveseg, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CubicCurveseg], obj: TypedObject): CubicCurveseg {.importcpp: "DCAST(CubicCurveseg, @)".}

type ParametricCurveCollection* {.importcpp: "PT(ParametricCurveCollection)", bycopy, pure, inheritable, header: "parametricCurveCollection.h".} = object of ReferenceCount
  ## This is a set of zero or more ParametricCurves, which may or may not be
  ## related.  If they are related, the set should contain no more than one XYZ
  ## curve, no more than one HPR curve, and zero or more Timewarp curves, which
  ## can then be evaluated as a unit to return a single transformation matrix
  ## for a given unit of time.

converter toParametricCurveCollection*(_: type(nil)): ParametricCurveCollection {.importcpp: "(nullptr)".}
converter toBool*(this: ParametricCurveCollection): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ParametricCurveCollection, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ParametricCurveCollection], obj: TypedObject): ParametricCurveCollection {.importcpp: "DCAST(ParametricCurveCollection, @)".}

type CurveFitter* {.importcpp: "CurveFitter", pure, inheritable, header: "curveFitter.h".} = object

type PiecewiseCurve* {.importcpp: "PT(PiecewiseCurve)", bycopy, pure, inheritable, header: "piecewiseCurve.h".} = object of ParametricCurve
  ## A PiecewiseCurve is a curve made up of several curve segments, connected in
  ## a head-to-tail fashion.  The length of each curve segment in parametric
  ## space is definable.

converter toPiecewiseCurve*(_: type(nil)): PiecewiseCurve {.importcpp: "(nullptr)".}
converter toBool*(this: PiecewiseCurve): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PiecewiseCurve, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PiecewiseCurve], obj: TypedObject): PiecewiseCurve {.importcpp: "DCAST(PiecewiseCurve, @)".}

type HermiteCurve* {.importcpp: "PT(HermiteCurve)", bycopy, pure, inheritable, header: "hermiteCurve.h".} = object of PiecewiseCurve
  ## A parametric curve defined by a sequence of control vertices, each with an
  ## in and out tangent.
  ##
  ## This class is actually implemented as a PiecewiseCurve made up of several
  ## CubicCurvesegs, each of which is created using the hermite_basis() method.
  ## The HermiteCurve class itself keeps its own list of the CV's that are used
  ## to define the curve (since the CubicCurveseg class doesn't retain these).

converter toHermiteCurve*(_: type(nil)): HermiteCurve {.importcpp: "(nullptr)".}
converter toBool*(this: HermiteCurve): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: HermiteCurve, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[HermiteCurve], obj: TypedObject): HermiteCurve {.importcpp: "DCAST(HermiteCurve, @)".}

type NurbsCurveInterface* {.importcpp: "NurbsCurveInterface*", bycopy, pure, inheritable, header: "nurbsCurveInterface.h".} = object
  ## This abstract class defines the interface only for a Nurbs-style curve,
  ## with knots and coordinates in homogeneous space.
  ##
  ## The NurbsCurve class inherits both from this and from ParametricCurve.

converter toNurbsCurveInterface*(_: type(nil)): NurbsCurveInterface {.importcpp: "(nullptr)".}
converter toBool*(this: NurbsCurveInterface): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: NurbsCurveInterface, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type NurbsCurve* {.importcpp: "PT(NurbsCurve)", bycopy, pure, inheritable, header: "nurbsCurve.h".} = object of PiecewiseCurve
  ## A Nonuniform Rational B-Spline.
  ##
  ## This class is actually implemented as a PiecewiseCurve made up of several
  ## CubicCurvesegs, each of which is created using the nurbs_basis() method.
  ## The list of CV's and knots is kept here, within the NurbsCurve class.
  ##
  ## This class is the original Panda-native implementation of a NURBS curve.
  ## It is typedeffed as "NurbsCurve" and performs all NURBS curve functions if
  ## we do not have the NURBS++ library available.
  ##
  ## However, if we \*do\* have the NURBS++ library, another class exists, the
  ## NurbsPPCurve, which is a wrapper around that library and provides some
  ## additional functionality.  In that case, the other class is typedeffed to
  ## "NurbsCurve" instead of this one, and performs most of the NURBS curve
  ## functions.  This class then becomes vestigial.

converter toNurbsCurve*(_: type(nil)): NurbsCurve {.importcpp: "(nullptr)".}
converter toBool*(this: NurbsCurve): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: NurbsCurve, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[NurbsCurve], obj: TypedObject): NurbsCurve {.importcpp: "DCAST(NurbsCurve, @)".}

type NurbsCurveResult* {.importcpp: "PT(NurbsCurveResult)", bycopy, pure, inheritable, header: "nurbsCurveResult.h".} = object of ReferenceCount
  ## The result of a NurbsCurveEvaluator.  This object represents a curve in a
  ## particular coordinate space.  It can return the point and/or tangent to the
  ## curve at any point.
  ##
  ## This is not related to NurbsCurve, CubicCurveseg or any of the
  ## ParametricCurve-derived objects in this module.  It is a completely
  ## parallel implementation of NURBS curves, and will probably eventually
  ## replace the whole ParametricCurve class hierarchy.

converter toNurbsCurveResult*(_: type(nil)): NurbsCurveResult {.importcpp: "(nullptr)".}
converter toBool*(this: NurbsCurveResult): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: NurbsCurveResult, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[NurbsCurveResult], obj: TypedObject): NurbsCurveResult {.importcpp: "DCAST(NurbsCurveResult, @)".}

type NurbsCurveEvaluator* {.importcpp: "PT(NurbsCurveEvaluator)", bycopy, pure, inheritable, header: "nurbsCurveEvaluator.h".} = object of ReferenceCount
  ## This class is an abstraction for evaluating NURBS curves.  It accepts an
  ## array of vertices, each of which may be in a different coordinate space (as
  ## defined by a NodePath), as well as an optional knot vector.
  ##
  ## This is not related to NurbsCurve, CubicCurveseg or any of the
  ## ParametricCurve-derived objects in this module.  It is a completely
  ## parallel implementation of NURBS curves, and will probably eventually
  ## replace the whole ParametricCurve class hierarchy.

converter toNurbsCurveEvaluator*(_: type(nil)): NurbsCurveEvaluator {.importcpp: "(nullptr)".}
converter toBool*(this: NurbsCurveEvaluator): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: NurbsCurveEvaluator, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[NurbsCurveEvaluator], obj: TypedObject): NurbsCurveEvaluator {.importcpp: "DCAST(NurbsCurveEvaluator, @)".}

type NurbsSurfaceResult* {.importcpp: "PT(NurbsSurfaceResult)", bycopy, pure, inheritable, header: "nurbsSurfaceResult.h".} = object of ReferenceCount
  ## The result of a NurbsSurfaceEvaluator.  This object represents a surface in
  ## a particular coordinate space.  It can return the point and/or normal to
  ## the surface at any point.

converter toNurbsSurfaceResult*(_: type(nil)): NurbsSurfaceResult {.importcpp: "(nullptr)".}
converter toBool*(this: NurbsSurfaceResult): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: NurbsSurfaceResult, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[NurbsSurfaceResult], obj: TypedObject): NurbsSurfaceResult {.importcpp: "DCAST(NurbsSurfaceResult, @)".}

type NurbsSurfaceEvaluator* {.importcpp: "PT(NurbsSurfaceEvaluator)", bycopy, pure, inheritable, header: "nurbsSurfaceEvaluator.h".} = object of ReferenceCount
  ## This class is an abstraction for evaluating NURBS surfaces.  It accepts an
  ## array of vertices, each of which may be in a different coordinate space (as
  ## defined by a NodePath), as well as an optional knot vector.

converter toNurbsSurfaceEvaluator*(_: type(nil)): NurbsSurfaceEvaluator {.importcpp: "(nullptr)".}
converter toBool*(this: NurbsSurfaceEvaluator): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: NurbsSurfaceEvaluator, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[NurbsSurfaceEvaluator], obj: TypedObject): NurbsSurfaceEvaluator {.importcpp: "DCAST(NurbsSurfaceEvaluator, @)".}

type RopeNode* {.importcpp: "PT(RopeNode)", bycopy, pure, inheritable, header: "ropeNode.h".} = object of PandaNode
  ## This class draws a visible representation of the NURBS curve stored in its
  ## NurbsCurveEvaluator.  It automatically recomputes the curve every frame.
  ##
  ## This is not related to NurbsCurve, CubicCurveseg or any of the
  ## ParametricCurve-derived objects in this module.  It is a completely
  ## parallel implementation of NURBS curves, and will probably eventually
  ## replace the whole ParametricCurve class hierarchy.

converter toRopeNode*(_: type(nil)): RopeNode {.importcpp: "(nullptr)".}
converter toBool*(this: RopeNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RopeNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[RopeNode], obj: TypedObject): RopeNode {.importcpp: "DCAST(RopeNode, @)".}

type SheetNode* {.importcpp: "PT(SheetNode)", bycopy, pure, inheritable, header: "sheetNode.h".} = object of PandaNode
  ## This class draws a visible representation of the NURBS surface stored in
  ## its NurbsSurfaceEvaluator.  It automatically recomputes the surface every
  ## frame.
  ##
  ## This is not related to NurbsSurface, CubicSurfaceseg or any of the
  ## ParametricSurface-derived objects in this module.  It is a completely
  ## parallel implementation of NURBS surfaces, and will probably eventually
  ## replace the whole ParametricSurface class hierarchy.

converter toSheetNode*(_: type(nil)): SheetNode {.importcpp: "(nullptr)".}
converter toBool*(this: SheetNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: SheetNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[SheetNode], obj: TypedObject): SheetNode {.importcpp: "DCAST(SheetNode, @)".}

type pixel* {.importcpp: "pixel", pure, inheritable, header: "pnmimage_base.h".} = object

type xel* = pixel

type PNMFileType* {.importcpp: "PNMFileType", pure, inheritable, header: "pnmFileType.h".} = object of TypedWritable
  ## This is the base class of a family of classes that represent particular
  ## image file types that PNMImage supports.

type PNMFileTypeRegistry* {.importcpp: "PNMFileTypeRegistry", pure, inheritable, header: "pnmFileTypeRegistry.h".} = object
  ## This class maintains the set of all known PNMFileTypes in the universe.

type PNMImageHeader* {.importcpp: "PNMImageHeader", pure, inheritable, header: "pnmImageHeader.h".} = object
  ## This is the base class of PNMImage, PNMReader, and PNMWriter.  It
  ## encapsulates all the information associated with an image that describes
  ## its size, number of channels, etc; that is, all the information about the
  ## image except the image data itself.  It's the sort of information you
  ## typically read from the image file's header.

type PfmFile* {.importcpp: "PfmFile", pure, inheritable, header: "pfmFile.h".} = object of PNMImageHeader
  ## Defines a pfm file, a 2-d table of floating-point numbers, either
  ## 3-component or 1-component, or with a special extension, 2- or 4-component.

type PNMBrush* {.importcpp: "PT(PNMBrush)", bycopy, pure, inheritable, header: "pnmBrush.h".} = object of ReferenceCount
  ## This class is used to control the shape and color of the drawing operations
  ## performed by a PNMPainter object.
  ##
  ## Normally, you don't create a PNMBrush directly; instead, use one of the
  ## static PNMBrush::make_\*() methods provided here.
  ##
  ## A PNMBrush is used to draw the border of a polygon or rectangle, as well as
  ## for filling its interior.  When it is used to draw a border, the brush is
  ## "smeared" over the border; when it is used to fill the interior, it is
  ## tiled through the interior.

converter toPNMBrush*(_: type(nil)): PNMBrush {.importcpp: "(nullptr)".}
converter toBool*(this: PNMBrush): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PNMBrush, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PNMBrush], obj: TypedObject): PNMBrush {.importcpp: "DCAST(PNMBrush, @)".}

type PNMImage* {.importcpp: "PNMImage", pure, inheritable, header: "pnmImage.h".} = object of PNMImageHeader
  ## The name of this class derives from the fact that we originally implemented
  ## it as a layer on top of the "pnm library", based on netpbm, which was built
  ## to implement pbm, pgm, and pbm files, and is the underlying support of a
  ## number of public-domain image file converters.  Nowadays we are no longer
  ## derived directly from the pnm library, mainly to allow support of C++
  ## iostreams instead of the C stdio FILE interface.
  ##
  ## Conceptually, a PNMImage is a two-dimensional array of xels, which are the
  ## PNM-defined generic pixel type.  Each xel may have a red, green, and blue
  ## component, or (if the image is grayscale) a gray component.  The image may
  ## be read in, the individual xels manipulated, and written out again, or a
  ## black image may be constructed from scratch.
  ##
  ## A PNMImage has a color space and a maxval, the combination of which defines
  ## how a floating-point linear color value is encoded as an integer value in
  ## memory.  The functions ending in _val operate on encoded colors, whereas
  ## the regular ones work with linear floating-point values.  All operations
  ## are color space correct unless otherwise specified.
  ##
  ## The image is of size XSize() by YSize() xels, numbered from top to bottom,
  ## left to right, beginning at zero.
  ##
  ## Files can be specified by filename, or by an iostream pointer.  The
  ## filename "-" refers to stdin or stdout.
  ##
  ## This class is not inherently thread-safe; use it from a single thread or
  ## protect access using a mutex.

type PNMPainter* {.importcpp: "PNMPainter", pure, inheritable, header: "pnmPainter.h".} = object
  ## This class provides a number of convenient methods for painting drawings
  ## directly into a PNMImage.
  ##
  ## It stores a pointer to the PNMImage you pass it, but it does not take
  ## ownership of the object; you are responsible for ensuring that the PNMImage
  ## does not destruct during the lifetime of the PNMPainter object.

type TextGlyph* {.importcpp: "PT(TextGlyph)", bycopy, pure, inheritable, header: "textGlyph.h".} = object of TypedReferenceCount
  ## A representation of a single glyph (character) from a font.  This is a
  ## piece of renderable geometry of some kind.

converter toTextGlyph*(_: type(nil)): TextGlyph {.importcpp: "(nullptr)".}
converter toBool*(this: TextGlyph): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TextGlyph, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TextGlyph], obj: TypedObject): TextGlyph {.importcpp: "DCAST(TextGlyph, @)".}

type TextFont* {.importcpp: "PT(TextFont)", bycopy, pure, inheritable, header: "textFont.h".} = object of TypedReferenceCount
  ## An encapsulation of a font; i.e.  a set of glyphs that may be assembled
  ## together by a TextNode to represent a string of text.
  ##
  ## This is just an abstract interface; see StaticTextFont or DynamicTextFont
  ## for an actual implementation.

converter toTextFont*(_: type(nil)): TextFont {.importcpp: "(nullptr)".}
converter toBool*(this: TextFont): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TextFont, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[TextFont], obj: TypedObject): TextFont {.importcpp: "DCAST(TextFont, @)".}

type DynamicTextGlyph* {.importcpp: "PT(DynamicTextGlyph)", bycopy, pure, inheritable, header: "dynamicTextGlyph.h".} = object of TextGlyph
  ## A specialization on TextGlyph that is generated and stored by a
  ## DynamicTextFont.  This keeps some additional information, such as where the
  ## glyph appears on a texture map.

converter toDynamicTextGlyph*(_: type(nil)): DynamicTextGlyph {.importcpp: "(nullptr)".}
converter toBool*(this: DynamicTextGlyph): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DynamicTextGlyph, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DynamicTextGlyph], obj: TypedObject): DynamicTextGlyph {.importcpp: "DCAST(DynamicTextGlyph, @)".}

type DynamicTextPage* {.importcpp: "PT(DynamicTextPage)", bycopy, pure, inheritable, header: "dynamicTextPage.h".} = object of Texture
  ## A single "page" of a DynamicTextFont.  This is a single texture that holds
  ## a number of glyphs for rendering.  The font starts out with one page, and
  ## will add more as it needs them.

converter toDynamicTextPage*(_: type(nil)): DynamicTextPage {.importcpp: "(nullptr)".}
converter toBool*(this: DynamicTextPage): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DynamicTextPage, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DynamicTextPage], obj: TypedObject): DynamicTextPage {.importcpp: "DCAST(DynamicTextPage, @)".}

type FreetypeFont* {.importcpp: "FreetypeFont", pure, inheritable, header: "freetypeFont.h".} = object of Namable
  ## This is a common base class for both DynamicTextFont and PNMTextMaker.
  ## Both of these are utility classes that use the FreeType library to generate
  ## glyphs from fonts; this class abstracts out that common wrapper around
  ## FreeType.

type DynamicTextFont* {.importcpp: "PT(DynamicTextFont)", bycopy, pure, inheritable, header: "dynamicTextFont.h".} = object of TextFont
  ## A DynamicTextFont is a special TextFont object that rasterizes its glyphs
  ## from a standard font file (e.g.  a TTF file) on the fly.  It requires the
  ## FreeType 2.0 library (or any higher, backward-compatible version).

converter toDynamicTextFont*(_: type(nil)): DynamicTextFont {.importcpp: "(nullptr)".}
converter toBool*(this: DynamicTextFont): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DynamicTextFont, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DynamicTextFont], obj: TypedObject): DynamicTextFont {.importcpp: "DCAST(DynamicTextFont, @)".}

type FontPool* {.importcpp: "FontPool", pure, inheritable, header: "fontPool.h".} = object
  ## This is the preferred interface for loading fonts for the TextNode system.
  ## It is similar to ModelPool and TexturePool in that it unifies references to
  ## the same filename.

type GeomTextGlyph* {.importcpp: "PT(GeomTextGlyph)", bycopy, pure, inheritable, header: "geomTextGlyph.h".} = object of Geom
  ## This is a specialization on Geom for containing a primitive intended to
  ## represent a TextGlyph.  Its sole purpose is to maintain the geom count on
  ## the glyph, so we can determine the actual usage count on a dynamic glyph
  ## (and thus know when it is safe to recycle the glyph).

converter toGeomTextGlyph*(_: type(nil)): GeomTextGlyph {.importcpp: "(nullptr)".}
converter toBool*(this: GeomTextGlyph): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: GeomTextGlyph, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[GeomTextGlyph], obj: TypedObject): GeomTextGlyph {.importcpp: "DCAST(GeomTextGlyph, @)".}

type StaticTextFont* {.importcpp: "PT(StaticTextFont)", bycopy, pure, inheritable, header: "staticTextFont.h".} = object of TextFont
  ## A StaticTextFont is loaded up from a model that was previously generated
  ## via egg-mkfont, and contains all of its glyphs already generated and
  ## available for use.  It doesn't require linking with any external libraries
  ## like FreeType.

converter toStaticTextFont*(_: type(nil)): StaticTextFont {.importcpp: "(nullptr)".}
converter toBool*(this: StaticTextFont): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: StaticTextFont, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[StaticTextFont], obj: TypedObject): StaticTextFont {.importcpp: "DCAST(StaticTextFont, @)".}

type TextGraphic* {.importcpp: "TextGraphic", pure, inheritable, header: "textGraphic.h".} = object
  ## This defines a special model that has been constructed for the purposes of
  ## embedding an arbitrary graphic image within a text paragraph.
  ##
  ## It can be any arbitrary model, though it should be built along the same
  ## scale as the text, and it should probably be at least mostly two-
  ## dimensional.  Typically, this means it should be constructed in the X-Z
  ## plane, and it should have a maximum vertical (Z) height of 1.0.
  ##
  ## The frame specifies an arbitrary bounding volume in the form (left, right,
  ## bottom, top).  This indicates the amount of space that will be reserved
  ## within the paragraph.  The actual model is not actually required to fit
  ## within this rectangle, but if it does not, it may visually overlap with
  ## nearby text.

type TextPropertiesManager* {.importcpp: "TextPropertiesManager", pure, inheritable, header: "textPropertiesManager.h".} = object
  ## This defines all of the TextProperties structures that might be referenced
  ## by name from an embedded text string.
  ##
  ## A text string, as rendered by a TextNode, can contain embedded references
  ## to one of the TextProperties defined here, by enclosing the name between \1
  ## (ASCII 0x01) characters; this causes a "push" to the named state.  All text
  ## following the closing \1 character will then be rendered in the new state.
  ## The next \2 (ASCII 0x02) character will then restore the previous state for
  ## subsequent text.
  ##
  ## For instance, "x\1up\1n\2 + y" indicates that the character "x" will be
  ## rendered in the normal state, the character "n" will be rendered in the
  ## "up" state, and then " + y" will be rendered in the normal state again.
  ##
  ## This can also be used to define arbitrary models that can serve as embedded
  ## graphic images in a text paragraph.  This works similarly; the convention
  ## is to create a TextGraphic that describes the graphic image, and then
  ## associate it here via the set_graphic() call.  Then "\5name\5" will embed
  ## the named graphic.

type TextAssembler* {.importcpp: "TextAssembler", pure, inheritable, header: "textAssembler.h".} = object
  ## This class is not normally used directly by user code, but is used by the
  ## TextNode to lay out a block of text and convert it into rows of Geoms
  ## according to the TextProperties.  However, user code may take advantage of
  ## it, if desired, for very low-level text operations.

type ButtonThrower* {.importcpp: "PT(ButtonThrower)", bycopy, pure, inheritable, header: "buttonThrower.h".} = object of DataNode
  ## Throws Panda Events for button down/up events generated within the data
  ## graph.
  ##
  ## This is a DataNode which is intended to be parented to the data graph below
  ## a device which is generating a sequence of button events, like a
  ## MouseAndKeyboard device.  It simply takes each button it finds and throws a
  ## corresponding event based on the button name via the throw_event() call.

converter toButtonThrower*(_: type(nil)): ButtonThrower {.importcpp: "(nullptr)".}
converter toBool*(this: ButtonThrower): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ButtonThrower, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ButtonThrower], obj: TypedObject): ButtonThrower {.importcpp: "DCAST(ButtonThrower, @)".}

type MouseInterfaceNode* {.importcpp: "PT(MouseInterfaceNode)", bycopy, pure, inheritable, header: "mouseInterfaceNode.h".} = object of DataNode
  ## This is the base class for some classes that monitor the mouse and keyboard
  ## input and perform some action due to their state.
  ##
  ## It collects together some common interface; in particular, the
  ## require_button() and related methods.

converter toMouseInterfaceNode*(_: type(nil)): MouseInterfaceNode {.importcpp: "(nullptr)".}
converter toBool*(this: MouseInterfaceNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MouseInterfaceNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MouseInterfaceNode], obj: TypedObject): MouseInterfaceNode {.importcpp: "DCAST(MouseInterfaceNode, @)".}

type DriveInterface* {.importcpp: "PT(DriveInterface)", bycopy, pure, inheritable, header: "driveInterface.h".} = object of MouseInterfaceNode
  ## This is a TFormer, similar to Trackball, that moves around a transform
  ## matrix in response to mouse input.  The basic motion is on a horizontal
  ## plane, as if driving a vehicle.

converter toDriveInterface*(_: type(nil)): DriveInterface {.importcpp: "(nullptr)".}
converter toBool*(this: DriveInterface): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DriveInterface, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[DriveInterface], obj: TypedObject): DriveInterface {.importcpp: "DCAST(DriveInterface, @)".}

type MouseSubregion* {.importcpp: "PT(MouseSubregion)", bycopy, pure, inheritable, header: "mouseSubregion.h".} = object of MouseInterfaceNode
  ## The MouseSubregion object scales the mouse inputs from within a rectangular
  ## region of the screen, as if they were the full-screen inputs.
  ##
  ## If you choose your MouseSubregion coordinates to exactly match a
  ## DisplayRegion within your window, you end up with a virtual mouse within
  ## your DisplayRegion.

converter toMouseSubregion*(_: type(nil)): MouseSubregion {.importcpp: "(nullptr)".}
converter toBool*(this: MouseSubregion): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MouseSubregion, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MouseSubregion], obj: TypedObject): MouseSubregion {.importcpp: "DCAST(MouseSubregion, @)".}

type MouseWatcherRegion* {.importcpp: "PT(MouseWatcherRegion)", bycopy, pure, inheritable, header: "mouseWatcherRegion.h".} = object of TypedWritableReferenceCount
  ## This is the class that defines a rectangular region on the screen for the
  ## MouseWatcher.

converter toMouseWatcherRegion*(_: type(nil)): MouseWatcherRegion {.importcpp: "(nullptr)".}
converter toBool*(this: MouseWatcherRegion): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MouseWatcherRegion, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MouseWatcherRegion], obj: TypedObject): MouseWatcherRegion {.importcpp: "DCAST(MouseWatcherRegion, @)".}

type MouseWatcherBase* {.importcpp: "MouseWatcherBase*", bycopy, pure, inheritable, header: "mouseWatcherBase.h".} = object
  ## This represents a collection of MouseWatcherRegions that may be managed as
  ## a group.  This is the base class for both MouseWatcherGroup and
  ## MouseWatcher, and exists so that we don't have to make MouseWatcher inherit
  ## from ReferenceCount more than once.

converter toMouseWatcherBase*(_: type(nil)): MouseWatcherBase {.importcpp: "(nullptr)".}
converter toBool*(this: MouseWatcherBase): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MouseWatcherBase, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type MouseWatcherGroup* {.importcpp: "PT(MouseWatcherGroup)", bycopy, pure, inheritable, header: "mouseWatcherGroup.h".} = object of MouseWatcherBase
  ## This represents a collection of MouseWatcherRegions that may be managed as
  ## a group.  The implementation for this is in MouseWatcherBase; this class
  ## exists so that we can inherit from ReferenceCount.

converter toMouseWatcherGroup*(_: type(nil)): MouseWatcherGroup {.importcpp: "(nullptr)".}
converter toBool*(this: MouseWatcherGroup): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MouseWatcherGroup, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MouseWatcherGroup], obj: TypedObject): MouseWatcherGroup {.importcpp: "DCAST(MouseWatcherGroup, @)".}

type MouseWatcher* {.importcpp: "PT(MouseWatcher)", bycopy, pure, inheritable, header: "mouseWatcher.h".} = object of DataNode
  ## This TFormer maintains a list of rectangular regions on the screen that are
  ## considered special mouse regions; typically these will be click buttons.
  ## When the mouse passes in or out of one of these regions, or when a button
  ## is clicked while the mouse is in one of these regions, an event is thrown.
  ##
  ## Mouse events may also be suppressed from the rest of the datagraph in these
  ## special regions.
  ##
  ## This class can also implement a software mouse pointer by automatically
  ## generating a transform to apply to a piece of geometry placed under the 2-d
  ## scene graph.  It will move the geometry around according to the mouse's
  ## known position.
  ##
  ## Finally, this class can keep a record of the mouse trail.  This is useful
  ## if you want to know, not just where the mouse is, but the exact sequence of
  ## movements it took to get there.  This information is mainly useful for
  ## gesture-recognition code.  To use trail logging, you need to enable the
  ## generation of pointer events in the GraphicsWindowInputDevice and set the
  ## trail log duration in the MouseWatcher.  Otherwise, the trail log will be
  ## empty.

converter toMouseWatcher*(_: type(nil)): MouseWatcher {.importcpp: "(nullptr)".}
converter toBool*(this: MouseWatcher): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: MouseWatcher, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[MouseWatcher], obj: TypedObject): MouseWatcher {.importcpp: "DCAST(MouseWatcher, @)".}

type MouseWatcherParameter* {.importcpp: "MouseWatcherParameter", pure, inheritable, header: "mouseWatcherParameter.h".} = object
  ## This is sent along as a parameter to most events generated for a region to
  ## indicate the mouse and button state for the event.

type Trackball* {.importcpp: "PT(Trackball)", bycopy, pure, inheritable, header: "trackball.h".} = object of MouseInterfaceNode
  ## Trackball acts like Performer in trackball mode.  It can either spin around
  ## a piece of geometry directly, or it can spin around a camera with the
  ## inverse transform to make it appear that the whole world is spinning.
  ##
  ## The Trackball object actually just places a transform in the data graph;
  ## parent a Transform2SG node under it to actually transform objects (or
  ## cameras) in the world.

converter toTrackball*(_: type(nil)): Trackball {.importcpp: "(nullptr)".}
converter toBool*(this: Trackball): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Trackball, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Trackball], obj: TypedObject): Trackball {.importcpp: "DCAST(Trackball, @)".}

type Transform2SG* {.importcpp: "PT(Transform2SG)", bycopy, pure, inheritable, header: "transform2sg.h".} = object of DataNode
  ## input: Transform (matrix)
  ##
  ## output: none, but applies the matrix as the transform transition for a
  ## given arc of the scene graph.

converter toTransform2SG*(_: type(nil)): Transform2SG {.importcpp: "(nullptr)".}
converter toBool*(this: Transform2SG): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Transform2SG, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Transform2SG], obj: TypedObject): Transform2SG {.importcpp: "DCAST(Transform2SG, @)".}

type AutoTextureScale* = enum
  ATS_none = 0
  ATS_down = 1
  ATS_up = 2
  ATS_pad = 3
  ATS_unspecified = 4

type UpdateSeq* {.importcpp: "UpdateSeq", pure, inheritable, header: "updateSeq.h".} = object
  ## This is a sequence number that increments monotonically.  It can be used to
  ## track cache updates, or serve as a kind of timestamp for any changing
  ## properties.
  ##
  ## A special class is used instead of simply an int, so we can elegantly
  ## handle such things as wraparound and special cases.  There are two special
  ## cases.  Firstly, a sequence number is 'initial' when it is first created.
  ## This sequence is older than any other sequence number.  Secondly, a
  ## sequence number may be explicitly set to 'old'.  This is older than any
  ## other sequence number except 'initial'.  Finally, we have the explicit
  ## number 'fresh', which is newer than any other sequence number.  All other
  ## sequences are numeric and are monotonically increasing.

type BamCacheRecord* {.importcpp: "PT(BamCacheRecord)", bycopy, pure, inheritable, header: "bamCacheRecord.h".} = object of TypedWritableReferenceCount
  ## An instance of this class is written to the front of a Bam or Txo file to
  ## make the file a cached instance of some other loadable resource.  This
  ## record contains information needed to test the validity of the cache.

converter toBamCacheRecord*(_: type(nil)): BamCacheRecord {.importcpp: "(nullptr)".}
converter toBool*(this: BamCacheRecord): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: BamCacheRecord, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[BamCacheRecord], obj: TypedObject): BamCacheRecord {.importcpp: "DCAST(BamCacheRecord, @)".}

type BamCache* {.importcpp: "BamCache", pure, inheritable, header: "bamCache.h".} = object
  ## This class maintains a cache of Bam and/or Txo objects generated from model
  ## files and texture images (as well as possibly other kinds of loadable
  ## objects that can be stored in bam file format).
  ##
  ## This class also maintains a persistent index that lists all of the cached
  ## objects (see BamCacheIndex). We go through some considerable effort to make
  ## sure this index gets saved correctly to disk, even in the presence of
  ## multiple different processes writing to the same index, and without relying
  ## too heavily on low-level os-provided file locks (which work poorly with C++
  ## iostreams).

type LoaderOptions* {.importcpp: "LoaderOptions", pure, inheritable, header: "loaderOptions.h".} = object
  ## Specifies parameters that may be passed to the loader.

type BamReader* {.importcpp: "BamReader", pure, inheritable, header: "bamReader.h".} = object of BamEnums
  ## This is the fundamental interface for extracting binary objects from a Bam
  ## file, as generated by a BamWriter.
  ##
  ## A Bam file can be thought of as a linear collection of objects.  Each
  ## object is an instance of a class that inherits, directly or indirectly,
  ## from TypedWritable.  The objects may include pointers to other objects
  ## within the Bam file; the BamReader automatically manages these (with help
  ## from code within each class) and restores the pointers correctly.
  ##
  ## This is the abstract interface and does not specifically deal with disk
  ## files, but rather with a DatagramGenerator of some kind, which is simply a
  ## linear source of Datagrams.  It is probably from a disk file, but it might
  ## conceivably be streamed directly from a network or some such nonsense.
  ##
  ## Bam files are most often used to store scene graphs or subgraphs, and by
  ## convention they are given filenames ending in the extension ".bam" when
  ## they are used for this purpose.  However, a Bam file may store any
  ## arbitrary list of TypedWritable objects; in this more general usage, they
  ## are given filenames ending in ".boo" to differentiate them from the more
  ## common scene graph files.
  ##
  ## See also BamFile, which defines a higher-level interface to read and write
  ## Bam files on disk.

type BamWriter* {.importcpp: "BamWriter", pure, inheritable, header: "bamWriter.h".} = object of BamEnums
  ## This is the fundamental interface for writing binary objects to a Bam file,
  ## to be extracted later by a BamReader.
  ##
  ## A Bam file can be thought of as a linear collection of objects.  Each
  ## object is an instance of a class that inherits, directly or indirectly,
  ## from TypedWritable.  The objects may include pointers to other objects; the
  ## BamWriter automatically manages these (with help from code within each
  ## class) and writes all referenced objects to the file in such a way that the
  ## pointers may be correctly restored later.
  ##
  ## This is the abstract interface and does not specifically deal with disk
  ## files, but rather with a DatagramSink of some kind, which simply accepts a
  ## linear stream of Datagrams.  It is probably written to a disk file, but it
  ## might conceivably be streamed directly to a network or some such nonsense.
  ##
  ## Bam files are most often used to store scene graphs or subgraphs, and by
  ## convention they are given filenames ending in the extension ".bam" when
  ## they are used for this purpose.  However, a Bam file may store any
  ## arbitrary list of TypedWritable objects; in this more general usage, they
  ## are given filenames ending in ".boo" to differentiate them from the more
  ## common scene graph files.
  ##
  ## See also BamFile, which defines a higher-level interface to read and write
  ## Bam files on disk.

type BitMask*[T: typedesc, U: static[int]] {.importcpp: "BitMask<'0, '1>", pure, inheritable, header: "bitMask.h".} = object

type BitMask16* = BitMask[uint16, 16]

type BitMask32* = BitMask[uint32, 32]

type BitMask64* = BitMask[uint64, 64]

type BitMaskNative* {.importcpp: "BitMaskNative", pure, inheritable, header: "bitMask.h".} = object

type BitArray* {.importcpp: "BitArray", pure, inheritable, header: "bitArray.h".} = object
  ## A dynamic array with an unlimited number of bits.
  ##
  ## This is similar to a BitMask, except it appears to contain an infinite
  ## number of bits.  You can use it very much as you would use a BitMask.

type ButtonHandle* {.importcpp: "ButtonHandle", pure, header: "buttonHandle.h".} = object
  ## A ButtonHandle represents a single button from any device, including
  ## keyboard buttons and mouse buttons (but see KeyboardButton and
  ## MouseButton).

type ButtonRegistry* {.importcpp: "ButtonRegistry", pure, inheritable, header: "buttonRegistry.h".} = object
  ## The ButtonRegistry class maintains all the assigned ButtonHandles in a
  ## given system.  There should be only one ButtonRegistry class during the
  ## lifetime of the application.

type ButtonMap* {.importcpp: "PT(ButtonMap)", bycopy, pure, inheritable, header: "buttonMap.h".} = object of TypedReferenceCount
  ## This class represents a map containing all of the buttons of a (keyboard)
  ## device, though it can also be used as a generic mapping between
  ## ButtonHandles.  It maps an underlying 'raw' button to a 'virtual' button,
  ## which may optionally be associated with an appropriate platform-specific
  ## name for the button.

converter toButtonMap*(_: type(nil)): ButtonMap {.importcpp: "(nullptr)".}
converter toBool*(this: ButtonMap): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ButtonMap, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ButtonMap], obj: TypedObject): ButtonMap {.importcpp: "DCAST(ButtonMap, @)".}

type CallbackObject* {.importcpp: "PT(CallbackObject)", bycopy, pure, inheritable, header: "callbackObject.h".} = object of TypedReferenceCount
  ## This is a generic object that can be assigned to a callback at various
  ## points in the rendering process.  This is actually a base class for a
  ## handful of specialized callback object types.  You can also subclass it
  ## yourself to make your own callback handler.

converter toCallbackObject*(_: type(nil)): CallbackObject {.importcpp: "(nullptr)".}
converter toBool*(this: CallbackObject): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: CallbackObject, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[CallbackObject], obj: TypedObject): CallbackObject {.importcpp: "DCAST(CallbackObject, @)".}

type PythonCallbackObject* {.importcpp: "PT(PythonCallbackObject)", bycopy, pure, inheritable, header: "pythonCallbackObject.h".} = object of CallbackObject
  ## This is a specialization on CallbackObject to allow a callback to directly
  ## call an arbitrary Python function.  Powerful!  But use with caution.

converter toPythonCallbackObject*(_: type(nil)): PythonCallbackObject {.importcpp: "(nullptr)".}
converter toBool*(this: PythonCallbackObject): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PythonCallbackObject, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PythonCallbackObject], obj: TypedObject): PythonCallbackObject {.importcpp: "DCAST(PythonCallbackObject, @)".}

type TimeVal* {.importcpp: "TimeVal", pure, inheritable, header: "clockObject.h".} = object

type ClockObject* {.importcpp: "PT(ClockObject)", bycopy, pure, inheritable, header: "clockObject.h".} = object of ReferenceCount
  ## A ClockObject keeps track of elapsed real time and discrete time.  In
  ## normal mode, get_frame_time() returns the time as of the last time tick()
  ## was called.  This is the "discrete" time, and is usually used to get the
  ## time as of, for instance, the beginning of the current frame.
  ##
  ## In other modes, as set by set_mode() or the clock-mode config variable,
  ## get_frame_time() may return other values to simulate different timing
  ## effects, for instance to perform non-real-time animation.  See set_mode().
  ##
  ## In all modes, get_real_time() always returns the elapsed real time in
  ## seconds since the ClockObject was constructed, or since it was last reset.
  ##
  ## You can create your own ClockObject whenever you want to have your own
  ## local timer.  There is also a default, global ClockObject intended to
  ## represent global time for the application; this is normally set up to tick
  ## every frame so that its get_frame_time() will return the time for the
  ## current frame.

converter toClockObject*(_: type(nil)): ClockObject {.importcpp: "(nullptr)".}
converter toBool*(this: ClockObject): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ClockObject, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ClockObject], obj: TypedObject): ClockObject {.importcpp: "DCAST(ClockObject, @)".}

type CollideMask* = BitMask32

type ColorSpace* = enum
  CS_unspecified = 0
  CS_linear = 1
  CS_sRGB = 2
  CS_scRGB = 3

type DatagramBuffer* {.importcpp: "DatagramBuffer", pure, inheritable, header: "datagramBuffer.h".} = object of DatagramSink
  ## This class can be used to write a series of datagrams into a memory buffer.
  ## It acts as both a datagram sink and generator; you can fill it up with
  ## datagrams and then read as many datagrams from it.
  ##
  ## This uses the same format as DatagramInputFile and DatagramOutputFile,
  ## meaning that Datagram sizes are always stored little-endian.

type DatagramInputFile* {.importcpp: "DatagramInputFile", pure, inheritable, header: "datagramInputFile.h".} = object of DatagramGenerator
  ## This class can be used to read a binary file that consists of an arbitrary
  ## header followed by a number of datagrams.

type DatagramOutputFile* {.importcpp: "DatagramOutputFile", pure, inheritable, header: "datagramOutputFile.h".} = object of DatagramSink
  ## This class can be used to write a binary file that consists of an arbitrary
  ## header followed by a number of datagrams.

type DrawMask* = BitMask32

type GamepadButton* {.importcpp: "GamepadButton", pure, inheritable, header: "gamepadButton.h".} = object
  ## This class is just used as a convenient namespace for grouping all of these
  ## handy functions that return buttons which map to gamepad buttons.

type KeyboardButton* {.importcpp: "KeyboardButton", pure, inheritable, header: "keyboardButton.h".} = object
  ## This class is just used as a convenient namespace for grouping all of these
  ## handy functions that return buttons which map to standard keyboard keys.

type ModifierButtons* {.importcpp: "ModifierButtons", pure, inheritable, header: "modifierButtons.h".} = object
  ## This class monitors the state of a number of individual buttons and tracks
  ## whether each button is known to be down or up.

type MouseButton* {.importcpp: "MouseButton", pure, inheritable, header: "mouseButton.h".} = object
  ## This class is just used as a convenient namespace for grouping all of these
  ## handy functions that return buttons which map to standard mouse buttons.

type PointerType* {.pure.} = enum
  ## Contains the types of pointer device.
  unknown = 0
  mouse = 1
  finger = 2
  stylus = 3
  eraser = 4

type PointerData* {.importcpp: "PointerData", pure, inheritable, header: "pointerData.h".} = object
  ## Holds the data that might be generated by a 2-d pointer input device, such
  ## as the mouse in the GraphicsWindow.

type MouseData* = PointerData

type SparseArray* {.importcpp: "SparseArray", pure, inheritable, header: "sparseArray.h".} = object
  ## This class records a set of integers, where each integer is either present
  ## or not present in the set.
  ##
  ## It is similar in principle and in interface to a BitArray (which can be
  ## thought of as a set of integers, one integer corresponding to each
  ## different bit position), but the SparseArray is implemented as a list of
  ## min/max subrange lists, rather than as a bitmask.
  ##
  ## This makes it particularly efficient for storing sets which consist of
  ## large sections of consecutively included or consecutively excluded
  ## elements, with arbitrarily large integers, but particularly inefficient for
  ## doing boolean operations such as & or \|.
  ##
  ## Also, unlike BitArray, the SparseArray can store negative integers.

type ParamTypedRefCount* {.importcpp: "PT(ParamTypedRefCount)", bycopy, pure, inheritable, header: "paramValue.h".} = object of ParamValueBase
  ## A class object for storing specifically objects of type
  ## TypedReferenceCount, which is different than TypedWritableReferenceCount.

converter toParamTypedRefCount*(_: type(nil)): ParamTypedRefCount {.importcpp: "(nullptr)".}
converter toBool*(this: ParamTypedRefCount): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ParamTypedRefCount, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[ParamTypedRefCount], obj: TypedObject): ParamTypedRefCount {.importcpp: "DCAST(ParamTypedRefCount, @)".}

type WritableConfigurable* {.importcpp: "WritableConfigurable", pure, inheritable, header: "writableConfigurable.h".} = object of TypedWritable
  ## Defined as a fix to allow creating Configurable and Writable objects.
  ## Otherwise the compiler gets confused since both TypedWritable and
  ## Configurable inherit from TypedObject.
  ##
  ## An object that has data or parameters that are set less frequently (at
  ## least occasionally) than every frame.  We can cache the configuration info
  ## by by using the "dirty" flag.

type UniqueIdAllocator* {.importcpp: "UniqueIdAllocator", pure, inheritable, header: "uniqueIdAllocator.h".} = object
  ## Manage a set of ID values from min to max inclusive.  The ID numbers that
  ## are freed will be allocated (reused) in the same order.  I.e.  the oldest
  ## ID numbers will be allocated.
  ##
  ## This implementation will use 4 bytes per id number, plus a few bytes of
  ## management data.  e.g.  10,000 ID numbers will use 40KB.
  ##
  ## Also be advised that ID -1 and -2 are used internally by the allocator.  If
  ## allocate returns IndexEnd (-1) then the allocator is out of free ID
  ## numbers.
  ##
  ## There are other implementations that can better leverage runs of used or
  ## unused IDs or use bit arrays for the IDs.  But, it takes extra work to
  ## track the age of freed IDs, which is required for what we wanted.  If you
  ## would like to kick around other implementation ideas, please contact
  ## Schuyler.

type PortalMask* = BitMask32

type FilterProperties* {.importcpp: "PT(FilterProperties)", bycopy, pure, inheritable, header: "filterProperties.h".} = object of TypedReferenceCount

converter toFilterProperties*(_: type(nil)): FilterProperties {.importcpp: "(nullptr)".}
converter toBool*(this: FilterProperties): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: FilterProperties, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[FilterProperties], obj: TypedObject): FilterProperties {.importcpp: "DCAST(FilterProperties, @)".}

type AudioSound* {.importcpp: "PT(AudioSound)", bycopy, pure, inheritable, header: "audioSound.h".} = object of TypedReferenceCount

converter toAudioSound*(_: type(nil)): AudioSound {.importcpp: "(nullptr)".}
converter toBool*(this: AudioSound): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AudioSound, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AudioSound], obj: TypedObject): AudioSound {.importcpp: "DCAST(AudioSound, @)".}

type AudioManager* {.importcpp: "PT(AudioManager)", bycopy, pure, inheritable, header: "audioManager.h".} = object of TypedReferenceCount

converter toAudioManager*(_: type(nil)): AudioManager {.importcpp: "(nullptr)".}
converter toBool*(this: AudioManager): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AudioManager, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AudioManager], obj: TypedObject): AudioManager {.importcpp: "DCAST(AudioManager, @)".}

type AudioLoadRequest* {.importcpp: "PT(AudioLoadRequest)", bycopy, pure, inheritable, header: "audioLoadRequest.h".} = object of AsyncTask
  ## A class object that manages a single asynchronous audio load request.  This
  ## works in conjunction with the Loader class defined in pgraph, or really
  ## with any AsyncTaskManager.  Create a new AudioLoadRequest, and add it to
  ## the loader via load_async(), to begin an asynchronous load.

converter toAudioLoadRequest*(_: type(nil)): AudioLoadRequest {.importcpp: "(nullptr)".}
converter toBool*(this: AudioLoadRequest): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: AudioLoadRequest, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[AudioLoadRequest], obj: TypedObject): AudioLoadRequest {.importcpp: "DCAST(AudioLoadRequest, @)".}

type PGFrameStyle* {.importcpp: "PGFrameStyle", pure, inheritable, header: "pgFrameStyle.h".} = object

type PGItem* {.importcpp: "PT(PGItem)", bycopy, pure, inheritable, header: "pgItem.h".} = object of PandaNode
  ## This is the base class for all the various kinds of gui widget objects.
  ##
  ## It is a Node which corresponds to a rectangular region on the screen, and
  ## it may have any number of "state" subgraphs, one of which is rendered at
  ## any given time according to its current state.
  ##
  ## The PGItem node must be parented to the scene graph somewhere beneath a
  ## PGTop node in order for this behavior to work.

converter toPGItem*(_: type(nil)): PGItem {.importcpp: "(nullptr)".}
converter toBool*(this: PGItem): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PGItem, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PGItem], obj: TypedObject): PGItem {.importcpp: "DCAST(PGItem, @)".}

type PGButton* {.importcpp: "PT(PGButton)", bycopy, pure, inheritable, header: "pgButton.h".} = object of PGItem
  ## This is a particular kind of PGItem that is specialized to behave like a
  ## normal button object.  It keeps track of its own state, and handles mouse
  ## events sensibly.

converter toPGButton*(_: type(nil)): PGButton {.importcpp: "(nullptr)".}
converter toBool*(this: PGButton): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PGButton, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PGButton], obj: TypedObject): PGButton {.importcpp: "DCAST(PGButton, @)".}

type PGTop* {.importcpp: "PT(PGTop)", bycopy, pure, inheritable, header: "pgTop.h".} = object of PandaNode
  ## The "top" node of the new Panda GUI system.  This node must be parented to
  ## the 2-d scene graph, and all PG objects should be parented to this node or
  ## somewhere below it.  PG objects not parented within this hierarchy will not
  ## be clickable.
  ##
  ## This node begins the special traversal of the PG objects that registers
  ## each node within the MouseWatcher and forces everything to render in a
  ## depth-first, left-to-right order, appropriate for 2-d objects.

converter toPGTop*(_: type(nil)): PGTop {.importcpp: "(nullptr)".}
converter toBool*(this: PGTop): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PGTop, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PGTop], obj: TypedObject): PGTop {.importcpp: "DCAST(PGTop, @)".}

type PGEntry* {.importcpp: "PT(PGEntry)", bycopy, pure, inheritable, header: "pgEntry.h".} = object of PGItem
  ## This is a particular kind of PGItem that handles simple one-line or short
  ## multi-line text entries, of the sort where the user can type any string.
  ##
  ## A PGEntry does all of its internal manipulation on a wide string, so it can
  ## store the full Unicode character set.  The interface can support either the
  ## wide string getters and setters, or the normal 8-bit string getters and
  ## setters, which use whatever encoding method is specified by the associated
  ## TextNode.

converter toPGEntry*(_: type(nil)): PGEntry {.importcpp: "(nullptr)".}
converter toBool*(this: PGEntry): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PGEntry, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PGEntry], obj: TypedObject): PGEntry {.importcpp: "DCAST(PGEntry, @)".}

type PGMouseWatcherParameter* {.importcpp: "PT(PGMouseWatcherParameter)", bycopy, pure, inheritable, header: "pgMouseWatcherParameter.h".} = object of TypedWritableReferenceCount
  ## This specialization on MouseWatcherParameter allows us to tag on additional
  ## elements to events for the gui system, and also inherits from
  ## TypedWritableReferenceCount so we can attach this thing to an event.

converter toPGMouseWatcherParameter*(_: type(nil)): PGMouseWatcherParameter {.importcpp: "(nullptr)".}
converter toBool*(this: PGMouseWatcherParameter): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PGMouseWatcherParameter, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PGMouseWatcherParameter], obj: TypedObject): PGMouseWatcherParameter {.importcpp: "DCAST(PGMouseWatcherParameter, @)".}

type PGMouseWatcherBackground* {.importcpp: "PT(PGMouseWatcherBackground)", bycopy, pure, inheritable, header: "pgMouseWatcherBackground.h".} = object of MouseWatcherRegion
  ## This is a special kind of MouseWatcherRegion that doesn't have a rectangle
  ## and is never active, but just quietly listens for keypresses and sends them
  ## to all the PGItems with background focus.

converter toPGMouseWatcherBackground*(_: type(nil)): PGMouseWatcherBackground {.importcpp: "(nullptr)".}
converter toBool*(this: PGMouseWatcherBackground): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PGMouseWatcherBackground, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PGMouseWatcherBackground], obj: TypedObject): PGMouseWatcherBackground {.importcpp: "DCAST(PGMouseWatcherBackground, @)".}

type PGVirtualFrame* {.importcpp: "PT(PGVirtualFrame)", bycopy, pure, inheritable, header: "pgVirtualFrame.h".} = object of PGItem
  ## This represents a frame that is rendered as a window onto another (possibly
  ## much larger) canvas.  You can only see the portion of the canvas that is
  ## below the window at any given time.
  ##
  ## This works simply by automatically defining a scissor effect to be applied
  ## to a special child node, called the canvas_node, of the PGVirtualFrame
  ## node.  Every object that is parented to the canvas_node will be clipped by
  ## the scissor effect.  Also, you can modify the canvas_transform through
  ## convenience methods here, which actually modifies the transform on the
  ## canvas_node.
  ##
  ## The net effect is that the virtual canvas is arbitrarily large, and we can
  ## peek at it through the scissor region, and scroll through different parts
  ## of it by modifying the canvas_transform.
  ##
  ## See PGScrollFrame for a specialization of this class that handles the
  ## traditional scrolling canvas, with scroll bars.

converter toPGVirtualFrame*(_: type(nil)): PGVirtualFrame {.importcpp: "(nullptr)".}
converter toBool*(this: PGVirtualFrame): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PGVirtualFrame, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PGVirtualFrame], obj: TypedObject): PGVirtualFrame {.importcpp: "DCAST(PGVirtualFrame, @)".}

type PGSliderBar* {.importcpp: "PT(PGSliderBar)", bycopy, pure, inheritable, header: "pgSliderBar.h".} = object of PGItem
  ## This is a particular kind of PGItem that draws a little bar with a slider
  ## that moves from left to right indicating a value between the ranges.
  ##
  ## This is used as an implementation for both DirectSlider and for
  ## DirectScrollBar.

converter toPGSliderBar*(_: type(nil)): PGSliderBar {.importcpp: "(nullptr)".}
converter toBool*(this: PGSliderBar): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PGSliderBar, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PGSliderBar], obj: TypedObject): PGSliderBar {.importcpp: "DCAST(PGSliderBar, @)".}

type PGScrollFrame* {.importcpp: "PT(PGScrollFrame)", bycopy, pure, inheritable, header: "pgScrollFrame.h".} = object of PGVirtualFrame
  ## This is a special kind of frame that pretends to be much larger than it
  ## actually is.  You can scroll through the frame, as if you're looking
  ## through a window at the larger frame beneath.  All children of this frame
  ## node are scrolled and clipped as if they were children of the larger,
  ## virtual frame.
  ##
  ## This is implemented as a specialization of PGVirtualFrame, which handles
  ## the meat of the virtual canvas.  This class adds automatic support for
  ## scroll bars, and restricts the virtual transform to translate only (no
  ## scale or rotate).

converter toPGScrollFrame*(_: type(nil)): PGScrollFrame {.importcpp: "(nullptr)".}
converter toBool*(this: PGScrollFrame): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PGScrollFrame, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PGScrollFrame], obj: TypedObject): PGScrollFrame {.importcpp: "DCAST(PGScrollFrame, @)".}

type PGWaitBar* {.importcpp: "PT(PGWaitBar)", bycopy, pure, inheritable, header: "pgWaitBar.h".} = object of PGItem
  ## This is a particular kind of PGItem that draws a little bar that fills from
  ## left to right to indicate a slow process gradually completing, like a
  ## traditional "wait, loading" bar.

converter toPGWaitBar*(_: type(nil)): PGWaitBar {.importcpp: "(nullptr)".}
converter toBool*(this: PGWaitBar): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: PGWaitBar, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[PGWaitBar], obj: TypedObject): PGWaitBar {.importcpp: "DCAST(PGWaitBar, @)".}

type NetAddress* {.importcpp: "NetAddress", pure, inheritable, header: "netAddress.h".} = object
  ## Represents a network address to which UDP packets may be sent or to which a
  ## TCP socket may be bound.

type Connection* {.importcpp: "PT(Connection)", bycopy, pure, inheritable, header: "connection.h".} = object of ReferenceCount
  ## Represents a single TCP or UDP socket for input or output.

converter toConnection*(_: type(nil)): Connection {.importcpp: "(nullptr)".}
converter toBool*(this: Connection): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Connection, y: type(nil)): bool {.importcpp: "(# == nullptr)".}
func dcast*(_: typedesc[Connection], obj: TypedObject): Connection {.importcpp: "DCAST(Connection, @)".}

type ConnectionReader* {.importcpp: "ConnectionReader*", bycopy, pure, inheritable, header: "connectionReader.h".} = object
  ## This is an abstract base class for a family of classes that listen for
  ## activity on a socket and respond to it, for instance by reading a datagram
  ## and serving it (or queueing it up for later service).
  ##
  ## A ConnectionReader may define an arbitrary number of threads (at least one)
  ## to process datagrams coming in from an arbitrary number of sockets that it
  ## is monitoring.  The number of threads is specified at construction time and
  ## cannot be changed, but the set of sockets that is to be monitored may be
  ## constantly modified at will.
  ##
  ## This is an abstract class because it doesn't define how to process each
  ## received datagram.  See QueuedConnectionReader.  Also note that
  ## ConnectionListener derives from this class, extending it to accept
  ## connections on a rendezvous socket rather than read datagrams.

converter toConnectionReader*(_: type(nil)): ConnectionReader {.importcpp: "(nullptr)".}
converter toBool*(this: ConnectionReader): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ConnectionReader, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type ConnectionListener* {.importcpp: "ConnectionListener*", bycopy, pure, inheritable, header: "connectionListener.h".} = object of ConnectionReader
  ## This is a special kind of ConnectionReader that waits for activity on a
  ## rendezvous port and accepts a TCP connection (instead of attempting to read
  ## a datagram from the rendezvous port).
  ##
  ## It is itself an abstract class, as it doesn't define what to do with the
  ## established connection.  See QueuedConnectionListener.

converter toConnectionListener*(_: type(nil)): ConnectionListener {.importcpp: "(nullptr)".}
converter toBool*(this: ConnectionListener): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ConnectionListener, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type NetDatagram* {.importcpp: "NetDatagram", pure, inheritable, header: "netDatagram.h".} = object of Datagram
  ## A specific kind of Datagram, especially for sending across or receiving
  ## from a network.  It's different only in that it knows which Connection
  ## and/or NetAddress it is to be sent to or was received from.

type ConnectionManager* {.importcpp: "ConnectionManager*", bycopy, pure, inheritable, header: "connectionManager.h".} = object
  ## The primary interface to the low-level networking layer in this package.  A
  ## ConnectionManager is used to establish and destroy TCP and UDP connections.
  ## Communication on these connections, once established, is handled via
  ## ConnectionReader, ConnectionWriter, and ConnectionListener.
  ##
  ## You may use this class directly if you don't care about tracking which
  ## connections have been unexpectedly closed; otherwise, you should use
  ## QueuedConnectionManager to get reports about these events (or derive your
  ## own class to handle these events properly).

converter toConnectionManager*(_: type(nil)): ConnectionManager {.importcpp: "(nullptr)".}
converter toBool*(this: ConnectionManager): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: ConnectionManager, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type ConnectionWriter* {.importcpp: "ConnectionWriter", pure, inheritable, header: "connectionWriter.h".} = object
  ## This class handles threaded delivery of datagrams to various TCP or UDP
  ## sockets.
  ##
  ## A ConnectionWriter may define an arbitrary number of threads (0 or more) to
  ## write its datagrams to sockets.  The number of threads is specified at
  ## construction time and cannot be changed.

type DatagramGeneratorNet* {.importcpp: "DatagramGeneratorNet*", bycopy, pure, inheritable, header: "datagramGeneratorNet.h".} = object of DatagramGenerator
  ## This class provides datagrams one-at-a-time as read directly from the net,
  ## via a TCP connection.  If a datagram is not available, get_datagram() will
  ## block until one is.

converter toDatagramGeneratorNet*(_: type(nil)): DatagramGeneratorNet {.importcpp: "(nullptr)".}
converter toBool*(this: DatagramGeneratorNet): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: DatagramGeneratorNet, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type DatagramSinkNet* {.importcpp: "DatagramSinkNet", pure, inheritable, header: "datagramSinkNet.h".} = object of DatagramSink
  ## This class accepts datagrams one-at-a-time and sends them over the net, via
  ## a TCP connection.

type QueuedConnectionListener* {.importcpp: "QueuedConnectionListener*", bycopy, pure, inheritable, header: "queuedConnectionListener.h".} = object of ConnectionListener
  ## This flavor of ConnectionListener will queue up all of the TCP connections
  ## it established for later detection by the client code.

converter toQueuedConnectionListener*(_: type(nil)): QueuedConnectionListener {.importcpp: "(nullptr)".}
converter toBool*(this: QueuedConnectionListener): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: QueuedConnectionListener, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type QueuedConnectionManager* {.importcpp: "QueuedConnectionManager*", bycopy, pure, inheritable, header: "queuedConnectionManager.h".} = object of ConnectionManager
  ## This flavor of ConnectionManager will queue up all of the reset-connection
  ## messages from the ConnectionReaders and ConnectionWriters and report them
  ## to the client on demand.
  ##
  ## When a reset connection has been discovered via
  ## reset_connection_available()/get_reset_connection(), it is still the
  ## responsibility of the client to call close_connection() on that connection
  ## to free up its resources.

converter toQueuedConnectionManager*(_: type(nil)): QueuedConnectionManager {.importcpp: "(nullptr)".}
converter toBool*(this: QueuedConnectionManager): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: QueuedConnectionManager, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type QueuedConnectionReader* {.importcpp: "QueuedConnectionReader*", bycopy, pure, inheritable, header: "queuedConnectionReader.h".} = object of ConnectionReader
  ## This flavor of ConnectionReader will read from its sockets and queue up all
  ## of the datagrams read for later receipt by the client code.  This class is
  ## useful for client code that doesn't want to deal with threading and is
  ## willing to poll for datagrams at its convenience.

converter toQueuedConnectionReader*(_: type(nil)): QueuedConnectionReader {.importcpp: "(nullptr)".}
converter toBool*(this: QueuedConnectionReader): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: QueuedConnectionReader, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type RecentConnectionReader* {.importcpp: "RecentConnectionReader*", bycopy, pure, inheritable, header: "recentConnectionReader.h".} = object of ConnectionReader
  ## This flavor of ConnectionReader will read from its sockets and retain only
  ## the single most recent datagram for inspection by client code.  It's useful
  ## particularly for reading telemetry-type data from UDP sockets where you
  ## don't care about getting every last socket, and in fact if the sockets are
  ## coming too fast you'd prefer to skip some of them.
  ##
  ## This class will always create one thread for itself.

converter toRecentConnectionReader*(_: type(nil)): RecentConnectionReader {.importcpp: "(nullptr)".}
converter toBool*(this: RecentConnectionReader): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: RecentConnectionReader, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type Socket_Address* {.importcpp: "Socket_Address*", bycopy, pure, inheritable, header: "socket_Address.h".} = object
  ## A simple place to store and manipulate tcp and port address for
  ## communication layer

converter toSocket_Address*(_: type(nil)): Socket_Address {.importcpp: "(nullptr)".}
converter toBool*(this: Socket_Address): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: Socket_Address, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type Socket_IP* {.importcpp: "Socket_IP", pure, inheritable, header: "socket_ip.h".} = object of TypedObject
  ## Base functionality for a INET domain Socket This call should be the
  ## starting point for all other unix domain sockets.
  ##
  ## SocketIP \|
  ## ------------------------------------------------------------------- \|
  ## \|                       \|                           \| SocketTCP
  ## SocketTCP_Listen    SocketUDP_Incoming   SocketUDP_OutBound

type Socket_TCP* {.importcpp: "Socket_TCP", pure, inheritable, header: "socket_tcp.h".} = object of Socket_IP
  ## Base functionality for a TCP connected socket This class is pretty useless
  ## by itself but it does hide some of the platform differences from machine to
  ## machine

type Socket_TCP_Listen* {.importcpp: "Socket_TCP_Listen", pure, inheritable, header: "socket_tcp_listen.h".} = object of Socket_IP
  ## Base functionality for a TCP rendezvous socket

type Socket_UDP_Incoming* {.importcpp: "Socket_UDP_Incoming", pure, inheritable, header: "socket_udp_incoming.h".} = object of Socket_IP
  ## Base functionality for a UDP Reader

type Socket_UDP_Outgoing* {.importcpp: "Socket_UDP_Outgoing", pure, inheritable, header: "socket_udp_outgoing.h".} = object of Socket_IP
  ## Base functionality for a UDP sending socket

type Socket_fdset* {.importcpp: "Socket_fdset", pure, inheritable, header: "socket_fdset.h".} = object

type Buffered_DatagramConnection* {.importcpp: "Buffered_DatagramConnection", pure, inheritable, header: "buffered_datagramconnection.h".} = object of Socket_TCP
  ## there are 3 states 1. Socket not even assigned,,,, 2. Socket Assigned and
  ## trying to get a active connect open 3. Socket is open and  writable.. (
  ## Fully powered up )...

type Socket_UDP* {.importcpp: "Socket_UDP", pure, inheritable, header: "socket_udp.h".} = object of Socket_UDP_Incoming
  ## Base functionality for a combination UDP Reader and Writer.  This
  ## duplicates code from Socket_UDP_Outgoing, to avoid the problems of multiple
  ## inheritance.

type TiXmlBase* {.importcpp: "TiXmlBase*", bycopy, pure, inheritable, header: "tinyxml.h".} = object
  ## TiXmlBase is a base class for every class in TinyXml.
  ## It does little except to establish that TinyXml classes
  ## can be printed and provide some utility functions.
  ##
  ## In XML, the document and elements can contain
  ## other elements and other types of nodes.
  ##
  ## @verbatim
  ## A Document can contain: Element (container or leaf)
  ## Comment (leaf)
  ## Unknown (leaf)
  ## Declaration( leaf )
  ##
  ## An Element can contain: Element (container or leaf)
  ## Text    (leaf)
  ## Attributes (not on tree)
  ## Comment (leaf)
  ## Unknown (leaf)
  ##
  ## A Decleration contains: Attributes (not on tree)
  ## @endverbatim

converter toTiXmlBase*(_: type(nil)): TiXmlBase {.importcpp: "(nullptr)".}
converter toBool*(this: TiXmlBase): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TiXmlBase, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type TiXmlNode* {.importcpp: "TiXmlNode*", bycopy, pure, inheritable, header: "tinyxml.h".} = object of TiXmlBase
  ## The parent class for everything in the Document Object Model.
  ## (Except for attributes).
  ## Nodes have siblings, a parent, and children. A node can be
  ## in a document, or stand on its own. The type of a TiXmlNode
  ## can be queried, and it can be cast to its more defined type.

converter toTiXmlNode*(_: type(nil)): TiXmlNode {.importcpp: "(nullptr)".}
converter toBool*(this: TiXmlNode): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TiXmlNode, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type TiXmlDeclaration* {.importcpp: "TiXmlDeclaration*", bycopy, pure, inheritable, header: "tinyxml.h".} = object of TiXmlNode
  ## In correct XML the declaration is the first entry in the file.
  ## @verbatim
  ## <?xml version="1.0" standalone="yes"?>
  ## @endverbatim
  ##
  ## TinyXml will happily read or write files without a declaration,
  ## however. There are 3 possible attributes to the declaration:
  ## version, encoding, and standalone.
  ##
  ## Note: In this version of the code, the attributes are
  ## handled as special cases, not generic attributes, simply
  ## because there can only be at most 3 and they are always the same.

converter toTiXmlDeclaration*(_: type(nil)): TiXmlDeclaration {.importcpp: "(nullptr)".}
converter toBool*(this: TiXmlDeclaration): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TiXmlDeclaration, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type TiXmlDocument* {.importcpp: "TiXmlDocument*", bycopy, pure, inheritable, header: "tinyxml.h".} = object of TiXmlNode
  ## Always the top level node. A document binds together all the
  ## XML pieces. It can be saved, loaded, and printed to the screen.
  ## The 'value' of a document node is the xml file name.

converter toTiXmlDocument*(_: type(nil)): TiXmlDocument {.importcpp: "(nullptr)".}
converter toBool*(this: TiXmlDocument): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TiXmlDocument, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type TiXmlElement* {.importcpp: "TiXmlElement*", bycopy, pure, inheritable, header: "tinyxml.h".} = object of TiXmlNode
  ## The element is a container class. It has a value, the element name,
  ## and can contain other elements, text, comments, and unknowns.
  ## Elements also contain an arbitrary number of attributes.

converter toTiXmlElement*(_: type(nil)): TiXmlElement {.importcpp: "(nullptr)".}
converter toBool*(this: TiXmlElement): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TiXmlElement, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type TiXmlCursor* {.importcpp: "TiXmlCursor", pure, inheritable, header: "tinyxml.h".} = object
  ## Internal structure for tracking location of items
  ## in the XML file.

type TiXmlVisitor* {.importcpp: "TiXmlVisitor*", bycopy, pure, inheritable, header: "tinyxml.h".} = object
  ## Implements the interface to the "Visitor pattern" (see the Accept() method.)
  ## If you call the Accept() method, it requires being passed a TiXmlVisitor
  ## class to handle callbacks. For nodes that contain other nodes (Document, Element)
  ## you will get called with a VisitEnter/VisitExit pair. Nodes that are always leaves
  ## are simply called with Visit().
  ##
  ## If you return 'true' from a Visit method, recursive parsing will continue. If you return
  ## false, <b>no children of this node or its sibilings</b> will be Visited.
  ##
  ## All flavors of Visit methods have a default implementation that returns 'true' (continue
  ## visiting). You need to only override methods that are interesting to you.
  ##
  ## Generally Accept() is called on the TiXmlDocument, although all nodes suppert Visiting.
  ##
  ## You should never change the document from a callback.
  ##
  ## @sa TiXmlNode::Accept()

converter toTiXmlVisitor*(_: type(nil)): TiXmlVisitor {.importcpp: "(nullptr)".}
converter toBool*(this: TiXmlVisitor): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TiXmlVisitor, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

const TIXML_SUCCESS*: int = 0
const TIXML_NO_ATTRIBUTE*: int = 1
const TIXML_WRONG_TYPE*: int = 2

type TiXmlEncoding* = enum
  ## Used by the parsing routines.
  TIXML_ENCODING_UNKNOWN = 0
  TIXML_ENCODING_UTF8 = 1
  TIXML_ENCODING_LEGACY = 2

type TiXmlAttribute* {.importcpp: "TiXmlAttribute", pure, inheritable, header: "tinyxml.h".} = object of TiXmlBase
  ## An attribute is a name-value pair. Elements have an arbitrary
  ## number of attributes, each with a unique name.
  ##
  ## @note The attributes are not TiXmlNodes, since they are not
  ## part of the tinyXML document object model. There are other
  ## suggested ways to look at this problem.

type TiXmlAttributeSet* {.importcpp: "TiXmlAttributeSet", pure, inheritable, header: "tinyxml.h".} = object
  ## A class used to manage a group of attributes.
  ## It is only used internally, both by the ELEMENT and the DECLARATION.
  ##
  ## The set can be changed transparent to the Element and Declaration
  ## classes that use it, but NOT transparent to the Attribute
  ## which has to implement a next() and previous() method. Which makes
  ## it a bit problematic and prevents the use of STL.
  ##
  ## This version is implemented with circular lists because:
  ## - I like circular lists
  ## - it demonstrates some independence from the (typical) doubly linked list.

type TiXmlComment* {.importcpp: "TiXmlComment*", bycopy, pure, inheritable, header: "tinyxml.h".} = object of TiXmlNode
  ## An XML comment.

converter toTiXmlComment*(_: type(nil)): TiXmlComment {.importcpp: "(nullptr)".}
converter toBool*(this: TiXmlComment): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TiXmlComment, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type TiXmlText* {.importcpp: "TiXmlText*", bycopy, pure, inheritable, header: "tinyxml.h".} = object of TiXmlNode
  ## XML text. A text node can have 2 ways to output the next. "normal" output
  ## and CDATA. It will default to the mode it was parsed from the XML file and
  ## you generally want to leave it alone, but you can change the output mode with
  ## SetCDATA() and query it with CDATA().

converter toTiXmlText*(_: type(nil)): TiXmlText {.importcpp: "(nullptr)".}
converter toBool*(this: TiXmlText): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TiXmlText, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type TiXmlUnknown* {.importcpp: "TiXmlUnknown*", bycopy, pure, inheritable, header: "tinyxml.h".} = object of TiXmlNode
  ## Any tag that tinyXml doesn't recognize is saved as an
  ## unknown. It is a tag of text, but should not be modified.
  ## It will be written back to the XML, unchanged, when the file
  ## is saved.
  ##
  ## DTD tags get thrown into TiXmlUnknowns.

converter toTiXmlUnknown*(_: type(nil)): TiXmlUnknown {.importcpp: "(nullptr)".}
converter toBool*(this: TiXmlUnknown): bool {.importcpp: "(# != nullptr)".}
func `==`*(x: TiXmlUnknown, y: type(nil)): bool {.importcpp: "(# == nullptr)".}

type TiXmlHandle* {.importcpp: "TiXmlHandle", pure, inheritable, header: "tinyxml.h".} = object
  ## A TiXmlHandle is a class that wraps a node pointer with null checks; this is
  ## an incredibly useful thing. Note that TiXmlHandle is not part of the TinyXml
  ## DOM structure. It is a separate utility class.
  ##
  ## Take an example:
  ## @verbatim
  ## <Document>
  ## <Element attributeA = "valueA">
  ## <Child attributeB = "value1" />
  ## <Child attributeB = "value2" />
  ## </Element>
  ## <Document>
  ## @endverbatim
  ##
  ## Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very
  ## easy to write a \*lot\* of code that looks like:
  ##
  ## @verbatim
  ## TiXmlElement\* root = document.FirstChildElement( "Document" );
  ## if ( root )
  ## {
  ## TiXmlElement\* element = root->FirstChildElement( "Element" );
  ## if ( element )
  ## {
  ## TiXmlElement\* child = element->FirstChildElement( "Child" );
  ## if ( child )
  ## {
  ## TiXmlElement\* child2 = child->NextSiblingElement( "Child" );
  ## if ( child2 )
  ## {
  ## Finally do something useful.
  ## @endverbatim
  ##
  ## And that doesn't even cover "else" cases. TiXmlHandle addresses the verbosity
  ## of such code. A TiXmlHandle checks for null pointers so it is perfectly safe
  ## and correct to use:
  ##
  ## @verbatim
  ## TiXmlHandle docHandle( &document );
  ## TiXmlElement\* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).ToElement();
  ## if ( child2 )
  ## {
  ## do something useful
  ## @endverbatim
  ##
  ## Which is MUCH more concise and useful.
  ##
  ## It is also safe to copy handles - internally they are nothing more than node pointers.
  ## @verbatim
  ## TiXmlHandle handleCopy = handle;
  ## @endverbatim
  ##
  ## What they should not be used for is iteration:
  ##
  ## @verbatim
  ## int i=0;
  ## while ( true )
  ## {
  ## TiXmlElement\* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", i ).ToElement();
  ## if ( !child )
  ## break;
  ## do something
  ## ++i;
  ## }
  ## @endverbatim
  ##
  ## It seems reasonable, but it is in fact two embedded while loops. The Child method is
  ## a linear walk to find the element, so this code would iterate much more than it needs
  ## to. Instead, prefer:
  ##
  ## @verbatim
  ## TiXmlElement\* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).FirstChild( "Child" ).ToElement();
  ##
  ## for( child; child; child=child->NextSiblingElement() )
  ## {
  ## do something
  ## }
  ## @endverbatim

type TiXmlPrinter* {.importcpp: "TiXmlPrinter", pure, inheritable, header: "tinyxml.h".} = object of TiXmlVisitor
  ## Print to memory functionality. The TiXmlPrinter is useful when you need to:
  ##
  ## -# Print to memory (especially in non-STL mode)
  ## -# Control formatting (line endings, etc.)
  ##
  ## When constructed, the TiXmlPrinter is in its default "pretty printing" mode.
  ## Before calling Accept() you can call methods to control the printing
  ## of the XML document. After TiXmlNode::Accept() is called, the printed document can
  ## be accessed via the CStr(), Str(), and Size() methods.
  ##
  ## TiXmlPrinter uses the Visitor API.
  ## @verbatim
  ## TiXmlPrinter printer;
  ## printer.SetIndent( "\t" );
  ##
  ## doc.Accept( &printer );
  ## fprintf( stdout, "%s", printer.CStr() );
  ## @endverbatim

type PNMTextGlyph* {.importcpp: "PNMTextGlyph", pure, inheritable, header: "pnmTextGlyph.h".} = object
  ## A single glyph in a PNMTextMaker.

type PNMTextMaker* {.importcpp: "PNMTextMaker", pure, inheritable, header: "pnmTextMaker.h".} = object of FreetypeFont
  ## This object uses the Freetype library to generate text directly into an
  ## image.  It is different from the TextNode/DynamicTextFont interface, which
  ## use the Freetype library to generate text in the scene graph, to be
  ## rendered onscreen via the Panda render traversal.

func index*(this: TypeHandle): int {.importcpp: "#.get_index()".} ## \
## Returns the integer index associated with this TypeHandle.  Each different
## TypeHandle will have a different index.  However, you probably shouldn't be
## using this method; you should just treat the TypeHandles as opaque classes.
## This is provided for the convenience of non-C++ scripting languages to
## build a hashtable of TypeHandles.

func name*(this: TypeHandle, `object`: TypedObject): string {.importcpp: "nimStringFromStdString(#.get_name(#))", header: stringConversionCode.} ## \
## Returns the name of the type.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

func name*(this: TypeHandle): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the type.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

func versionString*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_version_string())", header: "pandaSystem.h".} ## \
## Returns the current version of Panda, expressed as a string, e.g.  "1.0.0".
## The string will end in the letter "c" if this build does not represent an
## official version.

func majorVersion*(_: typedesc[PandaSystem]): int {.importcpp: "PandaSystem::get_major_version()", header: "pandaSystem.h".} ## \
## Returns the major version number of the current version of Panda.  This is
## the first number of the dotted triple returned by get_version_string().  It
## changes very rarely.

func minorVersion*(_: typedesc[PandaSystem]): int {.importcpp: "PandaSystem::get_minor_version()", header: "pandaSystem.h".} ## \
## Returns the minor version number of the current version of Panda.  This is
## the second number of the dotted triple returned by get_version_string().
## It changes with each release that introduces new features.

func sequenceVersion*(_: typedesc[PandaSystem]): int {.importcpp: "PandaSystem::get_sequence_version()", header: "pandaSystem.h".} ## \
## Returns the sequence version number of the current version of Panda.  This
## is the third number of the dotted triple returned by get_version_string().
## It changes with bugfix updates and very minor feature updates.

func officialVersion*(_: typedesc[PandaSystem]): bool {.importcpp: "PandaSystem::is_official_version()", header: "pandaSystem.h".} ## \
## Returns true if current version of Panda claims to be an "official"
## version, that is, one that was compiled by an official distributor of Panda
## using a specific version of the panda source tree.  If this is true, there
## will not be a "c" at the end of the version string returned by
## get_version_string().
##
## Note that we must take the distributor's word for it here.

func memoryAlignment*(_: typedesc[PandaSystem]): int {.importcpp: "PandaSystem::get_memory_alignment()", header: "pandaSystem.h".} ## \
## Returns the memory alignment that Panda's allocators are using.

func distributor*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_distributor())", header: "pandaSystem.h".} ## \
## Returns the string defined by the distributor of this version of Panda, or
## "homebuilt" if this version was built directly from the sources by the end-
## user.  This is a completely arbitrary string.

func compiler*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_compiler())", header: "pandaSystem.h".} ## \
## Returns a string representing the compiler that was used to generate this
## version of Panda, if it is available, or "unknown" if it is not.

func buildDate*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_build_date())", header: "pandaSystem.h".} ## \
## Returns a string representing the date and time at which this version of
## Panda (or at least dtool) was compiled, if available.

func gitCommit*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_git_commit())", header: "pandaSystem.h".} ## \
## Returns a string representing the git commit hash that this source tree is
## based on, or the empty string if it has not been specified at build time.

func platform*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_platform())", header: "pandaSystem.h".} ## \
## Returns a string representing the runtime platform that we are currently
## running on.  This will be something like "win32" or "osx_i386" or
## "linux_amd64".

func binaryName*(_: typedesc[ExecutionEnvironment]): string {.importcpp: "nimStringFromStdString(ExecutionEnvironment::get_binary_name())", header: "executionEnvironment.h".} ## \
## Returns the name of the binary executable that started this program, if it
## can be determined.

proc `binaryName=`*(_: typedesc[ExecutionEnvironment], name: string) {.importcpp: "#ExecutionEnvironment::set_binary_name(nimStringToStdString(#))", header: "executionEnvironment.h".} ## \
## Do not use.

func dtoolName*(_: typedesc[ExecutionEnvironment]): string {.importcpp: "nimStringFromStdString(ExecutionEnvironment::get_dtool_name())", header: "executionEnvironment.h".} ## \
## Returns the name of the libdtool DLL that is used in this program, if it
## can be determined.

proc `dtoolName=`*(_: typedesc[ExecutionEnvironment], name: string) {.importcpp: "#ExecutionEnvironment::set_dtool_name(nimStringToStdString(#))", header: "executionEnvironment.h".} ## \
## Do not use.

func cwd*(_: typedesc[ExecutionEnvironment]): Filename {.importcpp: "ExecutionEnvironment::get_cwd()", header: "executionEnvironment.h".} ## \
## Returns the name of the current working directory.

func pattern*(this: GlobPattern): string {.importcpp: "nimStringFromStdString(#.get_pattern())", header: stringConversionCode.} ## \
## Returns the pattern string that the GlobPattern object matches.

proc `pattern=`*(this: GlobPattern, pattern: string) {.importcpp: "#.set_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the pattern string that the GlobPattern object matches.

func caseSensitive*(this: GlobPattern): bool {.importcpp: "#.get_case_sensitive()".} ## \
## Returns whether the match is case sensitive (true) or case insensitive
## (false).  The default is case sensitive.

proc `caseSensitive=`*(this: GlobPattern, case_sensitive: bool) {.importcpp: "#.set_case_sensitive(#)".} ## \
## Sets whether the match is case sensitive (true) or case insensitive
## (false).  The default is case sensitive.

func nomatchChars*(this: GlobPattern): string {.importcpp: "nimStringFromStdString(#.get_nomatch_chars())", header: stringConversionCode.} ## \
## Returns the set of characters that are not matched by \* or ?.

proc `nomatchChars=`*(this: GlobPattern, nomatch_chars: string) {.importcpp: "#.set_nomatch_chars(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies a set of characters that are not matched by \* or ?.

func name*(this: ConfigPage): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the page.  If the page was loaded from a .prc file,
## this is usually the filename.

func special*(this: ConfigPage): bool {.importcpp: "#.is_special()".} ## \
## Returns true if this is the special "default" or "local" page, or false if
## it is an ordinary page, e.g.  an implicit page loaded from a prc file at
## startup, or an explicit page created by
## ConfigPageManager::make_explicit_page().

func implicit*(this: ConfigPage): bool {.importcpp: "#.is_implicit()".} ## \
## Returns true if the page was loaded by implicitly searching the config path
## on startup, or false if it was explicitly loaded by dynamic code after
## initial startup.

func sort*(this: ConfigPage): int {.importcpp: "#.get_sort()".} ## \
## Returns the explicit sort order of this particular ConfigPage.  See
## set_sort().

proc `sort=`*(this: ConfigPage, sort: int) {.importcpp: "#.set_sort(#)".} ## \
## Changes the explicit sort order of this particular ConfigPage.  Lower-
## numbered pages supercede higher-numbered pages.  Initially, all explicitly-
## loaded pages have sort value 0, and implicitly-loaded pages (found on disk)
## have sort value 10; you may set an individual page higher or lower to
## influence its priority relative to other pages.

func pageSeq*(this: ConfigPage): int {.importcpp: "#.get_page_seq()".} ## \
## Returns the sequence number of the page.
##
## Sequence numbers for a particular class (implicit vs.  explicit) of pages
## are assigned as each page is loaded; each page is given a higher sequence
## number than all the pages loaded before it.
##
## The implicit_load pages, which are discovered in the file system
## automatically, have a different set of sequence numbers than the explicit
## pages.

func trustLevel*(this: ConfigPage): int {.importcpp: "#.get_trust_level()".} ## \
## Returns the trust level associated with this page.  An untrusted page is
## trust level 0; if the page was loaded from a signed .prc file, its trust
## level is the index number of the certificate that signed it.  Generally, a
## higher trust level value represents a greater level of trust.

proc `trustLevel=`*(this: ConfigPage, trust_level: int) {.importcpp: "#.set_trust_level(#)".} ## \
## Explicitly sets the trust level on this particular page.  Note that any
## subsequent changes to the page, or to any variable declarations on it, will
## reset the trust level to zero.

func signature*(this: ConfigPage): string {.importcpp: "nimStringFromStdString(#.get_signature())", header: stringConversionCode.} ## \
## Returns the raw binary signature that was found in the prc file, if any.
## This method is probably not terribly useful for most applications.

func page*(this: ConfigDeclaration): ConfigPage {.importcpp: "#.get_page()".} ## \
## Returns the page on which this declaration can be found.

func variable*(this: ConfigDeclaration): ConfigVariableCore {.importcpp: "#.get_variable()".} ## \
## Returns the variable that this declaration names.  This variable may or may
## not have been defined by the time the declaration is read.

func name*(this: ConfigVariableCore): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the variable.

func used*(this: ConfigVariableCore): bool {.importcpp: "#.is_used()".} ## \
## Returns true if the variable has been referenced by a ConfigVariable
## somewhere in code, false otherwise.

func closed*(this: ConfigVariableCore): bool {.importcpp: "#.is_closed()".} ## \
## Returns true if the variable is not trusted by any prc file (and hence
## cannot be modified from its compiled-in default value), or false for the
## normal case, in which the variable can be modified by any prc file at or
## above its trust level (see get_trust_level()).
##
## This value only has effect in a release build (specifically, when
## PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).

func trustLevel*(this: ConfigVariableCore): int {.importcpp: "#.get_trust_level()".} ## \
## Returns the minimum trust_level a prc file must demonstrate in order to
## redefine the value for this variable.  Arguably, this should be called the
## "mistrust level", since the larger the value, the more suspicious we are of
## prc files.  This value is not used if is_closed() returns true, which
## indicates no file may be trusted.
##
## This value only has effect in a release build (specifically, when
## PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).

func dynamic*(this: ConfigVariableCore): bool {.importcpp: "#.is_dynamic()".} ## \
## Returns true if the variable was indicated as "dynamic" by its constructor,
## indicating that its name was dynamically generated, possibly from a large
## pool, and it should not be listed along with the other variables.

func description*(this: ConfigVariableCore): string {.importcpp: "nimStringFromStdString(#.get_description())", header: stringConversionCode.} ## \
## Returns the brief description of this variable, if it has been defined.

proc `description=`*(this: ConfigVariableCore, description: string) {.importcpp: "#.set_description(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the one-line description of this variable.  See
## get_description().  It is not an error to call this multiple times, but if
## the value changes once get_declaration() has been called, a warning is
## printed.

func defaultValue*(this: ConfigVariableCore): ConfigDeclaration {.importcpp: "#.get_default_value()".} ## \
## Returns the default variable specified for this variable.  If the variable
## has not yet been defined, this will return NULL.

proc `defaultValue=`*(this: ConfigVariableCore, default_value: string) {.importcpp: "#.set_default_value(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the default value for this variable if it is not defined in any
## prc file.

func searchPath*(this: ConfigPageManager): DSearchPath {.importcpp: "#.get_search_path()".} ## \
## Returns the search path used to locate implicit .prc files.  This is
## determined by the PRC_DIR and PRC_PATH environment variables.  The object
## returned by this method may be modified to change the path at runtime, and
## then reload_implicit_pages() called.

func name*(this: ConfigVariableBase): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the variable.

func description*(this: ConfigVariableBase): string {.importcpp: "nimStringFromStdString(#.get_description())", header: stringConversionCode.} ## \
## Returns the brief description of this variable, if it has been defined.

func closed*(this: ConfigVariableBase): bool {.importcpp: "#.is_closed()".} ## \
## Returns true if the variable is not trusted by any prc file (and hence
## cannot be modified from its compiled-in default value), or false for the
## normal case, in which the variable can be modified by any prc file at or
## above its trust level (see get_trust_level()).
##
## This value only has effect in a release build (specifically, when
## PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).

func trustLevel*(this: ConfigVariableBase): int {.importcpp: "#.get_trust_level()".} ## \
## Returns the minimum trust_level a prc file must demonstrate in order to
## redefine the value for this variable.  Arguably, this should be called the
## "mistrust level", since the larger the value, the more suspicious we are of
## prc files.  This value is not used if is_closed() returns true, which
## indicates no file may be trusted.
##
## This value only has effect in a release build (specifically, when
## PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).

func dynamic*(this: ConfigVariableBase): bool {.importcpp: "#.is_dynamic()".} ## \
## Returns true if the variable was indicated as "dynamic" by its constructor,
## indicating that its name was dynamically generated, possibly from a large
## pool, and it should not be listed along with the other variables.

func value*(this: ConfigVariableBool): bool {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc `value=`*(this: ConfigVariableBool, value: bool) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

func defaultValue*(this: ConfigVariableBool): bool {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

func value*(this: ConfigVariableDouble): float64 {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc `value=`*(this: ConfigVariableDouble, value: float64) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

func defaultValue*(this: ConfigVariableDouble): float64 {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

func value*(this: ConfigVariableFilename): Filename {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc `value=`*(this: ConfigVariableFilename, value: Filename) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

func defaultValue*(this: ConfigVariableFilename): Filename {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

func value*(this: ConfigVariableInt): int {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc `value=`*(this: ConfigVariableInt, value: int) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

func defaultValue*(this: ConfigVariableInt): int {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

func value*(this: ConfigVariableInt64): clonglong {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc `value=`*(this: ConfigVariableInt64, value: clonglong) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

func defaultValue*(this: ConfigVariableInt64): clonglong {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

func value*(this: ConfigVariableSearchPath): DSearchPath {.importcpp: "#.get_value()".}

func defaultValue*(this: ConfigVariableSearchPath): DSearchPath {.importcpp: "#.get_default_value()".}

func value*(this: ConfigVariableString): string {.importcpp: "nimStringFromStdString(#.get_value())", header: stringConversionCode.} ## \
## Returns the variable's value.

proc `value=`*(this: ConfigVariableString, value: string) {.importcpp: "#.set_value(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Reassigns the variable's local value.

func defaultValue*(this: ConfigVariableString): string {.importcpp: "nimStringFromStdString(#.get_default_value())", header: stringConversionCode.} ## \
## Returns the variable's default value.

func fullname*(this: NotifyCategory): string {.importcpp: "nimStringFromStdString(#.get_fullname())", header: stringConversionCode.}

func basename*(this: NotifyCategory): string {.importcpp: "nimStringFromStdString(#.get_basename())", header: stringConversionCode.}

func severity*(this: NotifyCategory): NotifySeverity {.importcpp: "#.get_severity()".}

proc `severity=`*(this: NotifyCategory, severity: NotifySeverity) {.importcpp: "#.set_severity(#)".} ## \
## Sets the severity level of messages that will be reported from this
## Category.  This allows any message of this severity level or higher.

func algorithm*(this: IDecryptStream): string {.importcpp: "nimStringFromStdString(#.get_algorithm())", header: stringConversionCode.} ## \
## Returns the encryption algorithm that was read from the stream.

func keyLength*(this: IDecryptStream): int {.importcpp: "#.get_key_length()".} ## \
## Returns the encryption key length, in bits, that was read from the stream.

func iterationCount*(this: IDecryptStream): int {.importcpp: "#.get_iteration_count()".} ## \
## Returns the value that was was read from the stream.

proc `algorithm=`*(this: OEncryptStream, algorithm: string) {.importcpp: "#.set_algorithm(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the encryption algorithm that should be used for future calls to
## open().  The default is whatever is specified by the encryption-algorithm
## config variable.  The complete set of available algorithms is defined by
## the current version of OpenSSL.
##
## If an invalid algorithm is specified, there is no immediate error return
## code, but open() will fail.

proc `keyLength=`*(this: OEncryptStream, key_length: int) {.importcpp: "#.set_key_length(#)".} ## \
## Specifies the length of the key, in bits, that should be used to encrypt
## the stream in future calls to open().  The default is whatever is specified
## by the encryption-key-length config variable.
##
## If an invalid key_length for the chosen algorithm is specified, there is no
## immediate error return code, but open() will fail.

proc `iterationCount=`*(this: OEncryptStream, iteration_count: int) {.importcpp: "#.set_iteration_count(#)".} ## \
## Specifies the number of times to repeatedly hash the key before writing it
## to the stream in future calls to open().  Its purpose is to make it
## computationally more expensive for an attacker to search the key space
## exhaustively.  This should be a multiple of 1,000 and should not exceed
## about 65 million; the value 0 indicates just one application of the hashing
## algorithm.
##
## The default is whatever is specified by the encryption-iteration-count
## config variable.

func scheme*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_scheme())", header: stringConversionCode.} ## \
## Returns the scheme specified by the URL, or empty string if no scheme is
## specified.

proc `scheme=`*(this: URLSpec, scheme: string) {.importcpp: "#.set_scheme(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the scheme part of the URL specification.

func authority*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_authority())", header: stringConversionCode.} ## \
## Returns the authority specified by the URL (this includes username, server,
## and/or port), or empty string if no authority is specified.

proc `authority=`*(this: URLSpec, authority: string) {.importcpp: "#.set_authority(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the authority part of the URL specification.  This includes the
## username, server, and port.

func username*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_username())", header: stringConversionCode.} ## \
## Returns the username specified by the URL, if any.  This might also include
## a password, e.g.  "username:password", although putting a password on the
## URL is probably a bad idea.

proc `username=`*(this: URLSpec, username: string) {.importcpp: "#.set_username(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the username part of the URL specification.

func server*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_server())", header: stringConversionCode.} ## \
## Returns the server name specified by the URL, if any.  In case of an IPv6
## address, does not include the enclosing brackets.

proc `server=`*(this: URLSpec, server: string) {.importcpp: "#.set_server(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the server part of the URL specification.
## Unlike set_server_and_port, this method does not require IPv6 addresses to
## be enclosed in square brackets.

func port*(this: URLSpec): int {.importcpp: "#.get_port()".} ## \
## Returns the port number specified by the URL, or the default port if not
## specified.

proc `port=`*(this: URLSpec, port: string) {.importcpp: "#.set_port(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the port part of the URL specification.

proc `port=`*(this: URLSpec, port: int) {.importcpp: "#.set_port(#)".} ## \
## Replaces the port part of the URL specification, given a numeric port
## number.

func serverAndPort*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_server_and_port())", header: stringConversionCode.} ## \
## Returns a string consisting of the server name, followed by a colon,
## followed by the port number.  If the port number is not explicitly given in
## the URL, this string will include the implicit port number.
## If the server is an IPv6 address, it will be enclosed in square brackets.

proc `serverAndPort=`*(this: URLSpec, server_and_port: string) {.importcpp: "#.set_server_and_port(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the server and port parts of the URL specification simultaneously.
## The input string should be of the form "server:port", or just "server" to
## make the port number implicit.
## Any IPv6 address must be enclosed in square brackets.

func path*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_path())", header: stringConversionCode.} ## \
## Returns the path specified by the URL, or "/" if no path is specified.

proc `path=`*(this: URLSpec, path: string) {.importcpp: "#.set_path(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the path part of the URL specification.

func query*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_query())", header: stringConversionCode.} ## \
## Returns the query specified by the URL, or empty string if no query is
## specified.

proc `query=`*(this: URLSpec, query: string) {.importcpp: "#.set_query(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the query part of the URL specification.

func ssl*(this: URLSpec): bool {.importcpp: "#.is_ssl()".} ## \
## Returns true if the URL's scheme specifies an SSL-secured protocol such as
## https, or false otherwise.

func name*(this: HTTPCookie): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the cookie.  This is the key value specified by the
## server.

proc `name=`*(this: HTTPCookie, name: string) {.importcpp: "#.set_name(nimStringToStdString(#))", header: stringConversionCode.}

func value*(this: HTTPCookie): string {.importcpp: "nimStringFromStdString(#.get_value())", header: stringConversionCode.} ## \
## Returns the value of the cookie.  This is the arbitrary string associated
## with the cookie's name, as specified by the server.

proc `value=`*(this: HTTPCookie, value: string) {.importcpp: "#.set_value(nimStringToStdString(#))", header: stringConversionCode.}

func domain*(this: HTTPCookie): string {.importcpp: "nimStringFromStdString(#.get_domain())", header: stringConversionCode.}

proc `domain=`*(this: HTTPCookie, domain: string) {.importcpp: "#.set_domain(nimStringToStdString(#))", header: stringConversionCode.}

func path*(this: HTTPCookie): string {.importcpp: "nimStringFromStdString(#.get_path())", header: stringConversionCode.} ## \
## Returns the prefix of the URL paths on the server for which this cookie
## will be sent.

proc `path=`*(this: HTTPCookie, path: string) {.importcpp: "#.set_path(nimStringToStdString(#))", header: stringConversionCode.}

func expires*(this: HTTPCookie): HTTPDate {.importcpp: "#.get_expires()".} ## \
## Returns the expiration date of the cookie if it is set, or an invalid date
## if it is not.

proc `expires=`*(this: HTTPCookie, expires: HTTPDate) {.importcpp: "#.set_expires(#)".}

func secure*(this: HTTPCookie): bool {.importcpp: "#.get_secure()".} ## \
## Returns true if the server has indicated this is a "secure" cookie which
## should only be sent over an HTTPS channel.

proc `secure=`*(this: HTTPCookie, flag: bool) {.importcpp: "#.set_secure(#)".}

func refCount*(this: ReferenceCount): int {.importcpp: "#->get_ref_count()".} ## \
## Returns the current reference count.

func url*(this: DocumentSpec): URLSpec {.importcpp: "#.get_url()".} ## \
## Retrieves the URL of the DocumentSpec.

proc `url=`*(this: DocumentSpec, url: URLSpec) {.importcpp: "#.set_url(#)".} ## \
## Changes the URL of the DocumentSpec without modifying its other properties.
## Normally this would be a strange thing to do, because the tag and date are
## usually strongly associated with the URL.  To get a DocumentSpec pointing
## to a new URL, you would normally create a new DocumentSpec object.

func tag*(this: DocumentSpec): HTTPEntityTag {.importcpp: "#.get_tag()".} ## \
## Returns the identity tag associated with the DocumentSpec, if there is one.
## It is an error to call this if has_tag() returns false.
##
## The identity tag is set by the HTTP server to uniquely refer to a
## particular version of a document.

proc `tag=`*(this: DocumentSpec, tag: HTTPEntityTag) {.importcpp: "#.set_tag(#)".} ## \
## Changes the identity tag associated with the DocumentSpec.

func date*(this: DocumentSpec): HTTPDate {.importcpp: "#.get_date()".} ## \
## Returns the last-modified date associated with the DocumentSpec, if there
## is one.  It is an error to call this if has_date() returns false.

proc `date=`*(this: DocumentSpec, date: HTTPDate) {.importcpp: "#.set_date(#)".} ## \
## Changes the last-modified date associated with the DocumentSpec.

func progress*(this: Decompressor): float32 {.importcpp: "#.get_progress()".} ## \
## Returns the ratio through the decompression step in the background.

func progress*(this: Extractor): float32 {.importcpp: "#.get_progress()".} ## \
## Returns the fraction of the Multifile extracted so far.

func tracking*(_: typedesc[MemoryUsage]): bool {.importcpp: "MemoryUsage::is_tracking()", header: "memoryUsage.h".} ## \
## Returns true if the MemoryUsage object is currently tracking memory (e.g.
## track-memory-usage is configured #t).

func counting*(_: typedesc[MemoryUsage]): bool {.importcpp: "MemoryUsage::is_counting()", header: "memoryUsage.h".} ## \
## Returns true if the MemoryUsage object is currently at least counting
## memory (e.g.  this is a Windows debug build), even if it's not fully
## tracking it.

func currentCppSize*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_current_cpp_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes of allocated memory consumed by C++
## objects, not including the memory previously frozen.

func totalCppSize*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_total_cpp_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes of allocated memory consumed by C++
## objects, including the memory previously frozen.

func pandaHeapSingleSize*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_panda_heap_single_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes allocated from the heap from code within
## Panda, for individual objects.

func pandaHeapArraySize*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_panda_heap_array_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes allocated from the heap from code within
## Panda, for arrays.

func pandaHeapOverhead*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_panda_heap_overhead()", header: "memoryUsage.h".} ## \
## Returns the extra bytes allocated from the system that are not immediately
## used for holding allocated objects.  This can only be determined if
## ALTERNATIVE_MALLOC is enabled.

func pandaMmapSize*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_panda_mmap_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes allocated from the virtual memory pool
## from code within Panda.

func externalSize*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_external_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes of allocated memory in the heap that
## Panda didn't seem to be responsible for.  This includes a few bytes for
## very low-level objects (like ConfigVariables) that cannot use Panda memory
## tracking because they are so very low-level.
##
## This also includes all of the memory that might have been allocated by a
## high-level interpreter, like Python.
##
## This number is only available if Panda is able to hook into the actual heap
## callback.

func totalSize*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_total_size()", header: "memoryUsage.h".} ## \
## Returns the total size of allocated memory consumed by the process, as
## nearly as can be determined.

func filename*(this: DatagramSink): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the filename that provides the target for these datagrams, if any,
## or empty string if the datagrams do not get written to a file on disk.

func file*(this: DatagramSink): FileReference {.importcpp: "deconstify(#->get_file())", header: deconstifyCode.} ## \
## Returns the FileReference that provides the target for these datagrams, if
## any, or NULL if the datagrams do not written to a file on disk.

func filePos*(this: DatagramSink): clonglong {.importcpp: "#->get_file_pos()".} ## \
## Returns the current file position within the data stream, if any, or 0 if
## the file position is not meaningful or cannot be determined.
##
## For DatagramSinks that return a meaningful file position, this will be
## pointing to the first byte following the datagram returned after a call to
## put_datagram().

func magicNumber*(_: typedesc[Multifile]): string {.importcpp: "nimStringFromStdString(Multifile::get_magic_number())", header: "multifile.h".} ## \
## Returns a string with the first n bytes written to a Multifile, to identify
## it as a Multifile.

func name*(this: Namable): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.}

proc `name=`*(this: Namable, name: string) {.importcpp: "#->set_name(nimStringToStdString(#))", header: stringConversionCode.}

func longTime*(this: TrueClock): float64 {.importcpp: "#.get_long_time()".} ## \
## get_long_time() returns the most accurate timer we have over a long
## interval.  It may not be very precise for measuring short intervals, but
## it should not drift substantially over the long haul.

func shortTime*(this: TrueClock): float64 {.importcpp: "#.get_short_time()".} ## \
## get_short_time() returns the most precise timer we have over a short
## interval.  It may tend to drift over the long haul, but it should have
## lots of digits to measure short intervals very precisely.

func shortRawTime*(this: TrueClock): float64 {.importcpp: "#.get_short_raw_time()".} ## \
## get_short_raw_time() is like get_short_time(), but does not apply any
## corrections (e.g.  paranoid-clock) to the result returned by the OS.

func errorCount*(this: TrueClock): int {.importcpp: "#.get_error_count()".} ## \
## Returns the number of clock errors that have been detected.  Each time a
## clock error is detected, in which the value returned by either of the above
## methods is suspect, the value returned by this method will be incremented.
## Applications can monitor this value and react, for instance, by
## resynchronizing their clocks each time this value changes.

func progress*(this: Patchfile): float32 {.importcpp: "#.get_progress()".} ## \
## Returns a value in the range 0..1, representing the amount of progress
## through the patchfile, during a session.

func allowMultifile*(this: Patchfile): bool {.importcpp: "#.get_allow_multifile()".} ## \
## See set_allow_multifile().

proc `allowMultifile=`*(this: Patchfile, allow_multifile: bool) {.importcpp: "#.set_allow_multifile(#)".} ## \
## If this flag is set true, the Patchfile will make a special case for
## patching Panda Multifiles, if detected, and attempt to patch them on a
## subfile-by-subfile basis.  If this flag is false, the Patchfile will always
## patch the file on a full-file basis.
##
## This has effect only when building patches; it is not used for applying
## patches.

func footprintLength*(this: Patchfile): int {.importcpp: "#.get_footprint_length()".}

proc `footprintLength=`*(this: Patchfile, length: int) {.importcpp: "#.set_footprint_length(#)".}

func sourceHash*(this: Patchfile): HashVal {.importcpp: "#.get_source_hash()".} ## \
## Returns the MD5 hash for the source file.

func resultHash*(this: Patchfile): HashVal {.importcpp: "#.get_result_hash()".} ## \
## Returns the MD5 hash for the file after the patch has been applied.

func state*(this: PandaNode, current_thread: Thread): RenderState {.importcpp: "deconstify(#->get_state(#))", header: deconstifyCode.} ## \
## Returns the complete RenderState that will be applied to all nodes at this
## level and below, as set on this node.  This returns only the RenderState
## set on this particular node, and has nothing to do with state that might be
## inherited from above.

func state*(this: PandaNode): RenderState {.importcpp: "deconstify(#->get_state())", header: deconstifyCode.} ## \
## Returns the complete RenderState that will be applied to all nodes at this
## level and below, as set on this node.  This returns only the RenderState
## set on this particular node, and has nothing to do with state that might be
## inherited from above.

proc `state=`*(this: PandaNode, state: RenderState, current_thread: Thread) {.importcpp: "#->set_state(#, #)".} ## \
## Sets the complete RenderState that will be applied to all nodes at this
## level and below.  (The actual state that will be applied to lower nodes is
## based on the composition of RenderStates from above this node as well).
## This completely replaces whatever has been set on this node via repeated
## calls to set_attrib().

proc `state=`*(this: PandaNode, state: RenderState) {.importcpp: "#->set_state(#)".} ## \
## Sets the complete RenderState that will be applied to all nodes at this
## level and below.  (The actual state that will be applied to lower nodes is
## based on the composition of RenderStates from above this node as well).
## This completely replaces whatever has been set on this node via repeated
## calls to set_attrib().

func effects*(this: PandaNode, current_thread: Thread): RenderEffects {.importcpp: "deconstify(#->get_effects(#))", header: deconstifyCode.} ## \
## Returns the complete RenderEffects that will be applied to this node.

func effects*(this: PandaNode): RenderEffects {.importcpp: "deconstify(#->get_effects())", header: deconstifyCode.} ## \
## Returns the complete RenderEffects that will be applied to this node.

proc `effects=`*(this: PandaNode, effects: RenderEffects, current_thread: Thread) {.importcpp: "#->set_effects(#, #)".} ## \
## Sets the complete RenderEffects that will be applied this node.  This
## completely replaces whatever has been set on this node via repeated calls
## to set_attrib().

proc `effects=`*(this: PandaNode, effects: RenderEffects) {.importcpp: "#->set_effects(#)".} ## \
## Sets the complete RenderEffects that will be applied this node.  This
## completely replaces whatever has been set on this node via repeated calls
## to set_attrib().

func transform*(this: PandaNode, current_thread: Thread): TransformState {.importcpp: "deconstify(#->get_transform(#))", header: deconstifyCode.} ## \
## Returns the transform that has been set on this particular node.  This is
## not the net transform from the root, but simply the transform on this
## particular node.

func transform*(this: PandaNode): TransformState {.importcpp: "deconstify(#->get_transform())", header: deconstifyCode.} ## \
## Returns the transform that has been set on this particular node.  This is
## not the net transform from the root, but simply the transform on this
## particular node.

proc `transform=`*(this: PandaNode, transform: TransformState, current_thread: Thread) {.importcpp: "#->set_transform(#, #)".} ## \
## Sets the transform that will be applied to this node and below.  This
## defines a new coordinate space at this point in the scene graph and below.

proc `transform=`*(this: PandaNode, transform: TransformState) {.importcpp: "#->set_transform(#)".} ## \
## Sets the transform that will be applied to this node and below.  This
## defines a new coordinate space at this point in the scene graph and below.

func prevTransform*(this: PandaNode, current_thread: Thread): TransformState {.importcpp: "deconstify(#->get_prev_transform(#))", header: deconstifyCode.} ## \
## Returns the transform that has been set as this node's "previous" position.
## See set_prev_transform().

func prevTransform*(this: PandaNode): TransformState {.importcpp: "deconstify(#->get_prev_transform())", header: deconstifyCode.} ## \
## Returns the transform that has been set as this node's "previous" position.
## See set_prev_transform().

func overallBit*(_: typedesc[PandaNode]): DrawMask {.importcpp: "PandaNode::get_overall_bit()", header: "pandaNode.h".} ## \
## Returns the special bit that, when specifically cleared in the node's
## DrawMask, indicates that the node is hidden to all cameras, regardless of
## the remaining DrawMask bits.

func allCameraMask*(_: typedesc[PandaNode]): DrawMask {.importcpp: "PandaNode::get_all_camera_mask()", header: "pandaNode.h".} ## \
## Returns a DrawMask that is appropriate for rendering to all cameras.

func overallHidden*(this: PandaNode): bool {.importcpp: "#->is_overall_hidden()".} ## \
## Returns true if the node has been hidden to all cameras by clearing its
## overall bit.

proc `overallHidden=`*(this: PandaNode, overall_hidden: bool) {.importcpp: "#->set_overall_hidden(#)".} ## \
## Sets or clears the hidden flag.  When the hidden flag is true, the node and
## all of its children are invisible to all cameras, regardless of the setting
## of any draw masks.  Setting the hidden flag to false restores the previous
## visibility as established by the draw masks.
##
## This actually works by twiddling the reserved _overall_bit in the node's
## draw mask, which has special meaning.

func drawControlMask*(this: PandaNode): DrawMask {.importcpp: "#->get_draw_control_mask()".} ## \
## Returns the set of bits in draw_show_mask that are considered meaningful.
## See adjust_draw_mask().

func drawShowMask*(this: PandaNode): DrawMask {.importcpp: "#->get_draw_show_mask()".} ## \
## Returns the hide/show bits of this particular node.  See
## adjust_draw_mask().

func intoCollideMask*(this: PandaNode): CollideMask {.importcpp: "#->get_into_collide_mask()".} ## \
## Returns the "into" collide mask for this node.

proc `intoCollideMask=`*(this: PandaNode, mask: CollideMask) {.importcpp: "#->set_into_collide_mask(#)".} ## \
## Sets the "into" CollideMask.
##
## This specifies the set of bits that must be shared with a CollisionNode's
## "from" CollideMask in order for the CollisionNode to detect a collision
## with this particular node.
##
## The actual CollideMask that will be set is masked by the return value from
## get_legal_collide_mask(). Thus, the into_collide_mask cannot be set to
## anything other than nonzero except for those types of nodes that can be
## collided into, such as CollisionNodes and GeomNodes.

func legalCollideMask*(this: PandaNode): CollideMask {.importcpp: "#->get_legal_collide_mask()".} ## \
## Returns the subset of CollideMask bits that may be set for this particular
## type of PandaNode.  For most nodes, this is 0; it doesn't make sense to set
## a CollideMask for most kinds of nodes.
##
## For nodes that can be collided with, such as GeomNode and CollisionNode,
## this returns all bits on.

func nestedVertices*(this: PandaNode, current_thread: Thread): int {.importcpp: "#->get_nested_vertices(#)".} ## \
## Returns the total number of vertices that will be rendered by this node and
## all of its descendents.
##
## This is not necessarily an accurate count of vertices that will actually be
## rendered, since this will include all vertices of all LOD's, and it will
## also include hidden nodes.  It may also omit or only approximate certain
## kinds of dynamic geometry.  However, it will not include stashed nodes.

func nestedVertices*(this: PandaNode): int {.importcpp: "#->get_nested_vertices()".} ## \
## Returns the total number of vertices that will be rendered by this node and
## all of its descendents.
##
## This is not necessarily an accurate count of vertices that will actually be
## rendered, since this will include all vertices of all LOD's, and it will
## also include hidden nodes.  It may also omit or only approximate certain
## kinds of dynamic geometry.  However, it will not include stashed nodes.

func internalBounds*(this: PandaNode, current_thread: Thread): BoundingVolume {.importcpp: "deconstify(#->get_internal_bounds(#))", header: deconstifyCode.} ## \
## Returns the node's internal bounding volume.  This is the bounding volume
## around the node alone, without including children.  If the user has called
## set_bounds(), it will be the specified bounding volume.

func internalBounds*(this: PandaNode): BoundingVolume {.importcpp: "deconstify(#->get_internal_bounds())", header: deconstifyCode.} ## \
## Returns the node's internal bounding volume.  This is the bounding volume
## around the node alone, without including children.  If the user has called
## set_bounds(), it will be the specified bounding volume.

func internalVertices*(this: PandaNode, current_thread: Thread): int {.importcpp: "#->get_internal_vertices(#)".} ## \
## Returns the total number of vertices that will be rendered by this
## particular node alone, not accounting for its children.
##
## This may not include all vertices for certain dynamic effects.

func internalVertices*(this: PandaNode): int {.importcpp: "#->get_internal_vertices()".} ## \
## Returns the total number of vertices that will be rendered by this
## particular node alone, not accounting for its children.
##
## This may not include all vertices for certain dynamic effects.

func boundsStale*(this: PandaNode): bool {.importcpp: "#->is_bounds_stale()".} ## \
## Returns true if the bounding volume of this node is stale and will be
## implicitly recomputed at the next call to get_bounds(), or false if it is
## fresh and need not be recomputed.

func final*(this: PandaNode, current_thread: Thread): bool {.importcpp: "#->is_final(#)".} ## \
## Returns the current state of the "final" flag.  Initially, this flag is off
## (false), but it may be changed by an explicit call to set_final().  See
## set_final().

func final*(this: PandaNode): bool {.importcpp: "#->is_final()".} ## \
## Returns the current state of the "final" flag.  Initially, this flag is off
## (false), but it may be changed by an explicit call to set_final().  See
## set_final().

proc `final=`*(this: PandaNode, flag: bool) {.importcpp: "#->set_final(#)".} ## \
## Sets the "final" flag on this PandaNode.  If this is true, than no bounding
## volume need be tested below it; a positive intersection with this node's
## bounding volume is deemed to be a positive intersection with all geometry
## inside.
##
## This is useful to quickly force a larger bounding volume around a node when
## the GeomNodes themselves are inaccurate for some reason, without forcing a
## recompute of every nested bounding volume.  It's also helpful when the
## bounding volume is tricked by some special properties, like billboards,
## that may move geometry out of its bounding volume otherwise.

func stashed*(this: PandaNode, n: int, current_thread: Thread): PandaNode {.importcpp: "#->get_stashed(#, #)".} ## \
## Returns the nth stashed child of this node.  See get_num_stashed().  Also
## see get_stashed(), if your intention is to iterate through the complete
## list of stashed children; get_stashed() is preferable in this case.

func stashed*(this: PandaNode, n: int): PandaNode {.importcpp: "#->get_stashed(#)".} ## \
## Returns the nth stashed child of this node.  See get_num_stashed().  Also
## see get_stashed(), if your intention is to iterate through the complete
## list of stashed children; get_stashed() is preferable in this case.

func color*(this: Light): LColor {.importcpp: "#->get_color()".} ## \
## Returns the basic color of the light.

proc `color=`*(this: Light, color: LColor) {.importcpp: "#->set_color(#)".} ## \
## Sets the basic color of the light.

func colorTemperature*(this: Light): float32 {.importcpp: "#->get_color_temperature()".} ## \
## Returns the basic color temperature of the light, assuming
## has_color_temperature() returns true.
##
## @since 1.10.0

proc `colorTemperature=`*(this: Light, temperature: float32) {.importcpp: "#->set_color_temperature(#)".} ## \
## Sets the color temperature of the light in kelvins.  This will recalculate
## the light's color.
##
## The default value is 6500 K, corresponding to a perfectly white light
## assuming a D65 white point.
##
## @since 1.10.0

func priority*(this: Light): int {.importcpp: "#->get_priority()".} ## \
## Returns the priority associated with this light.  See set_priority().

proc `priority=`*(this: Light, priority: int) {.importcpp: "#->set_priority(#)".} ## \
## Changes the relative importance of this light relative to the other lights
## that are applied simultaneously.
##
## The priority number is used to decide which of the requested lights are to
## be selected for rendering when more lights are requested than the hardware
## will support.  The highest-priority n lights are selected for rendering.
##
## This is similar to TextureStage::set_priority().

func cullCallback*(this: CallbackNode): CallbackObject {.importcpp: "#->get_cull_callback()".} ## \
## Returns the CallbackObject set by set_cull_callback().

proc `cullCallback=`*(this: CallbackNode, `object`: CallbackObject) {.importcpp: "#->set_cull_callback(#)".} ## \
## Sets the CallbackObject that will be notified when this node is visited
## during the cull traversal.  This callback will be made during the cull
## thread.
##
## The cull traversal is responsible for determining which nodes are visible
## and within the view frustum, and for accumulating state and transform, and
## generally building up the list of CullableObjects that are to be eventually
## passed to the draw traversal for rendering.
##
## At the time the cull traversal callback is made, the node has been
## determined to be visible and it has passed the bounding-volume test, so it
## lies within the view frustum.
##
## The callback is passed an instance of a NodeCullCallbackData, which
## contains pointers to the CullTraverser and CullTraverserData--enough data
## to examine the current node and its place within the scene graph.  The
## callback \*replaces\* the normal cull behavior, so if your callback does
## nothing, the cull traversal will not continue below this node.  If you wish
## the cull traversal to continue to visit this node and below, you must call
## cbdata->upcall() from your callback.

func drawCallback*(this: CallbackNode): CallbackObject {.importcpp: "#->get_draw_callback()".} ## \
## Returns the CallbackObject set by set_draw_callback().

proc `drawCallback=`*(this: CallbackNode, `object`: CallbackObject) {.importcpp: "#->set_draw_callback(#)".} ## \
## Sets the CallbackObject that will be notified when this node is visited
## during the draw traversal.  This callback will be made during the draw
## thread.
##
## The draw traversal is responsible for actually issuing the commands to the
## graphics engine to draw primitives.  Its job is to walk through the list of
## CullableObjects build up by the cull traversal, as quickly as possible,
## issuing the appropriate commands to draw each one.
##
## At the time the draw traversal callback is made, the graphics state has
## been loaded with the correct modelview transform and render state, and the
## primitives (if any) in this node are ready to be drawn.
##
## The callback is passed an instance of a GeomDrawCallbackData, which
## contains pointers to the current state and transform, as well as the
## current GSG.  There is a Geom pointer as well, but it will always be NULL
## to this callback, since the CallbackNode does not itself contain any Geoms.

func active*(this: Camera): bool {.importcpp: "#->is_active()".} ## \
## Returns the current setting of the active flag on the camera.

proc `active=`*(this: Camera, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets the active flag on the camera.  When the camera is not active, nothing
## will be rendered.

func scene*(this: Camera): NodePath {.importcpp: "#->get_scene()".} ## \
## Returns the scene that will be rendered by the camera.  See set_scene().

proc `scene=`*(this: Camera, scene: NodePath) {.importcpp: "#->set_scene(#)".} ## \
## Sets the scene that will be rendered by the camera.  This is normally the
## root node of a scene graph, typically a node called 'render', although it
## could represent the root of any subgraph.
##
## Note that the use of this method is now deprecated.  In the absence of an
## explicit scene set on the camera, the camera will render whatever scene it
## is parented into.  This is the preferred way to specify the scene, since it
## is the more intuitive mechanism.

func cameraMask*(this: Camera): DrawMask {.importcpp: "#->get_camera_mask()".} ## \
## Returns the set of bits that represent the subset of the scene graph the
## camera will render.  See set_camera_mask().

proc `cameraMask=`*(this: Camera, mask: DrawMask) {.importcpp: "#->set_camera_mask(#)".} ## \
## Changes the set of bits that represent the subset of the scene graph the
## camera will render.
##
## During the cull traversal, a node is not visited if none of its draw mask
## bits intersect with the camera's camera mask bits.  These masks can be used
## to selectively hide and show different parts of the scene graph from
## different cameras that are otherwise viewing the same scene.

func cullCenter*(this: Camera): NodePath {.importcpp: "#->get_cull_center()".} ## \
## Returns the point from which the culling operations will be performed, if
## it was set by set_cull_center(), or the empty NodePath otherwise.

proc `cullCenter=`*(this: Camera, cull_center: NodePath) {.importcpp: "#->set_cull_center(#)".} ## \
## Specifies the point from which the culling operations are performed.
## Normally, this is the same as the camera, and that is the default if this
## is not specified; but it may sometimes be useful to perform the culling
## from some other viewpoint, particularly when you are debugging the culling
## itself.

func cullBounds*(this: Camera): BoundingVolume {.importcpp: "#->get_cull_bounds()".} ## \
## Returns the custom cull volume that was set by set_cull_bounds(), if any,
## or NULL if no custom cull volume was set.

proc `cullBounds=`*(this: Camera, cull_bounds: BoundingVolume) {.importcpp: "#->set_cull_bounds(#)".} ## \
## Specifies the bounding volume that should be used to perform culling from
## this camera.  Normally, this is the bounding volume returned from the
## active lens' make_bounds() call, but you may override this to specify a
## custom volume if you require.  The specified bounding volume will be
## understood to be in the coordinate space of the get_cull_center() node.

func lodCenter*(this: Camera): NodePath {.importcpp: "#->get_lod_center()".} ## \
## Returns the point from which the LOD distances will be measured, if it was
## set by set_lod_center(), or the empty NodePath otherwise.

proc `lodCenter=`*(this: Camera, lod_center: NodePath) {.importcpp: "#->set_lod_center(#)".} ## \
## Specifies the point from which the LOD distances are measured.  Normally,
## this is the same as the camera, and that is the default if this is not
## specified; but it may sometimes be useful to perform the distance test from
## some other viewpoint.  This may be used, for instance, to reduce LOD
## popping when the camera rotates in a small circle about an avatar.

func initialState*(this: Camera): RenderState {.importcpp: "deconstify(#->get_initial_state())", header: deconstifyCode.} ## \
## Returns the initial state as set by a previous call to set_initial_state().

proc `initialState=`*(this: Camera, state: RenderState) {.importcpp: "#->set_initial_state(#)".} ## \
## Sets the initial state which is applied to all nodes in the scene, as if it
## were set at the top of the scene graph.

func tagStateKey*(this: Camera): string {.importcpp: "nimStringFromStdString(#->get_tag_state_key())", header: stringConversionCode.} ## \
## Returns the tag key as set by a previous call to set_tag_state_key().

proc `tagStateKey=`*(this: Camera, tag_state_key: string) {.importcpp: "#->set_tag_state_key(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the tag key which, when encountered as a tag on nodes in the scene
## graph, causes this Camera to apply an arbitrary state transition based on
## the value of the tag (as specified to set_tag_state()).

func lodScale*(this: Camera): float32 {.importcpp: "#->get_lod_scale()".} ## \
## Returns the multiplier for LOD distances.

proc `lodScale=`*(this: Camera, value: float32) {.importcpp: "#->set_lod_scale(#)".} ## \
## Sets the multiplier for LOD distances.  This value is multiplied with the
## LOD scale set on LodNodes.

func shadowCaster*(this: LightLensNode): bool {.importcpp: "#->is_shadow_caster()".} ## \
## Returns whether this light is configured to cast shadows or not.

func shadowBufferSize*(this: LightLensNode): LVecBase2i {.importcpp: "#->get_shadow_buffer_size()".} ## \
## Returns the size of the shadow buffer to be created for this light source.

proc `shadowBufferSize=`*(this: LightLensNode, size: LVecBase2i) {.importcpp: "#->set_shadow_buffer_size(#)".} ## \
## Sets the size of the shadow buffer to be created for this light source.

proc `specularColor=`*(this: DirectionalLight, color: LColor) {.importcpp: "#->set_specular_color(#)".} ## \
## Sets the color of specular highlights generated by the light.

func point*(this: DirectionalLight): LPoint3 {.importcpp: "#->get_point()".} ## \
## Returns the point in space at which the light is located.  This is local to
## the coordinate space in which the light is assigned.
##
## This actually has no bearing on the visual effect of the light, since the
## light is rendered as if it were infinitely far away.  This is only used to
## create a visible representation of the light.

proc `point=`*(this: DirectionalLight, point: LPoint3) {.importcpp: "#->set_point(#)".} ## \
## Sets the point in space at which the light is located.

func direction*(this: DirectionalLight): LVector3 {.importcpp: "#->get_direction()".} ## \
## Returns the direction in which the light is aimed.  This is local to the
## coordinate space in which the light is assigned.

proc `direction=`*(this: DirectionalLight, direction: LVector3) {.importcpp: "#->set_direction(#)".} ## \
## Sets the direction in which the light is aimed.

func lowestSwitch*(this: LODNode): int {.importcpp: "#->get_lowest_switch()".} ## \
## Returns the index number of the child with the lowest level of detail; that
## is, the one that is designed to be seen from the farthest away.  This is
## usually the first child, but it is not necessarily so.

func highestSwitch*(this: LODNode): int {.importcpp: "#->get_highest_switch()".} ## \
## Returns the index number of the child with the highest level of detail;
## that is, the one that is designed to be seen from the closest to the
## camera.  This is usually the last child, but it is not necessarily so.

func lodScale*(this: LODNode): float32 {.importcpp: "#->get_lod_scale()".} ## \
## Returns the multiplier for lod distances

proc `lodScale=`*(this: LODNode, value: float32) {.importcpp: "#->set_lod_scale(#)".} ## \
## Sets the multiplier for lod distances.  A higher value means you'll see
## farther switchs than normal

func center*(this: LODNode): LPoint3 {.importcpp: "#->get_center()".} ## \
## Returns the center of the LOD.  This is the point that is compared to the
## camera (in camera space) to determine the particular LOD that should be
## chosen.

proc `center=`*(this: LODNode, center: LPoint3) {.importcpp: "#->set_center(#)".} ## \
## Specifies the center of the LOD.  This is the point that is compared to the
## camera (in camera space) to determine the particular LOD that should be
## chosen.

func fadeTime*(this: FadeLODNode): float32 {.importcpp: "#->get_fade_time()".} ## \
## get the time taken to complete an LOD switch

proc `fadeTime=`*(this: FadeLODNode, t: float32) {.importcpp: "#->set_fade_time(#)".} ## \
## set the time taken to complete an LOD switch

func fadeBinName*(this: FadeLODNode): string {.importcpp: "nimStringFromStdString(#->get_fade_bin_name())", header: stringConversionCode.} ## \
## Returns the cull bin that is assigned to the fading part of the geometry
## during a transition.

func fadeBinDrawOrder*(this: FadeLODNode): int {.importcpp: "#->get_fade_bin_draw_order()".} ## \
## Returns the draw order that is assigned (along with the bin name) to the
## fading part of the geometry during a transition.

func fadeStateOverride*(this: FadeLODNode): int {.importcpp: "#->get_fade_state_override()".} ## \
## Returns the override value that is applied to the state changes necessary
## to apply the fade effect.  This should be larger than any attrib overrides
## on the fading geometry.

proc `fadeStateOverride=`*(this: FadeLODNode, override: int) {.importcpp: "#->set_fade_state_override(#)".} ## \
## Specifies the override value that is applied to the state changes necessary
## to apply the fade effect.  This should be larger than any attrib overrides
## on the fading geometry.

proc `specularColor=`*(this: PointLight, color: LColor) {.importcpp: "#->set_specular_color(#)".} ## \
## Sets the color of specular highlights generated by the light.

proc `attenuation=`*(this: PointLight, attenuation: LVecBase3) {.importcpp: "#->set_attenuation(#)".} ## \
## Sets the terms of the attenuation equation for the light.  These are, in
## order, the constant, linear, and quadratic terms based on the distance from
## the point to the vertex.

func maxDistance*(this: PointLight): float32 {.importcpp: "#->get_max_distance()".} ## \
## Returns the maximum distance at which the light has any effect, as previously
## specified by set_max_distance.

proc `maxDistance=`*(this: PointLight, max_distance: float32) {.importcpp: "#->set_max_distance(#)".} ## \
## Sets the radius of the light's sphere of influence.  Beyond this distance, the
## light may be attenuated to zero, if this is supported by the shader.

func point*(this: PointLight): LPoint3 {.importcpp: "#->get_point()".} ## \
## Returns the point in space at which the light is located.  This is local to
## the coordinate space in which the light is assigned, and is usually 0.

proc `point=`*(this: PointLight, point: LPoint3) {.importcpp: "#->set_point(#)".} ## \
## Sets the point in space at which the light is located.  Usually 0.

func maxDistance*(this: RectangleLight): float32 {.importcpp: "#->get_max_distance()".} ## \
## Returns the maximum distance at which the light has any effect, as previously
## specified by set_max_distance.

proc `maxDistance=`*(this: RectangleLight, max_distance: float32) {.importcpp: "#->set_max_distance(#)".} ## \
## Sets the radius of the light's sphere of influence.  Beyond this distance, the
## light may be attenuated to zero, if this is supported by the shader.

func playRate*(this: AnimInterface): float64 {.importcpp: "#->get_play_rate()".} ## \
## Returns the rate at which the animation plays.  See set_play_rate().

proc `playRate=`*(this: AnimInterface, play_rate: float64) {.importcpp: "#->set_play_rate(#)".} ## \
## Changes the rate at which the animation plays.  1.0 is the normal speed,
## 2.0 is twice normal speed, and 0.5 is half normal speed.  0.0 is legal to
## pause the animation, and a negative value will play the animation
## backwards.

func frameRate*(this: AnimInterface): float64 {.importcpp: "#->get_frame_rate()".} ## \
## Returns the native frame rate of the animation.  This is the number of
## frames per second that will elapse when the play_rate is set to 1.0.  It is
## a fixed property of the animation and may not be adjusted by the user.

func numFrames*(this: AnimInterface): int {.importcpp: "#->get_num_frames()".} ## \
## Returns the number of frames in the animation.  This is a property of the
## animation and may not be directly adjusted by the user (although it may
## change without warning with certain kinds of animations, since this is a
## virtual method that may be overridden).

func frame*(this: AnimInterface): int {.importcpp: "#->get_frame()".} ## \
## Returns the current integer frame number.  This number will be in the range
## 0 <= f < get_num_frames().

func nextFrame*(this: AnimInterface): int {.importcpp: "#->get_next_frame()".} ## \
## Returns the current integer frame number + 1, constrained to the range 0 <=
## f < get_num_frames().
##
## If the play mode is PM_play, this will clamp to the same value as
## get_frame() at the end of the animation.  If the play mode is any other
## value, this will wrap around to frame 0 at the end of the animation.

func frac*(this: AnimInterface): float64 {.importcpp: "#->get_frac()".} ## \
## Returns the fractional part of the current frame.  Normally, this is in the
## range 0.0 <= f < 1.0, but in the one special case of an animation playing
## to its end frame and stopping, it might exactly equal 1.0.
##
## It will always be true that get_full_frame() + get_frac() ==
## get_full_fframe().

func fullFrame*(this: AnimInterface): int {.importcpp: "#->get_full_frame()".} ## \
## Returns the current integer frame number.
##
## Unlike the value returned by get_frame(), this frame number may extend
## beyond the range of get_num_frames() if the frame range passed to play(),
## loop(), etc.  did.
##
## Unlike the value returned by get_full_fframe(), this return value will
## never exceed the value passed to to_frame in the play() method.

func fullFframe*(this: AnimInterface): float64 {.importcpp: "#->get_full_fframe()".} ## \
## Returns the current floating-point frame number.
##
## Unlike the value returned by get_frame(), this frame number may extend
## beyond the range of get_num_frames() if the frame range passed to play(),
## loop(), etc.  did.
##
## Unlike the value returned by get_full_frame(), this return value may equal
## (to_frame + 1.0), when the animation has played to its natural end.
## However, in this case the return value of get_full_frame() will be
## to_frame, not (to_frame + 1).

func playing*(this: AnimInterface): bool {.importcpp: "#->is_playing()".} ## \
## Returns true if the animation is currently playing, false if it is stopped
## (e.g.  because stop() or pose() was called, or because it reached the end
## of the animation after play() was called).

proc `frameRate=`*(this: SequenceNode, frame_rate: float64) {.importcpp: "#->set_frame_rate(#)".} ## \
## Changes the advertised frame rate of the SequenceNode.  This can be used in
## conjunction with get_play_rate() to change the effective frame rate of the
## node.

func radius*(this: SphereLight): float32 {.importcpp: "#->get_radius()".} ## \
## Returns the radius of the sphere.

proc `radius=`*(this: SphereLight, radius: float32) {.importcpp: "#->set_radius(#)".} ## \
## Sets the radius of the sphere.

proc `exponent=`*(this: Spotlight, exponent: float32) {.importcpp: "#->set_exponent(#)".} ## \
## Sets the exponent that controls the amount of light falloff from the center
## of the spotlight.  The light is attenuated by the cosine of the angle
## between the direction of the light and the direction of the point being
## lighted, raised to the power of this exponent.  Thus, higher exponents
## result in a more focused light source, regardless of the field-of-view of
## the lens.

proc `specularColor=`*(this: Spotlight, color: LColor) {.importcpp: "#->set_specular_color(#)".} ## \
## Sets the color of specular highlights generated by the light.

proc `attenuation=`*(this: Spotlight, attenuation: LVecBase3) {.importcpp: "#->set_attenuation(#)".} ## \
## Sets the terms of the attenuation equation for the light.  These are, in
## order, the constant, linear, and quadratic terms based on the distance from
## the point to the vertex.

func maxDistance*(this: Spotlight): float32 {.importcpp: "#->get_max_distance()".} ## \
## Returns the maximum distance at which the light has any effect, as previously
## specified by set_max_distance.

proc `maxDistance=`*(this: Spotlight, max_distance: float32) {.importcpp: "#->set_max_distance(#)".} ## \
## Sets the radius of the light's sphere of influence.  Beyond this distance, the
## light may be attenuated to zero, if this is supported by the shader.

func visibleChild*(this: SwitchNode): int {.importcpp: "#->get_visible_child()".} ## \
## Returns the index of the child that should be visible.

proc `visibleChild=`*(this: SwitchNode, index: int) {.importcpp: "#->set_visible_child(#)".} ## \
## Specifies the particular child of this node, by index, that will be
## visible.

func uSpeed*(this: UvScrollNode): float32 {.importcpp: "#->get_u_speed()".}

proc `uSpeed=`*(this: UvScrollNode, u_speed: float32) {.importcpp: "#->set_u_speed(#)".}

func vSpeed*(this: UvScrollNode): float32 {.importcpp: "#->get_v_speed()".}

proc `vSpeed=`*(this: UvScrollNode, v_speed: float32) {.importcpp: "#->set_v_speed(#)".}

func wSpeed*(this: UvScrollNode): float32 {.importcpp: "#->get_w_speed()".}

proc `wSpeed=`*(this: UvScrollNode, w_speed: float32) {.importcpp: "#->set_w_speed(#)".}

func rSpeed*(this: UvScrollNode): float32 {.importcpp: "#->get_r_speed()".}

proc `rSpeed=`*(this: UvScrollNode, r_speed: float32) {.importcpp: "#->set_r_speed(#)".}

func cacheRefCount*(this: CachedTypedWritableReferenceCount): int {.importcpp: "#->get_cache_ref_count()".} ## \
## Returns the current reference count.

func pos*(this: TransformState): LPoint3 {.importcpp: "#->get_pos()".} ## \
## Returns the pos component of the transform.  It is an error to call this if
## has_pos() returned false.

func hpr*(this: TransformState): LVecBase3 {.importcpp: "#->get_hpr()".} ## \
## Returns the rotation component of the transform as a trio of Euler angles.
## It is an error to call this if has_components() returned false.

func quat*(this: TransformState): LQuaternion {.importcpp: "#->get_quat()".} ## \
## Returns the rotation component of the transform as a quaternion.  The
## return value will be normalized if a normalized quaternion was given to the
## constructor (or if the quaternion was computed implicitly); it will be non-
## normalized if a non-normalized quaternion was given to the constructor.
## See also get_norm_quat().
##
## It is an error to call this if has_components() returned false.

func normQuat*(this: TransformState): LQuaternion {.importcpp: "#->get_norm_quat()".} ## \
## Returns the rotation component of the transform as a quaternion.  Unlike
## the result of get_quat(), the return value of this method is guaranteed to
## be normalized.  It is an error to call this if has_components() returned
## false.

func scale*(this: TransformState): LVecBase3 {.importcpp: "#->get_scale()".} ## \
## Returns the scale component of the transform.  It is an error to call this
## if has_components() returned false.

func shear*(this: TransformState): LVecBase3 {.importcpp: "#->get_shear()".} ## \
## Returns the shear component of the transform.  It is an error to call this
## if has_components() returned false.

func mat*(this: TransformState): LMatrix4 {.importcpp: "#->get_mat()".} ## \
## Returns the matrix that describes the transform.

func slot*(this: RenderAttrib): int {.importcpp: "#->get_slot()".}

func thickness*(this: RenderModeAttrib): float32 {.importcpp: "#->get_thickness()".} ## \
## Returns the line width or point thickness.  This is only relevant when
## rendering points or lines, such as when the mode is M_wireframe or M_point
## (or when rendering actual points or lines primitives in M_polygon mode).

func perspective*(this: RenderModeAttrib): bool {.importcpp: "#->get_perspective()".} ## \
## Returns the perspective flag.  When this is true, the point thickness
## represented by get_thickness() is actually a width in 3-d units, and the
## points should scale according to perspective.  When it is false, the
## default, the point thickness is actually a width in pixels, and points are
## a uniform size regardless of distance from the camera.

func wireframeColor*(this: RenderModeAttrib): LColor {.importcpp: "#->get_wireframe_color()".} ## \
## Returns the color that is used in M_filled_wireframe mode to distinguish
## the wireframe from the rest of the geometry.

func classSlot*(_: typedesc[RenderModeAttrib]): int {.importcpp: "RenderModeAttrib::get_class_slot()", header: "renderModeAttrib.h".}

func classSlot*(_: typedesc[TexMatrixAttrib]): int {.importcpp: "TexMatrixAttrib::get_class_slot()", header: "texMatrixAttrib.h".}

func referenceAlpha*(this: AlphaTestAttrib): float32 {.importcpp: "#->get_reference_alpha()".} ## \
## Returns the alpha reference value.

func classSlot*(_: typedesc[AlphaTestAttrib]): int {.importcpp: "AlphaTestAttrib::get_class_slot()", header: "alphaTestAttrib.h".}

func mode*(this: AntialiasAttrib): int {.importcpp: "#->get_mode()".} ## \
## Returns the specified antialias mode.

func modeType*(this: AntialiasAttrib): int {.importcpp: "#->get_mode_type()".} ## \
## Returns the specified antialias mode, with the quality bits masked out.
## This therefore indicates only the requested type of antialiasing: M_none,
## M_auto, or some specific combination.

func modeQuality*(this: AntialiasAttrib): int {.importcpp: "#->get_mode_quality()".} ## \
## Returns the specified antialias mode, with the type bits masked out.  This
## therefore indicates only the requested quality settings: one of M_faster,
## M_better, M_dont_care, or zero (unspecified).

func classSlot*(_: typedesc[AntialiasAttrib]): int {.importcpp: "AntialiasAttrib::get_class_slot()", header: "antialiasAttrib.h".}

func classSlot*(_: typedesc[TransparencyAttrib]): int {.importcpp: "TransparencyAttrib::get_class_slot()", header: "transparencyAttrib.h".}

func classSlot*(_: typedesc[LogicOpAttrib]): int {.importcpp: "LogicOpAttrib::get_class_slot()", header: "logicOpAttrib.h".}

func children*(this: NodePath, current_thread: Thread): NodePathCollection {.importcpp: "#.get_children(#)".} ## \
## Returns the set of all child nodes of the referenced node.

func children*(this: NodePath): NodePathCollection {.importcpp: "#.get_children()".} ## \
## Returns the set of all child nodes of the referenced node.

func stashedChildren*(this: NodePath, current_thread: Thread): NodePathCollection {.importcpp: "#.get_stashed_children(#)".} ## \
## Returns the set of all child nodes of the referenced node that have been
## stashed.  These children are not normally visible on the node, and do not
## appear in the list returned by get_children().

func stashedChildren*(this: NodePath): NodePathCollection {.importcpp: "#.get_stashed_children()".} ## \
## Returns the set of all child nodes of the referenced node that have been
## stashed.  These children are not normally visible on the node, and do not
## appear in the list returned by get_children().

func parent*(this: NodePath, current_thread: Thread): NodePath {.importcpp: "#.get_parent(#)".} ## \
## Returns the NodePath to the parent of the referenced node: that is, this
## NodePath, shortened by one node.  The parent of a singleton NodePath is
## defined to be the empty NodePath.

func parent*(this: NodePath): NodePath {.importcpp: "#.get_parent()".} ## \
## Returns the NodePath to the parent of the referenced node: that is, this
## NodePath, shortened by one node.  The parent of a singleton NodePath is
## defined to be the empty NodePath.

func sort*(this: NodePath, current_thread: Thread): int {.importcpp: "#.get_sort(#)".} ## \
## Returns the sort value of the referenced node within its parent; that is,
## the sort number passed on the last reparenting operation for this node.
## This will control the position of the node within its parent's list of
## children.

func sort*(this: NodePath): int {.importcpp: "#.get_sort()".} ## \
## Returns the sort value of the referenced node within its parent; that is,
## the sort number passed on the last reparenting operation for this node.
## This will control the position of the node within its parent's list of
## children.

func name*(this: NodePath): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the referenced node.

proc `name=`*(this: NodePath, name: string) {.importcpp: "#.set_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name of the referenced node.

func volume*(this: AudioVolumeAttrib): float32 {.importcpp: "#->get_volume()".} ## \
## Returns the volume to be applied to sounds.

func classSlot*(_: typedesc[AudioVolumeAttrib]): int {.importcpp: "AudioVolumeAttrib::get_class_slot()", header: "audioVolumeAttrib.h".}

func outputs*(this: AuxBitplaneAttrib): int {.importcpp: "#->get_outputs()".} ## \
## Returns the AuxBitplaneAttrib output bits.

func classSlot*(_: typedesc[AuxBitplaneAttrib]): int {.importcpp: "AuxBitplaneAttrib::get_class_slot()", header: "auxBitplaneAttrib.h".}

func fileStdfloatDouble*(this: BamFile): bool {.importcpp: "#.get_file_stdfloat_double()".} ## \
## Returns true if the file stores all "standard" floats as 64-bit doubles, or
## false if they are 32-bit floats.

func reader*(this: BamFile): BamReader {.importcpp: "#.get_reader()".} ## \
## Returns the BamReader in charge of performing the read operations.  This
## will return NULL unless open_read() was called.

func writer*(this: BamFile): BamWriter {.importcpp: "#.get_writer()".} ## \
## Returns the BamWriter in charge of performing the write operations.  This
## will return NULL unless open_write() was called.

func plane*(this: PlaneNode): LPlane {.importcpp: "#->get_plane()".} ## \
## Returns the plane represented by the PlaneNode.

proc `plane=`*(this: PlaneNode, plane: LPlane) {.importcpp: "#->set_plane(#)".} ## \
## Sets the particular plane represented by the PlaneNode.

func vizScale*(this: PlaneNode): float32 {.importcpp: "#->get_viz_scale()".} ## \
## Returns the size of the visual representation of the plane that is drawn if
## the PlaneNode is shown.

proc `vizScale=`*(this: PlaneNode, viz_scale: float32) {.importcpp: "#->set_viz_scale(#)".} ## \
## Specifies the size of the visual representation of the plane that is drawn
## if the PlaneNode is shown.

func priority*(this: PlaneNode): int {.importcpp: "#->get_priority()".} ## \
## Returns the priority associated with this clip plane.  See set_priority().

proc `priority=`*(this: PlaneNode, priority: int) {.importcpp: "#->set_priority(#)".} ## \
## Changes the relative importance of this PlaneNode (when it is used as a
## clip plane) relative to the other clip planes that are applied
## simultaneously.
##
## The priority number is used to decide which of the requested clip planes
## are to be activated when more clip planes are requested than the hardware
## will support.  The highest-priority n planes are selected for rendering.
##
## This is similar to TextureStage::set_priority().

func clipEffect*(this: PlaneNode): int {.importcpp: "#->get_clip_effect()".} ## \
## Returns the clip_effect bits for this clip plane.  See set_clip_effect().

proc `clipEffect=`*(this: PlaneNode, clip_effect: int) {.importcpp: "#->set_clip_effect(#)".} ## \
## Specifies the sort of things this plane will actually clip (when it is used
## as a clip plane).  This is a bitmask union of ClipEffect values.  If it
## includes CE_visible, then it will clip visible geometry; if it includes
## CE_collision, then it will clip collision polygons.  If it includes neither
## bit, it will still affect culling, but objects will either be wholly behind
## the clipping plane, or wholly present.

func classSlot*(_: typedesc[ClipPlaneAttrib]): int {.importcpp: "ClipPlaneAttrib::get_class_slot()", header: "clipPlaneAttrib.h".}

func color*(this: ColorAttrib): LColor {.importcpp: "#->get_color()".} ## \
## If the type is T_flat or T_off, this returns the color that will be applied
## to geometry.  If the type is T_vertex, this is meaningless.

func classSlot*(_: typedesc[ColorAttrib]): int {.importcpp: "ColorAttrib::get_class_slot()", header: "colorAttrib.h".}

func color*(this: ColorBlendAttrib): LColor {.importcpp: "#->get_color()".} ## \
## Returns the constant color associated with the attrib.

func classSlot*(_: typedesc[ColorBlendAttrib]): int {.importcpp: "ColorBlendAttrib::get_class_slot()", header: "colorBlendAttrib.h".}

func scale*(this: ColorScaleAttrib): LVecBase4 {.importcpp: "#->get_scale()".} ## \
## Returns the scale to be applied to colors.

func classSlot*(_: typedesc[ColorScaleAttrib]): int {.importcpp: "ColorScaleAttrib::get_class_slot()", header: "colorScaleAttrib.h".}

func channels*(this: ColorWriteAttrib): int {.importcpp: "#->get_channels()".} ## \
## Returns the mask of color channels that are enabled by this attrib.

func classSlot*(_: typedesc[ColorWriteAttrib]): int {.importcpp: "ColorWriteAttrib::get_class_slot()", header: "colorWriteAttrib.h".}

func defaultCollideMask*(_: typedesc[GeomNode]): CollideMask {.importcpp: "GeomNode::get_default_collide_mask()", header: "geomNode.h".} ## \
## Returns the default into_collide_mask assigned to new GeomNodes.

func binName*(this: CullBinAttrib): string {.importcpp: "nimStringFromStdString(#->get_bin_name())", header: stringConversionCode.} ## \
## Returns the name of the bin this attribute specifies.  If this is the empty
## string, it refers to the default bin.

func drawOrder*(this: CullBinAttrib): int {.importcpp: "#->get_draw_order()".} ## \
## Returns the draw order this attribute specifies.  Some bins (in particular,
## CullBinFixed bins) use this to further specify the order in which objects
## should be rendered.

func classSlot*(_: typedesc[CullBinAttrib]): int {.importcpp: "CullBinAttrib::get_class_slot()", header: "cullBinAttrib.h".}

func reverse*(this: CullFaceAttrib): bool {.importcpp: "#->get_reverse()".} ## \
## Returns the 'reverse' flag.  If this is true, the actual cull direction
## (clockwise vs.  counterclockwise) is the reverse of what is specified here.
## This allows support for make_reverse(), which defines a CullFaceAttrib that
## reverses whatever the sense of culling would have been.

func classSlot*(_: typedesc[CullFaceAttrib]): int {.importcpp: "CullFaceAttrib::get_class_slot()", header: "cullFaceAttrib.h".}

func color*(this: Fog): LColor {.importcpp: "#->get_color()".} ## \
## Returns the color of the fog.

proc `color=`*(this: Fog, color: LColor) {.importcpp: "#->set_color(#)".} ## \
## Sets the color of the fog.  The alpha component is not used.

proc `color=`*(this: Fog, r: float32, g: float32, b: float32) {.importcpp: "#->set_color(#, #, #)".} ## \
## Sets the color of the fog.

func linearOnsetPoint*(this: Fog): LPoint3 {.importcpp: "#->get_linear_onset_point()".} ## \
## Returns the point in space at which the fog begins.  This is only used if
## the mode is M_linear.

proc `linearOnsetPoint=`*(this: Fog, linear_onset_point: LPoint3) {.importcpp: "#->set_linear_onset_point(#)".} ## \
## Specifies the point in space at which the fog begins.  This is only used if
## the mode is M_linear.

proc `linearOnsetPoint=`*(this: Fog, x: float32, y: float32, z: float32) {.importcpp: "#->set_linear_onset_point(#, #, #)".} ## \
## Specifies the point in space at which the fog begins.  This is only used if
## the mode is M_linear.

func linearOpaquePoint*(this: Fog): LPoint3 {.importcpp: "#->get_linear_opaque_point()".} ## \
## Returns the point in space at which the fog completely obscures geometry.
## This is only used if the mode is M_linear.

proc `linearOpaquePoint=`*(this: Fog, linear_opaque_point: LPoint3) {.importcpp: "#->set_linear_opaque_point(#)".} ## \
## Specifies the point in space at which the fog completely obscures geometry.
## This is only used if the mode is M_linear.

proc `linearOpaquePoint=`*(this: Fog, x: float32, y: float32, z: float32) {.importcpp: "#->set_linear_opaque_point(#, #, #)".} ## \
## Specifies the point in space at which the fog completely obscures geometry.
## This is only used if the mode is M_linear.

func expDensity*(this: Fog): float32 {.importcpp: "#->get_exp_density()".} ## \
## Returns the density of the fog for exponential calculations.  This is only
## used if the mode is not M_linear.

proc `expDensity=`*(this: Fog, exp_density: float32) {.importcpp: "#->set_exp_density(#)".} ## \
## Sets the density of the fog for exponential calculations.  This is only
## used if the mode is not M_linear.
##
## If the mode is currently set to M_linear, this function implicitly sets it
## to M_exponential.

func fog*(this: FogAttrib): Fog {.importcpp: "#->get_fog()".} ## \
## If the FogAttrib is not an 'off' FogAttrib, returns the fog that is
## associated.  Otherwise, return NULL.

func classSlot*(_: typedesc[FogAttrib]): int {.importcpp: "FogAttrib::get_class_slot()", header: "fogAttrib.h".}

func classSlot*(_: typedesc[RescaleNormalAttrib]): int {.importcpp: "RescaleNormalAttrib::get_class_slot()", header: "rescaleNormalAttrib.h".}

func offset*(this: DepthOffsetAttrib): int {.importcpp: "#->get_offset()".} ## \
## Returns the depth offset represented by this attrib.

func minValue*(this: DepthOffsetAttrib): float32 {.importcpp: "#->get_min_value()".} ## \
## Returns the value for the minimum (closest) depth value to be stored in the
## buffer, in the range 0 .. 1.

func maxValue*(this: DepthOffsetAttrib): float32 {.importcpp: "#->get_max_value()".} ## \
## Returns the value for the maximum (farthest) depth value to be stored in
## the buffer, in the range 0 .. 1.

func classSlot*(_: typedesc[DepthOffsetAttrib]): int {.importcpp: "DepthOffsetAttrib::get_class_slot()", header: "depthOffsetAttrib.h".}

func classSlot*(_: typedesc[DepthTestAttrib]): int {.importcpp: "DepthTestAttrib::get_class_slot()", header: "depthTestAttrib.h".}

func classSlot*(_: typedesc[DepthWriteAttrib]): int {.importcpp: "DepthWriteAttrib::get_class_slot()", header: "depthWriteAttrib.h".}

func classSlot*(_: typedesc[LightAttrib]): int {.importcpp: "LightAttrib::get_class_slot()", header: "lightAttrib.h".}

func classSlot*(_: typedesc[LightRampAttrib]): int {.importcpp: "LightRampAttrib::get_class_slot()", header: "lightRampAttrib.h".}

func material*(this: MaterialAttrib): Material {.importcpp: "#->get_material()".} ## \
## If the MaterialAttrib is not an 'off' MaterialAttrib, returns the material
## that is associated.  Otherwise, return NULL.

func classSlot*(_: typedesc[MaterialAttrib]): int {.importcpp: "MaterialAttrib::get_class_slot()", header: "materialAttrib.h".}

func doneEvent*(this: AsyncFuture): string {.importcpp: "nimStringFromStdString(#->get_done_event())", header: stringConversionCode.} ## \
## Returns the event name that will be triggered when the future finishes.
## See set_done_event().

proc `doneEvent=`*(this: AsyncFuture, done_event: string) {.importcpp: "#->set_done_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the event name that will be triggered when the future finishes.  Will
## not be triggered if the future is cancelled, but it will be triggered for
## a coroutine task that exits with an exception.

func alive*(this: AsyncTask): bool {.importcpp: "#->is_alive()".} ## \
## Returns true if the task is currently active or sleeping on some task
## chain, meaning that it will be executed in its turn, or false if it is not
## active.  If the task has recently been removed while it is in the middle of
## execution, this will return false, because the task will not run again once
## it finishes.

func manager*(this: AsyncTask): AsyncTaskManager {.importcpp: "#->get_manager()".} ## \
## Returns the AsyncTaskManager that this task is active on.  This will be
## NULL if the state is S_inactive.

proc `name=`*(this: AsyncTask, name: string) {.importcpp: "#->set_name(nimStringToStdString(#))", header: stringConversionCode.}

func id*(this: AsyncTask): int {.importcpp: "#->get_task_id()".} ## \
## Returns a number guaranteed to be unique for each different AsyncTask
## object in the universe.

func taskChain*(this: AsyncTask): string {.importcpp: "nimStringFromStdString(#->get_task_chain())", header: stringConversionCode.} ## \
## Returns the AsyncTaskChain on which this task will be running.  Each task
## chain runs tasks independently of the others.

proc `taskChain=`*(this: AsyncTask, chain_name: string) {.importcpp: "#->set_task_chain(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the AsyncTaskChain on which this task will be running.  Each task
## chain runs tasks independently of the others.

func sort*(this: AsyncTask): int {.importcpp: "#->get_sort()".} ## \
## Returns the task's current sort value.  See set_sort().

proc `sort=`*(this: AsyncTask, sort: int) {.importcpp: "#->set_sort(#)".} ## \
## Specifies a sort value for this task.  Within a given AsyncTaskManager, all
## of the tasks with a given sort value are guaranteed to be completed before
## any tasks with a higher sort value are begun.
##
## To put it another way, two tasks might execute in parallel with each other
## only if they both have the same sort value.  Tasks with a lower sort value
## are executed first.
##
## This is different from the priority, which makes no such exclusion
## guarantees.

func priority*(this: AsyncTask): int {.importcpp: "#->get_priority()".} ## \
## Returns the task's current priority value.  See set_priority().

proc `priority=`*(this: AsyncTask, priority: int) {.importcpp: "#->set_priority(#)".} ## \
## Specifies a priority value for this task.  In general, tasks with a higher
## priority value are executed before tasks with a lower priority value (but
## only for tasks with the same sort value).
##
## Unlike the sort value, tasks with different priorities may execute at the
## same time, if the AsyncTaskManager has more than one thread servicing
## tasks.
##
## Also see AsyncTaskChain::set_timeslice_priority(), which changes the
## meaning of this value.  In the default mode, when the timeslice_priority
## flag is false, all tasks always run once per epoch, regardless of their
## priority values (that is, the priority controls the order of the task
## execution only, not the number of times it runs).  On the other hand, if
## you set the timeslice_priority flag to true, then changing a task's
## priority has an effect on the number of times it runs.

proc `doneEvent=`*(this: AsyncTask, done_event: string) {.importcpp: "#->set_done_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the event name that will be triggered when the task finishes.  This
## should only be called before the task has been started, or after it has
## finished and before it is about to be restarted (i.e.  when get_state()
## returns S_inactive).

func dt*(this: AsyncTask): float64 {.importcpp: "#->get_dt()".} ## \
## Returns the amount of time elapsed during the task's previous run cycle, in
## seconds.

func maxDt*(this: AsyncTask): float64 {.importcpp: "#->get_max_dt()".} ## \
## Returns the maximum amount of time elapsed during any one of the task's
## previous run cycles, in seconds.

func averageDt*(this: AsyncTask): float64 {.importcpp: "#->get_average_dt()".} ## \
## Returns the average amount of time elapsed during each of the task's
## previous run cycles, in seconds.

func orig*(this: ModelFlattenRequest): PandaNode {.importcpp: "#->get_orig()".} ## \
## Returns the original, unflattened node.

func filename*(this: ModelLoadRequest): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the filename associated with this asynchronous ModelLoadRequest.

func options*(this: ModelLoadRequest): LoaderOptions {.importcpp: "#->get_options()".} ## \
## Returns the LoaderOptions associated with this asynchronous
## ModelLoadRequest.

func loader*(this: ModelLoadRequest): Loader {.importcpp: "#->get_loader()".} ## \
## Returns the Loader object associated with this asynchronous
## ModelLoadRequest.

func modelRefCount*(this: ModelRoot): int {.importcpp: "#->get_model_ref_count()".} ## \
## Returns the number of copies that exist of this particular ModelRoot node.
## Each time ModelRoot::copy_subgraph() or make_copy() is called (or some
## other copying mechanism, such as NodePath.copy_to(), is used), this count
## will increment by one in all copies; when one of the copies is destructed,
## this count will decrement.

func fullpath*(this: ModelRoot): Filename {.importcpp: "#->get_fullpath()".} ## \
## Returns the full pathname of the model represented by this node, as found
## on disk.  This is mainly useful for reference purposes, but is also used to
## index the ModelRoot into the ModelPool.

proc `fullpath=`*(this: ModelRoot, fullpath: Filename) {.importcpp: "#->set_fullpath(#)".} ## \
## Sets the full pathname of the model represented by this node, as found on
## disk.  This is mainly useful for reference purposes, but is also used to
## index the ModelRoot into the ModelPool.
##
## This is normally set automatically when a model is loaded, and should not
## be set directly by the user.  If you change this on a loaded model, then
## ModelPool::release_model() may fail.

func timestamp*(this: ModelRoot): time_t.Time {.importcpp: "#->get_timestamp()".} ## \
## Returns the timestamp of the file on disk that was read for this model, at
## the time it was read, if it is known.  Returns 0 if the timestamp is not
## known or could not be provided.  This can be used as a quick (but fallible)
## check to verify whether the file might have changed since the model was
## read.

proc `timestamp=`*(this: ModelRoot, timestamp: time_t.Time) {.importcpp: "#->set_timestamp(#)".} ## \
## Sets the timestamp of the file on disk that was read for this model.  This
## is normally set automatically when a model is loaded, and should not be set
## directly by the user.

func filename*(this: ModelSaveRequest): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the filename associated with this asynchronous ModelSaveRequest.

func options*(this: ModelSaveRequest): LoaderOptions {.importcpp: "#->get_options()".} ## \
## Returns the LoaderOptions associated with this asynchronous
## ModelSaveRequest.

func node*(this: ModelSaveRequest): PandaNode {.importcpp: "#->get_node()".} ## \
## Returns the node that was passed to the constructor.

func loader*(this: ModelSaveRequest): Loader {.importcpp: "#->get_loader()".} ## \
## Returns the Loader object associated with this asynchronous
## ModelSaveRequest.

func classSlot*(_: typedesc[TextureAttrib]): int {.importcpp: "TextureAttrib::get_class_slot()", header: "textureAttrib.h".}

func classSlot*(_: typedesc[TexGenAttrib]): int {.importcpp: "TexGenAttrib::get_class_slot()", header: "texGenAttrib.h".}

func doubleSided*(this: OccluderNode): bool {.importcpp: "#->is_double_sided()".} ## \
## Is this occluder double-sided

proc `doubleSided=`*(this: OccluderNode, value: bool) {.importcpp: "#->set_double_sided(#)".} ## \
## If true, the back-face will also be used to occlude

func minCoverage*(this: OccluderNode): float32 {.importcpp: "#->get_min_coverage()".} ## \
## Returns the minimum screen coverage.

proc `minCoverage=`*(this: OccluderNode, value: float32) {.importcpp: "#->set_min_coverage(#)".} ## \
## Minimum screen coverage needed before occluder used.  Range should be 0 to
## 1. For example, setting to 0.2 would mean that the occluder needs to cover
## 20% of the screen to be considered.

func shader*(this: ShaderAttrib): Shader {.importcpp: "deconstify(#->get_shader())", header: deconstifyCode.} ## \
## Returns the shader object associated with the node.  If get_override
## returns true, but get_shader returns NULL, that means that this attribute
## should disable the shader.

func instanceCount*(this: ShaderAttrib): int {.importcpp: "#->get_instance_count()".} ## \
## Returns the number of geometry instances.  A value of 0 means not to use
## instancing at all.

func classSlot*(_: typedesc[ShaderAttrib]): int {.importcpp: "ShaderAttrib::get_class_slot()", header: "shaderAttrib.h".}

func intoPortalMask*(this: PortalNode): PortalMask {.importcpp: "#->get_into_portal_mask()".} ## \
## Returns the current "into" PortalMask.  In order for a portal to be
## detected from another object into this object, the intersection of the
## other object's "from" mask and this object's "into" mask must be nonzero.

proc `intoPortalMask=`*(this: PortalNode, mask: PortalMask) {.importcpp: "#->set_into_portal_mask(#)".} ## \
## Sets the "into" PortalMask.  In order for a portal to be detected from
## another object into this object, the intersection of the other object's
## "from" mask and this object's "into" mask must be nonzero.

func fromPortalMask*(this: PortalNode): PortalMask {.importcpp: "#->get_from_portal_mask()".} ## \
## Returns the current "from" PortalMask.  In order for a portal to be
## detected from this object into another object, the intersection of this
## object's "from" mask and the other object's "into" mask must be nonzero.

proc `fromPortalMask=`*(this: PortalNode, mask: PortalMask) {.importcpp: "#->set_from_portal_mask(#)".} ## \
## Sets the "from" PortalMask.  In order for a portal to be detected from this
## object into another object, the intersection of this object's "from" mask
## and the other object's "into" mask must be nonzero.

func portalGeom*(this: PortalNode): bool {.importcpp: "#->get_portal_geom()".} ## \
## Returns the current state of the portal_geom flag.  See set_portal_geom().

proc `portalGeom=`*(this: PortalNode, flag: bool) {.importcpp: "#->set_portal_geom(#)".} ## \
## Sets the state of the "portal geom" flag for this PortalNode.  Normally,
## this is false; when this is set true, the PortalSolids in this node will
## test for portals with actual renderable geometry, in addition to whatever
## PortalSolids may be indicated by the from_portal_mask.
##
## Setting this to true causes this to test \*all\* GeomNodes for portals.  It
## is an all-or-none thing; there is no way to portal with only some
## GeomNodes, as GeomNodes have no into_portal_mask.

func cellIn*(this: PortalNode): NodePath {.importcpp: "#->get_cell_in()".} ## \
## Sets the cell that this portal belongs to

proc `cellIn=`*(this: PortalNode, cell: NodePath) {.importcpp: "#->set_cell_in(#)".} ## \
## Sets the cell that this portal belongs to

func cellOut*(this: PortalNode): NodePath {.importcpp: "#->get_cell_out()".} ## \
## Sets the cell that this portal leads out to

proc `cellOut=`*(this: PortalNode, cell: NodePath) {.importcpp: "#->set_cell_out(#)".} ## \
## Sets the cell that this portal leads out to

func clipPlane*(this: PortalNode): bool {.importcpp: "#->is_clip_plane()".} ## \
## Is this portal clipping against its left-right planes

proc `clipPlane=`*(this: PortalNode, value: bool) {.importcpp: "#->set_clip_plane(#)".} ## \
## this is set if the portal will clip against its left and right planes

func visible*(this: PortalNode): bool {.importcpp: "#->is_visible()".} ## \
## Is this portal facing the camera

proc `visible=`*(this: PortalNode, value: bool) {.importcpp: "#->set_visible(#)".} ## \
## this is set if the portal is facing camera

func maxDepth*(this: PortalNode): int {.importcpp: "#->get_max_depth()".} ## \
## Returns the maximum depth this portal will be visible at

proc `maxDepth=`*(this: PortalNode, value: int) {.importcpp: "#->set_max_depth(#)".} ## \
## Set the maximum depth this portal will be visible at

func open*(this: PortalNode): bool {.importcpp: "#->is_open()".} ## \
## Is this portal open from current camera zone

proc `open=`*(this: PortalNode, value: bool) {.importcpp: "#->set_open(#)".} ## \
## Python sets this based on curent camera zone

func frame*(this: ScissorAttrib): LVecBase4 {.importcpp: "#->get_frame()".} ## \
## Returns the left, right, bottom, top coordinates of the scissor frame.
## This defines a frame within the current DisplayRegion, where 0,0 is the
## lower-left corner of the DisplayRegion, and 1,1 is the upper-right corner.

func classSlot*(_: typedesc[ScissorAttrib]): int {.importcpp: "ScissorAttrib::get_class_slot()", header: "scissorAttrib.h".}

func classSlot*(_: typedesc[ShadeModelAttrib]): int {.importcpp: "ShadeModelAttrib::get_class_slot()", header: "shadeModelAttrib.h".}

func classSlot*(_: typedesc[StencilAttrib]): int {.importcpp: "StencilAttrib::get_class_slot()", header: "stencilAttrib.h".}

func filename*(this: MovieAudio): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the movie's filename.  A movie is not guaranteed to have a
## filename, if not, then this function returns a null filename.

func filename*(this: MovieVideo): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the movie's filename.  A movie is not guaranteed to have a
## filename, if not, then this function returns an empty filename.

func subfileInfo*(this: MovieVideo): SubfileInfo {.importcpp: "#->get_subfile_info()".} ## \
## If the movie is to be loaded from a subfile on disk, this returns the
## subfile info.  Check info.is_empty() to see if this is valid data.

func channels*(this: MicrophoneAudio): int {.importcpp: "#->get_channels()".} ## \
## Returns the number of channels.

func rate*(this: MicrophoneAudio): int {.importcpp: "#->get_rate()".} ## \
## Returns the sample rate.

func font*(this: TextProperties): TextFont {.importcpp: "#.get_font()".} ## \
## Returns the font currently in use, if any.  If no font is in use, this
## returns the default font.

proc `font=`*(this: TextProperties, font: TextFont) {.importcpp: "#.set_font(#)".} ## \
## Sets the font that will be used when making text.  If this is set to NULL,
## the default font will be used, which can be set via set_default_font().

func smallCaps*(this: TextProperties): bool {.importcpp: "#.get_small_caps()".} ## \
## Returns the small_caps flag.  See set_small_caps().

proc `smallCaps=`*(this: TextProperties, small_caps: bool) {.importcpp: "#.set_small_caps(#)".} ## \
## Sets the small_caps flag.  When this is set, lowercase letters are
## generated as scaled-down versions of their uppercase equivalents.  This is
## particularly useful to set for fonts that do not have lowercase letters.
##
## It is also a good idea to set this for a (dynamic) font that has already
## implemented lowercase letters as scaled-down versions of their uppercase
## equivalents, since without this flag the texture memory may needlessly
## duplicate equivalent glyphs for upper and lowercase letters.  Setting this
## flag causes the texture memory to share the mixed-case letters.
##
## The amount by which the lowercase letters are scaled is specified by
## set_small_caps_scale().

func smallCapsScale*(this: TextProperties): float32 {.importcpp: "#.get_small_caps_scale()".} ## \
## Returns the scale factor applied to lowercase letters from their uppercase
## equivalents, when the small_caps flag is in effect.  See set_small_caps()
## and set_small_caps_scale().

proc `smallCapsScale=`*(this: TextProperties, small_caps_scale: float32) {.importcpp: "#.set_small_caps_scale(#)".} ## \
## Sets the scale factor applied to lowercase letters from their uppercase
## equivalents, when the small_caps flag is in effect.  See set_small_caps().
## Normally, this will be a number less than one.

func slant*(this: TextProperties): float32 {.importcpp: "#.get_slant()".} ## \
## Returns the factor by which the text is specified to slant to the right.

proc `slant=`*(this: TextProperties, slant: float32) {.importcpp: "#.set_slant(#)".} ## \
## Specifies the factor by which the text slants to the right.

func underscore*(this: TextProperties): bool {.importcpp: "#.get_underscore()".} ## \
## Returns the underscore flag.  See set_underscore().

proc `underscore=`*(this: TextProperties, underscore: bool) {.importcpp: "#.set_underscore(#)".} ## \
## Sets the underscore flag.  When this is set, the text is underscored with a
## one-pixel line the same color as the text foreground, drawn at the
## baseline.

func underscoreHeight*(this: TextProperties): float32 {.importcpp: "#.get_underscore_height()".} ## \
## Returns the vertical height of the underscore; see set_underscore_height().

proc `underscoreHeight=`*(this: TextProperties, underscore_height: float32) {.importcpp: "#.set_underscore_height(#)".} ## \
## Specifies the vertical height of the underscore, relative to the text
## baseline.  This only has meaning if the underscore mode is enabled with
## set_underscore().

func indent*(this: TextProperties): float32 {.importcpp: "#.get_indent()".}

proc `indent=`*(this: TextProperties, indent: float32) {.importcpp: "#.set_indent(#)".} ## \
## Specifies the amount of extra space that is inserted before the first
## character of each line.  This can be thought of as a left margin.

func wordwrap*(this: TextProperties): float32 {.importcpp: "#.get_wordwrap()".}

proc `wordwrap=`*(this: TextProperties, wordwrap: float32) {.importcpp: "#.set_wordwrap(#)".} ## \
## Sets the text up to automatically wordwrap when it exceeds the indicated
## width.  This can be thought of as a right margin or margin width.

func preserveTrailingWhitespace*(this: TextProperties): bool {.importcpp: "#.get_preserve_trailing_whitespace()".} ## \
## Returns the preserve_trailing_whitespace flag.  See
## set_preserve_trailing_whitespace().

proc `preserveTrailingWhitespace=`*(this: TextProperties, preserve_trailing_whitespace: bool) {.importcpp: "#.set_preserve_trailing_whitespace(#)".} ## \
## Sets the preserve_trailing_whitespace flag.  When this is set, trailing
## whitespace at the end of the line is not stripped when the text is
## wordwrapped (it is stripped by default).  Since the trailing whitespace is
## invisible, this is important primarily for determining the proper width of
## a frame or card behind the text.

func textColor*(this: TextProperties): LColor {.importcpp: "#.get_text_color()".}

proc `textColor=`*(this: TextProperties, text_color: LColor) {.importcpp: "#.set_text_color(#)".}

proc `textColor=`*(this: TextProperties, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_text_color(#, #, #, #)".}

func shadowColor*(this: TextProperties): LColor {.importcpp: "#.get_shadow_color()".}

proc `shadowColor=`*(this: TextProperties, shadow_color: LColor) {.importcpp: "#.set_shadow_color(#)".}

proc `shadowColor=`*(this: TextProperties, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_shadow_color(#, #, #, #)".}

func shadow*(this: TextProperties): LVector2 {.importcpp: "#.get_shadow()".} ## \
## Returns the offset of the shadow as set by set_shadow().  It is an error to
## call this if has_shadow() is false.

proc `shadow=`*(this: TextProperties, shadow_offset: LVecBase2) {.importcpp: "#.set_shadow(#)".} ## \
## Specifies that the text should be drawn with a shadow, by creating a second
## copy of the text and offsetting it slightly behind the first.

proc `shadow=`*(this: TextProperties, xoffset: float32, yoffset: float32) {.importcpp: "#.set_shadow(#, #)".} ## \
## Specifies that the text should be drawn with a shadow, by creating a second
## copy of the text and offsetting it slightly behind the first.

func bin*(this: TextProperties): string {.importcpp: "nimStringFromStdString(#.get_bin())", header: stringConversionCode.} ## \
## Returns the drawing bin set with set_bin(), or empty string if no bin has
## been set.

proc `bin=`*(this: TextProperties, bin: string) {.importcpp: "#.set_bin(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Names the CullBin that the text geometry should be assigned to.  If this is
## set, then a CullBinAttrib will be created to explicitly place each
## component in the named bin.
##
## The draw_order value will also be passed to each CullBinAttrib as
## appropriate; this is particularly useful if this names a CullBinFixed, e.g.
## "fixed".

func drawOrder*(this: TextProperties): int {.importcpp: "#.get_draw_order()".} ## \
## Returns the drawing order set with set_draw_order().

proc `drawOrder=`*(this: TextProperties, draw_order: int): int {.importcpp: "#.set_draw_order(#)".} ## \
## Sets the drawing order of text created by the TextNode.  This is actually
## the draw order of the card and frame.  The shadow is drawn at
## _draw_order+1, and the text at _draw_order+2.
##
## This affects the sorting order assigned to the nodes as they are created,
## and also is passed to whatever bin may be assigned via set_bin().
##
## The return value is the first unused draw_order number, e.g.  _draw_order +
## 3.

func tabWidth*(this: TextProperties): float32 {.importcpp: "#.get_tab_width()".} ## \
## Returns the width set via set_tab_width().

proc `tabWidth=`*(this: TextProperties, tab_width: float32) {.importcpp: "#.set_tab_width(#)".} ## \
## Sets the width of each tab stop, in screen units.  A tab character embedded
## in the text will advance the horizontal position to the next tab stop.

func glyphScale*(this: TextProperties): float32 {.importcpp: "#.get_glyph_scale()".} ## \
## Returns the scale factor of each letter as specified by set_glyph_scale().

proc `glyphScale=`*(this: TextProperties, glyph_scale: float32) {.importcpp: "#.set_glyph_scale(#)".} ## \
## Specifies the factor by which to scale each letter of the text as it is
## placed, in addition to any scales inherited from the node or from
## set_text_scale(). This can be used (possibly in conjunction with
## set_glyph_shift()) to implement superscripting or subscripting.
##
## The glyph scale is cumulative when applied to nested TextProperties.  It is
## intended primarily for implementing superscripts, not for scaling the text
## in general.  See also set_text_scale(), which is intended primarily for
## scaling the text in general, and is not cumulative.

func glyphShift*(this: TextProperties): float32 {.importcpp: "#.get_glyph_shift()".} ## \
## Returns the vertical shift of each letter as specified by
## set_glyph_shift().

proc `glyphShift=`*(this: TextProperties, glyph_shift: float32) {.importcpp: "#.set_glyph_shift(#)".} ## \
## Specifies a vertical amount to shift each letter of the text as it is
## placed.  This can be used (possibly in conjunction with set_glyph_scale())
## to implement superscripting or subscripting.

func textScale*(this: TextProperties): float32 {.importcpp: "#.get_text_scale()".} ## \
## Returns the scale factor of the text as specified by set_text_scale().

proc `textScale=`*(this: TextProperties, text_scale: float32) {.importcpp: "#.set_text_scale(#)".} ## \
## Specifies the factor by which to scale the text, in addition to any
## scalings imposed by the node, as well as in addition to the glyph scale.
##
## The text scale is not cumulative when applied to nested TextProperties.
## See also set_glyph_scale(), which is cumulative.

func maxRows*(this: TextNode): int {.importcpp: "#->get_max_rows()".} ## \
## Returns the limit on the height of the TextNode specified by
## set_max_rows().

proc `maxRows=`*(this: TextNode, max_rows: int) {.importcpp: "#->set_max_rows(#)".} ## \
## Sets the maximum number of rows that may be formatted by the TextNode.  If
## more text than this is attempted, it will be truncated and has_overflow()
## will return true.

func frameColor*(this: TextNode): LColor {.importcpp: "#->get_frame_color()".}

proc `frameColor=`*(this: TextNode, frame_color: LColor) {.importcpp: "#->set_frame_color(#)".}

proc `frameColor=`*(this: TextNode, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#->set_frame_color(#, #, #, #)".}

func cardColor*(this: TextNode): LColor {.importcpp: "#->get_card_color()".}

proc `cardColor=`*(this: TextNode, card_color: LColor) {.importcpp: "#->set_card_color(#)".}

proc `cardColor=`*(this: TextNode, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#->set_card_color(#, #, #, #)".}

func cardTexture*(this: TextNode): Texture {.importcpp: "#->get_card_texture()".}

proc `cardTexture=`*(this: TextNode, card_texture: Texture) {.importcpp: "#->set_card_texture(#)".}

func frameLineWidth*(this: TextNode): float32 {.importcpp: "#->get_frame_line_width()".} ## \
## Returns the thickness of the lines that will be used to draw the frame.

proc `frameLineWidth=`*(this: TextNode, line_width: float32) {.importcpp: "#->set_frame_line_width(#)".} ## \
## Specifies the thickness of the lines that will be used to draw the frame.

func frameCorners*(this: TextNode): bool {.importcpp: "#->get_frame_corners()".}

proc `frameCorners=`*(this: TextNode, corners: bool) {.importcpp: "#->set_frame_corners(#)".} ## \
## Enables or disables the drawing of corners for the frame.  These are extra
## points drawn at each of the four corners, to soften the ugly edges
## generated when the line width is greater than one.

func transform*(this: TextNode): LMatrix4 {.importcpp: "#->get_transform()".}

proc `transform=`*(this: TextNode, transform: LMatrix4) {.importcpp: "#->set_transform(#)".} ## \
## Sets an additional transform that is applied to the entire text paragraph.

func coordinateSystem*(this: TextNode): CoordinateSystem {.importcpp: "#->get_coordinate_system()".}

proc `coordinateSystem=`*(this: TextNode, cs: CoordinateSystem) {.importcpp: "#->set_coordinate_system(#)".} ## \
## Specifies the coordinate system in which the text will be generated.

func flattenFlags*(this: TextNode): int {.importcpp: "#->get_flatten_flags()".} ## \
## Returns the flatten flags.  See set_flatten_flags().

proc `flattenFlags=`*(this: TextNode, flatten_flags: int) {.importcpp: "#->set_flatten_flags(#)".} ## \
## Sets the flatten flags.  This should be a union of the
## TextNode::FlattenFlags options.  This controls the degree of flattening
## performed on the TextNode's internal geometry (i.e.  the scene graph
## returned by generate()) each time the text is changed.  In general, more
## flattening means a more optimal result, but it will take more time to
## generate.
##
## The choice may be any of these three:
##
## FF_none - No flatten operation is called.  The letters are left as
## independent Geoms.
##
## FF_light - A flatten_light() operation is called.  The attributes are
## applied to the vertices, but no nodes are removed.
##
## FF_medium - A flatten_medium() operation is called.  The attributes are
## applied to the vertices, and a few trivial nodes are removed.
##
## FF_strong - A flatten_strong() operation is called.  The attributes are
## applied to the vertices, and the resulting nodes are aggressively combined
## into as few nodes as possible.
##
## In addition to the above choices, you may optionally include the following
## flag:
##
## FF_dynamic_merge - Copy the geoms into a single GeomVertexData as we go,
## instead of relying on the flatten operation at the end.  This pre-flattens
## the text considerably, and may obviate the need for flatten altogether; it
## also tends to improve performance considerably even if you do call flatten.
## However, it is not as fast as not calling flatten at all.
##
## The default is taken from the text-flatten and text-dynamic-merge config
## variables.

proc `font=`*(this: TextNode, font: TextFont) {.importcpp: "#->set_font(#)".} ## \
## Sets the font that will be used when making text.  If this is set to NULL,
## the default font will be used, which can be set via set_default_font().

proc `smallCaps=`*(this: TextNode, small_caps: bool) {.importcpp: "#->set_small_caps(#)".} ## \
## Sets the small_caps flag.  When this is set, lowercase letters are
## generated as scaled-down versions of their uppercase equivalents.  This is
## particularly useful to set for fonts that do not have lowercase letters.
##
## It is also a good idea to set this for a (dynamic) font that has already
## implemented lowercase letters as scaled-down versions of their uppercase
## equivalents, since without this flag the texture memory may needlessly
## duplicate equivalent glyphs for upper and lowercase letters.  Setting this
## flag causes the texture memory to share the mixed-case letters.
##
## The amount by which the lowercase letters are scaled is specified by
## set_small_caps_scale().

proc `smallCapsScale=`*(this: TextNode, small_caps_scale: float32) {.importcpp: "#->set_small_caps_scale(#)".} ## \
## Sets the scale factor applied to lowercase letters from their uppercase
## equivalents, when the small_caps flag is in effect.  See set_small_caps().
## Normally, this will be a number less than one.

proc `slant=`*(this: TextNode, slant: float32) {.importcpp: "#->set_slant(#)".}

proc `indent=`*(this: TextNode, indent: float32) {.importcpp: "#->set_indent(#)".} ## \
## Specifies the amount of extra space that is inserted before the first
## character of each line.  This can be thought of as a left margin.

proc `wordwrap=`*(this: TextNode, wordwrap: float32) {.importcpp: "#->set_wordwrap(#)".} ## \
## Sets the text up to automatically wordwrap when it exceeds the indicated
## width.  This can be thought of as a right margin or margin width.

proc `textColor=`*(this: TextNode, text_color: LColor) {.importcpp: "#->set_text_color(#)".}

proc `textColor=`*(this: TextNode, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#->set_text_color(#, #, #, #)".}

proc `shadowColor=`*(this: TextNode, shadow_color: LColor) {.importcpp: "#->set_shadow_color(#)".}

proc `shadowColor=`*(this: TextNode, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#->set_shadow_color(#, #, #, #)".}

proc `shadow=`*(this: TextNode, shadow_offset: LVecBase2) {.importcpp: "#->set_shadow(#)".} ## \
## Specifies that the text should be drawn with a shadow, by creating a second
## copy of the text and offsetting it slightly behind the first.

proc `shadow=`*(this: TextNode, xoffset: float32, yoffset: float32) {.importcpp: "#->set_shadow(#, #)".} ## \
## Specifies that the text should be drawn with a shadow, by creating a second
## copy of the text and offsetting it slightly behind the first.

proc `bin=`*(this: TextNode, bin: string) {.importcpp: "#->set_bin(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Names the GeomBin that the TextNode geometry should be assigned to.  If
## this is set, then a GeomBinTransition will be created to explicitly place
## each component in the named bin.
##
## The draw_order value will also be passed to each GeomBinTransition as
## appropriate; this is particularly useful if this names a GeomBinFixed, e.g.
## "fixed".

proc `drawOrder=`*(this: TextNode, draw_order: int): int {.importcpp: "#->set_draw_order(#)".} ## \
## Sets the drawing order of text created by the TextMaker.  This is actually
## the draw order of the card and frame.  The shadow is drawn at
## _draw_order+1, and the text at _draw_order+2.
##
## This affects the sorting order assigned to the arcs as they are created,
## and also is passed to whatever bin may be assigned via set_bin().
##
## The return value is the first unused draw_order number, e.g.  _draw_order +
## 3.

proc `tabWidth=`*(this: TextNode, tab_width: float32) {.importcpp: "#->set_tab_width(#)".} ## \
## Sets the width of each tab stop, in screen units.  A tab character embedded
## in the text will advance the horizontal position to the next tab stop.

proc `glyphScale=`*(this: TextNode, glyph_scale: float32) {.importcpp: "#->set_glyph_scale(#)".} ## \
## Specifies the factor by which to scale each letter of the text as it is
## placed.  This can be used (possibly in conjunction with set_glyph_shift())
## to implement superscripting or subscripting.

proc `glyphShift=`*(this: TextNode, glyph_shift: float32) {.importcpp: "#->set_glyph_shift(#)".} ## \
## Specifies a vertical amount to shift each letter of the text as it is
## placed.  This can be used (possibly in conjunction with set_glyph_scale())
## to implement superscripting or subscripting.

func clearColor*(this: Texture): LColor {.importcpp: "#->get_clear_color()".} ## \
## Returns the color that was previously set using set_clear_color.

proc `clearColor=`*(this: Texture, color: LColor) {.importcpp: "#->set_clear_color(#)".} ## \
## Sets the color that will be used to fill the texture image in absence of
## any image data.  It is used when any of the setup_texture functions or
## clear_image is called and image data is not provided using read() or
## modify_ram_image().
##
## This does not affect a texture that has already been cleared; call
## clear_image to clear it again.

func filename*(this: Texture): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the filename that has been set.  This is the name of the file as it
## was requested.  Also see get_fullpath().

proc `filename=`*(this: Texture, filename: Filename) {.importcpp: "#->set_filename(#)".} ## \
## Sets the name of the file that contains the image's contents.  Normally,
## this is set automatically when the image is loaded, for instance via
## Texture::read().
##
## The Texture's get_name() function used to return the filename, but now
## returns just the basename (without the extension), which is a more useful
## name for identifying an image in show code.

func alphaFilename*(this: Texture): Filename {.importcpp: "#->get_alpha_filename()".} ## \
## Returns the alpha_filename that has been set.  If this is set, it
## represents the name of the alpha component, which is stored in a separate
## file.  See also get_filename(), and get_alpha_fullpath().

proc `alphaFilename=`*(this: Texture, alpha_filename: Filename) {.importcpp: "#->set_alpha_filename(#)".} ## \
## Sets the name of the file that contains the image's alpha channel contents.
## Normally, this is set automatically when the image is loaded, for instance
## via Texture::read().
##
## The Texture's get_filename() function returns the name of the image file
## that was loaded into the buffer.  In the case where a texture specified two
## separate files to load, a 1- or 3-channel color image and a 1-channel alpha
## image, this Filename is update to contain the name of the image file that
## was loaded into the buffer's alpha channel.

func fullpath*(this: Texture): Filename {.importcpp: "#->get_fullpath()".} ## \
## Returns the fullpath that has been set.  This is the full path to the file
## as it was found along the texture search path.

proc `fullpath=`*(this: Texture, fullpath: Filename) {.importcpp: "#->set_fullpath(#)".} ## \
## Sets the full pathname to the file that contains the image's contents, as
## found along the search path.  Normally, this is set automatically when the
## image is loaded, for instance via Texture::read().

func alphaFullpath*(this: Texture): Filename {.importcpp: "#->get_alpha_fullpath()".} ## \
## Returns the alpha_fullpath that has been set.  This is the full path to the
## alpha part of the image file as it was found along the texture search path.

proc `alphaFullpath=`*(this: Texture, alpha_fullpath: Filename) {.importcpp: "#->set_alpha_fullpath(#)".} ## \
## Sets the full pathname to the file that contains the image's alpha channel
## contents, as found along the search path.  Normally, this is set
## automatically when the image is loaded, for instance via Texture::read().

func xSize*(this: Texture): int {.importcpp: "#->get_x_size()".} ## \
## Returns the width of the texture image in texels.

proc `xSize=`*(this: Texture, x_size: int) {.importcpp: "#->set_x_size(#)".} ## \
## Changes the x size indicated for the texture.  This also implicitly unloads
## the texture if it has already been loaded.

func ySize*(this: Texture): int {.importcpp: "#->get_y_size()".} ## \
## Returns the height of the texture image in texels.  For a 1-d texture, this
## will be 1.

proc `ySize=`*(this: Texture, y_size: int) {.importcpp: "#->set_y_size(#)".} ## \
## Changes the y size indicated for the texture.  This also implicitly unloads
## the texture if it has already been loaded.

func zSize*(this: Texture): int {.importcpp: "#->get_z_size()".} ## \
## Returns the depth of the texture image in texels.  For a 1-d texture or 2-d
## texture, this will be 1. For a cube map texture, this will be 6.

proc `zSize=`*(this: Texture, z_size: int) {.importcpp: "#->set_z_size(#)".} ## \
## Changes the z size indicated for the texture.  This also implicitly unloads
## the texture if it has already been loaded.

func numViews*(this: Texture): int {.importcpp: "#->get_num_views()".} ## \
## Returns the number of "views" in the texture.  A view is a completely
## separate image stored within the Texture object.  Most textures have only
## one view, but a stereo texture, for instance, may have two views, a left
## and a right image.  Other uses for multiple views are not yet defined.
##
## If this value is greater than one, the additional views are accessed as
## additional pages beyond get_z_size().

proc `numViews=`*(this: Texture, num_views: int) {.importcpp: "#->set_num_views(#)".} ## \
## Sets the number of "views" within a texture.  A view is a completely
## separate image stored within the Texture object.  Most textures have only
## one view, but a stereo texture, for instance, may have two views, a left
## and a right image.  Other uses for multiple views are not yet defined.
##
## If this value is greater than one, the additional views are accessed as
## additional pages beyond get_z_size().
##
## This also implicitly unloads the texture if it has already been loaded.

func numPages*(this: Texture): int {.importcpp: "#->get_num_pages()".} ## \
## Returns the total number of pages in the texture.  Each "page" is a 2-d
## texture image within the larger image--a face of a cube map, or a level of
## a 3-d texture.  Normally, get_num_pages() is the same as get_z_size().
## However, in a multiview texture, this returns get_z_size() \*
## get_num_views().

func numComponents*(this: Texture): int {.importcpp: "#->get_num_components()".} ## \
## Returns the number of color components for each texel of the texture image.
## This is 3 for an rgb texture or 4 for an rgba texture; it may also be 1 or
## 2 for a grayscale texture.

func componentWidth*(this: Texture): int {.importcpp: "#->get_component_width()".} ## \
## Returns the number of bytes stored for each color component of a texel.
## Typically this is 1, but it may be 2 for 16-bit texels.

func anisotropicDegree*(this: Texture): int {.importcpp: "#->get_anisotropic_degree()".} ## \
## Returns the degree of anisotropic filtering that should be applied to the
## texture.  This value may return 0, indicating the default value; see also
## get_effective_anisotropic_degree.
##
## This returns the default sampler state for this texture; it may still be
## overridden by a sampler state specified at a higher level.

proc `anisotropicDegree=`*(this: Texture, anisotropic_degree: int) {.importcpp: "#->set_anisotropic_degree(#)".} ## \
## Specifies the level of anisotropic filtering to apply to the texture.  Set
## this 0 to indicate the default value, which is specified in the texture-
## anisotropic-degree config variable.
##
## To explicitly disable anisotropic filtering, set this value to 1.  To
## explicitly enable anisotropic filtering, set it to a value higher than 1;
## larger numbers indicate greater degrees of filtering.
##
## This sets the default sampler state for this texture; it may still be
## overridden by a sampler state specified at a higher level.

func effectiveAnisotropicDegree*(this: Texture): int {.importcpp: "#->get_effective_anisotropic_degree()".} ## \
## Returns the degree of anisotropic filtering that should be applied to the
## texture.  This value will normally not return 0, unless there is an error
## in the config file.
##
## This returns the default sampler state for this texture; it may still be
## overridden by a sampler state specified at a higher level.

func borderColor*(this: Texture): LColor {.importcpp: "#->get_border_color()".} ## \
## Returns the solid color of the texture's border.  Some OpenGL
## implementations use a border for tiling textures; in Panda, it is only used
## for specifying the clamp color.
##
## This returns the default sampler state for this texture; it may still be
## overridden by a sampler state specified at a higher level.

proc `borderColor=`*(this: Texture, color: LColor) {.importcpp: "#->set_border_color(#)".} ## \
## Specifies the solid color of the texture's border.  Some OpenGL
## implementations use a border for tiling textures; in Panda, it is only used
## for specifying the clamp color.
##
## This sets the default sampler state for this texture; it may still be
## overridden by a sampler state specified at a higher level.

func renderToTexture*(this: Texture): bool {.importcpp: "#->get_render_to_texture()".} ## \
## Returns a flag on the texture that indicates whether the texture is
## intended to be used as a direct-render target, by binding a framebuffer to
## a texture and rendering directly into the texture.
##
## Normally, a user should not need to set this flag directly; it is set
## automatically by the low-level display code when a texture is bound to a
## framebuffer.

proc `renderToTexture=`*(this: Texture, render_to_texture: bool) {.importcpp: "#->set_render_to_texture(#)".} ## \
## Sets a flag on the texture that indicates whether the texture is intended
## to be used as a direct-render target, by binding a framebuffer to a texture
## and rendering directly into the texture.
##
## This controls some low-level choices made about the texture object itself.
## For instance, compressed textures are disallowed when this flag is set
## true.
##
## Normally, a user should not need to set this flag directly; it is set
## automatically by the low-level display code when a texture is bound to a
## framebuffer.

func defaultSampler*(this: Texture): SamplerState {.importcpp: "#->get_default_sampler()".} ## \
## This returns the default sampler state for this texture, containing the
## wrap and filter properties specified on the texture level; it may still be
## overridden by a sampler state specified at a higher level.

proc `defaultSampler=`*(this: Texture, sampler: SamplerState) {.importcpp: "#->set_default_sampler(#)".} ## \
## This sets the default sampler state for this texture, containing the wrap
## and filter properties specified on the texture level; it may still be
## overridden by a sampler state specified at a higher level.  This
## encompasses the settings for get_wrap_u, get_minfilter,
## get_anisotropic_degree, etc.
##
## This makes a copy of the SamplerState object, so future modifications of
## the same SamplerState will have no effect on this texture unless you call
## set_default_sampler again.

func expectedNumMipmapLevels*(this: Texture): int {.importcpp: "#->get_expected_num_mipmap_levels()".} ## \
## Returns the number of mipmap levels that should be defined for this
## texture, given the texture's size.
##
## Note that this returns a number appropriate for mipmapping, even if the
## texture does not currently have mipmapping enabled.

func ramImageSize*(this: Texture): clonglong {.importcpp: "#->get_ram_image_size()".} ## \
## Returns the total number of bytes used by the in-memory image, across all
## pages and views, or 0 if there is no in-memory image.

func ramViewSize*(this: Texture): clonglong {.importcpp: "#->get_ram_view_size()".} ## \
## Returns the number of bytes used by the in-memory image per view, or 0 if
## there is no in-memory image.  Since each view is a stack of z_size pages,
## this is get_z_size() \* get_ram_page_size().

func ramPageSize*(this: Texture): clonglong {.importcpp: "#->get_ram_page_size()".} ## \
## Returns the number of bytes used by the in-memory image per page, or 0 if
## there is no in-memory image.
##
## For a non-compressed texture, this is the same as
## get_expected_ram_page_size().  For a compressed texture, this may be a
## smaller value.  (We do assume that all pages will be the same size on a
## compressed texture).

func expectedRamImageSize*(this: Texture): clonglong {.importcpp: "#->get_expected_ram_image_size()".} ## \
## Returns the number of bytes that \*ought\* to be used by the in-memory image,
## based on the texture parameters.

func expectedRamPageSize*(this: Texture): clonglong {.importcpp: "#->get_expected_ram_page_size()".} ## \
## Returns the number of bytes that should be used per each Z page of the 3-d
## texture.  For a 2-d or 1-d texture, this is the same as
## get_expected_ram_image_size().

func keepRamImage*(this: Texture): bool {.importcpp: "#->get_keep_ram_image()".} ## \
## Returns the flag that indicates whether this Texture is eligible to have
## its main RAM copy of the texture memory dumped when the texture is prepared
## for rendering.  See set_keep_ram_image().

proc `keepRamImage=`*(this: Texture, keep_ram_image: bool) {.importcpp: "#->set_keep_ram_image(#)".} ## \
## Sets the flag that indicates whether this Texture is eligible to have its
## main RAM copy of the texture memory dumped when the texture is prepared for
## rendering.
##
## This will be false for most textures, which can reload their images if
## needed by rereading the input file.  However, textures that were generated
## dynamically and cannot be easily reloaded will want to set this flag to
## true, so that the texture will always keep its image copy around.

func cacheable*(this: Texture): bool {.importcpp: "#->is_cacheable()".} ## \
## Returns true if there is enough information in this Texture object to write
## it to the bam cache successfully, false otherwise.  For most textures, this
## is the same as has_ram_image().

func numRamMipmapImages*(this: Texture): int {.importcpp: "#->get_num_ram_mipmap_images()".} ## \
## Returns the maximum number of mipmap level images available in system
## memory.  The actual number may be less than this (that is, there might be
## gaps in the sequence); use has_ram_mipmap_image() to verify each level.
##
## Also see get_num_loadable_ram_mipmap_images().

func numLoadableRamMipmapImages*(this: Texture): int {.importcpp: "#->get_num_loadable_ram_mipmap_images()".} ## \
## Returns the number of contiguous mipmap levels that exist in RAM, up until
## the first gap in the sequence.  It is guaranteed that at least mipmap
## levels [0, get_num_ram_mipmap_images()) exist.
##
## The number returned will never exceed the number of required mipmap images
## based on the size of the texture and its filter mode.
##
## This method is different from get_num_ram_mipmap_images() in that it
## returns only the number of mipmap levels that can actually be usefully
## loaded, regardless of the actual number that may be stored.

func simpleXSize*(this: Texture): int {.importcpp: "#->get_simple_x_size()".} ## \
## Returns the width of the "simple" image in texels.

func simpleYSize*(this: Texture): int {.importcpp: "#->get_simple_y_size()".} ## \
## Returns the height of the "simple" image in texels.

func propertiesModified*(this: Texture): UpdateSeq {.importcpp: "#->get_properties_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the texture properties (unrelated to the image) are modified.

func imageModified*(this: Texture): UpdateSeq {.importcpp: "#->get_image_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the texture image data (including mipmap levels) are modified.

func simpleImageModified*(this: Texture): UpdateSeq {.importcpp: "#->get_simple_image_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the texture's "simple" image data is modified.

func autoTextureScale*(this: Texture): AutoTextureScale {.importcpp: "#->get_auto_texture_scale()".} ## \
## Returns the power-of-2 texture-scaling mode that will be applied to this
## particular texture when it is next loaded from disk.  See
## set_textures_power_2().

proc `autoTextureScale=`*(this: Texture, scale: AutoTextureScale) {.importcpp: "#->set_auto_texture_scale(#)".} ## \
## Specifies the power-of-2 texture-scaling mode that will be applied to this
## particular texture when it is next loaded from disk.  See
## set_textures_power_2().

func origFileXSize*(this: Texture): int {.importcpp: "#->get_orig_file_x_size()".} ## \
## Returns the X size of the original disk image that this Texture was loaded
## from (if it came from a disk file), before any automatic rescaling by
## Panda.

func origFileYSize*(this: Texture): int {.importcpp: "#->get_orig_file_y_size()".} ## \
## Returns the Y size of the original disk image that this Texture was loaded
## from (if it came from a disk file), before any automatic rescaling by
## Panda.

func origFileZSize*(this: Texture): int {.importcpp: "#->get_orig_file_z_size()".} ## \
## Returns the Z size of the original disk image that this Texture was loaded
## from (if it came from a disk file), before any automatic rescaling by
## Panda.

func loadedFromImage*(this: Texture): bool {.importcpp: "#->get_loaded_from_image()".} ## \
## Returns the flag that indicates the texture has been loaded from a disk
## file or PNMImage.  See set_loaded_from_image().

proc `loadedFromImage=`*(this: Texture, flag: bool) {.importcpp: "#->set_loaded_from_image(#)".} ## \
## Sets the flag that indicates the texture has been loaded from a disk file
## or PNMImage.  You should also ensure the filename has been set correctly.
## When this flag is true, the texture may be automatically reloaded when its
## ram image needs to be replaced.

proc `loadedFromImage=`*(this: Texture) {.importcpp: "#->set_loaded_from_image()".} ## \
## Sets the flag that indicates the texture has been loaded from a disk file
## or PNMImage.  You should also ensure the filename has been set correctly.
## When this flag is true, the texture may be automatically reloaded when its
## ram image needs to be replaced.

func loadedFromTxo*(this: Texture): bool {.importcpp: "#->get_loaded_from_txo()".} ## \
## Returns the flag that indicates the texture has been loaded from a txo
## file.

proc `loadedFromTxo=`*(this: Texture, flag: bool) {.importcpp: "#->set_loaded_from_txo(#)".} ## \
## Sets the flag that indicates the texture has been loaded from a txo file.
## You probably shouldn't be setting this directly; it is set automatically
## when a Texture is loaded.

proc `loadedFromTxo=`*(this: Texture) {.importcpp: "#->set_loaded_from_txo()".} ## \
## Sets the flag that indicates the texture has been loaded from a txo file.
## You probably shouldn't be setting this directly; it is set automatically
## when a Texture is loaded.

func matchFramebufferFormat*(this: Texture): bool {.importcpp: "#->get_match_framebuffer_format()".} ## \
## Returns true if the special flag was set that indicates to the GSG that the
## Texture's format should be chosen to exactly match the framebuffer's
## format, presumably because the application intends to copy image data from
## the framebuffer into the Texture (or vice-versa).

proc `matchFramebufferFormat=`*(this: Texture, flag: bool) {.importcpp: "#->set_match_framebuffer_format(#)".} ## \
## Sets the special flag that, if true, indicates to the GSG that the
## Texture's format should be chosen to exactly match the framebuffer's
## format, presumably because the application intends to copy image data from
## the framebuffer into the Texture (or vice-versa).
##
## This sets only the graphics card's idea of the texture format; it is not
## related to the system-memory format.

func postLoadStoreCache*(this: Texture): bool {.importcpp: "#->get_post_load_store_cache()".} ## \
## Returns the setting of the post_load_store_cache flag.  See
## set_post_load_store_cache().

proc `postLoadStoreCache=`*(this: Texture, flag: bool) {.importcpp: "#->set_post_load_store_cache(#)".} ## \
## Sets the post_load_store_cache flag.  When this is set, the next time the
## texture is loaded on a GSG, it will automatically extract its RAM image
## from the GSG and save it to the global BamCache.
##
## This is used to store compressed RAM images in the BamCache.  This flag
## should not be set explicitly; it is set automatically by the TexturePool
## when model-cache-compressed-textures is set true.

func videoLength*(this: MovieTexture): float64 {.importcpp: "#->get_video_length()".} ## \
## Returns the length of the video.

func videoWidth*(this: MovieTexture): int {.importcpp: "#->get_video_width()".} ## \
## Returns the width in texels of the source video stream.  This is not
## necessarily the width of the actual texture, since the texture may have
## been expanded to raise it to a power of 2.

func videoHeight*(this: MovieTexture): int {.importcpp: "#->get_video_height()".} ## \
## Returns the height in texels of the source video stream.  This is not
## necessarily the height of the actual texture, since the texture may have
## been expanded to raise it to a power of 2.

func time*(this: MovieTexture): float64 {.importcpp: "#->get_time()".} ## \
## Returns the current value of the movie's cursor.  If the movie's loop count
## is greater than one, then its length is effectively multiplied for the
## purposes of this function.  In other words, the return value will be in the
## range 0.0 to (length \* loopcount).

proc `time=`*(this: MovieTexture, t: float64) {.importcpp: "#->set_time(#)".} ## \
## Sets the movie's cursor.

func loop*(this: MovieTexture): bool {.importcpp: "#->get_loop()".} ## \
## Returns true if the movie's loop count is not equal to one.

proc `loop=`*(this: MovieTexture, enable: bool) {.importcpp: "#->set_loop(#)".} ## \
## If true, sets the movie's loop count to 1 billion.  If false, sets the
## movie's loop count to one.

func loopCount*(this: MovieTexture): int {.importcpp: "#->get_loop_count()".} ## \
## Returns the movie's loop count.

proc `loopCount=`*(this: MovieTexture, count: int) {.importcpp: "#->set_loop_count(#)".} ## \
## Sets the movie's loop count to the desired value.

func playRate*(this: MovieTexture): float64 {.importcpp: "#->get_play_rate()".} ## \
## Gets the movie's play-rate.

proc `playRate=`*(this: MovieTexture, play_rate: float64) {.importcpp: "#->set_play_rate(#)".} ## \
## Sets the movie's play-rate.  This is the speed at which the movie's cursor
## advances.  The default is to advance 1.0 movie-seconds per real-time
## second.

func playing*(this: MovieTexture): bool {.importcpp: "#->is_playing()".} ## \
## Returns true if the movie's cursor is advancing.

func modified*(this: VertexTransform, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number that's guaranteed to change at least every time
## the value reported by get_matrix() changes.

func modified*(this: VertexTransform): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number that's guaranteed to change at least every time
## the value reported by get_matrix() changes.

func node*(this: NodeVertexTransform): PandaNode {.importcpp: "deconstify(#->get_node())", header: deconstifyCode.} ## \
## Returns the PandaNode whose transform supplies this object.

func prev*(this: NodeVertexTransform): VertexTransform {.importcpp: "deconstify(#->get_prev())", header: deconstifyCode.} ## \
## Returns the VertexTransform object whose matrix will be composed with the
## result of this node's transform.

func heightfield*(this: ShaderTerrainMesh): Texture {.importcpp: "#->get_heightfield()".} ## \
## @brief Returns the heightfield
## @details This returns the terrain heightfield, previously set with
## set_heightfield()
##
## @return Path to the heightfield

proc `heightfield=`*(this: ShaderTerrainMesh, heightfield: Texture) {.importcpp: "#->set_heightfield(#)".} ## \
## @brief Sets the heightfield texture
## @details This sets the heightfield texture. It should be 16bit
## single channel, and have a power-of-two resolution greater than 32.
## Common sizes are 2048x2048 or 4096x4096.
##
## You should call generate() after setting the heightfield.
##
## @param filename Heightfield texture

func chunkSize*(this: ShaderTerrainMesh): clonglong {.importcpp: "#->get_chunk_size()".} ## \
## @brief Returns the chunk size
## @details This returns the chunk size, previously set with set_chunk_size()
## @return Chunk size

proc `chunkSize=`*(this: ShaderTerrainMesh, chunk_size: clonglong) {.importcpp: "#->set_chunk_size(#)".} ## \
## @brief Sets the chunk size
## @details This sets the chunk size of the terrain. A chunk is basically the
## smallest unit in LOD. If the chunk size is too small, the terrain will
## perform bad, since there will be way too many chunks. If the chunk size
## is too big, you will not get proper LOD, and might also get bad performance.
##
## For terrains of the size 4096x4096 or 8192x8192, a chunk size of 32 seems
## to produce good results. For smaller resolutions, you should try out a
## size of 16 or even 8 for very small terrains.
##
## The amount of chunks generated for the last level equals to
## (heightfield_size / chunk_size) \*\* 2. The chunk size has to be a power
## of two.
##
## @param chunk_size Size of the chunks, has to be a power of two

func generatePatches*(this: ShaderTerrainMesh): bool {.importcpp: "#->get_generate_patches()".} ## \
## @brief Returns whether to generate patches
## @details This returns whether patches are generated, previously set with
## set_generate_patches()
##
## @return Whether to generate patches

proc `generatePatches=`*(this: ShaderTerrainMesh, generate_patches: bool) {.importcpp: "#->set_generate_patches(#)".} ## \
## @brief Sets whether to generate patches
## @details If this option is set to true, GeomPatches will be used instead of
## GeomTriangles. This is required when the terrain is used with tesselation
## shaders, since patches are required for tesselation, whereas triangles
## are required for regular rendering.
##
## If this option is set to true while not using a tesselation shader, the
## terrain will not get rendered, or even produce errors. The same applies
## when this is option is not set, but the terrain is used with tesselation
## shaders.
##
## @param generate_patches [description]

func updateEnabled*(this: ShaderTerrainMesh): bool {.importcpp: "#->get_update_enabled()".} ## \
## @brief Returns whether the terrain is getting updated
## @details This returns whether the terrain is getting updates, previously set with
## set_update_enabled()
##
## @return Whether to update the terrain

proc `updateEnabled=`*(this: ShaderTerrainMesh, update_enabled: bool) {.importcpp: "#->set_update_enabled(#)".} ## \
## @brief Sets whether to enable terrain updates
## @details This flag controls whether the terrain should be updated. If this value
## is set to false, no updating of the terrain will happen. This can be useful
## to debug the culling algorithm used by the terrain.
##
## @param update_enabled Whether to update the terrain

func targetTriangleWidth*(this: ShaderTerrainMesh): float32 {.importcpp: "#->get_target_triangle_width()".} ## \
## @brief Returns the target triangle width
## @details This returns the target triangle width, previously set with
## ShaderTerrainMesh::set_target_triangle_width()
##
## @return Target triangle width

proc `targetTriangleWidth=`*(this: ShaderTerrainMesh, target_triangle_width: float32) {.importcpp: "#->set_target_triangle_width(#)".} ## \
## @brief Sets the desired triangle width
## @details This sets the desired width a triangle should have in pixels.
## A value of 10.0 for example will make the terrain tesselate everything
## in a way that each triangle edge roughly is 10 pixels wide.
## Of course this will not always accurately match, however you can use this
## setting to control the LOD algorithm of the terrain.
##
## @param target_triangle_width Desired triangle width in pixels

func internalScene*(this: RigidBodyCombiner): NodePath {.importcpp: "#->get_internal_scene()".} ## \
## Returns a special NodePath that represents the internal node of this
## object.  This is the node that is actually sent to the graphics card for
## rendering; it contains the collection of the children of this node into as
## few Geoms as possible.
##
## This node is filled up by the last call to collect().

func baseFrameRate*(this: AnimBundle): float64 {.importcpp: "#->get_base_frame_rate()".} ## \
## Returns the ideal number of frames per second of the animation, when it is
## running at normal speed.  This may not be the same as the actual playing
## frame rate, as it might have been adjusted through set_play_rate() on the
## AnimControl object.  See AnimControl::get_effective_frame_rate().

func numFrames*(this: AnimBundle): int {.importcpp: "#->get_num_frames()".} ## \
## Returns the number of frames of animation, or 0 if the animation has no
## fixed number of frames.

func bundle*(this: AnimBundleNode): AnimBundle {.importcpp: "#->get_bundle()".}

func valueNode*(this: AnimChannelMatrixDynamic): PandaNode {.importcpp: "#->get_value_node()".} ## \
## Returns the node that was set via set_value_node(), if any.

proc `valueNode=`*(this: AnimChannelMatrixDynamic, node: PandaNode) {.importcpp: "#->set_value_node(#)".} ## \
## Specifies a node whose transform will be queried each frame to implicitly
## specify the transform of this joint.

proc `value=`*(this: AnimChannelScalarDynamic, value: float32) {.importcpp: "#->set_value(#)".} ## \
## Explicitly sets the value.  This will remove any node assigned via
## set_value_node().

proc `valueNode=`*(this: AnimChannelScalarDynamic, node: PandaNode) {.importcpp: "#->set_value_node(#)".} ## \
## Specifies a node whose transform will be queried each frame to implicitly
## specify the transform of this joint.  This will override the values set by
## set_value().

func animBlendFlag*(this: PartBundle): bool {.importcpp: "#->get_anim_blend_flag()".} ## \
## Returns whether the character allows multiple different animations to be
## bound simultaneously.  See set_anim_blend_flag().

proc `animBlendFlag=`*(this: PartBundle, anim_blend_flag: bool) {.importcpp: "#->set_anim_blend_flag(#)".} ## \
## Defines the way the character responds to multiple calls to
## set_control_effect()).  By default, this flag is set false, which disallows
## multiple animations.  When this flag is false, it is not necessary to
## explicitly set the control_effect when starting an animation; starting the
## animation will implicitly remove the control_effect from the previous
## animation and set it on the current one.
##
## However, if this flag is set true, the control_effect must be explicitly
## set via set_control_effect() whenever an animation is to affect the
## character.

func frameBlendFlag*(this: PartBundle): bool {.importcpp: "#->get_frame_blend_flag()".} ## \
## Returns whether the character interpolates (blends) between two sequential
## animation frames, or whether it holds the current frame until the next one
## is ready.  See set_frame_blend_flag().

proc `frameBlendFlag=`*(this: PartBundle, frame_blend_flag: bool) {.importcpp: "#->set_frame_blend_flag(#)".} ## \
## Specifies whether the character interpolates (blends) between two
## sequential frames of an active animation, showing a smooth intra-frame
## motion, or whether it holds each frame until the next frame is ready,
## showing precisely the specified animation.
##
## When this value is false, the character holds each frame until the next is
## ready.  When this is true, the character will interpolate between two
## consecutive frames of animation for each frame the animation is onscreen,
## according to the amount of time elapsed between the frames.
##
## The default value of this flag is determined by the interpolate-frames
## Config.prc variable.
##
## Use set_blend_type() to change the algorithm that the character uses to
## interpolate matrix positions.

func rootXform*(this: PartBundle): LMatrix4 {.importcpp: "#->get_root_xform()".} ## \
## Returns the transform matrix which is implicitly applied at the root of the
## animated hierarchy.

proc `rootXform=`*(this: PartBundle, root_xform: LMatrix4) {.importcpp: "#->set_root_xform(#)".} ## \
## Specifies the transform matrix which is implicitly applied at the root of
## the animated hierarchy.

func bundle*(this: PartBundleHandle): PartBundle {.importcpp: "#->get_bundle()".} ## \
## Returns the actual PartBundle embedded within the handle.

proc `bundle=`*(this: PartBundleHandle, bundle: PartBundle) {.importcpp: "#->set_bundle(#)".} ## \
## Changes the actual PartBundle embedded within the handle.

func clientName*(this: PStatClient): string {.importcpp: "nimStringFromStdString(#.get_client_name())", header: stringConversionCode.} ## \
## Retrieves the name of the client as set.

proc `clientName=`*(this: PStatClient, name: string) {.importcpp: "#.set_client_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the name of the client.  This is reported to the PStatsServer, and
## will presumably be written in the title bar or something.

func maxRate*(this: PStatClient): float64 {.importcpp: "#.get_max_rate()".} ## \
## Returns the maximum number of packets that will be sent to the server per
## second, per thread.  See set_max_rate().

proc `maxRate=`*(this: PStatClient, rate: float64) {.importcpp: "#.set_max_rate(#)".} ## \
## Controls the number of packets that will be sent to the server.  Normally,
## one packet is sent per frame, but this can flood the server with more
## packets than it can handle if the frame rate is especially good (e.g.  if
## nothing is onscreen at the moment).  Set this parameter to a reasonable
## number to prevent this from happening.
##
## This number specifies the maximum number of packets that will be sent to
## the server per second, per thread.

func mainThread*(this: PStatClient): PStatThread {.importcpp: "#.get_main_thread()".} ## \
## Returns a handle to the client's Main thread.  This is the thread that
## started the application.

func currentThread*(this: PStatClient): PStatThread {.importcpp: "#.get_current_thread()".} ## \
## Returns a handle to the currently-executing thread.  This is the thread
## that PStatCollectors will be counted in if they do not specify otherwise.

func realTime*(this: PStatClient): float64 {.importcpp: "#.get_real_time()".} ## \
## Returns the time according to to the PStatClient's clock object.  It keeps
## its own clock, instead of using the global clock object, so the stats won't
## get mucked up if you put the global clock in non-real-time mode or
## something.

func thread*(this: PStatThread): Thread {.importcpp: "#.get_thread()".} ## \
## Returns the Panda Thread object associated with this particular
## PStatThread.

func index*(this: PStatThread): int {.importcpp: "#.get_index()".} ## \
## Returns the index number of this particular thread within the PStatClient.

func name*(this: VertexSlider): InternalName {.importcpp: "deconstify(#->get_name())", header: deconstifyCode.} ## \
## Returns the name of this particular slider.  Every unique blend shape
## within a particular Geom must be identified with a different name, which is
## shared by the slider that controls it.

func slider*(this: VertexSlider): float32 {.importcpp: "#->get_slider()".}

func modified*(this: VertexSlider, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number that's guaranteed to change at least every time
## the value reported by get_slider() changes.

func modified*(this: VertexSlider): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number that's guaranteed to change at least every time
## the value reported by get_slider() changes.

func collisionOrigin*(this: CollisionSolid): LPoint3 {.importcpp: "#->get_collision_origin()".}

func tangible*(this: CollisionSolid): bool {.importcpp: "#->is_tangible()".} ## \
## Returns whether the solid is considered 'tangible' or not.  An intangible
## solid has no effect in a CollisionHandlerPusher (except to throw an event);
## it's useful for defining 'trigger' planes and spheres, that cause an effect
## when passed through.

proc `tangible=`*(this: CollisionSolid, tangible: bool) {.importcpp: "#->set_tangible(#)".} ## \
## Sets the current state of the 'tangible' flag.  Set this true to make the
## solid tangible, so that a CollisionHandlerPusher will not allow another
## object to intersect it, or false to make it intangible, so that a
## CollisionHandlerPusher will ignore it except to throw an event.

func respectEffectiveNormal*(this: CollisionSolid): bool {.importcpp: "#->get_respect_effective_normal()".} ## \
## See set_respect_effective_normal().

proc `respectEffectiveNormal=`*(this: CollisionSolid, respect_effective_normal: bool) {.importcpp: "#->set_respect_effective_normal(#)".} ## \
## This is only meaningful for CollisionSolids that will be added to a
## traverser as colliders.  It is normally true, but if set false, it means
## that this particular solid does not care about the "effective" normal of
## other solids it meets, but rather always uses the true normal.

func bounds*(this: CollisionSolid): BoundingVolume {.importcpp: "deconstify(#->get_bounds())", header: deconstifyCode.} ## \
## Returns the solid's bounding volume.

proc `bounds=`*(this: CollisionSolid, bounding_volume: BoundingVolume) {.importcpp: "#->set_bounds(#)".} ## \
## Returns the solid's bounding volume.

func center*(this: CollisionBox): LPoint3 {.importcpp: "#->get_center()".}

func min*(this: CollisionBox): LPoint3 {.importcpp: "#->get_min()".}

func max*(this: CollisionBox): LPoint3 {.importcpp: "#->get_max()".}

func dimensions*(this: CollisionBox): LVector3 {.importcpp: "#->get_dimensions()".}

func pointA*(this: CollisionCapsule): LPoint3 {.importcpp: "#->get_point_a()".}

proc `pointA=`*(this: CollisionCapsule, a: LPoint3) {.importcpp: "#->set_point_a(#)".}

proc `pointA=`*(this: CollisionCapsule, x: float32, y: float32, z: float32) {.importcpp: "#->set_point_a(#, #, #)".}

func pointB*(this: CollisionCapsule): LPoint3 {.importcpp: "#->get_point_b()".}

proc `pointB=`*(this: CollisionCapsule, b: LPoint3) {.importcpp: "#->set_point_b(#)".}

proc `pointB=`*(this: CollisionCapsule, x: float32, y: float32, z: float32) {.importcpp: "#->set_point_b(#, #, #)".}

func radius*(this: CollisionCapsule): float32 {.importcpp: "#->get_radius()".}

proc `radius=`*(this: CollisionCapsule, radius: float32) {.importcpp: "#->set_radius(#)".}

func fromCollideMask*(this: CollisionNode): CollideMask {.importcpp: "#->get_from_collide_mask()".} ## \
## Returns the current "from" CollideMask.  In order for a collision to be
## detected from this object into another object, the intersection of this
## object's "from" mask and the other object's "into" mask must be nonzero.

proc `fromCollideMask=`*(this: CollisionNode, mask: CollideMask) {.importcpp: "#->set_from_collide_mask(#)".} ## \
## Sets the "from" CollideMask.  In order for a collision to be detected from
## this object into another object, the intersection of this object's "from"
## mask and the other object's "into" mask must be nonzero.

func intoCollideMask*(this: CollisionNode): CollideMask {.importcpp: "#->get_into_collide_mask()".} ## \
## Returns the current "into" CollideMask.  In order for a collision to be
## detected from another object into this object, the intersection of the
## other object's "from" mask and this object's "into" mask must be nonzero.

proc `intoCollideMask=`*(this: CollisionNode, mask: CollideMask) {.importcpp: "#->set_into_collide_mask(#)".} ## \
## Sets the "into" CollideMask.  In order for a collision to be detected from
## another object into this object, the intersection of the other object's
## "from" mask and this object's "into" mask must be nonzero.

func colliderSort*(this: CollisionNode): int {.importcpp: "#->get_collider_sort()".} ## \
## Returns the collider_sort value that has been set for this particular node.
## See set_collider_sort().

proc `colliderSort=`*(this: CollisionNode, sort: int) {.importcpp: "#->set_collider_sort(#)".} ## \
## Sets a particular collider_sort value on this node.  This controls the
## order in which colliders (that is, "from nodes") are grouped together for
## the collision traversal.
##
## If there are 32 or fewer colliders added to any particular
## CollisionTraverser, then this value has no meaning.  It is only useful if
## there are many colliders, which may force the CollisionTraverser to make
## multiple passes through the data; in that case, it may be a useful
## optimization to group colliders that have similar bounding volumes together
## (by giving them similar sort values).

func defaultCollideMask*(_: typedesc[CollisionNode]): CollideMask {.importcpp: "CollisionNode::get_default_collide_mask()", header: "collisionNode.h".} ## \
## Returns the default into_collide_mask assigned to new CollisionNodes.

func respectPrevTransform*(this: CollisionTraverser): bool {.importcpp: "#.get_respect_prev_transform()".} ## \
## Returns the flag that indicates whether the prev_transform stored on a node
## is respected to calculate collisions.  See set_respect_prev_transform().

proc `respectPrevTransform=`*(this: CollisionTraverser, flag: bool) {.importcpp: "#.set_respect_prev_transform(#)".} ## \
## Sets the flag that indicates whether the prev_transform stored on a node
## (as updated via set_fluid_pos(), etc.) is respected to calculate
## collisions.  If this is true, certain types of collision tests will be
## enhanced by the information about objects in motion.  If this is false,
## objects are always considered to be static.  The default is false.

func recorder*(this: CollisionTraverser): CollisionRecorder {.importcpp: "#.get_recorder()".} ## \
## Returns the CollisionRecorder currently assigned, or NULL if no recorder is
## assigned.

proc `recorder=`*(this: CollisionTraverser, recorder: CollisionRecorder) {.importcpp: "#.set_recorder(#)".} ## \
## Uses the indicated CollisionRecorder object to start recording the
## intersection tests made by each subsequent call to traverse() on this
## object.  A particular CollisionRecorder object can only record one
## traverser at a time; if this object has already been assigned to another
## traverser, that assignment is broken.
##
## This is intended to be used in a debugging mode to try to determine what
## work is being performed by the collision traversal.  Usually, attaching a
## recorder will impose significant runtime overhead.
##
## This does not transfer ownership of the CollisionRecorder pointer;
## maintenance of that remains the caller's responsibility.  If the
## CollisionRecorder is destructed, it will cleanly remove itself from the
## traverser.

func fromSolid*(this: CollisionEntry): CollisionSolid {.importcpp: "deconstify(#->get_from())", header: deconstifyCode.} ## \
## Returns the CollisionSolid pointer for the particular solid that triggered
## this collision.

func intoSolid*(this: CollisionEntry): CollisionSolid {.importcpp: "deconstify(#->get_into())", header: deconstifyCode.} ## \
## Returns the CollisionSolid pointer for the particular solid was collided
## into.  This pointer might be NULL if the collision was into a piece of
## visible geometry, instead of a normal CollisionSolid collision; see
## has_into().

func fromNode*(this: CollisionEntry): CollisionNode {.importcpp: "#->get_from_node()".} ## \
## Returns the node that contains the CollisionSolid that triggered this
## collision.  This will be a node that has been added to a CollisionTraverser
## via add_collider().

func intoNode*(this: CollisionEntry): PandaNode {.importcpp: "#->get_into_node()".} ## \
## Returns the node that contains the CollisionSolid that was collided into.
## This returns a PandaNode pointer instead of something more specific,
## because it might be either a CollisionNode or a GeomNode.
##
## Also see get_into_node_path().

func fromNodePath*(this: CollisionEntry): NodePath {.importcpp: "#->get_from_node_path()".} ## \
## Returns the NodePath that represents the CollisionNode that contains the
## CollisionSolid that triggered this collision.  This will be a NodePath that
## has been added to a CollisionTraverser via add_collider().

func intoNodePath*(this: CollisionEntry): NodePath {.importcpp: "#->get_into_node_path()".} ## \
## Returns the NodePath that represents the specific CollisionNode or GeomNode
## instance that was collided into.  This is the same node returned by
## get_into_node(), represented as a NodePath; however, it may be more useful
## because the NodePath can resolve the particular instance of the node, if
## there is more than one.

func t*(this: CollisionEntry): float32 {.importcpp: "#->get_t()".} ## \
## returns time value for this collision relative to other CollisionEntries

proc `t=`*(this: CollisionEntry, t: float32) {.importcpp: "#->set_t(#)".} ## \
## Sets a time value for this collision relative to other CollisionEntries

func respectPrevTransform*(this: CollisionEntry): bool {.importcpp: "#->get_respect_prev_transform()".} ## \
## Returns true if the collision was detected by a CollisionTraverser whose
## respect_prev_transform flag was set true, meaning we should consider motion
## significant in evaluating collisions.

func normal*(this: CollisionPlane): LVector3 {.importcpp: "#->get_normal()".}

func plane*(this: CollisionPlane): LPlane {.importcpp: "#->get_plane()".}

proc `plane=`*(this: CollisionPlane, plane: LPlane) {.importcpp: "#->set_plane(#)".}

func valid*(this: CollisionPolygon): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the CollisionPolygon is valid (that is, it has at least
## three vertices), or false otherwise.

func concave*(this: CollisionPolygon): bool {.importcpp: "#->is_concave()".} ## \
## Returns true if the CollisionPolygon appears to be concave, or false if it
## is safely convex.

func center*(this: CollisionHandlerPhysical): NodePath {.importcpp: "#->get_center()".} ## \
## Returns the NodePath specified with set_center, or the empty NodePath if
## nothing has been specified.

proc `center=`*(this: CollisionHandlerPhysical, center: NodePath) {.importcpp: "#->set_center(#)".} ## \
## Specifies an arbitrary NodePath that the handler is always considered to be
## facing.  It does not detect collisions with surfaces that appear to be
## facing away from this NodePath.  This works best when the collision
## surfaces in question are polygons.

func offset*(this: CollisionHandlerFloor): float32 {.importcpp: "#->get_offset()".} ## \
## Returns the linear offset to add to (or subtract from) the highest detected
## collision point to determine the actual height at which to set the
## collider.

proc `offset=`*(this: CollisionHandlerFloor, offset: float32) {.importcpp: "#->set_offset(#)".} ## \
## Sets the linear offset to add to (or subtract from) the highest detected
## collision point to determine the actual height at which to set the
## collider.

func reach*(this: CollisionHandlerFloor): float32 {.importcpp: "#->get_reach()".} ## \
## Returns the reach to add to (or subtract from) the highest collision point

proc `reach=`*(this: CollisionHandlerFloor, reach: float32) {.importcpp: "#->set_reach(#)".} ## \
## Sets the reach to add to (or subtract from) the highest collision point

func maxVelocity*(this: CollisionHandlerFloor): float32 {.importcpp: "#->get_max_velocity()".} ## \
## Retrieves the maximum speed at which the object will be allowed to descend
## towards a floor below it, in units per second.  See set_max_velocity().

proc `maxVelocity=`*(this: CollisionHandlerFloor, max_vel: float32) {.importcpp: "#->set_max_velocity(#)".} ## \
## Sets the maximum speed at which the object will be allowed to descend
## towards a floor below it, in units per second.  Set this to zero to allow
## it to instantly teleport any distance.

func horizontal*(this: CollisionHandlerPusher): bool {.importcpp: "#->get_horizontal()".}

proc `horizontal=`*(this: CollisionHandlerPusher, flag: bool) {.importcpp: "#->set_horizontal(#)".}

func offset*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_offset()".} ## \
## Returns the linear offset to add to (or subtract from) the highest detected
## collision point to determine the actual height at which to set the
## collider.

proc `offset=`*(this: CollisionHandlerGravity, offset: float32) {.importcpp: "#->set_offset(#)".} ## \
## Sets the linear offset to add to (or subtract from) the highest detected
## collision point to determine the actual height at which to set the
## collider.

func reach*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_reach()".} ## \
## Returns the reach to add to (or subtract from) the highest collision point

proc `reach=`*(this: CollisionHandlerGravity, reach: float32) {.importcpp: "#->set_reach(#)".} ## \
## Sets the reach to add to (or subtract from) the highest collision point

func airborneHeight*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_airborne_height()".} ## \
## Return the height of the object from the ground.
##
## The object might not necessarily be at rest.  Use is_on_ground() if you
## want to know whether the object is on the ground and at rest.

func onGround*(this: CollisionHandlerGravity): bool {.importcpp: "#->is_on_ground()".} ## \
## Is the object at rest?

func impactVelocity*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_impact_velocity()".} ## \
## How hard did the object hit the ground.  This value is set on impact with
## the ground.  You may want to watch (poll) on is_on_ground() and when that is
## true, call get_impact_velocity(). Normally I avoid polling, but we are
## calling is_on_ground() frequently anyway.

func contactNormal*(this: CollisionHandlerGravity): LVector3 {.importcpp: "#->get_contact_normal()".}

func velocity*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_velocity()".} ## \
## Gets the current vertical velocity.
##
## Generally, negative values mean the object is in free fall; while postive
## values mean the object has vertical thrust.
##
## A zero value does not necessarily mean the object on the ground, it may
## also be weightless and/or at the apex of its jump.
##
## See Also: is_on_ground() and get_gravity()

proc `velocity=`*(this: CollisionHandlerGravity, velocity: float32) {.importcpp: "#->set_velocity(#)".} ## \
## Sets the current vertical velocity.

func gravity*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_gravity()".} ## \
## Gets the linear gravity force (always plumb).

proc `gravity=`*(this: CollisionHandlerGravity, gravity: float32) {.importcpp: "#->set_gravity(#)".} ## \
## Sets the linear gravity force (always plumb).

func maxVelocity*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_max_velocity()".} ## \
## Retrieves the maximum speed at which the object will be allowed to descend
## towards a floor below it, in units per second.  See set_max_velocity().

proc `maxVelocity=`*(this: CollisionHandlerGravity, max_vel: float32) {.importcpp: "#->set_max_velocity(#)".} ## \
## Sets the maximum speed at which the object will be allowed to descend
## towards a floor below it, in units per second.  Set this to zero to allow
## it to instantly teleport any distance.

func center*(this: CollisionSphere): LPoint3 {.importcpp: "#->get_center()".}

proc `center=`*(this: CollisionSphere, center: LPoint3) {.importcpp: "#->set_center(#)".}

proc `center=`*(this: CollisionSphere, x: float32, y: float32, z: float32) {.importcpp: "#->set_center(#, #, #)".}

func radius*(this: CollisionSphere): float32 {.importcpp: "#->get_radius()".}

proc `radius=`*(this: CollisionSphere, radius: float32) {.importcpp: "#->set_radius(#)".}

func origin*(this: CollisionRay): LPoint3 {.importcpp: "#->get_origin()".}

proc `origin=`*(this: CollisionRay, origin: LPoint3) {.importcpp: "#->set_origin(#)".}

proc `origin=`*(this: CollisionRay, x: float32, y: float32, z: float32) {.importcpp: "#->set_origin(#, #, #)".}

func direction*(this: CollisionRay): LVector3 {.importcpp: "#->get_direction()".}

proc `direction=`*(this: CollisionRay, direction: LVector3) {.importcpp: "#->set_direction(#)".}

proc `direction=`*(this: CollisionRay, x: float32, y: float32, z: float32) {.importcpp: "#->set_direction(#, #, #)".}

func parabola*(this: CollisionParabola): LParabola {.importcpp: "#->get_parabola()".} ## \
## Returns the parabola specified by this solid.

proc `parabola=`*(this: CollisionParabola, parabola: LParabola) {.importcpp: "#->set_parabola(#)".} ## \
## Replaces the parabola specified by this solid.

func t1*(this: CollisionParabola): float32 {.importcpp: "#->get_t1()".} ## \
## Returns the starting point on the parabola.

proc `t1=`*(this: CollisionParabola, t1: float32) {.importcpp: "#->set_t1(#)".} ## \
## Changes the starting point on the parabola.

func t2*(this: CollisionParabola): float32 {.importcpp: "#->get_t2()".} ## \
## Returns the ending point on the parabola.

proc `t2=`*(this: CollisionParabola, t2: float32) {.importcpp: "#->set_t2(#)".} ## \
## Changes the ending point on the parabola.

func pointA*(this: CollisionSegment): LPoint3 {.importcpp: "#->get_point_a()".}

proc `pointA=`*(this: CollisionSegment, a: LPoint3) {.importcpp: "#->set_point_a(#)".}

proc `pointA=`*(this: CollisionSegment, x: float32, y: float32, z: float32) {.importcpp: "#->set_point_a(#, #, #)".}

func pointB*(this: CollisionSegment): LPoint3 {.importcpp: "#->get_point_b()".}

proc `pointB=`*(this: CollisionSegment, b: LPoint3) {.importcpp: "#->set_point_b(#)".}

proc `pointB=`*(this: CollisionSegment, x: float32, y: float32, z: float32) {.importcpp: "#->set_point_b(#, #, #)".}

func pointScale*(this: CollisionVisualizer): float32 {.importcpp: "#->get_point_scale()".} ## \
## Returns the value last set by set_point_scale().

proc `pointScale=`*(this: CollisionVisualizer, point_scale: float32) {.importcpp: "#->set_point_scale(#)".} ## \
## Scales the points that are drawn to represent the surface and interior
## intersection points of the collisions.  By default, these objects are drawn
## at an arbitrary scale which is appropriate if the window units are the
## default range -1 .. 1.  Change this scale accordinatly if the window units
## are measured on some other scale or if you need to observe these objects in
## a smaller window.

func normalScale*(this: CollisionVisualizer): float32 {.importcpp: "#->get_normal_scale()".} ## \
## Returns the value last set by set_normal_scale().

proc `normalScale=`*(this: CollisionVisualizer, normal_scale: float32) {.importcpp: "#->set_normal_scale(#)".} ## \
## Scales the line segments that are drawn to represent the normals of the
## collisions.  By default, these objects are drawn at an arbitrary scale
## which is appropriate if the scene units are measured in feet.  Change this
## scale accordinatly if the scene units are measured on some other scale or
## if you need to observe these normals from farther away.

func displayWidth*(this: GraphicsPipe): int {.importcpp: "#->get_display_width()".} ## \
## Returns the width of the entire display, if it is known.  This may return
## 0.  This is not a guarantee that windows (particularly fullscreen windows)
## may not be created larger than this width, but it is intended to provide a
## hint to the application.

func displayHeight*(this: GraphicsPipe): int {.importcpp: "#->get_display_height()".} ## \
## Returns the height of the entire display, if it is known.  This may return
## 0.  See the caveats for get_display_width().

func displayZoom*(this: GraphicsPipe): float32 {.importcpp: "#->get_display_zoom()".} ## \
## Returns the display zoom factor configured in the operating system.  If the
## operating system automatically scales windows to match the DPI (such as when
## dpi-aware is set to false), this will be 1.0.  Otherwise, this will be set to
## a value approximating the density of the monitor divided by the standard
## density of the operating system (usually 96), yielding a value like 1.5 or
## 2.0.
##
## @since 1.10.8

func displayInformation*(this: GraphicsPipe): DisplayInformation {.importcpp: "#->get_display_information()".} ## \
## Gets the pipe's DisplayInformation.

func interfaceName*(this: GraphicsPipe): string {.importcpp: "nimStringFromStdString(#->get_interface_name())", header: stringConversionCode.}

func clearColor*(this: DrawableRegion): LColor {.importcpp: "#->get_clear_color()".} ## \
## Returns the current clear color value.  This is the value that will be used
## to clear the color buffer every frame, but only if get_clear_color_active()
## returns true.  If get_clear_color_active() returns false, this is
## meaningless.

proc `clearColor=`*(this: DrawableRegion, color: LColor) {.importcpp: "#->set_clear_color(#)".} ## \
## Sets the clear color to the indicated value.  This is the value that will
## be used to clear the color buffer every frame, but only if
## get_clear_color_active() returns true.  If get_clear_color_active() returns
## false, this is meaningless.

func clearDepth*(this: DrawableRegion): float32 {.importcpp: "#->get_clear_depth()".} ## \
## Returns the current clear depth value.  This is the value that will be used
## to clear the depth buffer every frame, but only if get_clear_depth_active()
## returns true.  If get_clear_depth_active() returns false, this is
## meaningless.

proc `clearDepth=`*(this: DrawableRegion, depth: float32) {.importcpp: "#->set_clear_depth(#)".} ## \
## Sets the clear depth to the indicated value.  This is the value that will
## be used to clear the depth buffer every frame, but only if
## get_clear_depth_active() returns true.  If get_clear_depth_active() returns
## false, this is meaningless.

func clearStencil*(this: DrawableRegion): int {.importcpp: "#->get_clear_stencil()".} ## \
## Returns the current clear stencil value.  This is the value that will be
## used to clear the stencil buffer every frame, but only if
## get_clear_stencil_active() returns true.  If get_clear_stencil_active()
## returns false, this is meaningless.

proc `clearStencil=`*(this: DrawableRegion, stencil: int) {.importcpp: "#->set_clear_stencil(#)".}

func pixelZoom*(this: DrawableRegion): float32 {.importcpp: "#->get_pixel_zoom()".} ## \
## Returns the value set by set_pixel_zoom(), regardless of whether it is
## being respected or not.  Also see get_pixel_factor().

proc `pixelZoom=`*(this: DrawableRegion, pixel_zoom: float32) {.importcpp: "#->set_pixel_zoom(#)".} ## \
## Sets the amount by which the pixels of the region are scaled internally
## when filling the image interally.  Setting this number larger makes the
## pixels blockier, but may make the rendering faster, particularly for
## software renderers.  Setting this number to 2.0 reduces the number of
## pixels that have to be filled by the renderer by a factor of 2.0.  It
## doesn't make sense to set this lower than 1.0.
##
## It is possible to set this on either individual DisplayRegions or on
## overall GraphicsWindows, but you will get better performance for setting it
## on the window rather than its individual DisplayRegions.  Also, you may not
## set it on a DisplayRegion that doesn't have both clear_color() and
## clear_depth() enabled.
##
## This property is only supported on renderers for which it is particularly
## useful--currently, this is the tinydisplay software renderer.  Other kinds
## of renderers allow you to set this property, but ignore it.

func pixelFactor*(this: DrawableRegion): float32 {.importcpp: "#->get_pixel_factor()".} ## \
## Returns the amount by which the height and width of the region will be
## scaled internally, based on the zoom factor set by set_pixel_zoom().  This
## will return 1.0 if the pixel_zoom was not set or if it is not being
## respected (for instance, because the underlying renderer doesn't support it
## --see supports_pixel_zoom).

func configProperties*(_: typedesc[WindowProperties]): WindowProperties {.importcpp: "WindowProperties::get_config_properties()", header: "windowProperties.h".} ## \
## Returns a WindowProperties structure with all of the default values filled
## in according to the user's config file.

func default*(_: typedesc[WindowProperties]): WindowProperties {.importcpp: "WindowProperties::get_default()", header: "windowProperties.h".} ## \
## Returns the "default" WindowProperties.  If set_default() has been called,
## this returns that WindowProperties structure; otherwise, this returns
## get_config_properties().

proc `default=`*(_: typedesc[WindowProperties], default_properties: WindowProperties) {.importcpp: "#WindowProperties::set_default(#)", header: "windowProperties.h".} ## \
## Replaces the "default" WindowProperties with the specified structure.  The
## specified WindowProperties will be returned by future calls to
## get_default(), until clear_default() is called.
##
## Note that this completely replaces the default properties; it is not
## additive.

func origin*(this: WindowProperties): LPoint2i {.importcpp: "#.get_origin()".} ## \
## Returns the coordinates of the window's top-left corner, not including
## decorations.

proc `origin=`*(this: WindowProperties, origin: LPoint2i) {.importcpp: "#.set_origin(#)".} ## \
## Specifies the origin on the screen (in pixels, relative to the top-left
## corner) at which the window should appear.  This is the origin of the top-
## left corner of the useful part of the window, not including decorations.

proc `origin=`*(this: WindowProperties, x_origin: int, y_origin: int) {.importcpp: "#.set_origin(#, #)".} ## \
## Specifies the origin on the screen (in pixels, relative to the top-left
## corner) at which the window should appear.  This is the origin of the top-
## left corner of the useful part of the window, not including decorations.

func size*(this: WindowProperties): LVector2i {.importcpp: "#.get_size()".} ## \
## Returns size in pixels of the useful part of the window, not including
## decorations.

proc `size=`*(this: WindowProperties, size: LVector2i) {.importcpp: "#.set_size(#)".} ## \
## Specifies the requested size of the window, in pixels.  This is the size of
## the useful part of the window, not including decorations.

proc `size=`*(this: WindowProperties, x_size: int, y_size: int) {.importcpp: "#.set_size(#, #)".} ## \
## Specifies the requested size of the window, in pixels.  This is the size of
## the useful part of the window, not including decorations.

func title*(this: WindowProperties): string {.importcpp: "nimStringFromStdString(#.get_title())", header: stringConversionCode.} ## \
## Returns the window's title.

proc `title=`*(this: WindowProperties, title: string) {.importcpp: "#.set_title(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the title that should be assigned to the window.

func undecorated*(this: WindowProperties): bool {.importcpp: "#.get_undecorated()".} ## \
## Returns true if the window has no border.

proc `undecorated=`*(this: WindowProperties, undecorated: bool) {.importcpp: "#.set_undecorated(#)".} ## \
## Specifies whether the window should be created with a visible title and
## border (false, the default) or not (true).

func fixedSize*(this: WindowProperties): bool {.importcpp: "#.get_fixed_size()".} ## \
## Returns true if the window cannot be resized by the user, false otherwise.

proc `fixedSize=`*(this: WindowProperties, fixed_size: bool) {.importcpp: "#.set_fixed_size(#)".} ## \
## Specifies whether the window should be resizable by the user.

func fullscreen*(this: WindowProperties): bool {.importcpp: "#.get_fullscreen()".} ## \
## Returns true if the window is in fullscreen mode.

proc `fullscreen=`*(this: WindowProperties, fullscreen: bool) {.importcpp: "#.set_fullscreen(#)".} ## \
## Specifies whether the window should be opened in fullscreen mode (true) or
## normal windowed mode (false, the default).

func foreground*(this: WindowProperties): bool {.importcpp: "#.get_foreground()".} ## \
## Returns true if the window is in the foreground.

proc `foreground=`*(this: WindowProperties, foreground: bool) {.importcpp: "#.set_foreground(#)".} ## \
## Specifies whether the window should be opened in the foreground (true), or
## left in the background (false).

func minimized*(this: WindowProperties): bool {.importcpp: "#.get_minimized()".} ## \
## Returns true if the window is minimized.

proc `minimized=`*(this: WindowProperties, minimized: bool) {.importcpp: "#.set_minimized(#)".} ## \
## Specifies whether the window should be created minimized (true), or normal
## (false).

func open*(this: WindowProperties): bool {.importcpp: "#.get_open()".} ## \
## Returns true if the window is open.

proc `open=`*(this: WindowProperties, open: bool) {.importcpp: "#.set_open(#)".} ## \
## Specifies whether the window should be open.  It is legal to create a
## GraphicsWindow in the closed state, and later request it to open by
## changing this flag.

func cursorHidden*(this: WindowProperties): bool {.importcpp: "#.get_cursor_hidden()".} ## \
## Returns true if the mouse cursor is invisible.

proc `cursorHidden=`*(this: WindowProperties, cursor_hidden: bool) {.importcpp: "#.set_cursor_hidden(#)".} ## \
## Specifies whether the mouse cursor should be visible.

func iconFilename*(this: WindowProperties): Filename {.importcpp: "#.get_icon_filename()".} ## \
## Returns the icon filename associated with the window.

proc `iconFilename=`*(this: WindowProperties, icon_filename: Filename) {.importcpp: "#.set_icon_filename(#)".} ## \
## Specifies the file that contains the icon to associate with the window when
## it is minimized.

func cursorFilename*(this: WindowProperties): Filename {.importcpp: "#.get_cursor_filename()".} ## \
## Returns the icon filename associated with the mouse cursor.

proc `cursorFilename=`*(this: WindowProperties, cursor_filename: Filename) {.importcpp: "#.set_cursor_filename(#)".} ## \
## Specifies the file that contains the icon to associate with the mouse
## cursor when it is within the window (and visible).

func parentWindow*(this: WindowProperties): WindowHandle {.importcpp: "#.get_parent_window()".} ## \
## Returns the parent window specification, or NULL if there is no parent
## window specified.

proc `parentWindow=`*(this: WindowProperties, parent_window: WindowHandle) {.importcpp: "#.set_parent_window(#)".} ## \
## Specifies the window that this window should be attached to.  If this is
## NULL or unspecified, the window will be created as a toplevel window on the
## desktop; if this is non-NULL, the window will be bound as a child window to
## the indicated parent window.
##
## You should use GraphicsPipe::make_window_handle() to create an instance of
## a WindowHandle object given an appropriate OS-specific window handle
## representation.  Each OS-specific GraphicsPipe class defines a
## make_window_handle() method that returns an appropriate WindowHandle object
## to wrap the particular OS-specific representation.

proc `parentWindow=`*(this: WindowProperties) {.importcpp: "#.set_parent_window()".} ## \
## Specifies the window that this window should be attached to.  If this is
## NULL or unspecified, the window will be created as a toplevel window on the
## desktop; if this is non-NULL, the window will be bound as a child window to
## the indicated parent window.
##
## You should use GraphicsPipe::make_window_handle() to create an instance of
## a WindowHandle object given an appropriate OS-specific window handle
## representation.  Each OS-specific GraphicsPipe class defines a
## make_window_handle() method that returns an appropriate WindowHandle object
## to wrap the particular OS-specific representation.

proc `parentWindow=`*(this: WindowProperties, parent: clonglong) {.importcpp: "#.set_parent_window(#)".} ## \
## Specifies the window that this window should be attached to.
##
## This is a deprecated variant on this method, and exists only for backward
## compatibility.  Future code should use the version of set_parent_window()
## below that receives a WindowHandle object; that interface is much more
## robust.
##
## In this deprecated variant, the actual value for "parent" is platform-
## specific.  On Windows, it is the HWND of the parent window, cast to an
## unsigned integer.  On X11, it is the Window pointer of the parent window,
## similarly cast.  On OSX, this is the NSWindow pointer, which doesn't appear
## to work at all.

func dimensions*(this: DisplayRegion, i: int): LVecBase4 {.importcpp: "#->get_dimensions(#)".} ## \
## Retrieves the coordinates of the DisplayRegion's rectangle within its
## GraphicsOutput.  These numbers will be in the range [0..1].

func dimensions*(this: DisplayRegion): LVecBase4 {.importcpp: "#->get_dimensions()".} ## \
## Retrieves the coordinates of the DisplayRegion's rectangle within its
## GraphicsOutput.  These numbers will be in the range [0..1].

proc `dimensions=`*(this: DisplayRegion, dimensions: LVecBase4) {.importcpp: "#->set_dimensions(#)".} ## \
## Changes the portion of the framebuffer this DisplayRegion corresponds to.
## The parameters range from 0 to 1, where 0,0 is the lower left corner and
## 1,1 is the upper right; (0, 1, 0, 1) represents the whole screen.

proc `dimensions=`*(this: DisplayRegion, l: float32, r: float32, b: float32, t: float32) {.importcpp: "#->set_dimensions(#, #, #, #)".} ## \
## Changes the portion of the framebuffer this DisplayRegion corresponds to.
## The parameters range from 0 to 1, where 0,0 is the lower left corner and
## 1,1 is the upper right; (0, 1, 0, 1) represents the whole screen.

proc `dimensions=`*(this: DisplayRegion, i: int, dimensions: LVecBase4) {.importcpp: "#->set_dimensions(#, #)".} ## \
## Changes the portion of the framebuffer this DisplayRegion corresponds to.
## The parameters range from 0 to 1, where 0,0 is the lower left corner and
## 1,1 is the upper right; (0, 1, 0, 1) represents the whole screen.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc `dimensions=`*(this: DisplayRegion, i: int, l: float32, r: float32, b: float32, t: float32) {.importcpp: "#->set_dimensions(#, #, #, #, #)".} ## \
## Changes the portion of the framebuffer this DisplayRegion corresponds to.
## The parameters range from 0 to 1, where 0,0 is the lower left corner and
## 1,1 is the upper right; (0, 1, 0, 1) represents the whole screen.

func window*(this: DisplayRegion): GraphicsOutput {.importcpp: "#->get_window()".} ## \
## Returns the GraphicsOutput that this DisplayRegion is ultimately associated
## with, or NULL if no window is associated.

func pipe*(this: DisplayRegion): GraphicsPipe {.importcpp: "#->get_pipe()".} ## \
## Returns the GraphicsPipe that this DisplayRegion is ultimately associated
## with, or NULL if no pipe is associated.

func stereo*(this: DisplayRegion): bool {.importcpp: "#->is_stereo()".} ## \
## Returns true if this is a StereoDisplayRegion, false otherwise.

func camera*(this: DisplayRegion, current_thread: Thread): NodePath {.importcpp: "#->get_camera(#)".} ## \
## Returns the camera associated with this DisplayRegion, or an empty NodePath
## if no camera is associated.

func camera*(this: DisplayRegion): NodePath {.importcpp: "#->get_camera()".} ## \
## Returns the camera associated with this DisplayRegion, or an empty NodePath
## if no camera is associated.

proc `camera=`*(this: DisplayRegion, camera: NodePath) {.importcpp: "#->set_camera(#)".} ## \
## Sets the camera that is associated with this DisplayRegion.  There is a
## one-to-many association between cameras and DisplayRegions; one camera may
## be shared by multiple DisplayRegions.
##
## The camera is actually set via a NodePath, which clarifies which instance
## of the camera (if there happen to be multiple instances) we should use.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

func active*(this: DisplayRegion): bool {.importcpp: "#->is_active()".} ## \
## Returns the active flag associated with the DisplayRegion.

proc `active=`*(this: DisplayRegion, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets the active flag associated with the DisplayRegion.  If the
## DisplayRegion is marked inactive, nothing is rendered.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

func sort*(this: DisplayRegion): int {.importcpp: "#->get_sort()".} ## \
## Returns the sort value associated with the DisplayRegion.

proc `sort=`*(this: DisplayRegion, sort: int) {.importcpp: "#->set_sort(#)".} ## \
## Sets the sort value associated with the DisplayRegion.  Within a window,
## DisplayRegions will be rendered in order from the lowest sort value to the
## highest.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

func texViewOffset*(this: DisplayRegion): int {.importcpp: "#->get_tex_view_offset()".} ## \
## Returns the current texture view offset for this DisplayRegion.  This is
## normally set to zero.  If nonzero, it is used to select a particular view
## of any multiview textures that are rendered within this DisplayRegion.
##
## For a StereoDisplayRegion, this is normally 0 for the left eye, and 1 for
## the right eye, to support stereo textures.

proc `texViewOffset=`*(this: DisplayRegion, tex_view_offset: int) {.importcpp: "#->set_tex_view_offset(#)".} ## \
## Sets the current texture view offset for this DisplayRegion.  This is
## normally set to zero.  If nonzero, it is used to select a particular view
## of any multiview textures that are rendered within this DisplayRegion.
##
## For a StereoDisplayRegion, this is normally 0 for the left eye, and 1 for
## the right eye, to support stereo textures.  This is set automatically when
## you call set_stereo_channel().

func incompleteRender*(this: DisplayRegion): bool {.importcpp: "#->get_incomplete_render()".} ## \
## Returns the incomplete_render flag.  See set_incomplete_render().

proc `incompleteRender=`*(this: DisplayRegion, incomplete_render: bool) {.importcpp: "#->set_incomplete_render(#)".} ## \
## Sets the incomplete_render flag.  When this is true, the frame will be
## rendered even if some of the geometry or textures in the scene are not
## available (e.g.  they have been temporarily paged out).  When this is
## false, the frame will be held up while this data is reloaded.
##
## This flag may also be set on the GraphicsStateGuardian.  It will be
## considered true for a given DisplayRegion only if it is true on both the
## GSG and on the DisplayRegion.
##
## See GraphicsStateGuardian::set_incomplete_render() for more detail.

func textureReloadPriority*(this: DisplayRegion): int {.importcpp: "#->get_texture_reload_priority()".} ## \
## Returns the priority which is assigned to asynchronous texture reload
## requests.  See set_texture_reload_priority().

proc `textureReloadPriority=`*(this: DisplayRegion, texture_reload_priority: int) {.importcpp: "#->set_texture_reload_priority(#)".} ## \
## Specifies an integer priority which is assigned to any asynchronous texture
## reload requests spawned while processing this DisplayRegion.  This controls
## which textures are loaded first when multiple textures need to be reloaded
## at once; it also controls the relative priority between asynchronous
## texture loads and asynchronous model or animation loads.
##
## Specifying a larger number here makes the textures rendered by this
## DisplayRegion load up first.  This may be particularly useful to do, for
## instance, for the DisplayRegion that renders the gui.

func lensIndex*(this: DisplayRegion): int {.importcpp: "#->get_lens_index()".} ## \
## Returns the specific lens of the associated Camera that will be used for
## rendering this scene.  Most Cameras hold only one lens, but for multiple
## lenses this method may be used to selected between them.

proc `lensIndex=`*(this: DisplayRegion, index: int) {.importcpp: "#->set_lens_index(#)".} ## \
## Sets the lens index, allows for multiple lenses to be attached to a camera.
## This is useful for a variety of setups, such as fish eye rendering.  The
## default is 0.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

func cullTraverser*(this: DisplayRegion): CullTraverser {.importcpp: "#->get_cull_traverser()".} ## \
## Returns the CullTraverser that will be used to draw the contents of this
## DisplayRegion.

proc `cullTraverser=`*(this: DisplayRegion, trav: CullTraverser) {.importcpp: "#->set_cull_traverser(#)".} ## \
## Specifies the CullTraverser that will be used to draw the contents of this
## DisplayRegion.  Normally the default CullTraverser is sufficient, but this
## may be changed to change the default cull behavior.

func targetTexPage*(this: DisplayRegion): int {.importcpp: "#->get_target_tex_page()".} ## \
## Returns the target page number associated with this particular
## DisplayRegion, or -1 if it is not associated with a page.  See
## set_target_tex_page().

proc `targetTexPage=`*(this: DisplayRegion, page: int) {.importcpp: "#->set_target_tex_page(#)".} ## \
## This is a special parameter that is only used when rendering the faces of a
## cube map or multipage and/or multiview texture.
##
## This sets up the DisplayRegion to render to the ith page and jth view of
## its associated texture(s); the value must be consistent with the range of
## values availble to the texture.  A normal DisplayRegion that is not
## associated with any particular page should be set to page -1 and view 0.
##
## This is particularly useful when rendering cube maps and/or stereo
## textures.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

func scissorEnabled*(this: DisplayRegion): bool {.importcpp: "#->get_scissor_enabled()".} ## \
## Returns whether or not scissor testing is enabled for this region.  The
## default is true, except for the overlay display region.

proc `scissorEnabled=`*(this: DisplayRegion, scissor_enabled: bool) {.importcpp: "#->set_scissor_enabled(#)".} ## \
## Sets whether or not scissor testing is enabled for this region.  The
## default is true, except for the overlay display region.

func cullCallback*(this: DisplayRegion): CallbackObject {.importcpp: "#->get_cull_callback()".} ## \
## Returns the CallbackObject set by set_cull_callback().

proc `cullCallback=`*(this: DisplayRegion, `object`: CallbackObject) {.importcpp: "#->set_cull_callback(#)".} ## \
## Sets the CallbackObject that will be notified when the DisplayRegion is
## visited during the cull traversal.  This callback will be made during the
## cull thread.
##
## The cull traversal is responsible for determining which nodes are visible
## and within the view frustum, and for accumulating state and transform, and
## generally building up the list of CullableObjects that are to be eventually
## passed to the draw traversal for rendering.
##
## At the time the cull traversal callback is made, the traversal for this
## DisplayRegion has not yet started.
##
## The callback is passed an instance of a DisplayRegionCullCallbackData,
## which contains pointers to the current scene information, as well as the
## current DisplayRegion and GSG.  The callback \*replaces\* the normal cull
## behavior, so if your callback does nothing, the scene graph will not be
## traversed and therefore nothing will be drawn.  If you wish the normal cull
## traversal to be performed for this DisplayRegion, you must call
## cbdata->upcall() from your callback.

func drawCallback*(this: DisplayRegion): CallbackObject {.importcpp: "#->get_draw_callback()".} ## \
## Returns the CallbackObject set by set_draw_callback().

proc `drawCallback=`*(this: DisplayRegion, `object`: CallbackObject) {.importcpp: "#->set_draw_callback(#)".} ## \
## Sets the CallbackObject that will be notified when the contents of
## DisplayRegion is drawn during the draw traversal.  This callback will be
## made during the draw thread.
##
## The draw traversal is responsible for actually issuing the commands to the
## graphics engine to draw primitives.  Its job is to walk through the list of
## CullableObjects build up by the cull traversal, as quickly as possible,
## issuing the appropriate commands to draw each one.
##
## At the time the draw traversal callback is made, the graphics state is in
## the initial state, and no projection matrix or modelview matrix is in
## effect.  begin_scene() has not yet been called, and no objects have yet
## been drawn.  However, the viewport has already been set to the appropriate
## part of the window, and the clear commands for this DisplayRegion (if any)
## have been issued.
##
## The callback is passed an instance of a DisplayRegionDrawCallbackData,
## which contains pointers to the current scene information, as well as the
## current DisplayRegion and GSG.  The callback \*replaces\* the normal draw
## behavior, so if your callback does nothing, nothing in the DisplayRegion
## will be drawn.  If you wish the draw traversal to continue to draw the
## contents of this DisplayRegion, you must call cbdata->upcall() from your
## callback.

func pixelSize*(this: DisplayRegion, i: int): LVecBase2i {.importcpp: "#->get_pixel_size(#)".} ## \
## Returns the size of the DisplayRegion in pixels.

func pixelSize*(this: DisplayRegion): LVecBase2i {.importcpp: "#->get_pixel_size()".} ## \
## Returns the size of the DisplayRegion in pixels.

func gsg*(this: GraphicsOutput): GraphicsStateGuardian {.importcpp: "#->get_gsg()".} ## \
## Returns the GSG that is associated with this window.  There is a one-to-one
## association between windows and GSG's.
##
## This may return NULL if the graphics context has not yet been created for
## the window, e.g.  before the first frame has rendered; or after the window
## has been closed.

func pipe*(this: GraphicsOutput): GraphicsPipe {.importcpp: "#->get_pipe()".} ## \
## Returns the GraphicsPipe that this window is associated with.  It is
## possible that the GraphicsPipe might have been deleted while an outstanding
## PT(GraphicsOutput) prevented all of its children windows from also being
## deleted; in this unlikely case, get_pipe() may return NULL.

func engine*(this: GraphicsOutput): GraphicsEngine {.importcpp: "#->get_engine()".} ## \
## Returns the graphics engine that created this output.  Since there is
## normally only one GraphicsEngine object in an application, this is usually
## the same as the global GraphicsEngine.

func name*(this: GraphicsOutput): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Returns the name that was passed to the GraphicsOutput constructor.

func size*(this: GraphicsOutput): LVecBase2i {.importcpp: "#->get_size()".} ## \
## Returns the visible size of the window or buffer, if it is known.  In
## certain cases (e.g.  fullscreen windows), the size may not be known until
## after the object has been fully created.  Check has_size() first.
##
## Certain objects (like windows) may change size spontaneously; this method
## is not thread-safe.  To get the size of a window in a thread-safe manner,
## query get_properties().

func fbSize*(this: GraphicsOutput): LVecBase2i {.importcpp: "#->get_fb_size()".} ## \
## Returns the internal size of the window or buffer.  This is almost always
## the same as get_size(), except when a pixel_zoom is in effect--see
## set_pixel_zoom().

func sbsLeftSize*(this: GraphicsOutput): LVecBase2i {.importcpp: "#->get_sbs_left_size()".} ## \
## If side-by-side stereo is enabled, this returns the pixel size of the left
## eye, based on scaling get_size() by get_sbs_left_dimensions().  If side-by-
## side stereo is not enabled, this returns the same as get_size().

func sbsRightSize*(this: GraphicsOutput): LVecBase2i {.importcpp: "#->get_sbs_right_size()".} ## \
## If side-by-side stereo is enabled, this returns the pixel size of the right
## eye, based on scaling get_size() by get_sbs_right_dimensions().  If side-
## by-side stereo is not enabled, this returns the same as get_size().

func active*(this: GraphicsOutput): bool {.importcpp: "#->is_active()".} ## \
## Returns true if the window is ready to be rendered into, false otherwise.

proc `active=`*(this: GraphicsOutput, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets the active flag associated with the GraphicsOutput.  If the
## GraphicsOutput is marked inactive, nothing is rendered.

func oneShot*(this: GraphicsOutput): bool {.importcpp: "#->get_one_shot()".} ## \
## Returns the current setting of the one-shot flag.  When this is true, the
## GraphicsOutput will automatically set itself inactive after the next frame.

proc `oneShot=`*(this: GraphicsOutput, one_shot: bool) {.importcpp: "#->set_one_shot(#)".} ## \
## Changes the current setting of the one-shot flag.  When this is true, the
## GraphicsOutput will render the current frame and then automatically set
## itself inactive.  This is particularly useful for buffers that are created
## for the purposes of render-to-texture, for static textures that don't need
## to be continually re-rendered once they have been rendered the first time.
##
## Setting the buffer inactive is not the same thing as destroying it.  You
## are still responsible for passing this buffer to
## GraphicsEngine::remove_window() when you no longer need the texture, in
## order to clean up fully.  (However, you should not call remove_window() on
## this buffer while the texture is still needed, because depending on the
## render-to-texture mechanism in use, this may invalidate the texture
## contents.)

func inverted*(this: GraphicsOutput): bool {.importcpp: "#->get_inverted()".} ## \
## Returns the current setting of the inverted flag.  When this is true, the
## scene is rendered into the window upside-down, flipped like a mirror along
## the X axis.  See set_inverted().

proc `inverted=`*(this: GraphicsOutput, inverted: bool) {.importcpp: "#->set_inverted(#)".} ## \
## Changes the current setting of the inverted flag.  When this is true, the
## scene is rendered into the window upside-down and backwards, that is,
## inverted as if viewed through a mirror placed on the floor.
##
## This is primarily intended to support DirectX (and a few buggy OpenGL
## graphics drivers) that perform a framebuffer-to-texture copy upside-down
## from the usual OpenGL (and Panda) convention.  Panda will automatically set
## this flag for offscreen buffers on hardware that is known to do this, to
## compensate when rendering offscreen into a texture.

func swapEyes*(this: GraphicsOutput): bool {.importcpp: "#->get_swap_eyes()".} ## \
## Returns the current setting of the "swap eyes" flag.  See set_swap_eyes().

proc `swapEyes=`*(this: GraphicsOutput, swap_eyes: bool) {.importcpp: "#->set_swap_eyes(#)".} ## \
## Changes the "swap eyes" flag.  This flag is normally false.  When it is
## true, the left and right channels of a stereo DisplayRegion are sent to the
## opposite channels in the rendering backend.  This is meant to work around
## hardware that inadvertently swaps the output channels, or hardware for
## which it cannot be determined which channel is which until runtime.

func sort*(this: GraphicsOutput): int {.importcpp: "#->get_sort()".} ## \
## Returns the sorting order of this particular GraphicsOutput.  The various
## GraphicsOutputs within a particular thread will be rendered in the
## indicated order.

proc `sort=`*(this: GraphicsOutput, sort: int) {.importcpp: "#->set_sort(#)".} ## \
## Adjusts the sorting order of this particular GraphicsOutput, relative to
## other GraphicsOutputs.

func childSort*(this: GraphicsOutput): int {.importcpp: "#->get_child_sort()".} ## \
## Returns the sort value of future offscreen buffers created by
## make_texture_sort(). See set_child_sort().

proc `childSort=`*(this: GraphicsOutput, child_sort: int) {.importcpp: "#->set_child_sort(#)".} ## \
## Specifies the sort value of future offscreen buffers created by
## make_texture_sort().
##
## The purpose of this method is to allow the user to limit the sort value
## chosen for a buffer created via make_texture_buffer().  Normally, this
## buffer will be assigned a value of get_sort() - 1, so that it will be
## rendered before this window is rendered; but sometimes this isn't
## sufficiently early, especially if other buffers also have a view into the
## same scene.
##
## If you specify a value here, then new buffers created via
## make_texture_buffer() will be given that sort value instead of get_sort() -
## 1.

func supportsRenderTexture*(this: GraphicsOutput): bool {.importcpp: "#->get_supports_render_texture()".} ## \
## Returns true if this particular GraphicsOutput can render directly into a
## texture, or false if it must always copy-to-texture at the end of each
## frame to achieve this effect.

func active*(this: GraphicsStateGuardian): bool {.importcpp: "#->is_active()".} ## \
## Returns the active flag associated with the GraphicsStateGuardian.

proc `active=`*(this: GraphicsStateGuardian, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets the active flag associated with the GraphicsStateGuardian.  If the
## GraphicsStateGuardian is marked inactive, nothing is rendered.  This is not
## normally turned off unless there is a problem with the rendering detected
## at a low level.

func valid*(this: GraphicsStateGuardian): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the GSG has been correctly initialized within a graphics
## context, false if there has been some problem or it hasn't been initialized
## yet.

proc `incompleteRender=`*(this: GraphicsStateGuardian, incomplete_render: bool) {.importcpp: "#->set_incomplete_render(#)".} ## \
## Sets the incomplete_render flag.  When this is true, the frame will be
## rendered even if some of the geometry or textures in the scene are not
## available (e.g.  they have been temporarily paged out).  When this is
## false, the frame will be held up while this data is reloaded.
##
## Setting this true allows for a smoother frame rate, but occasionally parts
## of the frame will be invisible or missing (they will generally come in
## within a second or two).  Setting this false guarantees that every frame
## will be complete, but may cause more chugs as things are loaded up at
## runtime.
##
## You may want to set this false during loading screens, to guarantee that
## all of your assets are available by the time you take the loading screen
## down.
##
## This flag may also be set individually on each DisplayRegion.  It will be
## considered true for a given DisplayRegion only if it is true on both the
## GSG and on the DisplayRegion.

func loader*(this: GraphicsStateGuardian): Loader {.importcpp: "#->get_loader()".} ## \
## Returns the Loader object that will be used by this GSG to load textures
## when necessary, if get_incomplete_render() is true.

proc `loader=`*(this: GraphicsStateGuardian, loader: Loader) {.importcpp: "#->set_loader(#)".} ## \
## Sets the Loader object that will be used by this GSG to load textures when
## necessary, if get_incomplete_render() is true.

func shaderGenerator*(this: GraphicsStateGuardian): ShaderGenerator {.importcpp: "#->get_shader_generator()".} ## \
## Returns the ShaderGenerator object that will be used by this GSG to
## generate shaders when necessary.

proc `shaderGenerator=`*(this: GraphicsStateGuardian, shader_generator: ShaderGenerator) {.importcpp: "#->set_shader_generator(#)".} ## \
## Sets the ShaderGenerator object that will be used by this GSG to generate
## shaders when necessary.

func pipe*(this: GraphicsStateGuardian): GraphicsPipe {.importcpp: "#->get_pipe()".} ## \
## Returns the graphics pipe on which this GSG was created.

func maxTextureStages*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_texture_stages()".} ## \
## Returns the maximum number of simultaneous textures that may be applied to
## geometry with multitexturing, as supported by this particular GSG.  If you
## exceed this number, the lowest-priority texture stages will not be applied.
## Use TextureStage::set_priority() to adjust the relative importance of the
## different texture stages.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

func max3dTextureDimension*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_3d_texture_dimension()".} ## \
## Returns the largest possible texture size in any one dimension for a 3-d
## texture, or -1 if there is no particular limit.  Returns 0 if 3-d textures
## are not supported.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

func max2dTextureArrayLayers*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_2d_texture_array_layers()".} ## \
## Returns the largest possible number of pages, or -1 if there is no
## particular limit.  Returns 0 if 2-d texture arrays not supported.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

func maxCubeMapDimension*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_cube_map_dimension()".} ## \
## Returns the largest possible texture size in any one dimension for a cube
## map texture, or -1 if there is no particular limit.  Returns 0 if cube map
## textures are not supported.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

func maxBufferTextureSize*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_buffer_texture_size()".} ## \
## Returns the largest possible buffer texture size, or -1 if there is no
## particular limit.  Returns 0 if cube map textures are not supported.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

func supportsTextureCombine*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_texture_combine()".} ## \
## Returns true if this particular GSG can use the TextureStage::M_combine
## mode, which includes all of the texture blend modes specified by
## set_combine_rgb() and/or set_combine_alpha().  If this is false, you must
## limit yourself to using the simpler blend modes.

func supportsTextureSavedResult*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_texture_saved_result()".} ## \
## Returns true if this GSG can use the TextureStage::CS_last_saved_result
## source, which allows you to save the result of a TextureStage and re-use it
## for multiple inputs.

func supportsTextureDot3*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_texture_dot3()".} ## \
## Returns true if this GSG can use the TextureStage::CM_dot3_rgb or
## CM_dot3_rgba combine modes.

func supports3dTexture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_3d_texture()".} ## \
## Returns true if this GSG can render 3-d (volumetric) textures.

func supports2dTextureArray*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_2d_texture_array()".} ## \
## Returns true if this GSG can render 2-d textures array.

func supportsCubeMap*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_cube_map()".} ## \
## Returns true if this GSG can render cube map textures.

func supportsBufferTexture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_buffer_texture()".} ## \
## Returns true if this GSG can render buffer textures.

func supportsCubeMapArray*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_cube_map_array()".} ## \
## Returns true if this GSG can render cube map arrays.

func supportsTexNonPow2*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_tex_non_pow2()".} ## \
## Returns true if this GSG can handle non power of two sized textures.

func supportsCompressedTexture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_compressed_texture()".} ## \
## Returns true if this GSG can compress textures as it loads them into
## texture memory, and/or accept pre-compressed textures for storing.

func maxLights*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_lights()".} ## \
## Returns the maximum number of simultaneous lights that may be rendered on
## geometry, or -1 if there is no particular limit.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

func maxClipPlanes*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_clip_planes()".} ## \
## Returns the maximum number of simultaneous clip planes that may be applied
## to geometry, or -1 if there is no particular limit.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

func maxVertexTransforms*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_vertex_transforms()".} ## \
## Returns the maximum number of transform matrices that may be simultaneously
## used to transform any one vertex by the graphics hardware.  If this number
## is 0, then the hardware (or the graphics backend) doesn't support soft-
## skinned vertices (in which case Panda will animate the vertices in
## software).
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

func maxVertexTransformIndices*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_vertex_transform_indices()".} ## \
## Returns the maximum number of transforms there may be in a single
## TransformTable for this graphics hardware.  If this number is 0 (but
## get_max_transforms() is nonzero), then the graphics hardware (or API)
## doesn't support indexed transforms, but can support direct transform
## references.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

func copyTextureInverted*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_copy_texture_inverted()".} ## \
## Returns true if this particular GSG has the property that any framebuffer-
## to-texture copy results in a texture that is upside-down and backwards from
## Panda's usual convention; that is, it copies into a texture from the bottom
## up instead of from the top down.
##
## If this is true, then on offscreen GraphicsBuffer created for the purposes
## of rendering into a texture should be created with the invert flag set
## true, to compensate.  Panda will do this automatically if you create an
## offscreen buffer using GraphicsOutput::make_texture_buffer().

func supportsGenerateMipmap*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_generate_mipmap()".} ## \
## Returns true if this particular GSG can generate mipmaps for a texture
## automatically, or if they must be generated in software.  If this is true,
## then mipmaps can safely be enabled for rendered textures (e.g.  using the
## MultitexReducer).

func supportsDepthTexture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_depth_texture()".} ## \
## Returns true if this particular GSG supports textures whose format is
## F_depth_stencil.  This returns true if the GSG supports GL_DEPTH_COMPONENT
## textures, which are considered a limited but still valid case of
## F_depth_stencil.

func supportsDepthStencil*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_depth_stencil()".} ## \
## Returns true if this particular GSG supports textures whose format is
## F_depth_stencil.  This only returns true if the GSG supports the full
## packed depth-stencil functionality.

func supportsLuminanceTexture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_luminance_texture()".} ## \
## Returns true if this particular GSG supports luminance textures.

func supportsSamplerObjects*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_sampler_objects()".} ## \
## Returns true if this particular GSG supports the use of sampler objects to
## record texture sampling parameters separately from the texture objects.
## This doesn't really affect functionality, but if this is false, it may mean
## that using the same texture with different SamplerState objects will result
## in reduced performance.

func supportsBasicShaders*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_basic_shaders()".} ## \
## Returns true if this particular GSG supports arbfp1+arbvp1 or above.

func supportsGeometryShaders*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_geometry_shaders()".} ## \
## Returns true if this particular GSG supports geometry shaders.

func supportsTessellationShaders*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_tessellation_shaders()".} ## \
## Returns true if this particular GSG supports tesselation shaders.

func supportsComputeShaders*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_compute_shaders()".} ## \
## Returns true if this particular GSG supports compute shaders.

func supportsGlsl*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_glsl()".} ## \
## Returns true if this particular GSG supports GLSL shaders.

func supportsStencil*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_stencil()".} ## \
## Returns true if this particular GSG supports stencil buffers at all.

func supportsTwoSidedStencil*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_two_sided_stencil()".} ## \
## Returns true if this particular GSG supports two sided stencil: different
## stencil settings for the front and back side of the same polygon.

func supportsGeometryInstancing*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_geometry_instancing()".} ## \
## Returns true if this particular GSG supports hardware geometry instancing:
## the ability to render multiple copies of a model.  In OpenGL, this is done
## using the EXT_draw_instanced extension.

func supportsIndirectDraw*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_indirect_draw()".} ## \
## Returns true if this particular GSG supports draw calls for which the
## information comes from a buffer.

func supportsOcclusionQuery*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_occlusion_query()".} ## \
## Returns true if this GSG supports an occlusion query.  If this is true,
## then begin_occlusion_query() and end_occlusion_query() may be called to
## bracket a sequence of draw_triangles() (or whatever) calls to measure
## pixels that pass the depth test.

func supportsTimerQuery*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_timer_query()".} ## \
## Returns true if this GSG supports a timer query.

func timerQueriesActive*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_timer_queries_active()".} ## \
## Returns true if timer queries are currently enabled on this GSG.

func maxColorTargets*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_color_targets()".} ## \
## Returns the maximum number of simultaneous color textures that may be
## attached for render-to-texture, as supported by this particular GSG.  If
## you exceed this number, the lowest-priority render targets will not be
## applied.  Use RenderTarget::set_priority() to adjust the relative
## importance of the different render targets.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

func supportsDualSourceBlending*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_dual_source_blending()".} ## \
## Returns true if dual source (incoming1_color and incoming1_alpha) blend
## operands are supported by this GSG.

func coordinateSystem*(this: GraphicsStateGuardian): CoordinateSystem {.importcpp: "#->get_coordinate_system()".} ## \
## Returns the coordinate system in effect on this particular gsg.  Normally,
## this will be the default coordinate system, but it might be set differently
## at runtime.

proc `coordinateSystem=`*(this: GraphicsStateGuardian, cs: CoordinateSystem) {.importcpp: "#->set_coordinate_system(#)".}

func preparedObjects*(this: GraphicsStateGuardian): PreparedGraphicsObjects {.importcpp: "#->get_prepared_objects()".}

func gamma*(this: GraphicsStateGuardian): float32 {.importcpp: "#->get_gamma()".}

proc `gamma=`*(this: GraphicsStateGuardian, gamma: float32): bool {.importcpp: "#->set_gamma(#)".}

func flashTexture*(this: GraphicsStateGuardian): Texture {.importcpp: "#->get_flash_texture()".}

proc `flashTexture=`*(this: GraphicsStateGuardian, tex: Texture) {.importcpp: "#->set_flash_texture(#)".}

func driverVendor*(this: GraphicsStateGuardian): string {.importcpp: "nimStringFromStdString(#->get_driver_vendor())", header: stringConversionCode.}

func driverRenderer*(this: GraphicsStateGuardian): string {.importcpp: "nimStringFromStdString(#->get_driver_renderer())", header: stringConversionCode.}

func driverVersion*(this: GraphicsStateGuardian): string {.importcpp: "nimStringFromStdString(#->get_driver_version())", header: stringConversionCode.}

func driverVersionMajor*(this: GraphicsStateGuardian): int {.importcpp: "#->get_driver_version_major()".}

func driverVersionMinor*(this: GraphicsStateGuardian): int {.importcpp: "#->get_driver_version_minor()".}

func driverShaderVersionMajor*(this: GraphicsStateGuardian): int {.importcpp: "#->get_driver_shader_version_major()".}

func driverShaderVersionMinor*(this: GraphicsStateGuardian): int {.importcpp: "#->get_driver_shader_version_minor()".}

func scene*(this: GraphicsStateGuardian): SceneSetup {.importcpp: "#->get_scene()".}

proc `scene=`*(this: GraphicsStateGuardian, scene_setup: SceneSetup): bool {.importcpp: "#->set_scene(#)".}

func threadingModel*(this: GraphicsEngine): GraphicsThreadingModel {.importcpp: "#->get_threading_model()".} ## \
## Returns the threading model that will be applied to future objects.  See
## set_threading_model().

proc `threadingModel=`*(this: GraphicsEngine, threading_model: GraphicsThreadingModel) {.importcpp: "#->set_threading_model(#)".} ## \
## Specifies how future objects created via make_gsg(), make_buffer(), and
## make_output() will be threaded.  This does not affect any already-created
## objects.

func renderLock*(this: GraphicsEngine): ReMutex {.importcpp: "#->get_render_lock()".} ## \
## Returns a ReMutex object that is held by the GraphicsEngine during the
## entire call to render_frame().  While you hold this lock you can be
## confident that no part of the frame will be rendered (at least by the app
## thread).

func autoFlip*(this: GraphicsEngine): bool {.importcpp: "#->get_auto_flip()".} ## \
## Returns the current setting for the auto-flip flag.  See set_auto_flip.

proc `autoFlip=`*(this: GraphicsEngine, auto_flip: bool) {.importcpp: "#->set_auto_flip(#)".} ## \
## Set this flag true to indicate the GraphicsEngine should automatically
## cause windows to sync and flip as soon as they have finished drawing,
## rather than waiting for all of the windows to finish drawing first so they
## can flip together.
##
## This only affects the timing of when the flip occurs.  If this is true (the
## default), the flip occurs before render_frame() returns.  If this is false,
## the flip occurs whenever flip_frame() is called, or at the beginning of the
## next call to render_frame(), if flip_frame() is never called.

func portalCull*(this: GraphicsEngine): bool {.importcpp: "#->get_portal_cull()".} ## \
## Returns the current setting for the portal culling flag.

proc `portalCull=`*(this: GraphicsEngine, value: bool) {.importcpp: "#->set_portal_cull(#)".} ## \
## Set this flag true to indicate the GraphicsEngine should start portal
## culling

func defaultLoader*(this: GraphicsEngine): Loader {.importcpp: "#->get_default_loader()".} ## \
## Returns the Loader object that will be assigned to every GSG created with
## this GraphicsEngine.  See GraphicsStateGuardian::set_loader().

proc `defaultLoader=`*(this: GraphicsEngine, loader: Loader) {.importcpp: "#->set_default_loader(#)".} ## \
## Sets the Loader object that will be assigned to every GSG created with this
## GraphicsEngine.  See GraphicsStateGuardian::set_loader().

func leftEye*(this: StereoDisplayRegion): DisplayRegion {.importcpp: "#->get_left_eye()".} ## \
## Returns a pointer to the left DisplayRegion managed by this stereo object.

func rightEye*(this: StereoDisplayRegion): DisplayRegion {.importcpp: "#->get_right_eye()".} ## \
## Returns a pointer to the right DisplayRegion managed by this stereo object.

func depthBits*(this: FrameBufferProperties): int {.importcpp: "#.get_depth_bits()".} ## \
## Individual queries.

proc `depthBits=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_depth_bits(#)".} ## \
## Individual assigners.

func colorBits*(this: FrameBufferProperties): int {.importcpp: "#.get_color_bits()".}

proc `colorBits=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_color_bits(#)".} ## \
## Sets the number of requested color bits as a single number that represents
## the sum of the individual numbers of red, green and blue bits.  Panda won't
## care how the individual bits are divided up.
##
## See also set_rgba_bits, which allows you to specify requirements for the
## individual components.

func redBits*(this: FrameBufferProperties): int {.importcpp: "#.get_red_bits()".}

proc `redBits=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_red_bits(#)".}

func greenBits*(this: FrameBufferProperties): int {.importcpp: "#.get_green_bits()".}

proc `greenBits=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_green_bits(#)".}

func blueBits*(this: FrameBufferProperties): int {.importcpp: "#.get_blue_bits()".}

proc `blueBits=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_blue_bits(#)".}

func alphaBits*(this: FrameBufferProperties): int {.importcpp: "#.get_alpha_bits()".}

proc `alphaBits=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_alpha_bits(#)".}

func stencilBits*(this: FrameBufferProperties): int {.importcpp: "#.get_stencil_bits()".}

proc `stencilBits=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_stencil_bits(#)".}

func accumBits*(this: FrameBufferProperties): int {.importcpp: "#.get_accum_bits()".}

proc `accumBits=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_accum_bits(#)".}

func auxRgba*(this: FrameBufferProperties): int {.importcpp: "#.get_aux_rgba()".}

proc `auxRgba=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_aux_rgba(#)".}

func auxHrgba*(this: FrameBufferProperties): int {.importcpp: "#.get_aux_hrgba()".}

proc `auxHrgba=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_aux_hrgba(#)".}

func auxFloat*(this: FrameBufferProperties): int {.importcpp: "#.get_aux_float()".}

proc `auxFloat=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_aux_float(#)".}

func multisamples*(this: FrameBufferProperties): int {.importcpp: "#.get_multisamples()".}

proc `multisamples=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_multisamples(#)".}

func coverageSamples*(this: FrameBufferProperties): int {.importcpp: "#.get_coverage_samples()".} ## \
## If coverage samples are specified, and there is hardware support, we use
## coverage multisampling.

proc `coverageSamples=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_coverage_samples(#)".} ## \
## If coverage samples are specified, and there is hardware support, we use
## coverage multisampling

func backBuffers*(this: FrameBufferProperties): int {.importcpp: "#.get_back_buffers()".}

proc `backBuffers=`*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_back_buffers(#)".}

func indexedColor*(this: FrameBufferProperties): bool {.importcpp: "#.get_indexed_color()".}

proc `indexedColor=`*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_indexed_color(#)".}

func rgbColor*(this: FrameBufferProperties): bool {.importcpp: "#.get_rgb_color()".}

proc `rgbColor=`*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_rgb_color(#)".}

func stereo*(this: FrameBufferProperties): bool {.importcpp: "#.get_stereo()".}

proc `stereo=`*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_stereo(#)".}

func forceHardware*(this: FrameBufferProperties): bool {.importcpp: "#.get_force_hardware()".}

proc `forceHardware=`*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_force_hardware(#)".}

func forceSoftware*(this: FrameBufferProperties): bool {.importcpp: "#.get_force_software()".}

proc `forceSoftware=`*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_force_software(#)".}

func srgbColor*(this: FrameBufferProperties): bool {.importcpp: "#.get_srgb_color()".}

proc `srgbColor=`*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_srgb_color(#)".}

func floatColor*(this: FrameBufferProperties): bool {.importcpp: "#.get_float_color()".}

proc `floatColor=`*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_float_color(#)".}

func floatDepth*(this: FrameBufferProperties): bool {.importcpp: "#.get_float_depth()".}

proc `floatDepth=`*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_float_depth(#)".}

func properties*(this: GraphicsWindow): WindowProperties {.importcpp: "#->get_properties()".} ## \
## Returns the current properties of the window.

func requestedProperties*(this: GraphicsWindow): WindowProperties {.importcpp: "#->get_requested_properties()".} ## \
## Returns the properties of the window that are currently requested.  These
## properties will be applied to the window (if valid) at the next execution
## of process_events().

func rejectedProperties*(this: GraphicsWindow): WindowProperties {.importcpp: "#->get_rejected_properties()".} ## \
## Returns the set of properties that have recently been requested, but could
## not be applied to the window for some reason.  This set of properties will
## remain unchanged until they are changed by a new failed request, or
## clear_rejected_properties() is called.

func closed*(this: GraphicsWindow): bool {.importcpp: "#->is_closed()".} ## \
## Returns true if the window has not yet been opened, or has been fully
## closed, false if it is open.  The window is not opened immediately after
## GraphicsEngine::make_output() is called; nor is it closed immediately after
## GraphicsEngine::remove_window() is called.  Either operation may take a
## frame or two.

func windowEvent*(this: GraphicsWindow): string {.importcpp: "nimStringFromStdString(#->get_window_event())", header: stringConversionCode.} ## \
## Returns the name of the event that is generated when this window is
## modified externally, e.g.  to be resized or closed by the user.  See
## set_window_event().

proc `windowEvent=`*(this: GraphicsWindow, window_event: string) {.importcpp: "#->set_window_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name of the event that is generated when this window is
## modified externally, e.g.  to be resized or closed by the user.
##
## By default, all windows have the same window event unless they are
## explicitly changed.  When the event is generated, it includes one
## parameter: the window itself.

func closeRequestEvent*(this: GraphicsWindow): string {.importcpp: "nimStringFromStdString(#->get_close_request_event())", header: stringConversionCode.} ## \
## Returns the name of the event set via set_close_request_event().  If this
## string is nonempty, then when the user requests to close window, this event
## will be generated instead.  See set_close_request_event().

proc `closeRequestEvent=`*(this: GraphicsWindow, close_request_event: string) {.importcpp: "#->set_close_request_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the event that is triggered when the user requests to close the
## window, e.g.  via alt-F4, or clicking on the close box.
##
## The default for each window is for this event to be the empty string, which
## means the window-close request is handled immediately by Panda (and the
## window will be closed without the app getting a chance to intervene).  If
## you set this to a nonempty string, then the window is not closed, but
## instead the event is thrown.  It is then up to the app to respond
## appropriately, for instance by presenting an "are you sure?"  dialog box,
## and eventually calling close_window() when the user is sure.
##
## It is considered poor form to set this string and then not handle the
## event.  This can frustrate the user by making it difficult for him to
## cleanly shut down the application (and may force the user to hard-kill the
## app, or reboot the machine).

func unexposedDraw*(this: GraphicsWindow): bool {.importcpp: "#->get_unexposed_draw()".} ## \
## See set_unexposed_draw().

proc `unexposedDraw=`*(this: GraphicsWindow, unexposed_draw: bool) {.importcpp: "#->set_unexposed_draw(#)".} ## \
## If this flag is false, the window is redrawn only after it has received a
## recent "unexpose" or "draw" event from the underlying windowing system.  If
## this flag is true, the window is redrawn every frame regardless.  Setting
## this false may prevent the window from redrawing unnecessarily when it is
## hidden, and may play nicer with other windows on the desktop, but may
## adversely affect frame rate even when the window is fully visible; setting
## it true will ensure that the window contents are always current.

func windowHandle*(this: GraphicsWindow): WindowHandle {.importcpp: "#->get_window_handle()".} ## \
## Returns the WindowHandle corresponding to this window on the desktop.  This
## is mainly useful for communicating with external libraries.  Use
## window_handle->get_os_handle()->get_handle(), or
## window_handle->get_string_handle(), to get the actual OS-specific window
## handle object, whatever type that might be.

func syncName*(this: Thread): string {.importcpp: "nimStringFromStdString(#->get_sync_name())", header: stringConversionCode.} ## \
## Returns the sync name of the thread.  This name collects threads into "sync
## groups", which are expected to run synchronously.  This is mainly used for
## the benefit of PStats; threads with the same sync name can be ticked all at
## once via the thread_tick() call.

func pstatsIndex*(this: Thread): int {.importcpp: "#->get_pstats_index()".} ## \
## Returns the PStats index associated with this thread, or -1 if no index has
## yet been associated with this thread.  This is used internally by the
## PStatClient; you should not need to call this directly.

func pythonIndex*(this: Thread): int {.importcpp: "#->get_python_index()".} ## \
## Returns the Python index associated with this thread, or -1 if no index has
## yet been associated with this thread.  This is used internally by the
## direct.stdpy.thread module; you should not need to call this directly.

func uniqueId*(this: Thread): string {.importcpp: "nimStringFromStdString(#->get_unique_id())", header: stringConversionCode.} ## \
## Returns a string that is guaranteed to be unique to this thread, across all
## processes on the machine, during at least the lifetime of this process.

func pipelineStage*(this: Thread): int {.importcpp: "#->get_pipeline_stage()".} ## \
## Returns the Pipeline stage number associated with this thread.  The default
## stage is 0 if no stage is specified otherwise.  See set_pipeline_stage().

proc `pipelineStage=`*(this: Thread, pipeline_stage: int) {.importcpp: "#->set_pipeline_stage(#)".} ## \
## Specifies the Pipeline stage number associated with this thread.  The
## default stage is 0 if no stage is specified otherwise.
##
## This must be a value in the range [0 .. pipeline->get_num_stages() - 1].
## It specifies the values that this thread observes for all pipelined data.
## Typically, an application thread will leave this at 0, but a render thread
## may set it to 1 or 2 (to operate on the previous frame's data, or the
## second previous frame's data).

func mainThread*(_: typedesc[Thread]): Thread {.importcpp: "Thread::get_main_thread()", header: "thread.h".} ## \
## Returns a pointer to the "main" Thread object--this is the Thread that
## started the whole process.

func externalThread*(_: typedesc[Thread]): Thread {.importcpp: "Thread::get_external_thread()", header: "thread.h".} ## \
## Returns a pointer to the "external" Thread object--this is a special Thread
## object that corresponds to any thread spawned outside of Panda's threading
## interface.  Note that multiple different threads may share this same
## pointer.

func currentThread*(_: typedesc[Thread]): Thread {.importcpp: "Thread::get_current_thread()", header: "thread.h".} ## \
## Returns a pointer to the currently-executing Thread object.  If this is
## called from the main thread, this will return the same value as
## get_main_thread().
##
## This will always return some valid Thread pointer.  It will never return
## NULL, even if the current thread was spawned outside of Panda's threading
## system, although all non-Panda threads will return the exact same Thread
## pointer.

func currentPipelineStage*(_: typedesc[Thread]): int {.importcpp: "Thread::get_current_pipeline_stage()", header: "thread.h".} ## \
## Returns the integer pipeline stage associated with the current thread.
## This is the same thing as get_current_thread()->get_pipeline_stage(), but
## it may be faster to retrieve in some contexts.

func threadingSupported*(_: typedesc[Thread]): bool {.importcpp: "Thread::is_threading_supported()", header: "thread.h".} ## \
## Returns true if threading support has been compiled in and enabled, or
## false if no threading is available (and Thread::start() will always fail).

func trueThreads*(_: typedesc[Thread]): bool {.importcpp: "Thread::is_true_threads()", header: "thread.h".} ## \
## Returns true if a real threading library is available that supports actual
## OS-implemented threads, or false if the only threading we can provide is
## simulated user-space threading.

func simpleThreads*(_: typedesc[Thread]): bool {.importcpp: "Thread::is_simple_threads()", header: "thread.h".} ## \
## Returns true if Panda is currently compiled for "simple threads", which is
## to say, cooperative context switching only, reducing the need for quite so
## many critical section protections.  This is not necessarily the opposite of
## "true threads", since one possible implementation of simple threads is via
## true threads with mutex protection to ensure only one runs at a time.

func started*(this: Thread): bool {.importcpp: "#->is_started()".} ## \
## Returns true if the thread has been started, false if it has not, or if
## join() has already been called.

func joinable*(this: Thread): bool {.importcpp: "#->is_joinable()".} ## \
## Returns the value of joinable that was passed to the start() call.

func currentTask*(this: Thread): TypedReferenceCount {.importcpp: "#->get_current_task()".} ## \
## Returns the task currently executing on this thread (via the
## AsyncTaskManager), if any, or NULL if the thread is not currently servicing
## a task.

func clock*(this: AsyncTaskManager): ClockObject {.importcpp: "#->get_clock()".} ## \
## Returns the clock pointer used within the AsyncTaskManager.  See
## set_clock().

proc `clock=`*(this: AsyncTaskManager, clock: ClockObject) {.importcpp: "#->set_clock(#)".} ## \
## Replaces the clock pointer used within the AsyncTaskManager.  This is used
## to control when tasks with a set_delay() specified will be scheduled.  It
## can also be ticked automatically each epoch, if set_tick_clock() is true.
##
## The default is the global clock pointer.

func tasks*(this: AsyncTaskManager): AsyncTaskCollection {.importcpp: "#->get_tasks()".} ## \
## Returns the set of tasks that are active or sleeping on the task manager,
## at the time of the call.

func activeTasks*(this: AsyncTaskManager): AsyncTaskCollection {.importcpp: "#->get_active_tasks()".} ## \
## Returns the set of tasks that are active (and not sleeping) on the task
## manager, at the time of the call.

func sleepingTasks*(this: AsyncTaskManager): AsyncTaskCollection {.importcpp: "#->get_sleeping_tasks()".} ## \
## Returns the set of tasks that are sleeping (and not active) on the task
## manager, at the time of the call.

func nextWakeTime*(this: AsyncTaskManager): float64 {.importcpp: "#->get_next_wake_time()".} ## \
## Returns the scheduled time (on the manager's clock) of the next sleeping
## task, on any task chain, to awaken.  Returns -1 if there are no sleeping
## tasks.

func name*(this: Event): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.}

proc `name=`*(this: Event, name: string) {.importcpp: "#->set_name(nimStringToStdString(#))", header: stringConversionCode.}

func numTransforms*(this: GeomVertexAnimationSpec): int {.importcpp: "#.get_num_transforms()".} ## \
## This is only meaningful for animation_type AT_hardware.  It specifies the
## maximum number of transforms that might be simultaneously applied to any
## one vertex by the data in this format.

func indexedTransforms*(this: GeomVertexAnimationSpec): bool {.importcpp: "#.get_indexed_transforms()".} ## \
## This is only meaningful for animation_type AT_hardware.  If true, it
## indicates that the format uses indexed animation tables.  It is false if
## each vertex will reference the first _num_transforms table entries only.

func parent*(this: InternalName): InternalName {.importcpp: "#->get_parent()".} ## \
## Return the parent of this InternalName.  All names have a parent, except
## the root name.

func name*(this: InternalName): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Returns the complete name represented by the InternalName and all of its
## parents.

func basename*(this: InternalName): string {.importcpp: "nimStringFromStdString(#->get_basename())", header: stringConversionCode.} ## \
## Return the name represented by just this particular InternalName object,
## ignoring its parents names.  This is everything after the rightmost dot.

func registered*(this: GeomVertexArrayFormat): bool {.importcpp: "#->is_registered()".} ## \
## Returns true if this format has been registered, false if it has not.  It
## may not be used for a Geom until it has been registered, but once
## registered, it may no longer be modified.

func stride*(this: GeomVertexArrayFormat): int {.importcpp: "#->get_stride()".} ## \
## Returns the total number of bytes reserved in the array for each vertex.

proc `stride=`*(this: GeomVertexArrayFormat, stride: int) {.importcpp: "#->set_stride(#)".} ## \
## Changes the total number of bytes reserved in the array for each vertex.
## You may not reduce this below get_total_bytes(), but you may increase it
## arbitrarily.

func padTo*(this: GeomVertexArrayFormat): int {.importcpp: "#->get_pad_to()".} ## \
## Returns the byte divisor to which the data record must be padded to meet
## hardware limitations.  For instance, if this is 4, the stride will be
## automatically rounded up to the next multiple of 4 bytes.  This value is
## automatically increased as needed to ensure the individual numeric
## components in the array are word-aligned.

proc `padTo=`*(this: GeomVertexArrayFormat, pad_to: int) {.importcpp: "#->set_pad_to(#)".} ## \
## Explicitly sets the byte divisor to which the data record must be padded to
## meet hardware limitations.  See get_pad_to().  Normally it is not necessary
## to call this unless you have some specific requirements for row-to-row data
## alignment.  Note that this value may be automatically increased at each
## subsequent call to add_column().

func divisor*(this: GeomVertexArrayFormat): int {.importcpp: "#->get_divisor()".} ## \
## Returns the divisor attribute for the data in this array.  If 0, it
## contains per-vertex data.  If 1, it contains per-instance data.  If higher
## than 1, the read row is advanced for each n instances.

proc `divisor=`*(this: GeomVertexArrayFormat, divisor: int) {.importcpp: "#->set_divisor(#)".} ## \
## Set this to 0 to indicate that this array contains per-vertex data, or to 1
## to indicate that it contains per-instance data.  If higher than 1, the read
## row is advanced for each n instances.

func totalBytes*(this: GeomVertexArrayFormat): int {.importcpp: "#->get_total_bytes()".} ## \
## Returns the total number of bytes used by the data types within the format,
## including gaps between elements.

func registered*(this: GeomVertexFormat): bool {.importcpp: "#->is_registered()".} ## \
## Returns true if this format has been registered, false if it has not.  It
## may not be used for a Geom until it has been registered, but once
## registered, it may no longer be modified.

func animation*(this: GeomVertexFormat): GeomVertexAnimationSpec {.importcpp: "#->get_animation()".} ## \
## Returns the GeomVertexAnimationSpec that indicates how this format's
## vertices are set up for animation.

proc `animation=`*(this: GeomVertexFormat, animation: GeomVertexAnimationSpec) {.importcpp: "#->set_animation(#)".} ## \
## Resets the GeomVertexAnimationSpec that indicates how this format's
## vertices are set up for animation.  You should also, of course, change the
## columns in the tables accordingly.
##
## This may not be called once the format has been registered.

func saveFile*(_: typedesc[VertexDataPage]): VertexDataSaveFile {.importcpp: "VertexDataPage::get_save_file()", header: "vertexDataPage.h".} ## \
## Returns the global VertexDataSaveFile that will be used to save vertex data
## buffers to disk when necessary.

func arrayFormat*(this: GeomVertexArrayData): GeomVertexArrayFormat {.importcpp: "deconstify(#->get_array_format())", header: deconstifyCode.} ## \
## Returns the format object that describes this array.

func dataSizeBytes*(this: GeomVertexArrayData): clonglong {.importcpp: "#->get_data_size_bytes()".} ## \
## Returns the number of bytes stored in the array.

func modified*(this: GeomVertexArrayData): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the array vertex data is modified.

func arrayFormat*(this: GeomVertexArrayDataHandle): GeomVertexArrayFormat {.importcpp: "deconstify(#->get_array_format())", header: deconstifyCode.}

func dataSizeBytes*(this: GeomVertexArrayDataHandle): clonglong {.importcpp: "#->get_data_size_bytes()".}

func modified*(this: GeomVertexArrayDataHandle): UpdateSeq {.importcpp: "#->get_modified()".}

func registered*(this: TransformTable): bool {.importcpp: "#->is_registered()".} ## \
## Returns true if this table has been registered.  Once it has been
## registered, the set of transforms in a TransformTable may not be further
## modified; but it must be registered before it can be assigned to a Geom.

func modified*(this: TransformTable, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number that's guaranteed to change at least when any
## VertexTransforms in the table change.  (However, this is only true for a
## registered table.  An unregistered table may or may not reflect an update
## here when a VertexTransform changes.)

func modified*(this: TransformTable): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number that's guaranteed to change at least when any
## VertexTransforms in the table change.  (However, this is only true for a
## registered table.  An unregistered table may or may not reflect an update
## here when a VertexTransform changes.)

func modified*(this: TransformBlend, current_thread: Thread): UpdateSeq {.importcpp: "#.get_modified(#)".} ## \
## Returns a counter which is guaranteed to increment at least as often as the
## result of get_blend() changes.

func modified*(this: TransformBlend): UpdateSeq {.importcpp: "#.get_modified()".} ## \
## Returns a counter which is guaranteed to increment at least as often as the
## result of get_blend() changes.

func modified*(this: TransformBlendTable, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a counter which is guaranteed to increment at least when any
## TransformBlends within the table have changed.

func modified*(this: TransformBlendTable): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a counter which is guaranteed to increment at least when any
## TransformBlends within the table have changed.

func numTransforms*(this: TransformBlendTable): int {.importcpp: "#->get_num_transforms()".} ## \
## Returns the number of unique VertexTransform objects represented in the
## table.  This will correspond to the size of the TransformTable object that
## would represent the same table.  This is also the same limit reflected by
## GraphicsStateGuardian::get_max_vertex_transform_indices().

func maxSimultaneousTransforms*(this: TransformBlendTable): int {.importcpp: "#->get_max_simultaneous_transforms()".} ## \
## Returns the maximum number of unique VertexTransform objects that are
## applied to any one vertex simultaneously.  This is the same limit reflected
## by GraphicsStateGuardian::get_max_vertex_transforms().

func rows*(this: TransformBlendTable): SparseArray {.importcpp: "#->get_rows()".} ## \
## Returns the subset of rows (vertices) in the associated GeomVertexData that
## this TransformBlendTable actually affects.

proc `rows=`*(this: TransformBlendTable, rows: SparseArray) {.importcpp: "#->set_rows(#)".} ## \
## Specifies the subset of rows (vertices) in the associated GeomVertexData
## that this TransformBlendTable actually affects.

func modified*(this: SliderTable, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number that's guaranteed to change at least when any
## VertexSliders in the table change.  (However, this is only true for a
## registered table.  An unregistered table may or may not reflect an update
## here when a VertexSlider changes.)

func modified*(this: SliderTable): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number that's guaranteed to change at least when any
## VertexSliders in the table change.  (However, this is only true for a
## registered table.  An unregistered table may or may not reflect an update
## here when a VertexSlider changes.)

func name*(this: GeomVertexData): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Returns the name passed to the constructor, if any.  This name is reported
## on the PStats graph for vertex computations.

proc `name=`*(this: GeomVertexData, name: string) {.importcpp: "#->set_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name of the vertex data.  This name is reported on the PStats
## graph for vertex computations.

func format*(this: GeomVertexData): GeomVertexFormat {.importcpp: "deconstify(#->get_format())", header: deconstifyCode.} ## \
## Returns a pointer to the GeomVertexFormat structure that defines this data.

proc `format=`*(this: GeomVertexData, format: GeomVertexFormat) {.importcpp: "#->set_format(#)".} ## \
## Changes the format of the vertex data.  If the data is not empty, this will
## implicitly change every row to match the new format.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

func transformTable*(this: GeomVertexData): TransformTable {.importcpp: "deconstify(#->get_transform_table())", header: deconstifyCode.} ## \
## Returns a const pointer to the TransformTable assigned to this data.
## Vertices within the table will index into this table to indicate their
## dynamic skinning information; this table is used when the vertex animation
## is to be performed by the graphics hardware (but also see
## get_transform_blend_table()).
##
## This will return NULL if the vertex data does not have a TransformTable
## assigned (which implies the vertices will not be animated by the graphics
## hardware).

proc `transformTable=`*(this: GeomVertexData, table: TransformTable) {.importcpp: "#->set_transform_table(#)".} ## \
## Replaces the TransformTable on this vertex data with the indicated table.
## The length of this table should be consistent with the maximum table index
## assigned to the vertices under the "transform_index" name.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

func sliderTable*(this: GeomVertexData): SliderTable {.importcpp: "deconstify(#->get_slider_table())", header: deconstifyCode.} ## \
## Returns a const pointer to the SliderTable assigned to this data.  Vertices
## within the vertex data will look up their morph offsets, if any, within
## this table.
##
## This will return NULL if the vertex data does not have a SliderTable
## assigned.

proc `sliderTable=`*(this: GeomVertexData, table: SliderTable) {.importcpp: "#->set_slider_table(#)".} ## \
## Replaces the SliderTable on this vertex data with the indicated table.
## There should be an entry in this table for each kind of morph offset
## defined in the vertex data.
##
## The SliderTable object must have been registered prior to setting it on the
## GeomVertexData.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

func numBytes*(this: GeomVertexData): int {.importcpp: "#->get_num_bytes()".} ## \
## Returns the total number of bytes consumed by the different arrays of the
## vertex data.

func modified*(this: GeomVertexData, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the vertex data is modified.

func modified*(this: GeomVertexData): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the vertex data is modified.

func dataSizeBytes*(this: BufferContext): clonglong {.importcpp: "#->get_data_size_bytes()".} ## \
## Returns the number of bytes previously reported for the data object.  This
## is used to track changes in the data object's allocated size; if it changes
## from this, we need to create a new buffer.  This is also used to track
## memory utilization in PStats.

func modified*(this: BufferContext): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns the UpdateSeq that was recorded the last time mark_loaded() was
## called.

func active*(this: BufferContext): bool {.importcpp: "#->get_active()".} ## \
## Returns the active flag associated with this object.  An object is
## considered "active" if it was rendered in the current frame.

func resident*(this: BufferContext): bool {.importcpp: "#->get_resident()".} ## \
## Returns the resident flag associated with this object.  An object is
## considered "resident" if it appears to be resident in texture memory.

func geomRendering*(this: GeomPrimitive): int {.importcpp: "#->get_geom_rendering()".} ## \
## Returns the set of GeomRendering bits that represent the rendering
## properties required to properly render this primitive.

func numBytes*(this: GeomPrimitive): int {.importcpp: "#->get_num_bytes()".} ## \
## Returns the number of bytes consumed by the primitive and its index
## table(s).

func dataSizeBytes*(this: GeomPrimitive): int {.importcpp: "#->get_data_size_bytes()".} ## \
## Returns the number of bytes stored in the vertices array.

func modified*(this: GeomPrimitive): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the vertex index array is modified.

func indexStride*(this: GeomPrimitive): int {.importcpp: "#->get_index_stride()".} ## \
## A convenience function to return the gap between successive index numbers,
## in bytes, of the index data.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

func stripCutIndex*(this: GeomPrimitive): int {.importcpp: "#->get_strip_cut_index()".} ## \
## If relevant, returns the index value that may be used in some cases to
## signify the end of a primitive.  This is typically the highest value that
## the numeric type can store.

func mins*(this: GeomPrimitive): GeomVertexArrayData {.importcpp: "deconstify(#->get_mins())", header: deconstifyCode.} ## \
## Returns a const pointer to the primitive mins array so application code can
## read it directly.  Do not attempt to modify the returned array; use
## set_minmax() for this.
##
## Note that simple primitive types, like triangles, do not have a mins array.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

func maxs*(this: GeomPrimitive): GeomVertexArrayData {.importcpp: "deconstify(#->get_maxs())", header: deconstifyCode.} ## \
## Returns a const pointer to the primitive maxs array so application code can
## read it directly.  Do not attempt to modify the returned array; use
## set_minmax().
##
## Note that simple primitive types, like triangles, do not have a maxs array.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

func numVerticesPerPrimitive*(this: GeomPrimitive): int {.importcpp: "#->get_num_vertices_per_primitive()".} ## \
## If the primitive type is a simple type in which all primitives have the
## same number of vertices, like triangles, returns the number of vertices per
## primitive.  If the primitive type is a more complex type in which different
## primitives might have different numbers of vertices, for instance a
## triangle strip, returns 0.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

func minNumVerticesPerPrimitive*(this: GeomPrimitive): int {.importcpp: "#->get_min_num_vertices_per_primitive()".} ## \
## Returns the minimum number of vertices that must be added before
## close_primitive() may legally be called.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

func numUnusedVerticesPerPrimitive*(this: GeomPrimitive): int {.importcpp: "#->get_num_unused_vertices_per_primitive()".} ## \
## Returns the number of vertices that are added between primitives that
## aren't, strictly speaking, part of the primitives themselves.  This is
## used, for instance, to define degenerate triangles to connect otherwise
## disconnected triangle strips.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

func name*(this: TextureStage): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Returns the name of this texture stage

proc `name=`*(this: TextureStage, name: string) {.importcpp: "#->set_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name of this texture stage

func sort*(this: TextureStage): int {.importcpp: "#->get_sort()".} ## \
## Returns the sort order of this texture stage.

proc `sort=`*(this: TextureStage, sort: int) {.importcpp: "#->set_sort(#)".} ## \
## Changes the order in which the texture associated with this stage is
## rendered relative to the other texture stages.  When geometry is rendered
## with multiple textures, the textures are rendered in order from the lowest
## sort number to the highest sort number.
##
## Also see set_priority(), which is used to select the most important
## textures for rendering when some must be omitted because of hardware
## limitations.

func priority*(this: TextureStage): int {.importcpp: "#->get_priority()".} ## \
## Returns the priority associated with this stage.
##
## This is specially helpful for cards that do not support more than n stages
## of multi-texturing.

proc `priority=`*(this: TextureStage, priority: int) {.importcpp: "#->set_priority(#)".} ## \
## Changes the relative importance of the texture associated with this stage
## relative to the other texture stages that are applied simultaneously.
##
## This is unrelated to set_sort(), which controls the order in which multiple
## textures are applied.  The priority number is used to decide which of the
## requested textures are to be selected for rendering when more textures are
## requested than the hardware will support.  The highest-priority n textures
## are selected for rendering, and then rendered in order by their sort
## factor.

func texcoordName*(this: TextureStage): InternalName {.importcpp: "#->get_texcoord_name()".} ## \
## See set_texcoord_name.  The default is InternalName::get_texcoord().

proc `texcoordName=`*(this: TextureStage, name: InternalName) {.importcpp: "#->set_texcoord_name(#)".} ## \
## Indicate which set of UV's this texture stage will use.  Geometry may have
## any number of associated UV sets, each of which must have a unique name.

proc `texcoordName=`*(this: TextureStage, texcoord_name: string) {.importcpp: "#->set_texcoord_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Indicate which set of UV's this texture stage will use.  Geometry may have
## any number of associated UV sets, each of which must have a unique name.

func tangentName*(this: TextureStage): InternalName {.importcpp: "#->get_tangent_name()".} ## \
## Returns the set of tangents this texture stage will use.  This is the same
## as get_texcoord_name(), except that the first part is "tangent".

func binormalName*(this: TextureStage): InternalName {.importcpp: "#->get_binormal_name()".} ## \
## Returns the set of binormals this texture stage will use.  This is the same
## as get_binormal_name(), except that the first part is "binormal".

func color*(this: TextureStage): LColor {.importcpp: "#->get_color()".} ## \
## return the color for this stage

proc `color=`*(this: TextureStage, color: LColor) {.importcpp: "#->set_color(#)".} ## \
## Set the color for this stage

func rgbScale*(this: TextureStage): int {.importcpp: "#->get_rgb_scale()".} ## \
## See set_rgb_scale().

proc `rgbScale=`*(this: TextureStage, rgb_scale: int) {.importcpp: "#->set_rgb_scale(#)".} ## \
## Sets an additional factor that will scale all three r, g, b components
## after the texture has been applied.  This is used only when the mode is
## CM_combine.
##
## The only legal values are 1, 2, or 4.

func alphaScale*(this: TextureStage): int {.importcpp: "#->get_alpha_scale()".} ## \
## See set_alpha_scale().

proc `alphaScale=`*(this: TextureStage, alpha_scale: int) {.importcpp: "#->set_alpha_scale(#)".} ## \
## Sets an additional factor that will scale the alpha component after the
## texture has been applied.  This is used only when the mode is CM_combine.
##
## The only legal values are 1, 2, or 4.

func savedResult*(this: TextureStage): bool {.importcpp: "#->get_saved_result()".} ## \
## Returns the current setting of the saved_result flag.  See
## set_saved_result().

proc `savedResult=`*(this: TextureStage, saved_result: bool) {.importcpp: "#->set_saved_result(#)".} ## \
## Sets the saved_result flag.  When this is true, the output of this stage
## will be supplied as the "last_saved_result" source for any future stages,
## until the next TextureStage with a saved_result set true is encountered.
##
## This can be used to reuse the results of this texture stage as input to
## more than one stage later in the pipeline.
##
## The last texture in the pipeline (the one with the highest sort value)
## should not have this flag set.

func texViewOffset*(this: TextureStage): int {.importcpp: "#->get_tex_view_offset()".} ## \
## Returns the current setting of the tex_view_offset.  See
## set_tex_view_offset().

proc `texViewOffset=`*(this: TextureStage, tex_view_offset: int) {.importcpp: "#->set_tex_view_offset(#)".} ## \
## Sets the tex_view_offset value.  This is used only when a special multiview
## texture is bound to the TextureStage, and it selects the particular view of
## the texture that is to be used.
##
## This value is added to the similar parameter on DisplayRegion to derive the
## final texture view index that is selected for rendering.

func default*(_: typedesc[TextureStage]): TextureStage {.importcpp: "TextureStage::get_default()", header: "textureStage.h".} ## \
## Returns the default TextureStage that will be used for all texturing that
## does not name a particular stage.  This generally handles the normal
## single-texture case.

func geomRendering*(this: Geom): int {.importcpp: "#->get_geom_rendering()".} ## \
## Returns the set of GeomRendering bits that represent the rendering
## properties required to properly render this Geom.

func numBytes*(this: Geom): int {.importcpp: "#->get_num_bytes()".} ## \
## Returns the number of bytes consumed by the geom and its primitives (but
## not including its vertex table).

func modified*(this: Geom, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## any of the primitives in the Geom is modified, or the set of primitives is
## modified.  However, this does not include modifications to the vertex data,
## which should be tested separately.

func modified*(this: Geom): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## any of the primitives in the Geom is modified, or the set of primitives is
## modified.  However, this does not include modifications to the vertex data,
## which should be tested separately.

func geom*(this: GeomContext): Geom {.importcpp: "#.get_geom()".}

func anisotropicDegree*(this: SamplerState): int {.importcpp: "#.get_anisotropic_degree()".} ## \
## Returns the degree of anisotropic filtering that should be applied to the
## texture.  This value may return 0, indicating the default value; see also
## get_effective_anisotropic_degree.

proc `anisotropicDegree=`*(this: SamplerState, anisotropic_degree: int) {.importcpp: "#.set_anisotropic_degree(#)".} ## \
## Specifies the level of anisotropic filtering to apply to the SamplerState.
## Set this 0 to indicate the default value, which is specified in the
## SamplerState-anisotropic-degree config variable.
##
## To explicitly disable anisotropic filtering, set this value to 1.  To
## explicitly enable anisotropic filtering, set it to a value higher than 1;
## larger numbers indicate greater degrees of filtering.

func effectiveAnisotropicDegree*(this: SamplerState): int {.importcpp: "#.get_effective_anisotropic_degree()".} ## \
## Returns the degree of anisotropic filtering that should be applied to the
## texture.  This value will normally not return 0, unless there is an error
## in the config file.

func borderColor*(this: SamplerState): LColor {.importcpp: "#.get_border_color()".} ## \
## Returns the solid color of the texture's border.  Some OpenGL
## implementations use a border for tiling textures; in Panda, it is only used
## for specifying the clamp color.

proc `borderColor=`*(this: SamplerState, color: LColor) {.importcpp: "#.set_border_color(#)".} ## \
## Specifies the solid color of the SamplerState's border.  Some OpenGL
## implementations use a border for tiling SamplerStates; in Panda, it is only
## used for specifying the clamp color.

func minLod*(this: SamplerState): float32 {.importcpp: "#.get_min_lod()".} ## \
## Returns the minimum level of detail that will be observed when sampling
## this texture.

proc `minLod=`*(this: SamplerState, min_lod: float32) {.importcpp: "#.set_min_lod(#)".} ## \
## Sets the minimum level of detail that will be used when sampling this
## texture.  This may be a negative value.

func maxLod*(this: SamplerState): float32 {.importcpp: "#.get_max_lod()".} ## \
## Returns the maximum level of detail that will be observed when sampling
## this texture.

proc `maxLod=`*(this: SamplerState, max_lod: float32) {.importcpp: "#.set_max_lod(#)".} ## \
## Sets the maximum level of detail that will be used when sampling this
## texture.  This may exceed the number of mipmap levels that the texture has.

func lodBias*(this: SamplerState): float32 {.importcpp: "#.get_lod_bias()".} ## \
## Returns the bias that will be added to the texture level of detail when
## sampling this texture.

proc `lodBias=`*(this: SamplerState, lod_bias: float32) {.importcpp: "#.set_lod_bias(#)".} ## \
## Sets the value that will be added to the level of detail when sampling the
## texture.  This may be a negative value, although some graphics hardware may
## not support the use of negative LOD values.

func changeEvent*(this: Lens): string {.importcpp: "nimStringFromStdString(#->get_change_event())", header: stringConversionCode.} ## \
## Returns the name of the event that will be generated whenever any
## properties of this particular Lens have changed.

proc `changeEvent=`*(this: Lens, event: string) {.importcpp: "#->set_change_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the name of the event that will be generated whenever any properties
## of the Lens have changed.  If this is not set for a particular lens, no
## event will be generated.
##
## The event is thrown with one parameter, the lens itself.  This can be used
## to automatically track changes to camera fov, etc.  in the application.

func coordinateSystem*(this: Lens): CoordinateSystem {.importcpp: "#->get_coordinate_system()".} ## \
## Returns the coordinate system that all 3-d computations are performed
## within for this Lens.  Normally, this is CS_default.

proc `coordinateSystem=`*(this: Lens, cs: CoordinateSystem) {.importcpp: "#->set_coordinate_system(#)".} ## \
## Specifies the coordinate system that all 3-d computations are performed
## within for this Lens.  Normally, this is CS_default.

func filmSize*(this: Lens): LVecBase2 {.importcpp: "#->get_film_size()".} ## \
## Returns the horizontal and vertical film size of the virtual film.  See
## set_film_size().

proc `filmSize=`*(this: Lens, film_size: LVecBase2) {.importcpp: "#->set_film_size(#)".} ## \
## Sets the size and shape of the "film" within the lens.  This both
## establishes the units used by calls like set_focal_length(), and
## establishes the aspect ratio of the frame.
##
## In a physical camera, the field of view of a lens is determined by the
## lens' focal length and by the size of the film area exposed by the lens.
## For instance, a 35mm camera exposes a rectangle on the film about 24mm x
## 36mm, which means a 50mm lens gives about a 40-degree horizontal field of
## view.
##
## In the virtual camera, you may set the film size to any units here, and
## specify a focal length in the same units to simulate the same effect.  Or,
## you may ignore this parameter, and specify the field of view and aspect
## ratio of the lens directly.

proc `filmSize=`*(this: Lens, width: float32) {.importcpp: "#->set_film_size(#)".} ## \
## Sets the horizontal size of the film without changing its shape.  The
## aspect ratio remains unchanged; this computes the vertical size of the film
## to automatically maintain the aspect ratio.

proc `filmSize=`*(this: Lens, width: float32, height: float32) {.importcpp: "#->set_film_size(#, #)".} ## \
## Sets the size and shape of the "film" within the lens.  This both
## establishes the units used by calls like set_focal_length(), and
## establishes the aspect ratio of the frame.
##
## In a physical camera, the field of view of a lens is determined by the
## lens' focal length and by the size of the film area exposed by the lens.
## For instance, a 35mm camera exposes a rectangle on the film about 24mm x
## 36mm, which means a 50mm lens gives about a 40-degree horizontal field of
## view.
##
## In the virtual camera, you may set the film size to any units here, and
## specify a focal length in the same units to simulate the same effect.  Or,
## you may ignore this parameter, and specify the field of view and aspect
## ratio of the lens directly.

func filmOffset*(this: Lens): LVector2 {.importcpp: "#->get_film_offset()".} ## \
## Returns the horizontal and vertical offset amounts of this Lens.  See
## set_film_offset().

proc `filmOffset=`*(this: Lens, film_offset: LVecBase2) {.importcpp: "#->set_film_offset(#)".} ## \
## Sets the horizontal and vertical offset amounts of this Lens.  These are
## both in the same units specified in set_film_size().
##
## This can be used to establish an off-axis lens.

proc `filmOffset=`*(this: Lens, x: float32, y: float32) {.importcpp: "#->set_film_offset(#, #)".} ## \
## Sets the horizontal and vertical offset amounts of this Lens.  These are
## both in the same units specified in set_film_size().
##
## This can be used to establish an off-axis lens.

func focalLength*(this: Lens): float32 {.importcpp: "#->get_focal_length()".} ## \
## Returns the focal length of the lens.  This may have been set explicitly by
## a previous call to set_focal_length(), or it may be computed based on the
## lens' fov and film_size.  For certain kinds of lenses, the focal length has
## no meaning.

proc `focalLength=`*(this: Lens, focal_length: float32) {.importcpp: "#->set_focal_length(#)".} ## \
## Sets the focal length of the lens.  This may adjust the field-of-view
## correspondingly, and is an alternate way to specify field of view.
##
## For certain kinds of lenses (e.g.  OrthographicLens), the focal length has
## no meaning.

func fov*(this: Lens): LVecBase2 {.importcpp: "#->get_fov()".} ## \
## Returns the horizontal and vertical film size of the virtual film.  See
## set_fov().

proc `fov=`*(this: Lens, fov: LVecBase2) {.importcpp: "#->set_fov(#)".} ## \
## Sets the field of view of the lens in both dimensions.  This establishes
## both the field of view and the aspect ratio of the lens.  This is one way
## to specify the field of view of a lens; set_focal_length() is another way.
##
## For certain kinds of lenses (like OrthographicLens), the field of view has
## no meaning.

proc `fov=`*(this: Lens, fov: float32) {.importcpp: "#->set_fov(#)".} ## \
## Sets the horizontal field of view of the lens without changing the aspect
## ratio.  The vertical field of view is adjusted to maintain the same aspect
## ratio.

proc `fov=`*(this: Lens, hfov: float32, vfov: float32) {.importcpp: "#->set_fov(#, #)".} ## \
## Sets the field of view of the lens in both dimensions.  This establishes
## both the field of view and the aspect ratio of the lens.  This is one way
## to specify the field of view of a lens; set_focal_length() is another way.
##
## For certain kinds of lenses (like OrthoLens), the field of view has no
## meaning.

func minFov*(this: Lens): float32 {.importcpp: "#->get_min_fov()".} ## \
## Returns the field of view of the narrowest dimension of the window.  See
## set_min_fov().

proc `minFov=`*(this: Lens, min_fov: float32) {.importcpp: "#->set_min_fov(#)".} ## \
## Sets the field of view of the smallest dimension of the window.  If the
## window is wider than it is tall, this specifies the vertical field of view;
## if it is taller than it is wide, this specifies the horizontal field of
## view.
##
## In many cases, this is preferable to setting either the horizontal or
## vertical field of view explicitly.  Setting this parameter means that
## pulling the window wider will widen the field of view, which is usually
## what you expect to happen.

func aspectRatio*(this: Lens): float32 {.importcpp: "#->get_aspect_ratio()".} ## \
## Returns the aspect ratio of the Lens.  This is determined based on the
## indicated film size; see set_film_size().

proc `aspectRatio=`*(this: Lens, aspect_ratio: float32) {.importcpp: "#->set_aspect_ratio(#)".} ## \
## Sets the aspect ratio of the lens.  This is the ratio of the height to the
## width of the generated image.  Setting this overrides the two-parameter fov
## or film size setting.

func near*(this: Lens): float32 {.importcpp: "#->get_near()".} ## \
## Returns the position of the near plane (or cylinder, sphere, whatever).

proc `near=`*(this: Lens, near_distance: float32) {.importcpp: "#->set_near(#)".} ## \
## Defines the position of the near plane (or cylinder, sphere, whatever).
## Points closer to the lens than this may not be rendered.

func far*(this: Lens): float32 {.importcpp: "#->get_far()".} ## \
## Returns the position of the far plane (or cylinder, sphere, whatever).

proc `far=`*(this: Lens, far_distance: float32) {.importcpp: "#->set_far(#)".} ## \
## Defines the position of the far plane (or cylinder, sphere, whatever).
## Points farther from the lens than this may not be rendered.

func viewHpr*(this: Lens): LVecBase3 {.importcpp: "#->get_view_hpr()".} ## \
## Returns the direction in which the lens is facing.

proc `viewHpr=`*(this: Lens, view_hpr: LVecBase3) {.importcpp: "#->set_view_hpr(#)".} ## \
## Sets the direction in which the lens is facing.  Normally, this is down the
## forward axis (usually the Y axis), but it may be rotated.  This is only one
## way of specifying the rotation; you may also specify an explicit vector in
## which to look, or you may give a complete transformation matrix.

proc `viewHpr=`*(this: Lens, h: float32, p: float32, r: float32) {.importcpp: "#->set_view_hpr(#, #, #)".} ## \
## Sets the direction in which the lens is facing.  Normally, this is down the
## forward axis (usually the Y axis), but it may be rotated.  This is only one
## way of specifying the rotation; you may also specify an explicit vector in
## which to look, or you may give a complete transformation matrix.

func nodalPoint*(this: Lens): LPoint3 {.importcpp: "#->get_nodal_point()".} ## \
## Returns the center point of the lens: the point from which the lens is
## viewing.

func interocularDistance*(this: Lens): float32 {.importcpp: "#->get_interocular_distance()".} ## \
## See set_interocular_distance().

proc `interocularDistance=`*(this: Lens, interocular_distance: float32) {.importcpp: "#->set_interocular_distance(#)".} ## \
## Sets the distance between the left and right eyes of a stereo camera.  This
## distance is used to apply a stereo effect when the lens is rendered on a
## stereo display region.  It only has an effect on a PerspectiveLens.
##
## The left eye and the right eye are each offset along the X axis by half of
## this distance, so that this parameter specifies the total distance between
## them.
##
## Also see set_convergence_distance(), which relates.

func convergenceDistance*(this: Lens): float32 {.importcpp: "#->get_convergence_distance()".} ## \
## See set_convergence_distance().

proc `convergenceDistance=`*(this: Lens, convergence_distance: float32) {.importcpp: "#->set_convergence_distance(#)".} ## \
## Sets the distance between between the camera plane and the point in the
## distance that the left and right eyes are both looking at.  This distance
## is used to apply a stereo effect when the lens is rendered on a stereo
## display region.  It only has an effect on a PerspectiveLens.
##
## This parameter must be greater than 0, but may be as large as you like.  It
## controls the distance at which the two stereo images will appear to
## converge, which is a normal property of stereo vision.  Normally this
## should be set to the distance from the camera to the area of interest in
## your scene.  Anything beyond this distance will appear to go into the
## screen, and anything closer will appear to come out of the screen.  If you
## want to simulate parallel stereo, set this to infinity.
##
## Note that this creates an off-axis frustum, which means that the lenses are
## still pointing in the same direction, which is usually more desirable than
## the more naive toe-in approach, where the two lenses are simply tilted
## toward each other.
##
## Prior to Panda3D 1.9.0, the convergence was being calculated incorrectly.
## It has since been corrected.  To restore the legacy behavior you can set
## the stereo-lens-old-convergence variable to true.
##
## Also see set_interocular_distance(), which relates.

func viewMat*(this: Lens): LMatrix4 {.importcpp: "#->get_view_mat()".} ## \
## Returns the direction in which the lens is facing.

proc `viewMat=`*(this: Lens, view_mat: LMatrix4) {.importcpp: "#->set_view_mat(#)".} ## \
## Sets an arbitrary transformation on the lens.  This replaces the individual
## transformation components like set_view_hpr().
##
## Setting a transformation here will have a slightly different effect than
## putting one on the LensNode that contains this lens.  In particular,
## lighting and other effects computations will still be performed on the lens
## in its untransformed (facing forward) position, but the actual projection
## matrix will be transformed by this matrix.

func keystone*(this: Lens): LVecBase2 {.importcpp: "#->get_keystone()".} ## \
## Returns the keystone correction specified for the lens.

proc `keystone=`*(this: Lens, keystone: LVecBase2) {.importcpp: "#->set_keystone(#)".} ## \
## Indicates the ratio of keystone correction to perform on the lens, in each
## of three axes.  This will build a special non-affine scale factor into the
## projection matrix that will compensate for keystoning of a projected image;
## this can be used to compensate for a projector that for physical reasons
## cannot be aimed directly at its screen.
##
## The default value is taken from the default-keystone Config variable.  0, 0
## indicates no keystone correction; specify a small value (usually in the
## range -1 .. 1) in either the x or y position to generate a keystone
## correction in that axis.

func baseColor*(this: Material): LColor {.importcpp: "#->get_base_color()".} ## \
## Returns the base_color color setting, if it has been set.  If neither the
## base color nor the metallic have been set, this returns the diffuse color.

proc `baseColor=`*(this: Material, color: LColor) {.importcpp: "#->set_base_color(#)".} ## \
## Specifies the base color of the material.  In conjunction with
## set_metallic, this is an alternate way to specify the color of a material.
## For dielectrics, this will determine the value of the diffuse color, and
## for metals, this will determine the value of the specular color.
##
## Setting this will clear an explicit specular, diffuse or ambient color
## assignment.
##
## If this is not set, the object color will be used.

func ambient*(this: Material): LColor {.importcpp: "#->get_ambient()".} ## \
## Returns the ambient color setting, if it has been set.  Returns (0,0,0,0)
## if the ambient color has not been set.

proc `ambient=`*(this: Material, color: LColor) {.importcpp: "#->set_ambient(#)".} ## \
## Specifies the ambient color setting of the material.  This will be the
## multiplied by any ambient lights in effect on the material to set its base
## color.
##
## This is the color of the object as it appears in the absence of direct
## light.
##
## If this is not set, the object color will be used.

func diffuse*(this: Material): LColor {.importcpp: "#->get_diffuse()".} ## \
## Returns the diffuse color setting, if it has been set.  Returns (1,1,1,1)
## if the diffuse color has not been set.

proc `diffuse=`*(this: Material, color: LColor) {.importcpp: "#->set_diffuse(#)".} ## \
## Specifies the diffuse color setting of the material.  This will be
## multiplied by any lights in effect on the material to get the color in the
## parts of the object illuminated by the lights.
##
## This is the primary color of an object; the color of the object as it
## appears in direct light, in the absence of highlights.
##
## If this is not set, the object color will be used.

func specular*(this: Material): LColor {.importcpp: "#->get_specular()".} ## \
## Returns the specular color setting, if it has been set.  Returns (0,0,0,0)
## if the specular color has not been set.

proc `specular=`*(this: Material, color: LColor) {.importcpp: "#->set_specular(#)".} ## \
## Specifies the specular color setting of the material.  This will be
## multiplied by any lights in effect on the material to compute the color of
## specular highlights on the object.
##
## This is the highlight color of an object: the color of small highlight
## reflections.
##
## If this is not set, the specular color is taken from the index of
## refraction, which is 1 by default (meaning no specular reflections are
## generated).

func emission*(this: Material): LColor {.importcpp: "#->get_emission()".} ## \
## Returns the emission color setting, if it has been set.  Returns (0,0,0,0)
## if the emission color has not been set.

proc `emission=`*(this: Material, color: LColor) {.importcpp: "#->set_emission(#)".} ## \
## Specifies the emission color setting of the material.  This is the color of
## the object as it appears in the absence of any light whatsover, including
## ambient light.  It is as if the object is glowing by this color (although
## of course it will not illuminate neighboring objects).
##
## If this is not set, the object will not glow by its own light and will only
## appear visible in the presence of one or more lights.

func shininess*(this: Material): float32 {.importcpp: "#->get_shininess()".} ## \
## Returns the shininess exponent of the material.

proc `shininess=`*(this: Material, shininess: float32) {.importcpp: "#->set_shininess(#)".} ## \
## Sets the shininess exponent of the material.  This controls the size of the
## specular highlight spot.  In general, larger number produce a smaller
## specular highlight, which makes the object appear shinier.  Smaller numbers
## produce a larger highlight, which makes the object appear less shiny.
##
## This is usually in the range 0..128.
##
## Setting a shininess value removes any previous roughness assignment.

func roughness*(this: Material): float32 {.importcpp: "#->get_roughness()".} ## \
## Returns the roughness previously specified by set_roughness.  If none was
## previously set, this value is computed from the shininess value.

proc `roughness=`*(this: Material, roughness: float32) {.importcpp: "#->set_roughness(#)".} ## \
## Sets the roughness exponent of the material, where 0 is completely shiny
## (infinite shininess), and 1 is a completely dull object (0 shininess).
## This is a different, more perceptually intuitive way of controlling the
## size of the specular spot, and more commonly used in physically-based
## rendering.
##
## Setting a roughness recalculates the shininess value.

func metallic*(this: Material): float32 {.importcpp: "#->get_metallic()".} ## \
## Returns the metallic setting, if it has been set.  Returns 0 if it has not
## been set.

proc `metallic=`*(this: Material, metallic: float32) {.importcpp: "#->set_metallic(#)".} ## \
## Sets the metallic setting of the material, which is is used for physically-
## based rendering models.  This is usually 0 for dielectric materials and 1
## for metals.  It really does not make sense to set this to a value other
## than 0 or 1, but it is nonetheless a float for compatibility with tools
## that allow setting this to values other than 0 or 1.

func refractiveIndex*(this: Material): float32 {.importcpp: "#->get_refractive_index()".} ## \
## Returns the index of refraction, or 1 if none has been set for this
## material.

proc `refractiveIndex=`*(this: Material, refractive_index: float32) {.importcpp: "#->set_refractive_index(#)".} ## \
## Sets the index of refraction of the material, which is used to determine
## the specular color in absence of an explicit specular color assignment.
## This is usually 1.5 for dielectric materials.  It is not very useful for
## metals, since they cannot be described as easily with a single number.
##
## Should be 1 or higher.  The default is 1.

func local*(this: Material): bool {.importcpp: "#->get_local()".} ## \
## Returns the local viewer flag.  Set set_local().

proc `local=`*(this: Material, local: bool) {.importcpp: "#->set_local(#)".} ## \
## Sets the local viewer flag.  Set this true to enable camera-relative
## specular highlights, or false to use orthogonal specular highlights.  The
## default value is true.  Applications that use orthogonal projection should
## specify false.

func twoside*(this: Material): bool {.importcpp: "#->get_twoside()".} ## \
## Returns the state of the two-sided lighting flag.  See set_twoside().

proc `twoside=`*(this: Material, twoside: bool) {.importcpp: "#->set_twoside(#)".} ## \
## Set this true to enable two-sided lighting.  When two-sided lighting is on,
## both sides of a polygon will be lit by this material.  The default is for
## two-sided lighting to be off, in which case only the front surface is lit.

func userMat*(this: MatrixLens): LMatrix4 {.importcpp: "#->get_user_mat()".} ## \
## Returns the explicit projection matrix as set by the user.  This does not
## include transforms on the lens or film (e.g.  a film offset or view hpr).

proc `userMat=`*(this: MatrixLens, user_mat: LMatrix4) {.importcpp: "#->set_user_mat(#)".} ## \
## Explicitly specifies the projection matrix.  This matrix should convert X
## and Y to the range [-film_size/2, film_size/2], where (-fs/2,-fs/2) is the
## lower left corner of the screen and (fs/2, fs/2) is the upper right.  Z
## should go to the range [-1, 1], where -1 is the near plane and 1 is the far
## plane.  Note that this is a left-handed Y-up coordinate system.
##
## The default film_size for a MatrixLens is 2, so the default range is [-1,
## 1] for both X and Y.  This is consistent with the GL conventions for
## projection matrices.

func texture*(this: ParamTextureSampler): Texture {.importcpp: "#->get_texture()".} ## \
## Retrieves the texture stored in the parameter.

func sampler*(this: ParamTextureSampler): SamplerState {.importcpp: "#->get_sampler()".} ## \
## Retrieves the sampler state stored in the parameter.

func texture*(this: ParamTextureImage): Texture {.importcpp: "#->get_texture()".} ## \
## Retrieves the texture stored in the parameter.

func readAccess*(this: ParamTextureImage): bool {.importcpp: "#->has_read_access()".} ## \
## Returns true if this image should be bound with read access enabled.

func writeAccess*(this: ParamTextureImage): bool {.importcpp: "#->has_write_access()".} ## \
## Returns true if this image should be bound with write access enabled.

func bindLevel*(this: ParamTextureImage): int {.importcpp: "#->get_bind_level()".} ## \
## Returns the image level that should be bound.

func bindLayer*(this: ParamTextureImage): int {.importcpp: "#->get_bind_layer()".} ## \
## Returns the image layer that should be bound.  This is undefined if
## get_bind_layered() returns false.

func texture*(this: TextureReloadRequest): Texture {.importcpp: "#->get_texture()".} ## \
## Returns the Texture object associated with this asynchronous
## TextureReloadRequest.

func shader*(this: ShaderContext): Shader {.importcpp: "#.get_shader()".}

func videoWidth*(this: VideoTexture): int {.importcpp: "#->get_video_width()".} ## \
## Returns the width in texels of the source video stream.  This is not
## necessarily the width of the actual texture, since the texture may have
## been expanded to raise it to a power of 2.

func videoHeight*(this: VideoTexture): int {.importcpp: "#->get_video_height()".} ## \
## Returns the height in texels of the source video stream.  This is not
## necessarily the height of the actual texture, since the texture may have
## been expanded to raise it to a power of 2.

proc `x=`*(this: LVecBase2f, value: float32) {.importcpp: "#.set_x(#)".}

proc `y=`*(this: LVecBase2f, value: float32) {.importcpp: "#.set_y(#)".}

proc `x=`*(this: LVecBase2d, value: float64) {.importcpp: "#.set_x(#)".}

proc `y=`*(this: LVecBase2d, value: float64) {.importcpp: "#.set_y(#)".}

proc `x=`*(this: LVecBase2i, value: int) {.importcpp: "#.set_x(#)".}

proc `y=`*(this: LVecBase2i, value: int) {.importcpp: "#.set_y(#)".}

proc `x=`*(this: LVecBase3f, value: float32) {.importcpp: "#.set_x(#)".}

proc `y=`*(this: LVecBase3f, value: float32) {.importcpp: "#.set_y(#)".}

proc `z=`*(this: LVecBase3f, value: float32) {.importcpp: "#.set_z(#)".}

proc `x=`*(this: LVecBase3d, value: float64) {.importcpp: "#.set_x(#)".}

proc `y=`*(this: LVecBase3d, value: float64) {.importcpp: "#.set_y(#)".}

proc `z=`*(this: LVecBase3d, value: float64) {.importcpp: "#.set_z(#)".}

proc `x=`*(this: LVecBase3i, value: int) {.importcpp: "#.set_x(#)".}

proc `y=`*(this: LVecBase3i, value: int) {.importcpp: "#.set_y(#)".}

proc `z=`*(this: LVecBase3i, value: int) {.importcpp: "#.set_z(#)".}

func xy*(this: LVector3f): LVector2f {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

func xz*(this: LVector3f): LVector2f {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

func yz*(this: LVector3f): LVector2f {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

func xy*(this: LVector3d): LVector2d {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

func xz*(this: LVector3d): LVector2d {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

func yz*(this: LVector3d): LVector2d {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

func xy*(this: LVector3i): LVector2i {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

func xz*(this: LVector3i): LVector2i {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

func yz*(this: LVector3i): LVector2i {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

func xy*(this: LPoint3f): LPoint2f {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

func xz*(this: LPoint3f): LPoint2f {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

func yz*(this: LPoint3f): LPoint2f {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

func xy*(this: LPoint3d): LPoint2d {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

func xz*(this: LPoint3d): LPoint2d {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

func yz*(this: LPoint3d): LPoint2d {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

func xy*(this: LPoint3i): LPoint2i {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

func xz*(this: LPoint3i): LPoint2i {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

func yz*(this: LPoint3i): LPoint2i {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

proc `x=`*(this: LVecBase4f, value: float32) {.importcpp: "#.set_x(#)".}

proc `y=`*(this: LVecBase4f, value: float32) {.importcpp: "#.set_y(#)".}

proc `z=`*(this: LVecBase4f, value: float32) {.importcpp: "#.set_z(#)".}

proc `x=`*(this: LVecBase4d, value: float64) {.importcpp: "#.set_x(#)".}

proc `y=`*(this: LVecBase4d, value: float64) {.importcpp: "#.set_y(#)".}

proc `z=`*(this: LVecBase4d, value: float64) {.importcpp: "#.set_z(#)".}

proc `x=`*(this: LVecBase4i, value: int) {.importcpp: "#.set_x(#)".}

proc `y=`*(this: LVecBase4i, value: int) {.importcpp: "#.set_y(#)".}

proc `z=`*(this: LVecBase4i, value: int) {.importcpp: "#.set_z(#)".}

func xyz*(this: LVector4f): LVector3f {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

func xy*(this: LVector4f): LVector2f {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

func xyz*(this: LVector4d): LVector3d {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

func xy*(this: LVector4d): LVector2d {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

func xyz*(this: LVector4i): LVector3i {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

func xy*(this: LVector4i): LVector2i {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

func xyz*(this: LPoint4f): LPoint3f {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

func xy*(this: LPoint4f): LPoint2f {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

func xyz*(this: LPoint4d): LPoint3d {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

func xy*(this: LPoint4d): LPoint2d {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

func xyz*(this: LPoint4i): LPoint3i {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

func xy*(this: LPoint4i): LPoint2i {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

func min*(this: FiniteBoundingVolume): LPoint3 {.importcpp: "#->get_min()".}

func max*(this: FiniteBoundingVolume): LPoint3 {.importcpp: "#->get_max()".}

func volume*(this: FiniteBoundingVolume): float32 {.importcpp: "#->get_volume()".}

func plane*(this: BoundingPlane): LPlane {.importcpp: "#->get_plane()".}

func center*(this: BoundingSphere): LPoint3 {.importcpp: "#->get_center()".}

proc `center=`*(this: BoundingSphere, center: LPoint3) {.importcpp: "#->set_center(#)".} ## \
## Sets the center point of the sphere.

func radius*(this: BoundingSphere): float32 {.importcpp: "#->get_radius()".}

proc `radius=`*(this: BoundingSphere, radius: float32) {.importcpp: "#->set_radius(#)".} ## \
## Sets the radius of the sphere.

func plane*(this: Triangulator3): LPlaned {.importcpp: "#.get_plane()".} ## \
## Returns the plane of the polygon.  This is only available after calling
## triangulate().

func xyzCurve*(this: ParametricCurveCollection): ParametricCurve {.importcpp: "#->get_xyz_curve()".} ## \
## Returns the first XYZ curve in the collection, if any, or NULL if there are
## none.

func hprCurve*(this: ParametricCurveCollection): ParametricCurve {.importcpp: "#->get_hpr_curve()".} ## \
## Returns the first HPR curve in the collection, if any, or NULL if there are
## none.

func defaultCurve*(this: ParametricCurveCollection): ParametricCurve {.importcpp: "#->get_default_curve()".} ## \
## If there is an XYZ curve in the collection, returns it; otherwise, returns
## the first curve whose type is unspecified.  Returns NULL if no curve meets
## the criteria.

func maxT*(this: ParametricCurveCollection): float32 {.importcpp: "#->get_max_t()".} ## \
## Returns the maximum T value associated with the \*last\* curve in the
## collection.  Normally, this will be either the XYZ or HPR curve, or a
## timewarp curve.

func uOrder*(this: NurbsSurfaceEvaluator): int {.importcpp: "#->get_u_order()".} ## \
## Returns the order of the surface in the U direction as set by a previous
## call to set_u_order().

proc `uOrder=`*(this: NurbsSurfaceEvaluator, u_order: int) {.importcpp: "#->set_u_order(#)".} ## \
## Sets the order of the surface in the U direction.  This resets the knot
## vector to the default knot vector for the number of vertices.
##
## The order must be 1, 2, 3, or 4, and the value is one more than the degree
## of the surface.

func vOrder*(this: NurbsSurfaceEvaluator): int {.importcpp: "#->get_v_order()".} ## \
## Returns the order of the surface in the V direction as set by a previous
## call to set_v_order().

proc `vOrder=`*(this: NurbsSurfaceEvaluator, v_order: int) {.importcpp: "#->set_v_order(#)".} ## \
## Sets the order of the surface in the V direction.  This resets the knot
## vector to the default knot vector for the number of vertices.
##
## The order must be 1, 2, 3, or 4, and the value is one more than the degree
## of the surface.

func curve*(this: RopeNode): NurbsCurveEvaluator {.importcpp: "#->get_curve()".} ## \
## Returns the curve represented by the RopeNode.

proc `curve=`*(this: RopeNode, curve: NurbsCurveEvaluator) {.importcpp: "#->set_curve(#)".} ## \
## Sets the particular curve represented by the RopeNode.

func uvDirection*(this: RopeNode): bool {.importcpp: "#->get_uv_direction()".} ## \
## Returns true if the rope runs down the U coordinate of the texture, or
## false if it runs down the V coordinate.

proc `uvDirection=`*(this: RopeNode, u_dominant: bool) {.importcpp: "#->set_uv_direction(#)".} ## \
## Specify true to vary the U coordinate down the length of the rope, or false
## to vary the V coordinate.

func uvScale*(this: RopeNode): float32 {.importcpp: "#->get_uv_scale()".} ## \
## Returns the scaling factor to apply to generated UV's for the rope.

proc `uvScale=`*(this: RopeNode, scale: float32) {.importcpp: "#->set_uv_scale(#)".} ## \
## Specifies an additional scaling factor to apply to generated UV's along the
## rope.  This scale factor is applied in whichever direction is along the
## rope, as specified by set_uv_direction().

func tubeUp*(this: RopeNode): LVector3 {.importcpp: "#->get_tube_up()".} ## \
## Returns the normal vector used to control the "top" of the curve, when
## RenderMode is RM_tube.  See set_tube_up().

proc `tubeUp=`*(this: RopeNode, tube_up: LVector3) {.importcpp: "#->set_tube_up(#)".} ## \
## Specifies a normal vector, generally perpendicular to the main axis of the
## starting point of the curve, that controls the "top" of the curve, when
## RenderMode is RM_tube.  This is used to orient the vertices that make up
## the tube.  If this vector is too nearly parallel with the starting
## direction of the curve, there may be a tendency for the whole tube to
## gimble-lock around its primary axis.

func useVertexColor*(this: RopeNode): bool {.importcpp: "#->get_use_vertex_color()".} ## \
## Returns the "use vertex color" flag.  See set_use_vertex_color().

proc `useVertexColor=`*(this: RopeNode, flag: bool) {.importcpp: "#->set_use_vertex_color(#)".} ## \
## Sets the "use vertex color" flag.  When this is true, the R, G, B, A vertex
## color is assumed to be stored as the dimensions n + 0, n + 1, n + 2, n + 3,
## respectively, of the extended vertex values, where n is the value returned
## by get_vertex_color_dimension().  Use
## NurbsCurveEvaluator::set_extended_vertex() to set these values.

func vertexColorDimension*(_: typedesc[RopeNode]): int {.importcpp: "RopeNode::get_vertex_color_dimension()", header: "ropeNode.h".} ## \
## Returns the numeric extended dimension in which the color components should
## be found.  See NurbsCurveEvaluator::set_extended_vertex().
##
## The color components will be expected at (n, n + 1, n + 2, n + 3).

func numSubdiv*(this: RopeNode): int {.importcpp: "#->get_num_subdiv()".} ## \
## Returns the number of subdivisions per cubic segment to draw.  See
## set_num_subdiv().

proc `numSubdiv=`*(this: RopeNode, num_subdiv: int) {.importcpp: "#->set_num_subdiv(#)".} ## \
## Specifies the number of subdivisions per cubic segment (that is, per unique
## knot value) to draw in a fixed uniform tesselation of the curve.

func numSlices*(this: RopeNode): int {.importcpp: "#->get_num_slices()".} ## \
## Returns the number of radial subdivisions to make if RenderMode is RM_tube.
## It is ignored in the other render modes.  See set_num_slices().

proc `numSlices=`*(this: RopeNode, num_slices: int) {.importcpp: "#->set_num_slices(#)".} ## \
## Specifies the number of radial subdivisions to make if RenderMode is
## RM_tube.  It is ignored in the other render modes.
##
## Increasing this number increases the roundness of a cross-section of the
## tube.  The minimum value for a dimensional tube is 3; setting it to 2 will
## get you a thin piece of tape (which is similar to RM_billboard, except it
## won't rotate to face the camera).

func useVertexThickness*(this: RopeNode): bool {.importcpp: "#->get_use_vertex_thickness()".} ## \
## Returns the "use vertex thickness" flag.  See set_use_vertex_thickness().

proc `useVertexThickness=`*(this: RopeNode, flag: bool) {.importcpp: "#->set_use_vertex_thickness(#)".} ## \
## Sets the "use vertex thickness" flag.  When this is true, the vertex
## thickness is assumed to be stored as the dimension
## get_vertex_thickness_dimension(), of the extended vertex values.  Use
## NurbsCurveEvaluator::set_extended_vertex() to set these values.
##
## In this mode, the overall thickness is also applied as a scale to the
## vertex thickness.  Not all render modes support vertex thickness.

func vertexThicknessDimension*(_: typedesc[RopeNode]): int {.importcpp: "RopeNode::get_vertex_thickness_dimension()", header: "ropeNode.h".} ## \
## Returns the numeric extended dimension in which the thickness component
## should be found.  See NurbsCurveEvaluator::set_extended_vertex().

func thickness*(this: RopeNode): float32 {.importcpp: "#->get_thickness()".} ## \
## Returns the thickness of the rope.  See set_thickness().

proc `thickness=`*(this: RopeNode, thickness: float32) {.importcpp: "#->set_thickness(#)".} ## \
## Specifies the thickness of the rope, in pixels or in spatial units,
## depending on the render mode.  See set_render_mode().
##
## The thickness may also be specified on a per-vertex basis.  See
## set_use_vertex_thickness().

func matrix*(this: RopeNode): LMatrix4 {.importcpp: "#->get_matrix()".} ## \
## Returns the optional matrix which is used to transform each control vertex
## after it has been transformed into the RopeNode's coordinate space, but
## before the polygon vertices are generated.

proc `matrix=`*(this: RopeNode, matrix: LMatrix4) {.importcpp: "#->set_matrix(#)".} ## \
## Specifies an optional matrix which is used to transform each control vertex
## after it has been transformed into the RopeNode's coordinate space, but
## before the polygon vertices are generated.

func name*(this: PNMFileType): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.}

func suggestedExtension*(this: PNMFileType): string {.importcpp: "nimStringFromStdString(#.get_suggested_extension())", header: stringConversionCode.} ## \
## Returns a suitable filename extension (without a leading dot) to suggest
## for files of this type, or empty string if no suggestions are available.

func numChannels*(this: PNMImageHeader): int {.importcpp: "#.get_num_channels()".} ## \
## Returns the number of channels in the image.

func maxval*(this: PNMImageHeader): int {.importcpp: "#.get_maxval()".} ## \
## Returns the maximum channel value allowable for any pixel in this image;
## for instance, 255 for a typical 8-bit-per-channel image.  A pixel with this
## value is full on.

func colorSpace*(this: PNMImageHeader): ColorSpace {.importcpp: "#.get_color_space()".} ## \
## Returns the color space that the image is encoded in, or CS_unspecified if
## unknown.

func size*(this: PNMImageHeader): LVecBase2i {.importcpp: "#.get_size()".} ## \
## Returns the number of pixels in each direction.  This is one more than the
## largest allowable coordinates.

func comment*(this: PNMImageHeader): string {.importcpp: "nimStringFromStdString(#.get_comment())", header: stringConversionCode.} ## \
## Gets the user comment from the file.

proc `comment=`*(this: PNMImageHeader, comment: string) {.importcpp: "#.set_comment(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Writes a user comment string to the image (header).

func valid*(this: PfmFile): bool {.importcpp: "#.is_valid()".}

func scale*(this: PfmFile): float32 {.importcpp: "#.get_scale()".} ## \
## The "scale" is reported in the pfm header and is probably meaningless.

proc `scale=`*(this: PfmFile, scale: float32) {.importcpp: "#.set_scale(#)".} ## \
## The "scale" is reported in the pfm header and is probably meaningless.

func pen*(this: PNMPainter): PNMBrush {.importcpp: "#.get_pen()".} ## \
## Returns the current pen.  See set_pen().

proc `pen=`*(this: PNMPainter, pen: PNMBrush) {.importcpp: "#.set_pen(#)".} ## \
## Specifies a PNMBrush that will be used for drawing lines and edges.  If the
## brush is a bitmap brush, its image will be smeared pixelwise along the
## line.
##
## Unlike the PNMImage passed to the constructor, the PNMPainter will take
## ownership of the pen.  It is not necessary to keep a separate pointer to
## it.

func fill*(this: PNMPainter): PNMBrush {.importcpp: "#.get_fill()".} ## \
## Returns the current fill brush.  See set_fill().

proc `fill=`*(this: PNMPainter, fill: PNMBrush) {.importcpp: "#.set_fill(#)".} ## \
## Specifies a PNMBrush that will be used for filling in the interiors of
## objects.  If the brush is a bitmap brush, its image will be tiled
## throughout the space.
##
## Unlike the PNMImage passed to the constructor, the PNMPainter will take
## ownership of the fill brush.  It is not necessary to keep a separate
## pointer to it.

func character*(this: TextGlyph): int {.importcpp: "#->get_character()".} ## \
## Returns the Unicode value that corresponds to the character this glyph
## represents.

func state*(this: TextGlyph): RenderState {.importcpp: "deconstify(#->get_state())", header: deconstifyCode.} ## \
## Returns the state in which the glyph should be rendered.

func advance*(this: TextGlyph): float32 {.importcpp: "#->get_advance()".} ## \
## Returns the distance by which the character pointer should be advanced
## after placing this character; i.e.  the approximate width the character
## takes up on the line.

func valid*(this: TextFont): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the font is valid and ready to use, false otherwise.

func lineHeight*(this: TextFont): float32 {.importcpp: "#->get_line_height()".} ## \
## Returns the number of units high each line of text is.

proc `lineHeight=`*(this: TextFont, line_height: float32) {.importcpp: "#->set_line_height(#)".} ## \
## Changes the number of units high each line of text is.

func spaceAdvance*(this: TextFont): float32 {.importcpp: "#->get_space_advance()".} ## \
## Returns the number of units wide a space is.

proc `spaceAdvance=`*(this: TextFont, space_advance: float32) {.importcpp: "#->set_space_advance(#)".} ## \
## Changes the number of units wide a space is.

func page*(this: DynamicTextGlyph): DynamicTextPage {.importcpp: "#->get_page()".} ## \
## Returns the DynamicTextPage that this glyph is on.

func pointSize*(this: DynamicTextFont): float32 {.importcpp: "#->get_point_size()".} ## \
## Returns the point size of the font.

proc `pointSize=`*(this: DynamicTextFont, point_size: float32): bool {.importcpp: "#->set_point_size(#)".} ## \
## Sets the point size of the font.  This controls the apparent size of the
## font onscreen.  By convention, a 10 point font is about 1 screen unit high.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

func pixelsPerUnit*(this: DynamicTextFont): float32 {.importcpp: "#->get_pixels_per_unit()".} ## \
## Returns the resolution of the texture map.  See set_pixels_per_unit().

proc `pixelsPerUnit=`*(this: DynamicTextFont, pixels_per_unit: float32): bool {.importcpp: "#->set_pixels_per_unit(#)".} ## \
## Set the resolution of the texture map, and hence the clarity of the
## resulting font.  This sets the number of pixels in the texture map that are
## used for each onscreen unit.
##
## Setting this number larger results in an easier to read font, but at the
## cost of more texture memory.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

func scaleFactor*(this: DynamicTextFont): float32 {.importcpp: "#->get_scale_factor()".} ## \
## Returns the antialiasing scale factor.  See set_scale_factor().

proc `scaleFactor=`*(this: DynamicTextFont, scale_factor: float32): bool {.importcpp: "#->set_scale_factor(#)".} ## \
## Sets the factor by which the font is rendered larger by the FreeType
## library before being filtered down to its actual size in the texture as
## specified by set_pixels_per_unit().  This may be set to a number larger
## than 1.0 to improve the font's antialiasing (since FreeType doesn't really
## do a swell job of antialiasing by itself).  There is some performance
## implication for setting this different than 1.0, but it is probably small.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

func nativeAntialias*(this: DynamicTextFont): bool {.importcpp: "#->get_native_antialias()".} ## \
## Returns whether Freetype's built-in antialias mode is enabled.  See
## set_native_antialias().

proc `nativeAntialias=`*(this: DynamicTextFont, native_antialias: bool) {.importcpp: "#->set_native_antialias(#)".} ## \
## Sets whether the Freetype library's built-in antialias mode is enabled.
## There are two unrelated ways to achieve antialiasing: with Freetype's
## native antialias mode, and with the use of a scale_factor greater than one.
## By default, both modes are enabled.
##
## At low resolutions, some fonts may do better with one mode or the other.
## In general, Freetype's native antialiasing will produce less blurry
## results, but may introduce more artifacts.

func fontPixelSize*(this: DynamicTextFont): int {.importcpp: "#->get_font_pixel_size()".} ## \
## This is used to report whether the requested pixel size is being only
## approximated by a fixed-pixel-size font.  This returns 0 in the normal
## case, in which a scalable font is used, or the fixed-pixel-size font has
## exactly the requested pixel size.
##
## If this returns non-zero, it is the pixel size of the font that we are
## using to approximate our desired size.

func textureMargin*(this: DynamicTextFont): int {.importcpp: "#->get_texture_margin()".} ## \
## Returns the number of pixels of padding that is added around the border of
## each glyph in the texture map.  See set_texture_margin().

proc `textureMargin=`*(this: DynamicTextFont, texture_margin: int) {.importcpp: "#->set_texture_margin(#)".} ## \
## Sets the number of pixels of padding that is added around the border of
## each glyph before adding it to the texture map.  This reduces the bleed in
## from neighboring glyphs in the texture map.

func polyMargin*(this: DynamicTextFont): float32 {.importcpp: "#->get_poly_margin()".} ## \
## Returns the number of pixels of padding that is included around each glyph
## in the generated polygons.  See set_poly_margin().

proc `polyMargin=`*(this: DynamicTextFont, poly_margin: float32) {.importcpp: "#->set_poly_margin(#)".} ## \
## Sets the number of pixels of padding that is included around each glyph in
## the generated polygons.  This helps prevent the edges of the glyphs from
## being cut off at small minifications.  It is not related to the amount of
## extra pixels reserved in the texture map (but it should be set somewhat
## smaller than this number, which is controlled by set_texture_margin(), to
## prevent bleed-in from neighboring letters in the texture).

func pageSize*(this: DynamicTextFont): LVecBase2i {.importcpp: "#->get_page_size()".} ## \
## Returns the size of the textures that are created for the DynamicTextFont.
## See set_page_size().

proc `pageSize=`*(this: DynamicTextFont, page_size: LVecBase2i) {.importcpp: "#->set_page_size(#)".} ## \
## Sets the x, y size of the textures that are created for the
## DynamicTextFont.

proc `pageSize=`*(this: DynamicTextFont, x_size: int, y_size: int) {.importcpp: "#->set_page_size(#, #)".} ## \
## Sets the x, y size of the textures that are created for the
## DynamicTextFont.

func anisotropicDegree*(this: DynamicTextFont): int {.importcpp: "#->get_anisotropic_degree()".} ## \
## Returns the current anisotropic degree for textures created for this font.
## See set_anisotropic_degree().

proc `anisotropicDegree=`*(this: DynamicTextFont, anisotropic_degree: int) {.importcpp: "#->set_anisotropic_degree(#)".} ## \
## Enables or disables anisotropic filtering on the textures created for this
## font.  The default value is specified by the text-anisotropic-degree
## variable.  See Texture::set_anisotropic_degree().

func fg*(this: DynamicTextFont): LColor {.importcpp: "#->get_fg()".} ## \
## Returns the color of the foreground pixels of the font as they are rendered
## into the font texture.  See set_fg().

proc `fg=`*(this: DynamicTextFont, fg: LColor) {.importcpp: "#->set_fg(#)".} ## \
## Changes the color of the foreground pixels of the font as they are rendered
## into the font texture.  The default is (1, 1, 1, 1), or opaque white, which
## allows text created with the font to be colored individually.  Normally,
## you would not change this unless you really need a particular color effect
## to appear in the font itself.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

func bg*(this: DynamicTextFont): LColor {.importcpp: "#->get_bg()".} ## \
## Returns the color of the background pixels of the font as they are rendered
## into the font texture.  See set_bg().

proc `bg=`*(this: DynamicTextFont, bg: LColor) {.importcpp: "#->set_bg(#)".} ## \
## Changes the color of the background pixels of the font as they are rendered
## into the font texture.  The default is (1, 1, 1, 0), or transparent white,
## which allows text created with the font to be colored individually.  (Note
## that it should not generally be (0, 0, 0, 0), which would tend to bleed
## into the foreground color, unless you have also specified a outline color
## of (0, 0, 0, 1)) .
##
## Normally, you would not change this unless you really need a particular
## color effect to appear in the font itself.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

func model*(this: TextGraphic): NodePath {.importcpp: "#.get_model()".} ## \
## Returns the NodePath associated with the graphic, that renders the desired
## image.

proc `model=`*(this: TextGraphic, model: NodePath) {.importcpp: "#.set_model(#)".} ## \
## Changes the NodePath associated with the graphic.  This NodePath should
## contain geometry that will render the desired graphic image.

func frame*(this: TextGraphic): LVecBase4 {.importcpp: "#.get_frame()".} ## \
## Returns the frame specified for the graphic.  This is the amount of space
## that will be reserved for the graphic when it is embedded in a text
## paragraph, in the form (left, right, bottom, top).
##
## The actual graphic, as rendered by the NodePath specified via set_model(),
## should more or less fit within this rectangle.  It is not required to fit
## completely within it, but if it does not, it may visually overlap with
## nearby text.

proc `frame=`*(this: TextGraphic, frame: LVecBase4) {.importcpp: "#.set_frame(#)".} ## \
## Specifies the (left, right, bottom, top) bounding frame for the graphic.
## See get_frame().

proc `frame=`*(this: TextGraphic, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#.set_frame(#, #, #, #)".} ## \
## Specifies the (left, right, bottom, top) bounding frame for the graphic.
## See get_frame().

func instanceFlag*(this: TextGraphic): bool {.importcpp: "#.get_instance_flag()".} ## \
## Returns the instance_flag.  See set_instance_flag().

proc `instanceFlag=`*(this: TextGraphic, instance_flag: bool) {.importcpp: "#.set_instance_flag(#)".} ## \
## Sets the instance_flag.  When this is true, the graphic is directly
## instanced to the scene graph whenever it appears; when it is false, the
## graphic is copied.  The default is false, which is best for most
## applications.  You might need to set it true for special kinds of
## "graphics" like interactive elements, for instance a PGEntry.

func maxRows*(this: TextAssembler): int {.importcpp: "#.get_max_rows()".} ## \
## If max_rows is greater than zero, no more than max_rows will be accepted.
## Text beyond that will be truncated.

proc `maxRows=`*(this: TextAssembler, max_rows: int) {.importcpp: "#.set_max_rows(#)".} ## \
## If max_rows is greater than zero, no more than max_rows will be accepted.
## Text beyond that will be truncated.
##
## Setting this will not truncate text immediately.  You must follow this up
## with a call to set_wtext() to truncate the existing text.

func dynamicMerge*(this: TextAssembler): bool {.importcpp: "#.get_dynamic_merge()".} ## \
## Returns the dynamic_merge flag.  See TextNode::set_flatten_flags().

proc `dynamicMerge=`*(this: TextAssembler, dynamic_merge: bool) {.importcpp: "#.set_dynamic_merge(#)".} ## \
## Sets the dynamic_merge flag.  See TextNode::set_flatten_flags().

func multilineMode*(this: TextAssembler): bool {.importcpp: "#.get_multiline_mode()".} ## \
## Returns the multline_mode flag.  See TextNode::set_multiline_mode().

proc `multilineMode=`*(this: TextAssembler, flag: bool) {.importcpp: "#.set_multiline_mode(#)".} ## \
## Sets the multiline mode flag.  Set the multiline mode to allow text to
## wrap.  It defaults to true.

func properties*(this: TextAssembler): TextProperties {.importcpp: "#.get_properties()".} ## \
## Returns the default TextProperties that are applied to the text in the
## absence of any nested property change sequences.

func properties*(this: TextAssembler, n: int): TextProperties {.importcpp: "#.get_properties(#)".} ## \
## Returns the TextProperties in effect for the object at the indicated
## position in the pre-wordwrapped string.

func properties*(this: TextAssembler, r: int, c: int): TextProperties {.importcpp: "#.get_properties(#, #)".} ## \
## Returns the TextProperties in effect for the object at the indicated
## position in the indicated row.

proc `properties=`*(this: TextAssembler, properties: TextProperties) {.importcpp: "#.set_properties(#)".} ## \
## Specifies the default TextProperties that are applied to the text in the
## absence of any nested property change sequences.

func buttonDownEvent*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_button_down_event())", header: stringConversionCode.} ## \
## Returns the button_down_event that has been set on this ButtonThrower.  See
## set_button_down_event().

proc `buttonDownEvent=`*(this: ButtonThrower, button_down_event: string) {.importcpp: "#->set_button_down_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the generic event that is generated (if any) each time a key or
## button is depressed.  Unlike the specific events that are unique to each
## key, this same event name is used for \*all\* button events, and the name of
## the button pressed (possibly with modifier prefixes) will be sent as a
## parameter.
##
## If this string is empty, no event is generated.  It is possible to generate
## both generic events and specific events for the same button.
##
## See also set_keystroke_event().

func buttonUpEvent*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_button_up_event())", header: stringConversionCode.} ## \
## Returns the button_up_event that has been set on this ButtonThrower.  See
## set_button_up_event().

proc `buttonUpEvent=`*(this: ButtonThrower, button_up_event: string) {.importcpp: "#->set_button_up_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the generic event that is generated (if any) each time a key or
## button is released.  See set_button_down_event().

func buttonRepeatEvent*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_button_repeat_event())", header: stringConversionCode.} ## \
## Returns the button_repeat_event that has been set on this ButtonThrower.
## See set_button_repeat_event().

proc `buttonRepeatEvent=`*(this: ButtonThrower, button_repeat_event: string) {.importcpp: "#->set_button_repeat_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the generic event that is generated (if any) repeatedly while a
## key or button is held down.  Unlike the specific events that are unique to
## each key, this same event name is used for \*all\* button events, and the
## name of the button pressed (possibly with modifier prefixes) will be sent
## as a parameter.
##
## If this string is empty, no event is generated.  It is possible to generate
## both generic events and specific events for the same button.
##
## See also set_keystroke_event().

func keystrokeEvent*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_keystroke_event())", header: stringConversionCode.} ## \
## Returns the keystroke_event that has been set on this ButtonThrower.  See
## set_keystroke_event().

proc `keystrokeEvent=`*(this: ButtonThrower, keystroke_event: string) {.importcpp: "#->set_keystroke_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the event that is generated (if any) for each keystroke that is
## received.  A keystroke is different than a button event: it represents the
## semantic meaning of the sequence of keys that have been pressed.  For
## instance, pressing shift and 4 together will generate the button event
## "shift-4", but it will generate the keystroke "$".
##
## If a key is held down, keyrepeat will cause the same keystroke event to be
## generated repeatedly.  This is different from the corresponding down event,
## which will only be generated once, followed by a number of button repeat
## events.
##
## This event is generated with a single wstring parameter, which is a one-
## character string that contains the keystroke generated.  If this event
## string is empty, no event is generated.
##
## See also set_button_down_event().

func candidateEvent*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_candidate_event())", header: stringConversionCode.} ## \
## Returns the candidate_event that has been set on this ButtonThrower.  See
## set_candidate_event().

proc `candidateEvent=`*(this: ButtonThrower, candidate_event: string) {.importcpp: "#->set_candidate_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the event that is generated (if any) for each IME candidate
## string event received.  Events of this nature are received only when the
## user is entering data using a Microsoft Input Method Editor, typically used
## for Asian languages such as Japanese or Korean.
##
## If you are designing a typing user interface, you should track this event
## to support the use of the IME.  In response to this event, you should
## display the candidate string in the entry box, with the appropriate
## sections highlighted, so the user can scroll through the available choices.
##
## This event is generated with four parameters, in order: the candidate
## string, the character at which to start the highlight, the character at
## which to end the highlight, and the current cursor position.

func moveEvent*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_move_event())", header: stringConversionCode.} ## \
## Returns the move_event that has been set on this ButtonThrower.  See
## set_move_event().

proc `moveEvent=`*(this: ButtonThrower, move_event: string) {.importcpp: "#->set_move_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the event that is generated (if any) each time the mouse is moved
## within the window.

func rawButtonDownEvent*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_raw_button_down_event())", header: stringConversionCode.} ## \
## Returns the raw_button_down_event that has been set on this ButtonThrower.
## See set_raw_button_down_event().

proc `rawButtonDownEvent=`*(this: ButtonThrower, raw_button_down_event: string) {.importcpp: "#->set_raw_button_down_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Like set_button_down_event, but uses the raw, untransformed scan key from
## the operating system.  This uses buttons that are independent of the user's
## selected keyboard layout.

func rawButtonUpEvent*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_raw_button_up_event())", header: stringConversionCode.} ## \
## Returns the raw_button_up_event that has been set on this ButtonThrower.
## See set_raw_button_up_event().

proc `rawButtonUpEvent=`*(this: ButtonThrower, raw_button_up_event: string) {.importcpp: "#->set_raw_button_up_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the generic event that is generated (if any) each time a key or
## button is released.  See set_raw_button_down_event().

func prefix*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_prefix())", header: stringConversionCode.} ## \
## Returns the prefix that has been set on this ButtonThrower.  See
## set_prefix().

proc `prefix=`*(this: ButtonThrower, prefix: string) {.importcpp: "#->set_prefix(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the prefix which is prepended to all specific event names (that is,
## event names generated from the button name itself, as opposed to the
## generic event names like set_button_down_event) thrown by this object.

func specificFlag*(this: ButtonThrower): bool {.importcpp: "#->get_specific_flag()".} ## \
## Returns the flag that indicates whether specific events should be
## generated.  See set_specific_flag().

proc `specificFlag=`*(this: ButtonThrower, specific_flag: bool) {.importcpp: "#->set_specific_flag(#)".} ## \
## Sets the flag that indicates whether specific events (events prefixed by
## set_prefix, and based on the event name) should be generated at all.  This
## is true by default, but may be disabled if you are only interested in the
## generic events (for instance, events like set_button_down_event).

func timeFlag*(this: ButtonThrower): bool {.importcpp: "#->get_time_flag()".} ## \
## Returns the flag that indicates whether the time of the button event should
## be passed as a parameter.

proc `timeFlag=`*(this: ButtonThrower, time_flag: bool) {.importcpp: "#->set_time_flag(#)".} ## \
## Sets the flag that indicates whether the time of the button event should be
## passed as a parameter or not.  When this is true, an additional parameter
## is generated on each event (before all the parameters named by
## add_parameter) that consists of a single double value, and reflects the
## time the button was pressed or released, as a value from
## ClockObject::get_global_clock().

func modifierButtons*(this: ButtonThrower): ModifierButtons {.importcpp: "#->get_modifier_buttons()".} ## \
## Returns the set of ModifierButtons that the ButtonThrower will consider
## important enough to prepend the event name with.  Normally, this set will
## be empty, and the ButtonThrower will therefore ignore all ModifierButtons
## attached to the key events, but if one or more buttons have been added to
## this set, and those modifier buttons are set on the button event, then the
## event name will be prepended with the names of the modifier buttons.

proc `modifierButtons=`*(this: ButtonThrower, mods: ModifierButtons) {.importcpp: "#->set_modifier_buttons(#)".} ## \
## Changes the set of ModifierButtons that the ButtonThrower will consider
## important enough to prepend the event name with.  Normally, this set will
## be empty, and the ButtonThrower will therefore ignore all ModifierButtons
## attached to the key events, but if one or more buttons have been added to
## this set, then the event name will be prepended with the names of the
## modifier buttons.
##
## It is recommended that you change this setting by first calling
## get_modifier_buttons(), making adjustments, and passing the new value to
## set_modifier_buttons().  This way the current state of the modifier buttons
## will not be lost.

func throwButtonsActive*(this: ButtonThrower): bool {.importcpp: "#->get_throw_buttons_active()".} ## \
## Returns the flag that indicates whether the ButtonThrower will only process
## events for the explicitly named buttons or not.  See
## set_throw_buttons_active().

proc `throwButtonsActive=`*(this: ButtonThrower, flag: bool) {.importcpp: "#->set_throw_buttons_active(#)".} ## \
## Sets the flag that indicates whether the ButtonThrower will only process
## events for the explicitly named buttons or not.  Normally this is false,
## meaning all buttons are processed; set it true to indicate that only some
## buttons should be processed.  See add_throw_button().

func frame*(this: MouseWatcherRegion): LVecBase4 {.importcpp: "#->get_frame()".}

proc `frame=`*(this: MouseWatcherRegion, frame: LVecBase4) {.importcpp: "#->set_frame(#)".}

proc `frame=`*(this: MouseWatcherRegion, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#->set_frame(#, #, #, #)".}

func area*(this: MouseWatcherRegion): float32 {.importcpp: "#->get_area()".} ## \
## Returns the area of the rectangular region.

func sort*(this: MouseWatcherRegion): int {.importcpp: "#->get_sort()".} ## \
## Returns the current sorting order of this region.  See set_sort().

proc `sort=`*(this: MouseWatcherRegion, sort: int) {.importcpp: "#->set_sort(#)".} ## \
## Changes the sorting order of this particular region.  The sorting order is
## used to resolve conflicts in the case of overlapping region; the region
## with the highest sort value will be preferred, and between regions of the
## same sort value, the smallest region will be preferred.  The default
## sorting order, if none is explicitly specified, is 0.

func active*(this: MouseWatcherRegion): bool {.importcpp: "#->get_active()".} ## \
## Returns whether the region is active or not.  See set_active().

proc `active=`*(this: MouseWatcherRegion, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets whether the region is active or not.  If it is not active, the
## MouseWatcher will never consider the mouse to be over the region.  The
## region might still receive keypress events if its set_keyboard() flag is
## true.

func keyboard*(this: MouseWatcherRegion): bool {.importcpp: "#->get_keyboard()".} ## \
## Returns whether the region is interested in global keyboard events; see
## set_keyboard().

proc `keyboard=`*(this: MouseWatcherRegion, keyboard: bool) {.importcpp: "#->set_keyboard(#)".} ## \
## Sets whether the region is interested in global keyboard events.  If this
## is true, then any keyboard button events will be passed to press() and
## release() regardless of the position of the mouse onscreen; otherwise,
## these events will only be passed if the mouse is over the region.

func suppressFlags*(this: MouseWatcherRegion): int {.importcpp: "#->get_suppress_flags()".} ## \
## Returns the current suppress_flags.  See set_suppress_flags().

proc `suppressFlags=`*(this: MouseWatcherRegion, suppress_flags: int) {.importcpp: "#->set_suppress_flags(#)".} ## \
## Sets which events are suppressed when the mouse is over the region.  This
## is the union of zero or more various SF_\* values.  Normally, this is 0,
## indicating that no events are suppressed.
##
## If you set this to a non-zero value, for instance SF_mouse_position, then
## the mouse position will not be sent along the data graph when the mouse is
## over this particular region.

func sorted*(this: MouseWatcherBase): bool {.importcpp: "#->is_sorted()".} ## \
## Returns true if the group has already been sorted, false otherwise.

func seq*(this: UpdateSeq): int {.importcpp: "#.get_seq()".} ## \
## Returns the internal integer value associated with the UpdateSeq.  Useful
## for debugging only.

func sourcePathname*(this: BamCacheRecord): Filename {.importcpp: "#->get_source_pathname()".} ## \
## Returns the full pathname to the source file that originally generated this
## cache request.  In some cases, for instance in the case of a of a multipage
## texture like "cube_#.png", this may not not a true filename on disk.

func cacheFilename*(this: BamCacheRecord): Filename {.importcpp: "#->get_cache_filename()".} ## \
## Returns the name of the cache file as hashed from the source_pathname.
## This will be relative to the root of the cache directory, and it will not
## include any suffixes that may be appended to resolve hash conflicts.

func sourceTimestamp*(this: BamCacheRecord): time_t.Time {.importcpp: "#->get_source_timestamp()".} ## \
## Returns the file timestamp of the original source file that generated this
## cache record, if available.  In some cases the original file timestamp is
## not available, and this will return 0.

func recordedTime*(this: BamCacheRecord): time_t.Time {.importcpp: "#->get_recorded_time()".} ## \
## Returns the time at which this particular record was recorded or updated.

func data*(this: BamCacheRecord): TypedWritable {.importcpp: "#->get_data()".} ## \
## Returns a pointer to the data stored in the record, or NULL if there is no
## data.  The pointer is not removed from the record.

proc `data=`*(this: BamCacheRecord, `ptr`: TypedWritable) {.importcpp: "#->set_data(#)".} ## \
## This variant on set_data() is provided to easily pass objects deriving from
## TypedWritable.

proc `data=`*(this: BamCacheRecord, `ptr`: TypedWritable, ref_ptr: ReferenceCount) {.importcpp: "#->set_data(#, #)".} ## \
## Stores a new data object on the record.  You should pass the same pointer
## twice, to both parameters; this allows the C++ typecasting to automatically
## convert the pointer into both a TypedWritable and a ReferenceCount pointer,
## so that the BamCacheRecord object can reliably manage the reference counts.
##
## You may pass 0 or NULL as the second parameter.  If you do this, the
## BamCacheRecord will not manage the object's reference count; it will be up
## to you to ensure the object is not deleted during the lifetime of the
## BamCacheRecord object.

proc `data=`*(this: BamCacheRecord, `ptr`: TypedWritable, dummy: int) {.importcpp: "#->set_data(#, #)".} ## \
## This variant on set_data() is provided just to allow Python code to pass a
## 0 as the second parameter.

proc `data=`*(this: BamCacheRecord, `ptr`: TypedWritableReferenceCount) {.importcpp: "#->set_data(#)".} ## \
## This variant on set_data() is provided to easily pass objects deriving from
## TypedWritableReferenceCount.

func active*(this: BamCache): bool {.importcpp: "#.get_active()".} ## \
## Returns true if the BamCache is currently active, false if it is not.
## "active" means that the cache should be consulted automatically on loads,
## "not active" means that objects should be loaded directly without
## consulting the cache.
##
## This represents the global flag.  Also see the individual cache_models,
## cache_textures, cache_compressed_textures flags.

proc `active=`*(this: BamCache, flag: bool) {.importcpp: "#.set_active(#)".} ## \
## Changes the state of the active flag.  "active" means that the cache should
## be consulted automatically on loads, "not active" means that objects should
## be loaded directly without consulting the cache.
##
## This represents the global flag.  Also see the individual cache_models,
## cache_textures, cache_compressed_textures flags.

func cacheModels*(this: BamCache): bool {.importcpp: "#.get_cache_models()".} ## \
## Returns whether model files (e.g.  egg files and bam files) will be stored
## in the cache, as bam files.
##
## This also returns false if get_active() is false.

proc `cacheModels=`*(this: BamCache, flag: bool) {.importcpp: "#.set_cache_models(#)".} ## \
## Indicates whether model files (e.g.  egg files and bam files) will be
## stored in the cache, as bam files.

func cacheTextures*(this: BamCache): bool {.importcpp: "#.get_cache_textures()".} ## \
## Returns whether texture files (e.g.  egg files and bam files) will be
## stored in the cache, as txo files.
##
## This also returns false if get_active() is false.

proc `cacheTextures=`*(this: BamCache, flag: bool) {.importcpp: "#.set_cache_textures(#)".} ## \
## Indicates whether texture files will be stored in the cache, as
## uncompressed txo files.

func cacheCompressedTextures*(this: BamCache): bool {.importcpp: "#.get_cache_compressed_textures()".} ## \
## Returns whether compressed texture files will be stored in the cache, as
## compressed txo files.  See set_cache_compressed_textures().
##
## This also returns false if get_active() is false.

proc `cacheCompressedTextures=`*(this: BamCache, flag: bool) {.importcpp: "#.set_cache_compressed_textures(#)".} ## \
## Indicates whether compressed texture files will be stored in the cache, as
## compressed txo files.  The compressed data may either be generated in-CPU,
## via the squish library, or it may be extracted from the GSG after the
## texture has been loaded.
##
## This may be set in conjunction with set_cache_textures(), or independently
## of it.  If set_cache_textures() is true and this is false, all textures
## will be cached in their uncompressed form.  If set_cache_textures() is
## false and this is true, only compressed textures will be cached, and they
## will be cached in their compressed form.  If both are true, all textures
## will be cached, in their uncompressed or compressed form appropriately.

func cacheCompiledShaders*(this: BamCache): bool {.importcpp: "#.get_cache_compiled_shaders()".} ## \
## Returns whether compiled shader programs will be stored in the cache, as
## binary .txo files.  See set_cache_compiled_shaders().
##
## This also returns false if get_active() is false.

proc `cacheCompiledShaders=`*(this: BamCache, flag: bool) {.importcpp: "#.set_cache_compiled_shaders(#)".} ## \
## Indicates whether compiled shader programs will be stored in the cache, as
## binary .sho files.  This may not be supported by all shader languages or
## graphics renderers.

func root*(this: BamCache): Filename {.importcpp: "#.get_root()".} ## \
## Returns the current root pathname of the cache.  See set_root().

proc `root=`*(this: BamCache, root: Filename) {.importcpp: "#.set_root(#)".} ## \
## Changes the current root pathname of the cache.  This specifies where the
## cache files are stored on disk.  This should name a directory that is on a
## disk local to the machine (not on a network-mounted disk), for instance,
## tmp/panda-cache or /c/panda-cache.
##
## If the directory does not already exist, it will be created as a result of
## this call.

func flushTime*(this: BamCache): int {.importcpp: "#.get_flush_time()".} ## \
## Returns the time in seconds between automatic flushes of the cache index.

proc `flushTime=`*(this: BamCache, flush_time: int) {.importcpp: "#.set_flush_time(#)".} ## \
## Specifies the time in seconds between automatic flushes of the cache index.

func cacheMaxKbytes*(this: BamCache): int {.importcpp: "#.get_cache_max_kbytes()".} ## \
## Returns the maximum size, in kilobytes, which the cache is allowed to grow
## to.  See set_cache_max_kbytes().

proc `cacheMaxKbytes=`*(this: BamCache, max_kbytes: int) {.importcpp: "#.set_cache_max_kbytes(#)".} ## \
## Specifies the maximum size, in kilobytes, which the cache is allowed to
## grow to.  If a newly cached file would exceed this size, an older file is
## removed from the cache.
##
## Note that in the case of multiple different processes simultaneously
## operating on the same cache directory, the actual cache size may slightly
## exceed this value from time to time due to latency in checking between the
## processes.

func readOnly*(this: BamCache): bool {.importcpp: "#.get_read_only()".} ## \
## Returns true if the cache is in read-only mode.  Normally, the cache starts
## in read-write mode.  It can put itself into read-only mode automatically if
## it discovers that it does not have write access to the cache.

proc `readOnly=`*(this: BamCache, ro: bool) {.importcpp: "#.set_read_only(#)".} ## \
## Can be used to put the cache in read-only mode, or take it out of read-only
## mode.  Note that if you put it into read-write mode, and it discovers that
## it does not have write access, it will put itself right back into read-only
## mode.

func flags*(this: LoaderOptions): int {.importcpp: "#.get_flags()".}

proc `flags=`*(this: LoaderOptions, flags: int) {.importcpp: "#.set_flags(#)".}

func textureFlags*(this: LoaderOptions): int {.importcpp: "#.get_texture_flags()".}

proc `textureFlags=`*(this: LoaderOptions, flags: int) {.importcpp: "#.set_texture_flags(#)".}

func textureNumViews*(this: LoaderOptions): int {.importcpp: "#.get_texture_num_views()".} ## \
## See set_texture_num_views().

proc `textureNumViews=`*(this: LoaderOptions, num_views: int) {.importcpp: "#.set_texture_num_views(#)".} ## \
## Specifies the expected number of views to load for the texture.  This is
## ignored unless TF_multiview is included in texture_flags.  This must be
## specified when loading a 3-d multiview texture or 2-d texture array, in
## which case it is used to differentiate z levels from separate views; it
## may be zero in the case of 2-d textures or cube maps, in which case the
## number of views can be inferred from the number of images found on disk.

func autoTextureScale*(this: LoaderOptions): AutoTextureScale {.importcpp: "#.get_auto_texture_scale()".} ## \
## See set_auto_texture_scale().

proc `autoTextureScale=`*(this: LoaderOptions, scale: AutoTextureScale) {.importcpp: "#.set_auto_texture_scale(#)".} ## \
## Set this flag to ATS_none, ATS_up, ATS_down, or ATS_pad to control how a
## texture is scaled from disk when it is subsequently loaded.  Set it to
## ATS_unspecified to restore the default behavior.

func source*(this: BamReader): DatagramGenerator {.importcpp: "#.get_source()".} ## \
## Returns the current source of the BamReader as set by set_source() or the
## constructor.

proc `source=`*(this: BamReader, source: DatagramGenerator) {.importcpp: "#.set_source(#)".} ## \
## Changes the source of future datagrams for this BamReader.  This also
## implicitly calls init() if it has not already been called.

func filename*(this: BamReader): Filename {.importcpp: "#.get_filename()".} ## \
## If a BAM is a file, then the BamReader should contain the name of the file.
## This enables the reader to interpret pathnames in the BAM as relative to
## the directory containing the BAM.

func loaderOptions*(this: BamReader): LoaderOptions {.importcpp: "#.get_loader_options()".} ## \
## Returns the LoaderOptions passed to the loader when the model was
## requested, if any.

proc `loaderOptions=`*(this: BamReader, options: LoaderOptions) {.importcpp: "#.set_loader_options(#)".} ## \
## Specifies the LoaderOptions for this BamReader.

func fileStdfloatDouble*(this: BamReader): bool {.importcpp: "#.get_file_stdfloat_double()".} ## \
## Returns true if the file stores all "standard" floats as 64-bit doubles, or
## false if they are 32-bit floats.  This is determined by the compilation
## flags of the version of Panda that generated this file.

func target*(this: BamWriter): DatagramSink {.importcpp: "#.get_target()".} ## \
## Returns the current target of the BamWriter as set by set_target() or the
## constructor.

proc `target=`*(this: BamWriter, target: DatagramSink) {.importcpp: "#.set_target(#)".} ## \
## Changes the destination of future datagrams written by the BamWriter.  This
## also implicitly calls init() if it has not already been called.

func filename*(this: BamWriter): Filename {.importcpp: "#.get_filename()".} ## \
## If a BAM is a file, then the BamWriter should contain the name of the file.
## This enables the writer to convert pathnames in the BAM to relative to the
## directory containing the BAM.

func fileStdfloatDouble*(this: BamWriter): bool {.importcpp: "#.get_file_stdfloat_double()".} ## \
## Returns true if the file will store all "standard" floats as 64-bit
## doubles, or false if they are 32-bit floats.  This isn't runtime settable;
## it's based on the compilation flags of the version of Panda that generated
## this file.

func rootNode*(this: BamWriter): TypedWritable {.importcpp: "#.get_root_node()".} ## \
## Returns the root node of the part of the scene graph we are currently
## writing out.  This is used for determining what to make NodePaths relative
## to.

proc `rootNode=`*(this: BamWriter, root_node: TypedWritable) {.importcpp: "#.set_root_node(#)".} ## \
## Sets the root node of the part of the scene graph we are currently writing
## out.  NodePaths written to this bam file will be relative to this node.

func index*(this: ButtonHandle): int {.importcpp: "#.get_index()".} ## \
## Returns the integer index associated with this ButtonHandle.  Each
## different ButtonHandle will have a different index.  However, you probably
## shouldn't be using this method; you should just treat the ButtonHandles as
## opaque classes.  This is provided for the convenience of non-C++ scripting
## languages to build a hashtable of ButtonHandles.

func name*(this: ButtonHandle): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the button.

func asciiEquivalent*(this: ButtonHandle): char {.importcpp: "#.get_ascii_equivalent()".} ## \
## Returns the character code associated with the button, or '\0' if no ASCII
## code was associated.

func alias*(this: ButtonHandle): ButtonHandle {.importcpp: "#.get_alias()".} ## \
## Returns the alias (alternate name) associated with the button, if any, or
## ButtonHandle::none() if the button has no alias.
##
## Each button is allowed to have one alias, and multiple different buttons
## can refer to the same alias.  The alias should be the more general name for
## the button, for instance, shift is an alias for lshift, but not vice-versa.

func frameTime*(this: ClockObject, current_thread: Thread): float64 {.importcpp: "#->get_frame_time(#)".} ## \
## Returns the time in seconds as of the last time tick() was called
## (typically, this will be as of the start of the current frame).
##
## This is generally the kind of time you want to ask for in most rendering
## and animation contexts, since it's important that all of the animation for
## a given frame remains in sync with each other.

func frameTime*(this: ClockObject): float64 {.importcpp: "#->get_frame_time()".} ## \
## Returns the time in seconds as of the last time tick() was called
## (typically, this will be as of the start of the current frame).
##
## This is generally the kind of time you want to ask for in most rendering
## and animation contexts, since it's important that all of the animation for
## a given frame remains in sync with each other.

proc `frameTime=`*(this: ClockObject, time: float64, current_thread: Thread) {.importcpp: "#->set_frame_time(#, #)".} ## \
## Changes the time as reported for the current frame to the indicated time.
## Normally, the way to adjust the frame time is via tick(); this function is
## provided only for occasional special adjustments.

proc `frameTime=`*(this: ClockObject, time: float64) {.importcpp: "#->set_frame_time(#)".} ## \
## Changes the time as reported for the current frame to the indicated time.
## Normally, the way to adjust the frame time is via tick(); this function is
## provided only for occasional special adjustments.

func realTime*(this: ClockObject): float64 {.importcpp: "#->get_real_time()".} ## \
## Returns the actual number of seconds elapsed since the ClockObject was
## created, or since it was last reset.  This is useful for doing real timing
## measurements, e.g.  for performance statistics.
##
## This returns the most precise timer we have for short time intervals, but
## it may tend to drift over the long haul.  If more accurate timekeeping is
## needed over a long period of time, use get_long_time() instead.

proc `realTime=`*(this: ClockObject, time: float64) {.importcpp: "#->set_real_time(#)".} ## \
## Resets the clock to the indicated time.  This changes only the real time of
## the clock as reported by get_real_time(), but does not immediately change
## the time reported by get_frame_time()--that will change after the next call
## to tick().  Also see reset(), set_frame_time(), and set_frame_count().

func longTime*(this: ClockObject): float64 {.importcpp: "#->get_long_time()".} ## \
## Returns the actual number of seconds elapsed since the ClockObject was
## created, or since it was last reset.
##
## This is similar to get_real_time(), except that it uses the most accurate
## counter we have over a long period of time, and so it is less likely to
## drift.  However, it may not be very precise for measuring short intervals.
## On Windows, for instace, this is only accurate to within about 55
## milliseconds.

func frameCount*(this: ClockObject, current_thread: Thread): int {.importcpp: "#->get_frame_count(#)".} ## \
## Returns the number of times tick() has been called since the ClockObject
## was created, or since it was last reset.  This is generally the number of
## frames that have been rendered.

func frameCount*(this: ClockObject): int {.importcpp: "#->get_frame_count()".} ## \
## Returns the number of times tick() has been called since the ClockObject
## was created, or since it was last reset.  This is generally the number of
## frames that have been rendered.

proc `frameCount=`*(this: ClockObject, frame_count: int, current_thread: Thread) {.importcpp: "#->set_frame_count(#, #)".} ## \
## Resets the number of frames counted to the indicated number.  Also see
## reset(), set_real_time(), and set_frame_time().

proc `frameCount=`*(this: ClockObject, frame_count: int) {.importcpp: "#->set_frame_count(#)".} ## \
## Resets the number of frames counted to the indicated number.  Also see
## reset(), set_real_time(), and set_frame_time().

func dt*(this: ClockObject, current_thread: Thread): float64 {.importcpp: "#->get_dt(#)".} ## \
## Returns the elapsed time for the previous frame: the number of seconds
## elapsed between the last two calls to tick().

func dt*(this: ClockObject): float64 {.importcpp: "#->get_dt()".} ## \
## Returns the elapsed time for the previous frame: the number of seconds
## elapsed between the last two calls to tick().

proc `dt=`*(this: ClockObject, dt: float64) {.importcpp: "#->set_dt(#)".} ## \
## In non-real-time mode, sets the number of seconds that should appear to
## elapse between frames.  In forced mode or limited mode, sets our target dt.
## In normal mode, this has no effect.
##
## Also see set_frame_rate(), which is a different way to specify the same
## quantity.

func maxDt*(this: ClockObject): float64 {.importcpp: "#->get_max_dt()".} ## \
## Returns the current maximum allowable time elapsed between any two frames.
## See set_max_dt().

proc `maxDt=`*(this: ClockObject, max_dt: float64) {.importcpp: "#->set_max_dt(#)".} ## \
## Sets a limit on the value returned by get_dt().  If this value is less than
## zero, no limit is imposed; otherwise, this is the maximum value that will
## ever be returned by get_dt(), regardless of how much time has actually
## elapsed between frames.
##
## This limit is only imposed in real-time mode; in non-real-time mode, the dt
## is fixed anyway and max_dt is ignored.
##
## This is generally used to guarantee reasonable behavior even in the
## presence of a very slow or chuggy frame rame.

func degradeFactor*(this: ClockObject): float64 {.importcpp: "#->get_degrade_factor()".} ## \
## In degrade mode, returns the ratio by which the performance is degraded.  A
## value of 2.0 causes the clock to be slowed down by a factor of two
## (reducing performance to 1/2 what would be otherwise).
##
## This has no effect if mode is not M_degrade.

proc `degradeFactor=`*(this: ClockObject, degrade_factor: float64) {.importcpp: "#->set_degrade_factor(#)".} ## \
## In degrade mode, sets the ratio by which the performance is degraded.  A
## value of 2.0 causes the clock to be slowed down by a factor of two
## (reducing performance to 1/2 what would be otherwise).
##
## This has no effect if mode is not M_degrade.

func averageFrameRateInterval*(this: ClockObject): float64 {.importcpp: "#->get_average_frame_rate_interval()".} ## \
## Returns the interval of time (in seconds) over which
## get_average_frame_rate() averages the number of frames per second to
## compute the frame rate.

proc `averageFrameRateInterval=`*(this: ClockObject, time: float64) {.importcpp: "#->set_average_frame_rate_interval(#)".} ## \
## Specifies the interval of time (in seconds) over which
## get_average_frame_rate() averages the number of frames per second to
## compute the frame rate.  Changing this does not necessarily immediately
## change the result of get_average_frame_rate(), until this interval of time
## has elapsed again.
##
## Setting this to zero disables the computation of get_average_frame_rate().

func averageFrameRate*(this: ClockObject, current_thread: Thread): float64 {.importcpp: "#->get_average_frame_rate(#)".} ## \
## Returns the average frame rate in number of frames per second over the last
## get_average_frame_rate_interval() seconds.  This measures the virtual frame
## rate if the clock is in M_non_real_time mode.

func averageFrameRate*(this: ClockObject): float64 {.importcpp: "#->get_average_frame_rate()".} ## \
## Returns the average frame rate in number of frames per second over the last
## get_average_frame_rate_interval() seconds.  This measures the virtual frame
## rate if the clock is in M_non_real_time mode.

func maxFrameDuration*(this: ClockObject, current_thread: Thread): float64 {.importcpp: "#->get_max_frame_duration(#)".} ## \
## Returns the maximum frame duration over the last
## get_average_frame_rate_interval() seconds.

func maxFrameDuration*(this: ClockObject): float64 {.importcpp: "#->get_max_frame_duration()".} ## \
## Returns the maximum frame duration over the last
## get_average_frame_rate_interval() seconds.

func x*(this: PointerData): float64 {.importcpp: "#.get_x()".}

func y*(this: PointerData): float64 {.importcpp: "#.get_y()".}

func inWindow*(this: PointerData): bool {.importcpp: "#.get_in_window()".} ## \
## If this returns false, the pointer is not currently present in the window
## and the values returned by get_x() and get_y() may not be meaningful.

func value*(this: ParamTypedRefCount): TypedReferenceCount {.importcpp: "#->get_value()".} ## \
## Retrieves the value stored in the parameter.

func dlsPathname*(_: typedesc[AudioManager]): Filename {.importcpp: "AudioManager::get_dls_pathname()", header: "audioManager.h".}

func clickPrefix*(_: typedesc[PGButton]): string {.importcpp: "nimStringFromStdString(PGButton::get_click_prefix())", header: "pgButton.h".} ## \
## Returns the prefix that is used to define the click event for all
## PGButtons.  The click event is the concatenation of this string followed by
## get_id().

func hostName*(_: typedesc[ConnectionManager]): string {.importcpp: "nimStringFromStdString(ConnectionManager::get_host_name())", header: "connectionManager.h".} ## \
## Returns the name of this particular machine on the network, if available,
## or the empty string if the hostname cannot be determined.

proc getTotalAlloc*(_: typedesc[NeverFreeMemory]): clonglong {.importcpp: "NeverFreeMemory::get_total_alloc()", header: "neverFreeMemory.h".} ## \
## Returns the total number of bytes consumed by all the pages allocated
## internally by this object.

proc getTotalUsed*(_: typedesc[NeverFreeMemory]): clonglong {.importcpp: "NeverFreeMemory::get_total_used()", header: "neverFreeMemory.h".} ## \
## Returns the total number of bytes requested by the application in calls to
## NeverFreeMemory::alloc().

proc getTotalUnused*(_: typedesc[NeverFreeMemory]): clonglong {.importcpp: "NeverFreeMemory::get_total_unused()", header: "neverFreeMemory.h".} ## \
## Returns the difference between get_total_alloc() and get_total_used().
## This represents bytes in allocated pages that have not (yet) been used by
## the application.

proc initTypeHandle*(): TypeHandle {.importcpp: "TypeHandle()".}

proc initTypeHandle*(param0: TypeHandle): TypeHandle {.importcpp: "TypeHandle(#)".}

proc `==`*(this: TypeHandle, other: TypeHandle): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: TypeHandle, other: TypeHandle): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: TypeHandle, other: TypeHandle): bool {.importcpp: "#.operator <(#)".}

proc `<=`*(this: TypeHandle, other: TypeHandle): bool {.importcpp: "#.operator <=(#)".}

proc `>`*(this: TypeHandle, other: TypeHandle): bool {.importcpp: "#.operator >(#)".}

proc `>=`*(this: TypeHandle, other: TypeHandle): bool {.importcpp: "#.operator >=(#)".}

proc compareTo*(this: TypeHandle, other: TypeHandle): int {.importcpp: "#.compare_to(#)".} ## \
## Sorts TypeHandles arbitrarily (according to <, >, etc.).  Returns a number
## less than 0 if this type sorts before the other one, greater than zero if
## it sorts after, 0 if they are equivalent.

proc getHash*(this: TypeHandle): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a hash code suitable for phash_map.

proc getName*(this: TypeHandle, `object`: TypedObject): string {.importcpp: "nimStringFromStdString(#.get_name(#))", header: stringConversionCode.} ## \
## Returns the name of the type.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc getName*(this: TypeHandle): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the type.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc isDerivedFrom*(this: TypeHandle, parent: TypeHandle, `object`: TypedObject): bool {.importcpp: "#.is_derived_from(#, #)".} ## \
## Returns true if this type is derived from the indicated type, false
## otherwise.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc isDerivedFrom*(this: TypeHandle, parent: TypeHandle): bool {.importcpp: "#.is_derived_from(#)".} ## \
## Returns true if this type is derived from the indicated type, false
## otherwise.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc getNumParentClasses*(this: TypeHandle, `object`: TypedObject): int {.importcpp: "#.get_num_parent_classes(#)".} ## \
## Returns the number of parent classes that this type is known to have.  This
## may then be used to index into get_parent_class().  The result will be 0 if
## this class does not inherit from any other classes, 1 if normal, single
## inheritance is in effect, or greater than one if multiple inheritance is in
## effect.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc getNumParentClasses*(this: TypeHandle): int {.importcpp: "#.get_num_parent_classes()".} ## \
## Returns the number of parent classes that this type is known to have.  This
## may then be used to index into get_parent_class().  The result will be 0 if
## this class does not inherit from any other classes, 1 if normal, single
## inheritance is in effect, or greater than one if multiple inheritance is in
## effect.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc getParentClass*(this: TypeHandle, index: int): TypeHandle {.importcpp: "#.get_parent_class(#)".} ## \
## Returns the nth parent class of this type.  The index should be in the
## range 0 <= index < get_num_parent_classes().

proc getNumChildClasses*(this: TypeHandle, `object`: TypedObject): int {.importcpp: "#.get_num_child_classes(#)".} ## \
## Returns the number of child classes that this type is known to have.  This
## may then be used to index into get_child_class().
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc getNumChildClasses*(this: TypeHandle): int {.importcpp: "#.get_num_child_classes()".} ## \
## Returns the number of child classes that this type is known to have.  This
## may then be used to index into get_child_class().
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc getChildClass*(this: TypeHandle, index: int): TypeHandle {.importcpp: "#.get_child_class(#)".} ## \
## Returns the nth child class of this type.  The index should be in the range
## 0 <= index < get_num_child_classes().

proc getParentTowards*(this: TypeHandle, ancestor: TypeHandle, `object`: TypedObject): TypeHandle {.importcpp: "#.get_parent_towards(#, #)".} ## \
## Returns the parent class that is in a direct line of inheritance to the
## indicated ancestor class.  This is useful in the presence of multiple
## inheritance to try to determine what properties an unknown type may have.
##
## The return value is TypeHandle::none() if the type does not inherit from
## the ancestor.  If ancestor is the same as this type, the return value is
## this type.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc getParentTowards*(this: TypeHandle, ancestor: TypeHandle): TypeHandle {.importcpp: "#.get_parent_towards(#)".} ## \
## Returns the parent class that is in a direct line of inheritance to the
## indicated ancestor class.  This is useful in the presence of multiple
## inheritance to try to determine what properties an unknown type may have.
##
## The return value is TypeHandle::none() if the type does not inherit from
## the ancestor.  If ancestor is the same as this type, the return value is
## this type.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc getIndex*(this: TypeHandle): int {.importcpp: "#.get_index()".} ## \
## Returns the integer index associated with this TypeHandle.  Each different
## TypeHandle will have a different index.  However, you probably shouldn't be
## using this method; you should just treat the TypeHandles as opaque classes.
## This is provided for the convenience of non-C++ scripting languages to
## build a hashtable of TypeHandles.

proc output*(this: TypeHandle, `out`: ostream) {.importcpp: "#.output(#)".}

proc none*(_: typedesc[TypeHandle]): TypeHandle {.importcpp: "TypeHandle::none()", header: "typeHandle.h".}

proc `typecast bool`*(this: TypeHandle): bool {.importcpp: "#.operator typecast bool()".}

proc registerDynamicType*(this: TypeRegistry, name: string): TypeHandle {.importcpp: "#.register_dynamic_type(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Registers a new type on-the-fly, presumably at runtime.  A new TypeHandle
## is returned if the typename was not seen before; otherwise the same
## TypeHandle that was last used for this typename is returned.

proc recordDerivation*(this: TypeRegistry, child: TypeHandle, parent: TypeHandle) {.importcpp: "#.record_derivation(#, #)".} ## \
## Records that the type referenced by child inherits directly from the type
## referenced by parent.  In the event of multiple inheritance, this should be
## called once for each parent class.

proc recordAlternateName*(this: TypeRegistry, `type`: TypeHandle, name: string) {.importcpp: "#.record_alternate_name(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Indicates an alternate name for the same type.  This is particularly useful
## when a type has changed names, since the type is stored in a Bam file by
## name; setting the original name as the alternate will allow the type to be
## correctly read from old Bam files.

proc findType*(this: TypeRegistry, name: string): TypeHandle {.importcpp: "#.find_type(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Looks for a previously-registered type of the given name.  Returns its
## TypeHandle if it exists, or TypeHandle::none() if there is no such type.

proc findTypeById*(this: TypeRegistry, id: int): TypeHandle {.importcpp: "#.find_type_by_id(#)".} ## \
## Looks for a previously-registered type with the given id number (as
## returned by TypeHandle::get_index()). Returns its TypeHandle if it exists,
## or TypeHandle::none() if there is no such type.

proc getName*(this: TypeRegistry, `type`: TypeHandle, `object`: TypedObject): string {.importcpp: "nimStringFromStdString(#.get_name(#, #))", header: stringConversionCode.} ## \
## Returns the name of the indicated type.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc isDerivedFrom*(this: TypeRegistry, child: TypeHandle, base: TypeHandle, child_object: TypedObject): bool {.importcpp: "#.is_derived_from(#, #, #)".} ## \
## Returns true if the first type is derived from the second type, false
## otherwise.
##
## The "child_object" pointer is an optional pointer to the TypedObject class
## that owns the child TypeHandle.  It is only used in case the TypeHandle is
## inadvertently undefined.
##
## This function definition follows the definitions for look_up() and
## freshen_derivations() just to maximize the chance the the compiler will be
## able to inline the above functions.  Yeah, a compiler shouldn't care, but
## there's a big different between "shouldn't" and "doesn't".

proc getNumTypehandles*(this: TypeRegistry): int {.importcpp: "#.get_num_typehandles()".} ## \
## Returns the total number of unique TypeHandles in the system.

proc getTypehandle*(this: TypeRegistry, n: int): TypeHandle {.importcpp: "#.get_typehandle(#)".} ## \
## Returns the nth TypeHandle in the system.  See get_num_typehandles().

proc getNumRootClasses*(this: TypeRegistry): int {.importcpp: "#.get_num_root_classes()".} ## \
## Returns the number of root classes--that is, classes that do not inherit
## from any other classes--known in the system.

proc getRootClass*(this: TypeRegistry, n: int): TypeHandle {.importcpp: "#.get_root_class(#)".} ## \
## Returns the nth root class in the system.  See get_num_root_classes().

proc getNumParentClasses*(this: TypeRegistry, child: TypeHandle, child_object: TypedObject): int {.importcpp: "#.get_num_parent_classes(#, #)".} ## \
## Returns the number of parent classes that the indicated type is known to
## have.  This may then be used to index into get_parent_class().  The result
## will be 0 if this class does not inherit from any other classes, 1 if
## normal, single inheritance is in effect, or greater than one if multiple
## inheritance is in effect.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc getParentClass*(this: TypeRegistry, child: TypeHandle, index: int): TypeHandle {.importcpp: "#.get_parent_class(#, #)".} ## \
## Returns the nth parent class of this type.  The index should be in the
## range 0 <= index < get_num_parent_classes().

proc getNumChildClasses*(this: TypeRegistry, child: TypeHandle, child_object: TypedObject): int {.importcpp: "#.get_num_child_classes(#, #)".} ## \
## Returns the number of child classes that the indicated type is known to
## have.  This may then be used to index into get_child_class().
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc getChildClass*(this: TypeRegistry, child: TypeHandle, index: int): TypeHandle {.importcpp: "#.get_child_class(#, #)".} ## \
## Returns the nth child class of this type.  The index should be in the range
## 0 <= index < get_num_child_classes().

proc getParentTowards*(this: TypeRegistry, child: TypeHandle, base: TypeHandle, child_object: TypedObject): TypeHandle {.importcpp: "#.get_parent_towards(#, #, #)".} ## \
## Returns the parent of the indicated child class that is in a direct line of
## inheritance to the indicated ancestor class.  This is useful in the
## presence of multiple inheritance to try to determine what properties an
## unknown type may have.
##
## The "object" pointer is an optional pointer to the TypedObject class that
## owns this TypeHandle.  It is only used in case the TypeHandle is
## inadvertantly undefined.

proc reregisterTypes*(_: typedesc[TypeRegistry]) {.importcpp: "TypeRegistry::reregister_types()", header: "typeRegistry.h".} ## \
## Walks through the TypeRegistry tree and makes sure that each type that was
## previously registered is \*still\* registered.  This seems to get broken in
## certain circumstances when compiled against libc5--it is as if the static
## initializer stomps on the _type_handle values of each class after they've
## been registered.

proc write*(this: TypeRegistry, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Makes an attempt to format the entire TypeRegistry in a nice way that shows
## the derivation tree as intelligently as possible.

proc initTypeRegistry*(param0: TypeRegistry): TypeRegistry {.importcpp: "TypeRegistry(#)".}

proc getType*(this: TypedObject): TypeHandle {.importcpp: "#->get_type()".} ## \
## Derived classes should override this function to return get_class_type().

proc getTypeIndex*(this: TypedObject): int {.importcpp: "#->get_type_index()".} ## \
## Returns the internal index number associated with this object's TypeHandle,
## a unique number for each different type.  This is equivalent to
## get_type().get_index().

proc isOfType*(this: TypedObject, handle: TypeHandle): bool {.importcpp: "#->is_of_type(#)".} ## \
## Returns true if the current object is or derives from the indicated type.

proc isExactType*(this: TypedObject, handle: TypeHandle): bool {.importcpp: "#->is_exact_type(#)".} ## \
## Returns true if the current object is the indicated type exactly.

converter getClassType*(_: typedesc[TypedObject]): TypeHandle {.importcpp: "TypedObject::get_class_type()", header: "typedObject.h".}

proc get*(this: istream): int {.importcpp: "#.get()".}

proc tellg*(this: istream): clonglong {.importcpp: "#.tellg()".}

proc seekg*(this: istream, pos: clonglong) {.importcpp: "#.seekg(#)".}

converter upcastToIstream*(this: iostream): istream {.importcpp: "#.upcast_to_istream()".}

proc put*(this: ostream, c: char) {.importcpp: "#.put(#)".}

proc flush*(this: ostream) {.importcpp: "#.flush()".}

proc tellp*(this: ostream): clonglong {.importcpp: "#.tellp()".}

proc seekp*(this: ostream, pos: clonglong) {.importcpp: "#.seekp(#)".}

converter upcastToOstream*(this: iostream): ostream {.importcpp: "#.upcast_to_ostream()".}

proc flush*(this: iostream) {.importcpp: "#.flush()".}

proc initfstream*(): fstream {.importcpp: "fstream()".}

proc close*(this: fstream) {.importcpp: "#.close()".}

proc initifstream*(): ifstream {.importcpp: "ifstream()".}

proc close*(this: ifstream) {.importcpp: "#.close()".}

proc initofstream*(): ofstream {.importcpp: "ofstream()".}

proc close*(this: ofstream) {.importcpp: "#.close()".}

proc initIFileStream*(): IFileStream {.importcpp: "IFileStream()".}

proc initIFileStream*(filename: string): IFileStream {.importcpp: "IFileStream(nimStringToStdString(#))", header: stringConversionCode.}

proc open*(this: IFileStream, filename: string) {.importcpp: "#.open(nimStringToStdString(#))", header: stringConversionCode.}

proc close*(this: IFileStream) {.importcpp: "#.close()".}

proc initOFileStream*(): OFileStream {.importcpp: "OFileStream()".}

proc initOFileStream*(filename: string): OFileStream {.importcpp: "OFileStream(nimStringToStdString(#))", header: stringConversionCode.}

proc open*(this: OFileStream, filename: string) {.importcpp: "#.open(nimStringToStdString(#))", header: stringConversionCode.}

proc close*(this: OFileStream) {.importcpp: "#.close()".}

proc initFileStream*(): FileStream {.importcpp: "FileStream()".}

proc initFileStream*(filename: string): FileStream {.importcpp: "FileStream(nimStringToStdString(#))", header: stringConversionCode.}

proc open*(this: FileStream, filename: string) {.importcpp: "#.open(nimStringToStdString(#))", header: stringConversionCode.}

proc close*(this: FileStream) {.importcpp: "#.close()".}

proc newTextEncoder*(): TextEncoder {.importcpp: "new TextEncoder()".}

proc newTextEncoder*(copy: TextEncoder): TextEncoder {.importcpp: "new TextEncoder(#)".}

proc clearText*(this: TextEncoder) {.importcpp: "#->clear_text()".} ## \
## Removes the text from the TextEncoder.

proc hasText*(this: TextEncoder): bool {.importcpp: "#->has_text()".}

proc makeUpper*(this: TextEncoder) {.importcpp: "#->make_upper()".} ## \
## Adjusts the text stored within the encoder to all uppercase letters
## (preserving accent marks correctly).

proc makeLower*(this: TextEncoder) {.importcpp: "#->make_lower()".} ## \
## Adjusts the text stored within the encoder to all lowercase letters
## (preserving accent marks correctly).

proc appendUnicodeChar*(this: TextEncoder, character: int) {.importcpp: "#->append_unicode_char(#)".} ## \
## Appends a single character to the end of the stored text.  This may be a
## wide character, up to 16 bits in Unicode.

proc getNumChars*(this: TextEncoder): clonglong {.importcpp: "#->get_num_chars()".} ## \
## Returns the number of characters in the stored text.  This is a count of
## wide characters, after the string has been decoded according to
## set_encoding().

proc getUnicodeChar*(this: TextEncoder, index: clonglong): int {.importcpp: "#->get_unicode_char(#)".} ## \
## Returns the Unicode value of the nth character in the stored text.  This
## may be a wide character (greater than 255), after the string has been
## decoded according to set_encoding().

proc setUnicodeChar*(this: TextEncoder, index: clonglong, character: int) {.importcpp: "#->set_unicode_char(#, #)".} ## \
## Sets the Unicode value of the nth character in the stored text.  This may
## be a wide character (greater than 255), after the string has been decoded
## according to set_encoding().

proc getEncodedChar*(this: TextEncoder, index: clonglong): string {.importcpp: "nimStringFromStdString(#->get_encoded_char(#))", header: stringConversionCode.} ## \
## Returns the nth char of the stored text, as a one-, two-, or three-byte
## encoded string.

proc getTextAsAscii*(this: TextEncoder): string {.importcpp: "nimStringFromStdString(#->get_text_as_ascii())", header: stringConversionCode.} ## \
## Returns the text associated with the node, converted as nearly as possible
## to a fully-ASCII representation.  This means replacing accented letters
## with their unaccented ASCII equivalents.
##
## It is possible that some characters in the string cannot be converted to
## ASCII.  (The string may involve symbols like the copyright symbol, for
## instance, or it might involve letters in some other alphabet such as Greek
## or Cyrillic, or even Latin letters like thorn or eth that are not part of
## the ASCII character set.)  In this case, as much of the string as possible
## will be converted to ASCII, and the nonconvertible characters will remain
## encoded in the encoding specified by set_encoding().

proc unicodeIsalpha*(_: typedesc[TextEncoder], character: int): bool {.importcpp: "#TextEncoder::unicode_isalpha(#)", header: "textEncoder.h".} ## \
## Returns true if the indicated character is an alphabetic letter, false
## otherwise.  This is akin to ctype's isalpha(), extended to Unicode.

proc unicodeIsdigit*(_: typedesc[TextEncoder], character: int): bool {.importcpp: "#TextEncoder::unicode_isdigit(#)", header: "textEncoder.h".} ## \
## Returns true if the indicated character is a numeric digit, false
## otherwise.  This is akin to ctype's isdigit(), extended to Unicode.

proc unicodeIspunct*(_: typedesc[TextEncoder], character: int): bool {.importcpp: "#TextEncoder::unicode_ispunct(#)", header: "textEncoder.h".} ## \
## Returns true if the indicated character is a punctuation mark, false
## otherwise.  This is akin to ctype's ispunct(), extended to Unicode.

proc unicodeIslower*(_: typedesc[TextEncoder], character: int): bool {.importcpp: "#TextEncoder::unicode_islower(#)", header: "textEncoder.h".} ## \
## Returns true if the indicated character is a lowercase letter, false
## otherwise.  This is akin to ctype's islower(), extended to Unicode.

proc unicodeIsupper*(_: typedesc[TextEncoder], character: int): bool {.importcpp: "#TextEncoder::unicode_isupper(#)", header: "textEncoder.h".} ## \
## Returns true if the indicated character is an uppercase letter, false
## otherwise.  This is akin to ctype's isupper(), extended to Unicode.

proc unicodeIsspace*(_: typedesc[TextEncoder], character: int): bool {.importcpp: "#TextEncoder::unicode_isspace(#)", header: "textEncoder.h".} ## \
## Returns true if the indicated character is a whitespace letter, false
## otherwise.  This is akin to ctype's isspace(), extended to Unicode.

proc unicodeToupper*(_: typedesc[TextEncoder], character: int): int {.importcpp: "#TextEncoder::unicode_toupper(#)", header: "textEncoder.h".} ## \
## Returns the uppercase equivalent of the given Unicode character.  This is
## akin to ctype's toupper(), extended to Unicode.

proc unicodeTolower*(_: typedesc[TextEncoder], character: int): int {.importcpp: "#TextEncoder::unicode_tolower(#)", header: "textEncoder.h".} ## \
## Returns the uppercase equivalent of the given Unicode character.  This is
## akin to ctype's tolower(), extended to Unicode.

proc upper*(_: typedesc[TextEncoder], source: string): string {.importcpp: "nimStringFromStdString(#TextEncoder::upper(nimStringToStdString(#)))", header: "textEncoder.h".} ## \
## Converts the string to uppercase, assuming the string is encoded in the
## default encoding.

proc lower*(_: typedesc[TextEncoder], source: string): string {.importcpp: "nimStringFromStdString(#TextEncoder::lower(nimStringToStdString(#)))", header: "textEncoder.h".} ## \
## Converts the string to lowercase, assuming the string is encoded in the
## default encoding.

proc setWtext*(this: TextEncoder, wtext: string) {.importcpp: "#->set_wtext(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the text that is stored in the encoder.  Subsequent calls to
## get_wtext() will return this same string, while get_text() will return the
## encoded version of the string.

proc getWtext*(this: TextEncoder): string {.importcpp: "nimStringFromStdString(#->get_wtext())", header: stringConversionCode.} ## \
## Returns the text associated with the TextEncoder, as a wide-character
## string.

proc appendWtext*(this: TextEncoder, text: string) {.importcpp: "#->append_wtext(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Appends the indicates string to the end of the stored wide-character text.

proc getWtextAsAscii*(this: TextEncoder): string {.importcpp: "nimStringFromStdString(#->get_wtext_as_ascii())", header: stringConversionCode.} ## \
## Returns the text associated with the node, converted as nearly as possible
## to a fully-ASCII representation.  This means replacing accented letters
## with their unaccented ASCII equivalents.
##
## It is possible that some characters in the string cannot be converted to
## ASCII.  (The string may involve symbols like the copyright symbol, for
## instance, or it might involve letters in some other alphabet such as Greek
## or Cyrillic, or even Latin letters like thorn or eth that are not part of
## the ASCII character set.)  In this case, as much of the string as possible
## will be converted to ASCII, and the nonconvertible characters will remain
## in their original form.

proc isWtext*(this: TextEncoder): bool {.importcpp: "#->is_wtext()".} ## \
## Returns true if any of the characters in the string returned by get_wtext()
## are out of the range of an ASCII character (and, therefore, get_wtext()
## should be called in preference to get_text()).

proc initFilename*(): Filename {.importcpp: "Filename()".} ## \
## Creates an empty Filename.

proc initFilename*(dirname: Filename, basename: Filename): Filename {.importcpp: "Filename(#, #)".} ## \
## This constructor composes the filename out of a directory part and a
## basename part.  It will insert an intervening '/' if necessary.

proc textFilename*(_: typedesc[Filename], filename: Filename): Filename {.importcpp: "#Filename::text_filename(#)", header: "filename.h".} ## \
## Static constructors to explicitly create a filename that refers to a text
## or binary file.  This is in lieu of calling set_text() or set_binary() or
## set_type().

proc textFilename*(_: typedesc[Filename], filename: string): Filename {.importcpp: "#Filename::text_filename(nimStringToStdString(#))", header: "filename.h".}

proc binaryFilename*(_: typedesc[Filename], filename: Filename): Filename {.importcpp: "#Filename::binary_filename(#)", header: "filename.h".}

proc binaryFilename*(_: typedesc[Filename], filename: string): Filename {.importcpp: "#Filename::binary_filename(nimStringToStdString(#))", header: "filename.h".}

proc dsoFilename*(_: typedesc[Filename], filename: string): Filename {.importcpp: "#Filename::dso_filename(nimStringToStdString(#))", header: "filename.h".}

proc executableFilename*(_: typedesc[Filename], filename: string): Filename {.importcpp: "#Filename::executable_filename(nimStringToStdString(#))", header: "filename.h".}

proc patternFilename*(_: typedesc[Filename], filename: string): Filename {.importcpp: "#Filename::pattern_filename(nimStringToStdString(#))", header: "filename.h".} ## \
## Constructs a filename that represents a sequence of numbered files.  See
## set_pattern().

proc fromOsSpecific*(_: typedesc[Filename], os_specific: string): Filename {.importcpp: "#Filename::from_os_specific(nimStringToStdString(#))", header: "filename.h".} ## \
## This named constructor returns a Panda-style filename (that is, using
## forward slashes, and no drive letter) based on the supplied filename string
## that describes a filename in the local system conventions (for instance, on
## Windows, it may use backslashes or begin with a drive letter and a colon).
##
## Use this function to create a Filename from an externally-given filename
## string.  Use to_os_specific() again later to reconvert it back to the local
## operating system's conventions.
##
## This function will do the right thing even if the filename is partially
## local conventions and partially Panda conventions; e.g.  some backslashes
## and some forward slashes.

proc fromOsSpecificW*(_: typedesc[Filename], os_specific: string): Filename {.importcpp: "#Filename::from_os_specific_w(nimStringToStdString(#))", header: "filename.h".} ## \
## The wide-string variant of from_os_specific(). Returns a new Filename,
## converted from an os-specific wide-character string.

proc expandFrom*(_: typedesc[Filename], user_string: string): Filename {.importcpp: "#Filename::expand_from(nimStringToStdString(#))", header: "filename.h".} ## \
## Returns the same thing as from_os_specific(), but embedded environment
## variable references (e.g.  "$DMODELS/foo.txt") are expanded out.  It also
## automatically elevates the file to its true case if needed.

proc temporary*(_: typedesc[Filename], dirname: string, prefix: string, suffix: string): Filename {.importcpp: "#Filename::temporary(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: "filename.h".} ## \
## Generates a temporary filename within the indicated directory, using the
## indicated prefix.  If the directory is empty, a system-defined directory is
## chosen instead.
##
## The generated filename did not exist when the Filename checked, but since
## it does not specifically create the file, it is possible that another
## process could simultaneously create a file by the same name.

proc temporary*(_: typedesc[Filename], dirname: string, prefix: string): Filename {.importcpp: "#Filename::temporary(nimStringToStdString(#), nimStringToStdString(#))", header: "filename.h".} ## \
## Generates a temporary filename within the indicated directory, using the
## indicated prefix.  If the directory is empty, a system-defined directory is
## chosen instead.
##
## The generated filename did not exist when the Filename checked, but since
## it does not specifically create the file, it is possible that another
## process could simultaneously create a file by the same name.

proc getHomeDirectory*(_: typedesc[Filename]): Filename {.importcpp: "Filename::get_home_directory()", header: "filename.h".} ## \
## Returns a path to the user's home directory, if such a thing makes sense in
## the current OS, or to the nearest equivalent.  This may or may not be
## directly writable by the application.

proc getTempDirectory*(_: typedesc[Filename]): Filename {.importcpp: "Filename::get_temp_directory()", header: "filename.h".} ## \
## Returns a path to a system-defined temporary directory.

proc getUserAppdataDirectory*(_: typedesc[Filename]): Filename {.importcpp: "Filename::get_user_appdata_directory()", header: "filename.h".} ## \
## Returns a path to a system-defined directory appropriate for creating a
## subdirectory for storing application-specific data, specific to the current
## user.

proc getCommonAppdataDirectory*(_: typedesc[Filename]): Filename {.importcpp: "Filename::get_common_appdata_directory()", header: "filename.h".} ## \
## Returns a path to a system-defined directory appropriate for creating a
## subdirectory for storing application-specific data, common to all users.

proc `typecast`*(this: Filename): string {.importcpp: "nimStringFromStdString(#.operator typecast())", header: stringConversionCode.} ## \
## And retrieval is by any of the classic string operations.

proc cStr*(this: Filename): string {.importcpp: "nimStringFromStdString(#.c_str())", header: stringConversionCode.}

proc empty*(this: Filename): bool {.importcpp: "#.empty()".}

proc length*(this: Filename): clonglong {.importcpp: "#.length()".}

proc `[]`*(this: Filename, n: clonglong): char {.importcpp: "#.operator [](#)".}

proc substr*(this: Filename, begin: clonglong): string {.importcpp: "nimStringFromStdString(#.substr(#))", header: stringConversionCode.}

proc substr*(this: Filename, begin: clonglong, `end`: clonglong): string {.importcpp: "nimStringFromStdString(#.substr(#, #))", header: stringConversionCode.}

proc `+=`*(this: var Filename, other: string): Filename {.importcpp: "#.operator +=(nimStringToStdString(#))", header: stringConversionCode.}

proc `+`*(this: Filename, other: string): Filename {.importcpp: "#.operator +(nimStringToStdString(#))", header: stringConversionCode.}

proc `/`*(this: Filename, other: Filename): Filename {.importcpp: "#.operator /(#)".}

proc getFullpath*(this: Filename): string {.importcpp: "nimStringFromStdString(#.get_fullpath())", header: stringConversionCode.} ## \
## Returns the entire filename: directory, basename, extension.  This is the
## same thing returned by the string typecast operator.

proc getFullpathW*(this: Filename): string {.importcpp: "nimStringFromStdString(#.get_fullpath_w())", header: stringConversionCode.} ## \
## Returns the entire filename as a wide-character string.

proc getDirname*(this: Filename): string {.importcpp: "nimStringFromStdString(#.get_dirname())", header: stringConversionCode.} ## \
## Returns the directory part of the filename.  This is everything in the
## filename up to, but not including the rightmost slash.

proc getBasename*(this: Filename): string {.importcpp: "nimStringFromStdString(#.get_basename())", header: stringConversionCode.} ## \
## Returns the basename part of the filename.  This is everything in the
## filename after the rightmost slash, including any extensions.

proc getFullpathWoExtension*(this: Filename): string {.importcpp: "nimStringFromStdString(#.get_fullpath_wo_extension())", header: stringConversionCode.} ## \
## Returns the full filename--directory and basename parts--except for the
## extension.

proc getBasenameWoExtension*(this: Filename): string {.importcpp: "nimStringFromStdString(#.get_basename_wo_extension())", header: stringConversionCode.} ## \
## Returns the basename part of the filename, without the file extension.

proc getExtension*(this: Filename): string {.importcpp: "nimStringFromStdString(#.get_extension())", header: stringConversionCode.} ## \
## Returns the file extension.  This is everything after the rightmost dot, if
## there is one, or the empty string if there is not.

proc setFullpath*(this: Filename, s: string) {.importcpp: "#.set_fullpath(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the entire filename: directory, basename, extension.  This can
## also be achieved with the assignment operator.

proc setDirname*(this: Filename, s: string) {.importcpp: "#.set_dirname(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the directory part of the filename.  This is everything in the
## filename up to, but not including the rightmost slash.

proc setBasename*(this: Filename, s: string) {.importcpp: "#.set_basename(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the basename part of the filename.  This is everything in the
## filename after the rightmost slash, including any extensions.

proc setFullpathWoExtension*(this: Filename, s: string) {.importcpp: "#.set_fullpath_wo_extension(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the full filename--directory and basename parts--except for the
## extension.

proc setBasenameWoExtension*(this: Filename, s: string) {.importcpp: "#.set_basename_wo_extension(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the basename part of the filename, without the file extension.

proc setExtension*(this: Filename, s: string) {.importcpp: "#.set_extension(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the file extension.  This is everything after the rightmost dot,
## if there is one, or the empty string if there is not.

proc setBinary*(this: Filename) {.importcpp: "#.set_binary()".} ## \
## Setting these flags appropriately is helpful when opening or searching
## for a file; it helps the Filename resolve OS-specific conventions (for
## instance, that dynamic library names should perhaps be changed from .so
## to .dll).

proc setText*(this: Filename) {.importcpp: "#.set_text()".} ## \
## Indicates that the filename represents a text file.  This is primarily
## relevant to the read_file() and write_file() methods, so they can set the
## appropriate flags to the OS.

proc isBinary*(this: Filename): bool {.importcpp: "#.is_binary()".} ## \
## Returns true if the Filename has been indicated to represent a binary file
## via a previous call to set_binary().  It is possible that neither
## is_binary() nor is_text() will be true, if neither set_binary() nor
## set_text() was ever called.

proc isText*(this: Filename): bool {.importcpp: "#.is_text()".} ## \
## Returns true if the Filename has been indicated to represent a text file
## via a previous call to set_text().  It is possible that neither is_binary()
## nor is_text() will be true, if neither set_binary() nor set_text() was ever
## called.

proc isBinaryOrText*(this: Filename): bool {.importcpp: "#.is_binary_or_text()".} ## \
## Returns true either is_binary() or is_text() is true; that is, that the
## filename has been specified as either binary or text.  If this is false,
## the filename has not been specified.

proc setPattern*(this: Filename, pattern: bool) {.importcpp: "#.set_pattern(#)".} ## \
## Sets the flag indicating whether this is a filename pattern.  When this is
## true, the filename is understood to be a placeholder for a numbered
## sequence of filename, such as an image sequence.  In this case, a sequence
## of one or more hash characters ("#") should appear in the filename string;
## these characters will be filled in with the corresponding number (or more)
## of digits representing the sequence number.  Sequence numbers always begin
## counting at 0.
##
## When this is true, methods like has_hash() and get_hash_to_end() and
## get_filename_index() may be called.  Methods like is_exists() will
## implicitly test for existance of filename sequence 0.

proc getPattern*(this: Filename): bool {.importcpp: "#.get_pattern()".} ## \
## Returns the flag indicating whether this is a filename pattern.  See
## set_pattern().

proc hasHash*(this: Filename): bool {.importcpp: "#.has_hash()".} ## \
## Returns true if the filename is indicated to be a filename pattern (that
## is, set_pattern(true) was called), and the filename pattern did include a
## sequence of hash marks, or false if it was not a filename pattern or did
## not include hash marks.  If this is true, then get_filename_index() will
## return a different filename each time.

proc getFilenameIndex*(this: Filename, index: int): Filename {.importcpp: "#.get_filename_index(#)".} ## \
## If the pattern flag is set for this Filename and the filename string
## actually includes a sequence of hash marks, then this returns a new
## Filename with the sequence of hash marks replaced by the indicated index
## number.
##
## If the pattern flag is not set for this Filename or it does not contain a
## sequence of hash marks, this quietly returns the original filename.

proc getHashToEnd*(this: Filename): string {.importcpp: "nimStringFromStdString(#.get_hash_to_end())", header: stringConversionCode.} ## \
## Returns the part of the filename beginning at the hash sequence (if any),
## and continuing to the end of the filename.

proc setHashToEnd*(this: Filename, s: string) {.importcpp: "#.set_hash_to_end(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the part of the filename from the beginning of the hash sequence
## to the end of the filename.

proc standardize*(this: Filename) {.importcpp: "#.standardize()".} ## \
## Converts the filename to standard form by replacing consecutive slashes
## with a single slash, removing a trailing slash if present, and backing up
## over .. sequences within the filename where possible.

proc isLocal*(this: Filename): bool {.importcpp: "#.is_local()".} ## \
## Returns true if the filename is local, e.g.  does not begin with a slash,
## or false if the filename is fully specified from the root.

proc isFullyQualified*(this: Filename): bool {.importcpp: "#.is_fully_qualified()".} ## \
## Returns true if the filename is fully qualified, e.g.  begins with a slash.
## This is almost, but not quite, the same thing as !is_local().  It's not
## exactly the same because a special case is made for filenames that begin
## with a single dot followed by a slash--these are considered to be fully
## qualified (they are explicitly relative to the current directory, and do
## not refer to a filename on a search path somewhere).

proc makeAbsolute*(this: Filename) {.importcpp: "#.make_absolute()".} ## \
## Converts the filename to a fully-qualified pathname from the root (if it is
## a relative pathname), and then standardizes it (see standardize()).
##
## This is sometimes a little problematic, since it may convert the file to
## its 'true' absolute pathname, which could be an ugly NFS-named file,
## irrespective of symbolic links (e.g.
## .automount/dimbo/root/usr2/fit/people/drose instead of /fit/people/drose);
## besides being ugly, filenames like this may not be consistent across
## multiple different platforms.

proc makeAbsolute*(this: Filename, start_directory: Filename) {.importcpp: "#.make_absolute(#)".} ## \
## Converts the filename to a fully-qualified filename from the root (if it is
## a relative filename), and then standardizes it (see standardize()).  This
## flavor accepts a specific starting directory that the filename is known to
## be relative to.

proc makeCanonical*(this: Filename): bool {.importcpp: "#.make_canonical()".} ## \
## Converts this filename to a canonical name by replacing the directory part
## with the fully-qualified directory part.  This is done by changing to that
## directory and calling getcwd().
##
## This has the effect of (a) converting relative paths to absolute paths (but
## see make_absolute() if this is the only effect you want), and (b) always
## resolving a given directory name to the same string, even if different
## symbolic links are traversed, and (c) changing nice symbolic-link paths
## like fit/people/drose to ugly NFS automounter names like
## hosts/dimbo/usr2/fit/people/drose.  This can be troubling, but sometimes
## this is exactly what you want, particularly if you're about to call
## make_relative_to() between two filenames.
##
## The return value is true if successful, or false on failure (usually
## because the directory name does not exist or cannot be chdir'ed into).

proc makeTrueCase*(this: Filename): bool {.importcpp: "#.make_true_case()".} ## \
## On a case-insensitive operating system (e.g.  Windows), this method looks
## up the file in the file system and resets the Filename to represent the
## actual case of the file as it exists on the disk.  The return value is true
## if the file exists and the conversion can be made, or false if there is
## some error.
##
## On a case-sensitive operating system, this method does nothing and always
## returns true.
##
## An empty filename is considered to exist in this case.

proc toOsSpecific*(this: Filename): string {.importcpp: "nimStringFromStdString(#.to_os_specific())", header: stringConversionCode.} ## \
## Converts the filename from our generic Unix-like convention (forward
## slashes starting with the root at '/') to the corresponding filename in the
## local operating system (slashes in the appropriate direction, starting with
## the root at C:\, for instance).  Returns the string representing the
## converted filename, but does not change the Filename itself.
##
## See also from_os_specific().

proc toOsSpecificW*(this: Filename): string {.importcpp: "nimStringFromStdString(#.to_os_specific_w())", header: stringConversionCode.} ## \
## The wide-string variant on to_os_specific().

proc toOsGeneric*(this: Filename): string {.importcpp: "nimStringFromStdString(#.to_os_generic())", header: stringConversionCode.} ## \
## This is similar to to_os_specific(), but it is designed to generate a
## filename that can be understood on as many platforms as possible.  Since
## Windows can usually understand a forward-slash-delimited filename, this
## means it does the same thing as to_os_specific(), but it uses forward
## slashes instead of backslashes.
##
## This method has a pretty limited use; it should generally be used for
## writing file references to a file that might be read on any operating
## system.

proc toOsShortName*(this: Filename): string {.importcpp: "nimStringFromStdString(#.to_os_short_name())", header: stringConversionCode.} ## \
## This works like to_os_generic(), but it returns the "short name" version of
## the filename, if it exists, or the original filename otherwise.
##
## On Windows platforms, this returns the 8.3 filename version of the given
## filename, if the file exists, and the same thing as to_os_specific()
## otherwise.  On non-Windows platforms, this always returns the same thing as
## to_os_specific().

proc toOsLongName*(this: Filename): string {.importcpp: "nimStringFromStdString(#.to_os_long_name())", header: stringConversionCode.} ## \
## This is the opposite of to_os_short_name(): it returns the "long name" of
## the filename, if the filename exists.  On non-Windows platforms, this
## returns the same thing as to_os_specific().

proc exists*(this: Filename): bool {.importcpp: "#.exists()".} ## \
## Returns true if the filename exists on the disk, false otherwise.  If the
## type is indicated to be executable, this also tests that the file has
## execute permission.

proc isRegularFile*(this: Filename): bool {.importcpp: "#.is_regular_file()".} ## \
## Returns true if the filename exists and is the name of a regular file (i.e.
## not a directory or device), false otherwise.

proc isWritable*(this: Filename): bool {.importcpp: "#.is_writable()".} ## \
## Returns true if the filename exists and is either a directory or a regular
## file that can be written to, or false otherwise.

proc isDirectory*(this: Filename): bool {.importcpp: "#.is_directory()".} ## \
## Returns true if the filename exists and is a directory name, false
## otherwise.

proc isExecutable*(this: Filename): bool {.importcpp: "#.is_executable()".} ## \
## Returns true if the filename exists and is executable

proc compareTimestamps*(this: Filename, other: Filename, this_missing_is_old: bool, other_missing_is_old: bool): int {.importcpp: "#.compare_timestamps(#, #, #)".} ## \
## Returns a number less than zero if the file named by this object is older
## than the given file, zero if they have the same timestamp, or greater than
## zero if this one is newer.
##
## If this_missing_is_old is true, it indicates that a missing file will be
## treated as if it were older than any other file; otherwise, a missing file
## will be treated as if it were newer than any other file.  Similarly for
## other_missing_is_old.

proc compareTimestamps*(this: Filename, other: Filename, this_missing_is_old: bool): int {.importcpp: "#.compare_timestamps(#, #)".} ## \
## Returns a number less than zero if the file named by this object is older
## than the given file, zero if they have the same timestamp, or greater than
## zero if this one is newer.
##
## If this_missing_is_old is true, it indicates that a missing file will be
## treated as if it were older than any other file; otherwise, a missing file
## will be treated as if it were newer than any other file.  Similarly for
## other_missing_is_old.

proc compareTimestamps*(this: Filename, other: Filename): int {.importcpp: "#.compare_timestamps(#)".} ## \
## Returns a number less than zero if the file named by this object is older
## than the given file, zero if they have the same timestamp, or greater than
## zero if this one is newer.
##
## If this_missing_is_old is true, it indicates that a missing file will be
## treated as if it were older than any other file; otherwise, a missing file
## will be treated as if it were newer than any other file.  Similarly for
## other_missing_is_old.

proc getTimestamp*(this: Filename): time_t.Time {.importcpp: "#.get_timestamp()".} ## \
## Returns a time_t value that represents the time the file was last modified,
## to within whatever precision the operating system records this information
## (on a Windows95 system, for instance, this may only be accurate to within 2
## seconds).
##
## If the timestamp cannot be determined, either because it is not supported
## by the operating system or because there is some error (such as file not
## found), returns 0.

proc getAccessTimestamp*(this: Filename): time_t.Time {.importcpp: "#.get_access_timestamp()".} ## \
## Returns a time_t value that represents the time the file was last accessed,
## if this information is available.  See also get_timestamp(), which returns
## the last modification time.

proc getFileSize*(this: Filename): clonglong {.importcpp: "#.get_file_size()".} ## \
## Returns the size of the file in bytes, or 0 if there is an error.

proc resolveFilename*(this: Filename, searchpath: DSearchPath, default_extension: string): bool {.importcpp: "#.resolve_filename(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Searches the given search path for the filename.  If it is found, updates
## the filename to the full pathname found and returns true; otherwise,
## returns false.

proc resolveFilename*(this: Filename, searchpath: DSearchPath): bool {.importcpp: "#.resolve_filename(#)".} ## \
## Searches the given search path for the filename.  If it is found, updates
## the filename to the full pathname found and returns true; otherwise,
## returns false.

proc makeRelativeTo*(this: Filename, directory: Filename, allow_backups: bool): bool {.importcpp: "#.make_relative_to(#, #)".} ## \
## Adjusts this filename, which must be a fully-specified pathname beginning
## with a slash, to make it a relative filename, relative to the fully-
## specified directory indicated (which must also begin with, and may or may
## not end with, a slash--a terminating slash is ignored).
##
## This only performs a string comparsion, so it may be wise to call
## make_canonical() on both filenames before calling make_relative_to().
##
## If allow_backups is false, the filename will only be adjusted to be made
## relative if it is already somewhere within or below the indicated
## directory.  If allow_backups is true, it will be adjusted in all cases,
## even if this requires putting a series of .. characters before the filename
## --unless it would have to back all the way up to the root.
##
## Returns true if the file was adjusted, false if it was not.

proc makeRelativeTo*(this: Filename, directory: Filename): bool {.importcpp: "#.make_relative_to(#)".} ## \
## Adjusts this filename, which must be a fully-specified pathname beginning
## with a slash, to make it a relative filename, relative to the fully-
## specified directory indicated (which must also begin with, and may or may
## not end with, a slash--a terminating slash is ignored).
##
## This only performs a string comparsion, so it may be wise to call
## make_canonical() on both filenames before calling make_relative_to().
##
## If allow_backups is false, the filename will only be adjusted to be made
## relative if it is already somewhere within or below the indicated
## directory.  If allow_backups is true, it will be adjusted in all cases,
## even if this requires putting a series of .. characters before the filename
## --unless it would have to back all the way up to the root.
##
## Returns true if the file was adjusted, false if it was not.

proc findOnSearchpath*(this: Filename, searchpath: DSearchPath): int {.importcpp: "#.find_on_searchpath(#)".} ## \
## Performs the reverse of the resolve_filename() operation: assuming that the
## current filename is fully-specified pathname (i.e.  beginning with '/'),
## look on the indicated search path for a directory under which the file can
## be found.  When found, adjust the Filename to be relative to the indicated
## directory name.
##
## Returns the index of the directory on the searchpath at which the file was
## found, or -1 if it was not found.

proc openRead*(this: Filename, stream: pifstream): bool {.importcpp: "#.open_read(#)".} ## \
## Opens the indicated pifstream for reading the file, if possible.  Returns
## true if successful, false otherwise.  This requires the setting of the
## set_text()/set_binary() flags to open the file appropriately as indicated;
## it is an error to call open_read() without first calling one of set_text()
## or set_binary().

proc openRead*(this: Filename, stream: ifstream): bool {.importcpp: "#.open_read(#)".} ## \
## Opens the indicated ifstream for reading the file, if possible.  Returns
## true if successful, false otherwise.  This requires the setting of the
## set_text()/set_binary() flags to open the file appropriately as indicated;
## it is an error to call open_read() without first calling one of set_text()
## or set_binary().

proc openWrite*(this: Filename, stream: pofstream, truncate: bool): bool {.importcpp: "#.open_write(#, #)".} ## \
## Opens the indicated pifstream for writing the file, if possible.  Returns
## true if successful, false otherwise.  This requires the setting of the
## set_text()/set_binary() flags to open the file appropriately as indicated;
## it is an error to call open_read() without first calling one of set_text()
## or set_binary().
##
## If truncate is true, the file is truncated to zero length upon opening it,
## if it already exists.  Otherwise, the file is kept at its original length.

proc openWrite*(this: Filename, stream: pofstream): bool {.importcpp: "#.open_write(#)".} ## \
## Opens the indicated pifstream for writing the file, if possible.  Returns
## true if successful, false otherwise.  This requires the setting of the
## set_text()/set_binary() flags to open the file appropriately as indicated;
## it is an error to call open_read() without first calling one of set_text()
## or set_binary().
##
## If truncate is true, the file is truncated to zero length upon opening it,
## if it already exists.  Otherwise, the file is kept at its original length.

proc openWrite*(this: Filename, stream: ofstream, truncate: bool): bool {.importcpp: "#.open_write(#, #)".} ## \
## Opens the indicated ifstream for writing the file, if possible.  Returns
## true if successful, false otherwise.  This requires the setting of the
## set_text()/set_binary() flags to open the file appropriately as indicated;
## it is an error to call open_read() without first calling one of set_text()
## or set_binary().
##
## If truncate is true, the file is truncated to zero length upon opening it,
## if it already exists.  Otherwise, the file is kept at its original length.

proc openWrite*(this: Filename, stream: ofstream): bool {.importcpp: "#.open_write(#)".} ## \
## Opens the indicated ifstream for writing the file, if possible.  Returns
## true if successful, false otherwise.  This requires the setting of the
## set_text()/set_binary() flags to open the file appropriately as indicated;
## it is an error to call open_read() without first calling one of set_text()
## or set_binary().
##
## If truncate is true, the file is truncated to zero length upon opening it,
## if it already exists.  Otherwise, the file is kept at its original length.

proc openAppend*(this: Filename, stream: pofstream): bool {.importcpp: "#.open_append(#)".} ## \
## Opens the indicated pifstream for writing the file, if possible.  Returns
## true if successful, false otherwise.  This requires the setting of the
## set_text()/set_binary() flags to open the file appropriately as indicated;
## it is an error to call open_read() without first calling one of set_text()
## or set_binary().

proc openAppend*(this: Filename, stream: ofstream): bool {.importcpp: "#.open_append(#)".} ## \
## Opens the indicated ofstream for writing the file, if possible.  Returns
## true if successful, false otherwise.  This requires the setting of the
## set_text()/set_binary() flags to open the file appropriately as indicated;
## it is an error to call open_read() without first calling one of set_text()
## or set_binary().

proc openReadWrite*(this: Filename, stream: pfstream, truncate: bool): bool {.importcpp: "#.open_read_write(#, #)".} ## \
## Opens the indicated fstream for read/write access to the file, if possible.
## Returns true if successful, false otherwise.  This requires the setting of
## the set_text()/set_binary() flags to open the file appropriately as
## indicated; it is an error to call open_read_write() without first calling
## one of set_text() or set_binary().

proc openReadWrite*(this: Filename, stream: pfstream): bool {.importcpp: "#.open_read_write(#)".} ## \
## Opens the indicated fstream for read/write access to the file, if possible.
## Returns true if successful, false otherwise.  This requires the setting of
## the set_text()/set_binary() flags to open the file appropriately as
## indicated; it is an error to call open_read_write() without first calling
## one of set_text() or set_binary().

proc openReadWrite*(this: Filename, stream: fstream, truncate: bool): bool {.importcpp: "#.open_read_write(#, #)".} ## \
## Opens the indicated fstream for read/write access to the file, if possible.
## Returns true if successful, false otherwise.  This requires the setting of
## the set_text()/set_binary() flags to open the file appropriately as
## indicated; it is an error to call open_read_write() without first calling
## one of set_text() or set_binary().

proc openReadWrite*(this: Filename, stream: fstream): bool {.importcpp: "#.open_read_write(#)".} ## \
## Opens the indicated fstream for read/write access to the file, if possible.
## Returns true if successful, false otherwise.  This requires the setting of
## the set_text()/set_binary() flags to open the file appropriately as
## indicated; it is an error to call open_read_write() without first calling
## one of set_text() or set_binary().

proc openReadAppend*(this: Filename, stream: pfstream): bool {.importcpp: "#.open_read_append(#)".} ## \
## Opens the indicated pfstream for reading and writing the file, if possible;
## writes are appended to the end of the file.  Returns true if successful,
## false otherwise.  This requires the setting of the set_text()/set_binary()
## flags to open the file appropriately as indicated; it is an error to call
## open_read() without first calling one of set_text() or set_binary().

proc openReadAppend*(this: Filename, stream: fstream): bool {.importcpp: "#.open_read_append(#)".} ## \
## Opens the indicated ifstream for reading and writing the file, if possible;
## writes are appended to the end of the file.  Returns true if successful,
## false otherwise.  This requires the setting of the set_text()/set_binary()
## flags to open the file appropriately as indicated; it is an error to call
## open_read() without first calling one of set_text() or set_binary().

proc chdir*(this: Filename): bool {.importcpp: "#.chdir()".} ## \
## Changes directory to the specified location.  Returns true if successful,
## false if failure.

proc touch*(this: Filename): bool {.importcpp: "#.touch()".} ## \
## Updates the modification time of the file to the current time.  If the file
## does not already exist, it will be created.  Returns true if successful,
## false if there is an error.

proc unlink*(this: Filename): bool {.importcpp: "#.unlink()".} ## \
## Permanently deletes the file associated with the filename, if possible.
## Returns true if successful, false if failure (for instance, because the
## file did not exist, or because permissions were inadequate).

proc renameTo*(this: Filename, other: Filename): bool {.importcpp: "#.rename_to(#)".} ## \
## Renames the file to the indicated new filename.  If the new filename is in
## a different directory, this will perform a move.  Returns true if
## successful, false on failure.

proc copyTo*(this: Filename, other: Filename): bool {.importcpp: "#.copy_to(#)".} ## \
## Copies the file to the indicated new filename, by reading the contents and
## writing it to the new file.  Returns true if successful, false on failure.
## The copy is always binary, regardless of the filename settings.

proc makeDir*(this: Filename): bool {.importcpp: "#.make_dir()".} ## \
## Creates all the directories in the path to the file specified in the
## filename, except for the basename itself.  This assumes that the Filename
## contains the name of a file, not a directory name; it ensures that the
## directory containing the file exists.
##
## However, if the filename ends in a slash, it assumes the Filename
## represents the name of a directory, and creates all the paths.

proc mkdir*(this: Filename): bool {.importcpp: "#.mkdir()".} ## \
## Creates the directory named by this filename.  Unlike make_dir(), this
## assumes that the Filename contains the directory name itself.  Also, parent
## directories are not automatically created; this function fails if any
## parent directory is missing.

proc rmdir*(this: Filename): bool {.importcpp: "#.rmdir()".} ## \
## The inverse of mkdir(): this removes the directory named by this Filename,
## if it is in fact a directory.

proc `==`*(this: Filename, other: string): bool {.importcpp: "#.operator ==(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Comparison operators are handy.

proc `!=`*(this: Filename, other: string): bool {.importcpp: "#.operator !=(nimStringToStdString(#))", header: stringConversionCode.}

proc `<`*(this: Filename, other: string): bool {.importcpp: "#.operator <(nimStringToStdString(#))", header: stringConversionCode.}

proc compareTo*(this: Filename, other: Filename): int {.importcpp: "#.compare_to(#)".}

proc getHash*(this: Filename): int {.importcpp: "#.get_hash()".} ## \
## Returns a hash code that attempts to be mostly unique for different
## Filenames.

proc output*(this: Filename, `out`: ostream) {.importcpp: "#.output(#)".}

converter getClassType*(_: typedesc[Filename]): TypeHandle {.importcpp: "Filename::get_class_type()", header: "filename.h".}

proc getVersionString*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_version_string())", header: "pandaSystem.h".} ## \
## Returns the current version of Panda, expressed as a string, e.g.  "1.0.0".
## The string will end in the letter "c" if this build does not represent an
## official version.

proc getPackageVersionString*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_package_version_string())", header: "pandaSystem.h".} ## \
## Returns the version of the Panda3D distributable package that provides this
## build of Panda.
##
## When the currently-executing version of Panda was loaded from a
## distributable package, such as via the browser plugin, then this string
## will be nonempty and will contain the corresponding version string.  You
## can build applications that use this particular version of Panda by
## requesting it in the pdef file, using "panda3d", this version string, and
## the download host provided by get_package_host_url().
##
## If this string is empty, then the currently-executing Panda was built
## independently, and is not part of a distributable package.
##
## This string is set explicitly at compilation time.  Normally, it should be
## set to a nonempty string only when building a Panda3D package for
## distribution.

proc getPackageHostUrl*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_package_host_url())", header: "pandaSystem.h".} ## \
## Returns the URL of the download server that provides the Panda3D
## distributable package currently running.  This can be used, along with the
## get_package_version_string(), to uniquely identify the running version of
## Panda among distributable Panda versions.
##
## See get_package_version_string() for more information.
##
## This string is set explicitly at compilation time.  Normally, it should be
## set to a nonempty string only when building a Panda3D package for
## distribution.

proc getP3dCoreapiVersionString*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_p3d_coreapi_version_string())", header: "pandaSystem.h".} ## \
## Returns the current version of Panda's Core API, expressed as a string of
## dot-delimited integers.  There are usually four integers in this version,
## but this is not guaranteed.
##
## The Core API is used during the runtime (plugin) environment only.  This
## may be the empty string if the current version of Panda is not built to
## provide a particular Core API, which will be the normal case in a
## development SDK.  However, you should not use this method to determine
## whether you are running in a runtime environment or not.

proc getMajorVersion*(_: typedesc[PandaSystem]): int {.importcpp: "PandaSystem::get_major_version()", header: "pandaSystem.h".} ## \
## Returns the major version number of the current version of Panda.  This is
## the first number of the dotted triple returned by get_version_string().  It
## changes very rarely.

proc getMinorVersion*(_: typedesc[PandaSystem]): int {.importcpp: "PandaSystem::get_minor_version()", header: "pandaSystem.h".} ## \
## Returns the minor version number of the current version of Panda.  This is
## the second number of the dotted triple returned by get_version_string().
## It changes with each release that introduces new features.

proc getSequenceVersion*(_: typedesc[PandaSystem]): int {.importcpp: "PandaSystem::get_sequence_version()", header: "pandaSystem.h".} ## \
## Returns the sequence version number of the current version of Panda.  This
## is the third number of the dotted triple returned by get_version_string().
## It changes with bugfix updates and very minor feature updates.

proc isOfficialVersion*(_: typedesc[PandaSystem]): bool {.importcpp: "PandaSystem::is_official_version()", header: "pandaSystem.h".} ## \
## Returns true if current version of Panda claims to be an "official"
## version, that is, one that was compiled by an official distributor of Panda
## using a specific version of the panda source tree.  If this is true, there
## will not be a "c" at the end of the version string returned by
## get_version_string().
##
## Note that we must take the distributor's word for it here.

proc getMemoryAlignment*(_: typedesc[PandaSystem]): int {.importcpp: "PandaSystem::get_memory_alignment()", header: "pandaSystem.h".} ## \
## Returns the memory alignment that Panda's allocators are using.

proc getDistributor*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_distributor())", header: "pandaSystem.h".} ## \
## Returns the string defined by the distributor of this version of Panda, or
## "homebuilt" if this version was built directly from the sources by the end-
## user.  This is a completely arbitrary string.

proc getCompiler*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_compiler())", header: "pandaSystem.h".} ## \
## Returns a string representing the compiler that was used to generate this
## version of Panda, if it is available, or "unknown" if it is not.

proc getBuildDate*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_build_date())", header: "pandaSystem.h".} ## \
## Returns a string representing the date and time at which this version of
## Panda (or at least dtool) was compiled, if available.

proc getGitCommit*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_git_commit())", header: "pandaSystem.h".} ## \
## Returns a string representing the git commit hash that this source tree is
## based on, or the empty string if it has not been specified at build time.

proc getPlatform*(_: typedesc[PandaSystem]): string {.importcpp: "nimStringFromStdString(PandaSystem::get_platform())", header: "pandaSystem.h".} ## \
## Returns a string representing the runtime platform that we are currently
## running on.  This will be something like "win32" or "osx_i386" or
## "linux_amd64".

proc hasSystem*(this: PandaSystem, system: string): bool {.importcpp: "#.has_system(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if the current version of Panda claims to have the indicated
## subsystem installed, false otherwise.  The set of available subsystems is
## implementation defined.

proc getNumSystems*(this: PandaSystem): clonglong {.importcpp: "#.get_num_systems()".} ## \
## Returns the number of Panda subsystems that have registered themselves.
## This can be used with get_system() to iterate through the entire list of
## available Panda subsystems.

proc getSystem*(this: PandaSystem, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_system(#))", header: stringConversionCode.} ## \
## Returns the nth Panda subsystem that has registered itself.  This list will
## be sorted in alphabetical order.

proc getSystemTag*(this: PandaSystem, system: string, tag: string): string {.importcpp: "nimStringFromStdString(#.get_system_tag(nimStringToStdString(#), nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Returns the value associated with the indicated tag for the given system.
## This provides a standard way to query each subsystem's advertised
## capabilities.  The set of tags and values are per-system and
## implementation-defined.
##
## The return value is the empty string if the indicated system is undefined
## or if does not define the indicated tag.

proc addSystem*(this: PandaSystem, system: string) {.importcpp: "#.add_system(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Intended for use by each subsystem to register itself at startup.

proc setSystemTag*(this: PandaSystem, system: string, tag: string, value: string) {.importcpp: "#.set_system_tag(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Intended for use by each subsystem to register its set of capabilities at
## startup.

proc heapTrim*(this: PandaSystem, pad: clonglong): bool {.importcpp: "#.heap_trim(#)".} ## \
## Attempts to release memory back to the system, if possible.  The pad
## argument is the minimum amount of unused memory to keep in the heap
## (against future allocations).  Any memory above that may be released to the
## system, reducing the memory size of this process.  There is no guarantee
## that any memory may be released.
##
## Returns true if any memory was actually released, false otherwise.

proc output*(this: PandaSystem, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: PandaSystem, `out`: ostream) {.importcpp: "#.write(#)".}

proc getGlobalPtr*(_: typedesc[PandaSystem]): PandaSystem {.importcpp: "PandaSystem::get_global_ptr()", header: "pandaSystem.h".} ## \
## Returns the global PandaSystem object.

converter getClassType*(_: typedesc[PandaSystem]): TypeHandle {.importcpp: "PandaSystem::get_class_type()", header: "pandaSystem.h".}

proc initDSearchPath*(): DSearchPath {.importcpp: "DSearchPath()".}

proc initDSearchPath*(copy: DSearchPath): DSearchPath {.importcpp: "DSearchPath(#)".}

converter initDSearchPath*(directory: Filename): DSearchPath {.importcpp: "DSearchPath(#)".}

proc initDSearchPath*(path: string, separator: string): DSearchPath {.importcpp: "DSearchPath(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

converter initDSearchPath*(path: string): DSearchPath {.importcpp: "DSearchPath(nimStringToStdString(#))", header: stringConversionCode.}

proc clear*(this: DSearchPath) {.importcpp: "#.clear()".} ## \
## Removes all the directories from the search list.

proc appendDirectory*(this: DSearchPath, directory: Filename) {.importcpp: "#.append_directory(#)".} ## \
## Adds a new directory to the end of the search list.

proc prependDirectory*(this: DSearchPath, directory: Filename) {.importcpp: "#.prepend_directory(#)".} ## \
## Adds a new directory to the front of the search list.

proc appendPath*(this: DSearchPath, path: DSearchPath) {.importcpp: "#.append_path(#)".} ## \
## Adds all of the directories listed in the search path to the end of the
## search list.

proc appendPath*(this: DSearchPath, path: string, separator: string) {.importcpp: "#.append_path(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds all of the directories listed in the search path to the end of the
## search list.

proc appendPath*(this: DSearchPath, path: string) {.importcpp: "#.append_path(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds all of the directories listed in the search path to the end of the
## search list.

proc prependPath*(this: DSearchPath, path: DSearchPath) {.importcpp: "#.prepend_path(#)".} ## \
## Adds all of the directories listed in the search path to the beginning of
## the search list.

proc isEmpty*(this: DSearchPath): bool {.importcpp: "#.is_empty()".} ## \
## Returns true if the search list is empty, false otherwise.

proc getNumDirectories*(this: DSearchPath): clonglong {.importcpp: "#.get_num_directories()".} ## \
## Returns the number of directories on the search list.

proc getDirectory*(this: DSearchPath, n: clonglong): Filename {.importcpp: "#.get_directory(#)".} ## \
## Returns the nth directory on the search list.

proc findFile*(this: DSearchPath, filename: Filename): Filename {.importcpp: "#.find_file(#)".} ## \
## Searches all the directories in the search list for the indicated file, in
## order.  Returns the full matching pathname of the first match if found, or
## the empty string if not found.

proc searchPath*(_: typedesc[DSearchPath], filename: Filename, path: string, separator: string): Filename {.importcpp: "#DSearchPath::search_path(#, nimStringToStdString(#), nimStringToStdString(#))", header: "dSearchPath.h".} ## \
## A quick-and-easy way to search a searchpath for a file when you don't feel
## like building or keeping around a DSearchPath object.  This simply
## constructs a temporary DSearchPath based on the indicated path string, and
## searches that.

proc searchPath*(_: typedesc[DSearchPath], filename: Filename, path: string): Filename {.importcpp: "#DSearchPath::search_path(#, nimStringToStdString(#))", header: "dSearchPath.h".} ## \
## A quick-and-easy way to search a searchpath for a file when you don't feel
## like building or keeping around a DSearchPath object.  This simply
## constructs a temporary DSearchPath based on the indicated path string, and
## searches that.

proc output*(this: DSearchPath, `out`: ostream, separator: string) {.importcpp: "#.output(#, nimStringToStdString(#))", header: stringConversionCode.}

proc output*(this: DSearchPath, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: DSearchPath, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: DSearchPath, `out`: ostream) {.importcpp: "#.write(#)".}

proc hasEnvironmentVariable*(_: typedesc[ExecutionEnvironment], `var`: string): bool {.importcpp: "#ExecutionEnvironment::has_environment_variable(nimStringToStdString(#))", header: "executionEnvironment.h".} ## \
## Returns true if the indicated environment variable is defined.

proc getEnvironmentVariable*(_: typedesc[ExecutionEnvironment], `var`: string): string {.importcpp: "nimStringFromStdString(#ExecutionEnvironment::get_environment_variable(nimStringToStdString(#)))", header: "executionEnvironment.h".} ## \
## Returns the definition of the indicated environment variable, or the empty
## string if the variable is undefined.

proc setEnvironmentVariable*(_: typedesc[ExecutionEnvironment], `var`: string, value: string) {.importcpp: "#ExecutionEnvironment::set_environment_variable(nimStringToStdString(#), nimStringToStdString(#))", header: "executionEnvironment.h".} ## \
## Changes the definition of the indicated environment variable.

proc shadowEnvironmentVariable*(_: typedesc[ExecutionEnvironment], `var`: string, value: string) {.importcpp: "#ExecutionEnvironment::shadow_environment_variable(nimStringToStdString(#), nimStringToStdString(#))", header: "executionEnvironment.h".} ## \
## Changes the apparent definition of the indicated environment variable by
## masking it within this class with a new value.  This does not change the
## actual environment variable, but future calls to get_environment_variable()
## will return this new value.

proc clearShadow*(_: typedesc[ExecutionEnvironment], `var`: string) {.importcpp: "#ExecutionEnvironment::clear_shadow(nimStringToStdString(#))", header: "executionEnvironment.h".} ## \
## Removes a value set by a previous call to shadow_environment_variable(),
## and lets the actual value of the variable show again.

proc expandString*(_: typedesc[ExecutionEnvironment], str: string): string {.importcpp: "nimStringFromStdString(#ExecutionEnvironment::expand_string(nimStringToStdString(#)))", header: "executionEnvironment.h".} ## \
## Reads the string, looking for environment variable names marked by a $.
## Expands all such variable names.  A repeated dollar sign ($$) is mapped to
## a single dollar sign.
##
## Returns the expanded string.

proc getNumArgs*(_: typedesc[ExecutionEnvironment]): clonglong {.importcpp: "ExecutionEnvironment::get_num_args()", header: "executionEnvironment.h".} ## \
## Returns the number of command-line arguments available, not counting arg 0,
## the binary name.

proc getArg*(_: typedesc[ExecutionEnvironment], n: clonglong): string {.importcpp: "nimStringFromStdString(#ExecutionEnvironment::get_arg(#))", header: "executionEnvironment.h".} ## \
## Returns the nth command-line argument.  The index n must be in the range [0
## .. get_num_args()).  The first parameter, n == 0, is the first actual
## parameter, not the binary name.

proc getBinaryName*(_: typedesc[ExecutionEnvironment]): string {.importcpp: "nimStringFromStdString(ExecutionEnvironment::get_binary_name())", header: "executionEnvironment.h".} ## \
## Returns the name of the binary executable that started this program, if it
## can be determined.

proc getDtoolName*(_: typedesc[ExecutionEnvironment]): string {.importcpp: "nimStringFromStdString(ExecutionEnvironment::get_dtool_name())", header: "executionEnvironment.h".} ## \
## Returns the name of the libdtool DLL that is used in this program, if it
## can be determined.

proc setBinaryName*(_: typedesc[ExecutionEnvironment], name: string) {.importcpp: "#ExecutionEnvironment::set_binary_name(nimStringToStdString(#))", header: "executionEnvironment.h".} ## \
## Do not use.

proc setDtoolName*(_: typedesc[ExecutionEnvironment], name: string) {.importcpp: "#ExecutionEnvironment::set_dtool_name(nimStringToStdString(#))", header: "executionEnvironment.h".} ## \
## Do not use.

proc getCwd*(_: typedesc[ExecutionEnvironment]): Filename {.importcpp: "ExecutionEnvironment::get_cwd()", header: "executionEnvironment.h".} ## \
## Returns the name of the current working directory.

proc initExecutionEnvironment*(param0: ExecutionEnvironment): ExecutionEnvironment {.importcpp: "ExecutionEnvironment(#)".}

proc initGlobPattern*(copy: GlobPattern): GlobPattern {.importcpp: "GlobPattern(#)".}

converter initGlobPattern*(pattern: string): GlobPattern {.importcpp: "GlobPattern(nimStringToStdString(#))", header: stringConversionCode.}

proc initGlobPattern*(): GlobPattern {.importcpp: "GlobPattern()".}

proc `==`*(this: GlobPattern, other: GlobPattern): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: GlobPattern, other: GlobPattern): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: GlobPattern, other: GlobPattern): bool {.importcpp: "#.operator <(#)".}

proc setPattern*(this: GlobPattern, pattern: string) {.importcpp: "#.set_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the pattern string that the GlobPattern object matches.

proc getPattern*(this: GlobPattern): string {.importcpp: "nimStringFromStdString(#.get_pattern())", header: stringConversionCode.} ## \
## Returns the pattern string that the GlobPattern object matches.

proc setCaseSensitive*(this: GlobPattern, case_sensitive: bool) {.importcpp: "#.set_case_sensitive(#)".} ## \
## Sets whether the match is case sensitive (true) or case insensitive
## (false).  The default is case sensitive.

proc getCaseSensitive*(this: GlobPattern): bool {.importcpp: "#.get_case_sensitive()".} ## \
## Returns whether the match is case sensitive (true) or case insensitive
## (false).  The default is case sensitive.

proc setNomatchChars*(this: GlobPattern, nomatch_chars: string) {.importcpp: "#.set_nomatch_chars(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies a set of characters that are not matched by \* or ?.

proc getNomatchChars*(this: GlobPattern): string {.importcpp: "nimStringFromStdString(#.get_nomatch_chars())", header: stringConversionCode.} ## \
## Returns the set of characters that are not matched by \* or ?.

proc matches*(this: GlobPattern, candidate: string): bool {.importcpp: "#.matches(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if the candidate string matches the pattern, false otherwise.

proc matchesFile*(this: GlobPattern, candidate: Filename): bool {.importcpp: "#.matches_file(#)".} ## \
## Treats the GlobPattern as a filename pattern, and returns true if the given
## filename matches the pattern.  Unlike matches(), this will not match slash
## characters for single asterisk characters, and it will ignore path
## components that only contain a dot.

proc output*(this: GlobPattern, `out`: ostream) {.importcpp: "#.output(#)".}

proc hasGlobCharacters*(this: GlobPattern): bool {.importcpp: "#.has_glob_characters()".} ## \
## Returns true if the pattern includes any special globbing characters, or
## false if it is just a literal string.

proc getConstPrefix*(this: GlobPattern): string {.importcpp: "nimStringFromStdString(#.get_const_prefix())", header: stringConversionCode.} ## \
## Returns the initial part of the pattern before the first glob character.
## Since many glob patterns begin with a sequence of static characters and end
## with one or more glob characters, this can be used to optimized searches
## through sorted indices.

proc initLineStream*(): LineStream {.importcpp: "LineStream()".}

proc isTextAvailable*(this: LineStream): bool {.importcpp: "#.is_text_available()".} ## \
## Returns true if there is at least one line of text (or even a partial line)
## available in the LineStream object.  If this returns true, the line may
## then be retrieved via get_line().

proc getLine*(this: LineStream): string {.importcpp: "nimStringFromStdString(#.get_line())", header: stringConversionCode.} ## \
## Extracts and returns the next line (or partial line) of text available in
## the LineStream object.  Once the line has been extracted, you may call
## has_newline() to determine whether or not there was an explicit newline
## character written following this line.

proc hasNewline*(this: LineStream): bool {.importcpp: "#.has_newline()".} ## \
## Returns true if the line of text most recently returned by get_line() was
## written out with a terminating newline, or false if a newline character has
## not yet been written to the LineStream.

proc initConfigFlags*(): ConfigFlags {.importcpp: "ConfigFlags()".}

proc initConfigFlags*(param0: ConfigFlags): ConfigFlags {.importcpp: "ConfigFlags(#)".}

proc getDefaultPage*(_: typedesc[ConfigPage]): ConfigPage {.importcpp: "ConfigPage::get_default_page()", header: "configPage.h".} ## \
## Returns a pointer to the global "default page".  This is the ConfigPage
## that lists all variables' original default values.

proc getLocalPage*(_: typedesc[ConfigPage]): ConfigPage {.importcpp: "ConfigPage::get_local_page()", header: "configPage.h".} ## \
## Returns a pointer to the global "local page".  This is the ConfigPage that
## lists the locally-assigned values for any variables in the world that have
## such a local assignment.

proc getName*(this: ConfigPage): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the page.  If the page was loaded from a .prc file,
## this is usually the filename.

proc isSpecial*(this: ConfigPage): bool {.importcpp: "#.is_special()".} ## \
## Returns true if this is the special "default" or "local" page, or false if
## it is an ordinary page, e.g.  an implicit page loaded from a prc file at
## startup, or an explicit page created by
## ConfigPageManager::make_explicit_page().

proc isImplicit*(this: ConfigPage): bool {.importcpp: "#.is_implicit()".} ## \
## Returns true if the page was loaded by implicitly searching the config path
## on startup, or false if it was explicitly loaded by dynamic code after
## initial startup.

proc setSort*(this: ConfigPage, sort: int) {.importcpp: "#.set_sort(#)".} ## \
## Changes the explicit sort order of this particular ConfigPage.  Lower-
## numbered pages supercede higher-numbered pages.  Initially, all explicitly-
## loaded pages have sort value 0, and implicitly-loaded pages (found on disk)
## have sort value 10; you may set an individual page higher or lower to
## influence its priority relative to other pages.

proc getSort*(this: ConfigPage): int {.importcpp: "#.get_sort()".} ## \
## Returns the explicit sort order of this particular ConfigPage.  See
## set_sort().

proc getPageSeq*(this: ConfigPage): int {.importcpp: "#.get_page_seq()".} ## \
## Returns the sequence number of the page.
##
## Sequence numbers for a particular class (implicit vs.  explicit) of pages
## are assigned as each page is loaded; each page is given a higher sequence
## number than all the pages loaded before it.
##
## The implicit_load pages, which are discovered in the file system
## automatically, have a different set of sequence numbers than the explicit
## pages.

proc getTrustLevel*(this: ConfigPage): int {.importcpp: "#.get_trust_level()".} ## \
## Returns the trust level associated with this page.  An untrusted page is
## trust level 0; if the page was loaded from a signed .prc file, its trust
## level is the index number of the certificate that signed it.  Generally, a
## higher trust level value represents a greater level of trust.

proc setTrustLevel*(this: ConfigPage, trust_level: int) {.importcpp: "#.set_trust_level(#)".} ## \
## Explicitly sets the trust level on this particular page.  Note that any
## subsequent changes to the page, or to any variable declarations on it, will
## reset the trust level to zero.

proc getSignature*(this: ConfigPage): string {.importcpp: "nimStringFromStdString(#.get_signature())", header: stringConversionCode.} ## \
## Returns the raw binary signature that was found in the prc file, if any.
## This method is probably not terribly useful for most applications.

proc clear*(this: ConfigPage) {.importcpp: "#.clear()".} ## \
## Removes all of the declarations from the page.

proc readPrc*(this: ConfigPage, `in`: istream): bool {.importcpp: "#.read_prc(#)".} ## \
## Reads the contents of a complete prc file, as returned by the indicated
## istream, into the current page file.  Returns true on success, or false on
## some I/O error.
##
## This is a low-level interface.  Normally you do not need to call it
## directly.  See the global functions load_prc_file() and unload_prc_file(),
## defined in panda/src/putil, for a higher-level interface.

proc readEncryptedPrc*(this: ConfigPage, `in`: istream, password: string): bool {.importcpp: "#.read_encrypted_prc(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Automatically decrypts and reads the stream, given the indicated password.
## Note that if the password is incorrect, the result may be garbage.

proc makeDeclaration*(this: ConfigPage, variable: ConfigVariableCore, value: string): ConfigDeclaration {.importcpp: "#.make_declaration(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds the indicated variable/value pair as a new declaration on the page.

proc makeDeclaration*(this: ConfigPage, variable: string, value: string): ConfigDeclaration {.importcpp: "#.make_declaration(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds the indicated variable/value pair as a new declaration on the page.

proc deleteDeclaration*(this: ConfigPage, decl: ConfigDeclaration): bool {.importcpp: "#.delete_declaration(#)".} ## \
## Removes the indicated declaration from the page and deletes it.  Returns
## true if the declaration is successfully removed, false if it was not on the
## page.

proc getNumDeclarations*(this: ConfigPage): clonglong {.importcpp: "#.get_num_declarations()".} ## \
## Returns the number of declarations on the page.

proc getDeclaration*(this: ConfigPage, n: clonglong): ConfigDeclaration {.importcpp: "#.get_declaration(#)".} ## \
## Returns the nth declaration on the page.

proc modifyDeclaration*(this: ConfigPage, n: clonglong): ConfigDeclaration {.importcpp: "#.modify_declaration(#)".} ## \
## Returns a modifiable pointer to the nth declaration on the page.  Any
## modifications will appear in the output, if the page is written out with
## ConfigPage::write().

proc getVariableName*(this: ConfigPage, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_variable_name(#))", header: stringConversionCode.} ## \
## Returns the variable named by the nth declaration on the page.

proc getStringValue*(this: ConfigPage, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_string_value(#))", header: stringConversionCode.} ## \
## Returns the value assigned by the nth declaration on the page.

proc isVariableUsed*(this: ConfigPage, n: clonglong): bool {.importcpp: "#.is_variable_used(#)".} ## \
## Returns true if the nth active variable on the page has been used by code,
## false otherwise.

proc getPage*(this: ConfigDeclaration): ConfigPage {.importcpp: "#.get_page()".} ## \
## Returns the page on which this declaration can be found.

proc getVariable*(this: ConfigDeclaration): ConfigVariableCore {.importcpp: "#.get_variable()".} ## \
## Returns the variable that this declaration names.  This variable may or may
## not have been defined by the time the declaration is read.

proc getName*(this: ConfigVariableCore): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the variable.

proc isUsed*(this: ConfigVariableCore): bool {.importcpp: "#.is_used()".} ## \
## Returns true if the variable has been referenced by a ConfigVariable
## somewhere in code, false otherwise.

proc getDescription*(this: ConfigVariableCore): string {.importcpp: "nimStringFromStdString(#.get_description())", header: stringConversionCode.} ## \
## Returns the brief description of this variable, if it has been defined.

proc getFlags*(this: ConfigVariableCore): int {.importcpp: "#.get_flags()".} ## \
## Returns the flags value as set by set_flags().  This includes the trust
## level and some other settings.  See the individual methods is_closed(),
## get_trust_level(), etc.  to pull out the semantic meaning of these flags
## individually.

proc isClosed*(this: ConfigVariableCore): bool {.importcpp: "#.is_closed()".} ## \
## Returns true if the variable is not trusted by any prc file (and hence
## cannot be modified from its compiled-in default value), or false for the
## normal case, in which the variable can be modified by any prc file at or
## above its trust level (see get_trust_level()).
##
## This value only has effect in a release build (specifically, when
## PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).

proc getTrustLevel*(this: ConfigVariableCore): int {.importcpp: "#.get_trust_level()".} ## \
## Returns the minimum trust_level a prc file must demonstrate in order to
## redefine the value for this variable.  Arguably, this should be called the
## "mistrust level", since the larger the value, the more suspicious we are of
## prc files.  This value is not used if is_closed() returns true, which
## indicates no file may be trusted.
##
## This value only has effect in a release build (specifically, when
## PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).

proc isDynamic*(this: ConfigVariableCore): bool {.importcpp: "#.is_dynamic()".} ## \
## Returns true if the variable was indicated as "dynamic" by its constructor,
## indicating that its name was dynamically generated, possibly from a large
## pool, and it should not be listed along with the other variables.

proc getDefaultValue*(this: ConfigVariableCore): ConfigDeclaration {.importcpp: "#.get_default_value()".} ## \
## Returns the default variable specified for this variable.  If the variable
## has not yet been defined, this will return NULL.

proc setFlags*(this: ConfigVariableCore, flags: int) {.importcpp: "#.set_flags(#)".} ## \
## Specifies the trust level of this variable.  See get_flags().  It is not an
## error to call this multiple times, but if the value changes once
## get_declaration() has been called, a warning is printed.

proc setDescription*(this: ConfigVariableCore, description: string) {.importcpp: "#.set_description(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the one-line description of this variable.  See
## get_description().  It is not an error to call this multiple times, but if
## the value changes once get_declaration() has been called, a warning is
## printed.

proc setDefaultValue*(this: ConfigVariableCore, default_value: string) {.importcpp: "#.set_default_value(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the default value for this variable if it is not defined in any
## prc file.

proc setUsed*(this: ConfigVariableCore) {.importcpp: "#.set_used()".} ## \
## Marks that the variable has been "declared" by a ConfigVariable.

proc makeLocalValue*(this: ConfigVariableCore): ConfigDeclaration {.importcpp: "#.make_local_value()".} ## \
## Creates a new local value for this variable, if there is not already one
## specified.  This will shadow any values defined in the various .prc files.
##
## If there is already a local value defined for this variable, simply returns
## that one.
##
## Use clear_local_value() to remove the local value definition.

proc clearLocalValue*(this: ConfigVariableCore): bool {.importcpp: "#.clear_local_value()".} ## \
## Removes the local value defined for this variable, and allows its value to
## be once again retrieved from the .prc files.
##
## Returns true if the value was successfully removed, false if it did not
## exist in the first place.

proc hasLocalValue*(this: ConfigVariableCore): bool {.importcpp: "#.has_local_value()".} ## \
## Returns true if this variable's value has been shadowed by a local
## assignment (as created via make_local_value()), or false otherwise.

proc hasValue*(this: ConfigVariableCore): bool {.importcpp: "#.has_value()".} ## \
## Returns true if this variable has an explicit value, either from a prc file
## or locally set, or false if variable has its default value.

proc getNumDeclarations*(this: ConfigVariableCore): clonglong {.importcpp: "#.get_num_declarations()".} ## \
## Returns the number of declarations that contribute to this variable's
## value.  If the variable has been defined, this will always be at least 1
## (for the default value, at least).

proc getDeclaration*(this: ConfigVariableCore, n: clonglong): ConfigDeclaration {.importcpp: "#.get_declaration(#)".} ## \
## Returns the nth declarations that contributes to this variable's value.
## The declarations are arranged in order such that earlier declarations
## shadow later declarations; thus, get_declaration(0) is always defined and
## always returns the current value of the variable.

proc getNumReferences*(this: ConfigVariableCore): clonglong {.importcpp: "#.get_num_references()".} ## \
## Returns the number of prc files that reference this variable.  This is not
## exactly the same as the number of declarations; see get_reference().

proc getReference*(this: ConfigVariableCore, n: clonglong): ConfigDeclaration {.importcpp: "#.get_reference(#)".} ## \
## Returns the nth declaration in a prc file that references this variable.
## This is similar, but not identical to, get_declaration().  The difference
## is that this will list \*only\* true references in a prc file, and will not
## list default values or locally-assigned values; it also will list even the
## untrusted files.

proc getNumTrustedReferences*(this: ConfigVariableCore): clonglong {.importcpp: "#.get_num_trusted_references()".} ## \
## Returns the number of trusted prc files that reference this variable.  See
## also get_num_references().

proc getTrustedReference*(this: ConfigVariableCore, n: clonglong): ConfigDeclaration {.importcpp: "#.get_trusted_reference(#)".} ## \
## Returns the nth declaration in a trusted prc file that references this
## variable.  This is similar, but not identical to, get_declaration().  The
## difference is that this will list \*only\* true references in a prc file, and
## will not list default values or locally-assigned values.
##
## This is also similar to get_reference(), except that it only lists the
## trusted declarations, omitting the untrusted ones.

proc getNumUniqueReferences*(this: ConfigVariableCore): clonglong {.importcpp: "#.get_num_unique_references()".} ## \
## Returns the number of trusted, unique (by string value) values there exist
## for this variable.

proc getUniqueReference*(this: ConfigVariableCore, n: clonglong): ConfigDeclaration {.importcpp: "#.get_unique_reference(#)".} ## \
## Returns the nth trusted, unique value for this variable.  This is similar
## to get_trusted_reference(), except that duplicate values are removed.

proc output*(this: ConfigVariableCore, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: ConfigVariableCore, `out`: ostream) {.importcpp: "#.write(#)".}

proc getStringValue*(this: ConfigDeclaration): string {.importcpp: "nimStringFromStdString(#.get_string_value())", header: stringConversionCode.} ## \
## Returns the value assigned to this variable.  This is the original one-line
## text defined for the variable in the .prc file (or passed to
## ConfigPage::make_declaration()).

proc setStringValue*(this: ConfigDeclaration, value: string) {.importcpp: "#.set_string_value(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the value assigned to this variable.

proc getNumWords*(this: ConfigDeclaration): clonglong {.importcpp: "#.get_num_words()".} ## \
## Returns the number of words in the declaration's value.  A word is defined
## as a sequence of non-whitespace characters delimited by whitespace.

proc hasStringWord*(this: ConfigDeclaration, n: clonglong): bool {.importcpp: "#.has_string_word(#)".} ## \
## Returns true if the declaration's value has a valid string value for the
## nth word.  This is really the same thing as asking if there are at least n
## words in the value.

proc hasBoolWord*(this: ConfigDeclaration, n: clonglong): bool {.importcpp: "#.has_bool_word(#)".} ## \
## Returns true if the declaration's value has a valid boolean value for the
## nth word.

proc hasIntWord*(this: ConfigDeclaration, n: clonglong): bool {.importcpp: "#.has_int_word(#)".} ## \
## Returns true if the declaration's value has a valid integer value for the
## nth word.

proc hasInt64Word*(this: ConfigDeclaration, n: clonglong): bool {.importcpp: "#.has_int64_word(#)".} ## \
## Returns true if the declaration's value has a valid int64 value for the nth
## word.

proc hasDoubleWord*(this: ConfigDeclaration, n: clonglong): bool {.importcpp: "#.has_double_word(#)".} ## \
## Returns true if the declaration's value has a valid integer value for the
## nth word.

proc getStringWord*(this: ConfigDeclaration, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_string_word(#))", header: stringConversionCode.} ## \
## Returns the string value of the nth word of the declaration's value, or
## empty string if there is no nth value.  See also has_string_word().

proc getBoolWord*(this: ConfigDeclaration, n: clonglong): bool {.importcpp: "#.get_bool_word(#)".} ## \
## Returns the boolean value of the nth word of the declaration's value, or
## false if there is no nth value.  See also has_bool_word().

proc getIntWord*(this: ConfigDeclaration, n: clonglong): int {.importcpp: "#.get_int_word(#)".} ## \
## Returns the integer value of the nth word of the declaration's value, or 0
## if there is no nth value.  See also has_int_word().

proc getInt64Word*(this: ConfigDeclaration, n: clonglong): clonglong {.importcpp: "#.get_int64_word(#)".} ## \
## Returns the int64 value of the nth word of the declaration's value, or 0 if
## there is no nth value.  See also has_int64_word().

proc getDoubleWord*(this: ConfigDeclaration, n: clonglong): float64 {.importcpp: "#.get_double_word(#)".} ## \
## Returns the integer value of the nth word of the declaration's value, or 0
## if there is no nth value.  See also has_double_word().

proc setStringWord*(this: ConfigDeclaration, n: clonglong, value: string) {.importcpp: "#.set_string_word(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the nth word to the indicated value without affecting the other
## words.

proc setBoolWord*(this: ConfigDeclaration, n: clonglong, value: bool) {.importcpp: "#.set_bool_word(#, #)".} ## \
## Changes the nth word to the indicated value without affecting the other
## words.

proc setIntWord*(this: ConfigDeclaration, n: clonglong, value: int) {.importcpp: "#.set_int_word(#, #)".} ## \
## Changes the nth word to the indicated value without affecting the other
## words.

proc setInt64Word*(this: ConfigDeclaration, n: clonglong, value: clonglong) {.importcpp: "#.set_int64_word(#, #)".} ## \
## Changes the nth word to the indicated value without affecting the other
## words.

proc setDoubleWord*(this: ConfigDeclaration, n: clonglong, value: float64) {.importcpp: "#.set_double_word(#, #)".} ## \
## Changes the nth word to the indicated value without affecting the other
## words.

proc getFilenameValue*(this: ConfigDeclaration): Filename {.importcpp: "#.get_filename_value()".} ## \
## Interprets the string value as a filename and returns it, with any
## variables expanded.

proc getDeclSeq*(this: ConfigDeclaration): int {.importcpp: "#.get_decl_seq()".} ## \
## Returns the sequence number of the declaration within the page.  Sequence
## numbers are assigned as each declaration is created; each declaration is
## given a higher sequence number than all the declarations created in the
## page before it.

proc output*(this: ConfigDeclaration, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: ConfigDeclaration, `out`: ostream) {.importcpp: "#.write(#)".}

proc output*(this: ConfigPage, `out`: ostream) {.importcpp: "#.output(#)".}

proc outputBriefSignature*(this: ConfigPage, `out`: ostream) {.importcpp: "#.output_brief_signature(#)".} ## \
## Outputs the first few hex digits of the signature.

proc write*(this: ConfigPage, `out`: ostream) {.importcpp: "#.write(#)".}

proc initNotify*(): Notify {.importcpp: "Notify()".}

proc initNotify*(param0: Notify): Notify {.importcpp: "Notify(#)".}

proc setOstreamPtr*(this: Notify, ostream_ptr: ostream, delete_later: bool) {.importcpp: "#.set_ostream_ptr(#, #)".} ## \
## Changes the ostream that all subsequent Notify messages will be written to.
## If the previous ostream was set with delete_later = true, this will delete
## the previous ostream.  If ostream_ptr is NULL, this resets the default to
## cerr.

proc getOstreamPtr*(this: Notify): ostream {.importcpp: "#.get_ostream_ptr()".} ## \
## Returns the system-wide ostream for all Notify messages.

proc clearAssertHandler*(this: Notify) {.importcpp: "#.clear_assert_handler()".} ## \
## Removes the installed assert handler and restores default behavior of
## nassertr() and nassertv().

proc hasAssertHandler*(this: Notify): bool {.importcpp: "#.has_assert_handler()".} ## \
## Returns true if a user assert handler has been installed, false otherwise.

proc getAssertHandler*(this: Notify) {.importcpp: "#.get_assert_handler()".} ## \
## Returns a pointer to the user-installed assert handler, if one was
## installed, or NULL otherwise.

proc hasAssertFailed*(this: Notify): bool {.importcpp: "#.has_assert_failed()".} ## \
## Returns true if an assertion test has failed (and not been ignored) since
## the last call to clear_assert_failed().
##
## When an assertion test fails, the assert handler may decide either to
## abort, return, or ignore the assertion.  Naturally, if it decides to abort,
## this flag is irrelevant.  If it chooses to ignore the assertion, the flag
## is not set.  However, if the assert handler chooses to return out of the
## function (the normal case), it will also set this flag to indicate that an
## assertion failure has occurred.
##
## This will also be the behavior in the absence of a user-defined assert
## handler.

proc getAssertErrorMessage*(this: Notify): string {.importcpp: "nimStringFromStdString(#.get_assert_error_message())", header: stringConversionCode.} ## \
## Returns the error message that corresponds to the assertion that most
## recently failed.

proc clearAssertFailed*(this: Notify) {.importcpp: "#.clear_assert_failed()".} ## \
## Resets the assert_failed flag that is set whenever an assertion test fails.
## See has_assert_failed().

proc getTopCategory*(this: Notify): NotifyCategory {.importcpp: "#.get_top_category()".} ## \
## Returns the topmost Category in the hierarchy.  This may be used to
## traverse the hierarchy of available Categories.

proc getCategory*(this: Notify, fullname: string): NotifyCategory {.importcpp: "#.get_category(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Finds or creates a new Category given the fullname of the Category.  This
## name should be a sequence of colon-separated names of parent Categories,
## ending in the basename of this Category, e.g.  display:glxdisplay.  This is
## a shorthand way to define a Category when a pointer to its parent is not
## handy.

proc getCategory*(this: Notify, basename: string, parent_category: NotifyCategory): NotifyCategory {.importcpp: "#.get_category(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Finds or creates a new Category given the basename of the category and its
## parent in the category hierarchy.  The parent pointer may be NULL to
## indicate this is a top-level Category.

proc getCategory*(this: Notify, basename: string, parent_fullname: string): NotifyCategory {.importcpp: "#.get_category(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Finds or creates a new Category given the basename of the category and the
## fullname of its parent.  This is another way to create a category when you
## don't have a pointer to its parent handy, but you know the name of its
## parent.  If the parent Category does not already exist, it will be created.

proc null*(_: typedesc[Notify]): ostream {.importcpp: "Notify::null()", header: "pnotify.h".} ## \
## A convenient way to get an ostream that doesn't do anything.  Returned by
## Category::out() when a particular Category and/or Severity is disabled.

proc writeString*(_: typedesc[Notify], str: string) {.importcpp: "#Notify::write_string(nimStringToStdString(#))", header: "pnotify.h".} ## \
## A convenient way for scripting languages, which may know nothing about
## ostreams, to write to Notify.  This writes a single string, followed by an
## implicit newline, to the Notify output stream.

proc loadedImplicitPages*(this: ConfigPageManager): bool {.importcpp: "#.loaded_implicit_pages()".} ## \
## Returns true if the implicit `\*.prc` files have already been loaded, false
## otherwise.  Normally this will only be false briefly before startup.

proc loadImplicitPages*(this: ConfigPageManager) {.importcpp: "#.load_implicit_pages()".} ## \
## Searches the PRC_DIR and/or PRC_PATH directories for `\*.prc` files and loads
## them in as pages.  This is normally called automatically at startup time,
## when the first variable's value is referenced.  See also
## reload_implicit_pages().

proc reloadImplicitPages*(this: ConfigPageManager) {.importcpp: "#.reload_implicit_pages()".} ## \
## Searches the PRC_DIR and/or PRC_PATH directories for \*.prc files and loads
## them in as pages.
##
## This may be called after startup, to force the system to re-read all of the
## implicit prc files.

proc getSearchPath*(this: ConfigPageManager): DSearchPath {.importcpp: "#.get_search_path()".} ## \
## Returns the search path used to locate implicit .prc files.  This is
## determined by the PRC_DIR and PRC_PATH environment variables.  The object
## returned by this method may be modified to change the path at runtime, and
## then reload_implicit_pages() called.

proc getNumPrcPatterns*(this: ConfigPageManager): clonglong {.importcpp: "#.get_num_prc_patterns()".} ## \
## Returns the number of patterns, like `\*.prc`, that are compiled in that
## will be searched for as default config filenames.  Normally there is only
## one pattern, and it is `\*.prc`, but others may be specified with the
## PRC_FILENAME variable in Config.pp.

proc getPrcPattern*(this: ConfigPageManager, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_prc_pattern(#))", header: stringConversionCode.} ## \
## Returns the nth filename pattern that will be considered a match as a valid
## config file.  See get_num_prc_patterns().

proc getNumPrcEncryptedPatterns*(this: ConfigPageManager): clonglong {.importcpp: "#.get_num_prc_encrypted_patterns()".} ## \
## Returns the number of patterns, like `\*.pre`, that are compiled in that
## will be searched for as special config files that are understood to be
## encrypted.

proc getPrcEncryptedPattern*(this: ConfigPageManager, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_prc_encrypted_pattern(#))", header: stringConversionCode.} ## \
## Returns the nth filename pattern that will be considered a match as a valid
## encrypted config file.  See get_num_prc_encrypted_patterns().

proc getNumPrcExecutablePatterns*(this: ConfigPageManager): clonglong {.importcpp: "#.get_num_prc_executable_patterns()".} ## \
## Returns the number of patterns, like `\*.exe`, that are compiled in that
## will be searched for as special config files that are to be executed as a
## program, and their output taken to be input.  This is normally empty.

proc getPrcExecutablePattern*(this: ConfigPageManager, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_prc_executable_pattern(#))", header: stringConversionCode.} ## \
## Returns the nth filename pattern that will be considered a match as a valid
## executable-style config file.  See get_num_prc_executable_patterns().

proc makeExplicitPage*(this: ConfigPageManager, name: string): ConfigPage {.importcpp: "#.make_explicit_page(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates and returns a new, empty ConfigPage.  This page will be stacked on
## top of any pages that were created before; it may shadow variable
## declarations that are defined in previous pages.

proc deleteExplicitPage*(this: ConfigPageManager, page: ConfigPage): bool {.importcpp: "#.delete_explicit_page(#)".} ## \
## Removes a previously-constructed ConfigPage from the set of active pages,
## and deletes it.  The ConfigPage object is no longer valid after this call.
## Returns true if the page is successfully deleted, or false if it was
## unknown (which should never happen if the page was legitimately
## constructed).

proc getNumImplicitPages*(this: ConfigPageManager): clonglong {.importcpp: "#.get_num_implicit_pages()".} ## \
## Returns the current number of implicitly-loaded ConfigPages in the world.
## These represent files that were automatically discovered on the disk as
## .prc files.

proc getImplicitPage*(this: ConfigPageManager, n: clonglong): ConfigPage {.importcpp: "#.get_implicit_page(#)".} ## \
## Returns the nth implicit ConfigPage in the world.  See
## get_num_implicit_pages().

proc getNumExplicitPages*(this: ConfigPageManager): clonglong {.importcpp: "#.get_num_explicit_pages()".} ## \
## Returns the current number of explicitly-loaded ConfigPages in the world.
## These represent pages that were loaded dynamically at runtime by explicit
## calls to ConfigPageManager::make_explicit_page().

proc getExplicitPage*(this: ConfigPageManager, n: clonglong): ConfigPage {.importcpp: "#.get_explicit_page(#)".} ## \
## Returns the nth explicit ConfigPage in the world.  See
## get_num_explicit_pages().

proc output*(this: ConfigPageManager, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: ConfigPageManager, `out`: ostream) {.importcpp: "#.write(#)".}

proc getGlobalPtr*(_: typedesc[ConfigPageManager]): ConfigPageManager {.importcpp: "ConfigPageManager::get_global_ptr()", header: "configPageManager.h".}

proc makeVariable*(this: ConfigVariableManager, name: string): ConfigVariableCore {.importcpp: "#.make_variable(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates and returns a new, undefined ConfigVariableCore with the indicated
## name; or if a variable with this name has already been created, returns
## that one instead.

proc getNumVariables*(this: ConfigVariableManager): clonglong {.importcpp: "#.get_num_variables()".} ## \
## Returns the current number of active ConfigVariableCores in the world.

proc getVariable*(this: ConfigVariableManager, n: clonglong): ConfigVariableCore {.importcpp: "#.get_variable(#)".} ## \
## Returns the nth active ConfigVariableCore in the world.

proc getVariableName*(this: ConfigVariableManager, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_variable_name(#))", header: stringConversionCode.} ## \
## Returns the name of the nth active ConfigVariable in the list.

proc isVariableUsed*(this: ConfigVariableManager, n: clonglong): bool {.importcpp: "#.is_variable_used(#)".} ## \
## Returns true if the nth active ConfigVariable in the list has been used by
## code, false otherwise.

proc output*(this: ConfigVariableManager, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: ConfigVariableManager, `out`: ostream) {.importcpp: "#.write(#)".}

proc writePrcVariables*(this: ConfigVariableManager, `out`: ostream) {.importcpp: "#.write_prc_variables(#)".} ## \
## Writes all of the prc-set config variables, as they appear in a prc file
## somewhere, one per line, very concisely.  This lists the dominant value in
## the prc file; it does not list shadowed values, and it does not list
## locally-set values.
##
## This is mainly intended for generating a hash of the input config file
## state.

proc listUnusedVariables*(this: ConfigVariableManager) {.importcpp: "#.list_unused_variables()".} ## \
## Writes a list of all the variables that have been defined in a prc file
## without having been declared somewhere in code.

proc listVariables*(this: ConfigVariableManager) {.importcpp: "#.list_variables()".} ## \
## Writes a list of all the variables that have been declared somewhere in
## code, along with a brief description.

proc listDynamicVariables*(this: ConfigVariableManager) {.importcpp: "#.list_dynamic_variables()".} ## \
## Writes a list of all the "dynamic" variables that have been declared
## somewhere in code, along with a brief description.  This is a (usually
## large) list of config variables that are declared with a generated variable
## name.

proc getGlobalPtr*(_: typedesc[ConfigVariableManager]): ConfigVariableManager {.importcpp: "ConfigVariableManager::get_global_ptr()", header: "configVariableManager.h".}

proc getName*(this: ConfigVariableBase): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the variable.

proc getDescription*(this: ConfigVariableBase): string {.importcpp: "nimStringFromStdString(#.get_description())", header: stringConversionCode.} ## \
## Returns the brief description of this variable, if it has been defined.

proc getFlags*(this: ConfigVariableBase): int {.importcpp: "#.get_flags()".} ## \
## Returns the flags value as set by set_flags().  This includes the trust
## level and some other settings.  See the individual methods is_closed(),
## get_trust_level(), etc.  to pull out the semantic meaning of these flags
## individually.

proc isClosed*(this: ConfigVariableBase): bool {.importcpp: "#.is_closed()".} ## \
## Returns true if the variable is not trusted by any prc file (and hence
## cannot be modified from its compiled-in default value), or false for the
## normal case, in which the variable can be modified by any prc file at or
## above its trust level (see get_trust_level()).
##
## This value only has effect in a release build (specifically, when
## PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).

proc getTrustLevel*(this: ConfigVariableBase): int {.importcpp: "#.get_trust_level()".} ## \
## Returns the minimum trust_level a prc file must demonstrate in order to
## redefine the value for this variable.  Arguably, this should be called the
## "mistrust level", since the larger the value, the more suspicious we are of
## prc files.  This value is not used if is_closed() returns true, which
## indicates no file may be trusted.
##
## This value only has effect in a release build (specifically, when
## PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).

proc isDynamic*(this: ConfigVariableBase): bool {.importcpp: "#.is_dynamic()".} ## \
## Returns true if the variable was indicated as "dynamic" by its constructor,
## indicating that its name was dynamically generated, possibly from a large
## pool, and it should not be listed along with the other variables.

proc clearLocalValue*(this: ConfigVariableBase): bool {.importcpp: "#.clear_local_value()".} ## \
## Removes the local value defined for this variable, and allows its value to
## be once again retrieved from the .prc files.
##
## Returns true if the value was successfully removed, false if it did not
## exist in the first place.

proc hasLocalValue*(this: ConfigVariableBase): bool {.importcpp: "#.has_local_value()".} ## \
## Returns true if this variable's value has been shadowed by a local
## assignment (as created via make_local_value()), or false otherwise.

proc hasValue*(this: ConfigVariableBase): bool {.importcpp: "#.has_value()".} ## \
## Returns true if this variable has an explicit value, either from a prc file
## or locally set, or false if variable has its default value.

proc output*(this: ConfigVariableBase, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: ConfigVariableBase, `out`: ostream) {.importcpp: "#.write(#)".}

proc initConfigVariable*(param0: ConfigVariable): ConfigVariable {.importcpp: "ConfigVariable(#)".}

proc initConfigVariable*(name: string): ConfigVariable {.importcpp: "ConfigVariable(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Use this constructor to make a ConfigVariable of an unspecified type.
## Usually you'd want to do this just to reference a previously-defined
## ConfigVariable of a specific type, without having to know what type it is.

proc getStringValue*(this: ConfigVariable): string {.importcpp: "nimStringFromStdString(#.get_string_value())", header: stringConversionCode.} ## \
## Returns the toplevel value of the variable, formatted as a string.

proc setStringValue*(this: ConfigVariable, value: string) {.importcpp: "#.set_string_value(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the value assigned to this variable.  This creates a local value
## that shadows any values defined in the .prc files, until
## clear_local_value() is called.

proc clearValue*(this: ConfigVariable) {.importcpp: "#.clear_value()".} ## \
## Removes the value assigned to this variable, and lets its original value
## (as read from the prc files) show through.

proc getNumWords*(this: ConfigVariable): clonglong {.importcpp: "#.get_num_words()".} ## \
## Returns the number of words in the variable's value.  A word is defined as
## a sequence of non-whitespace characters delimited by whitespace.

proc initConfigVariableBool*(param0: ConfigVariableBool): ConfigVariableBool {.importcpp: "ConfigVariableBool(#)".}

proc initConfigVariableBool*(name: string): ConfigVariableBool {.importcpp: "ConfigVariableBool(nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableBool*(name: string, default_value: bool, description: string, flags: int): ConfigVariableBool {.importcpp: "ConfigVariableBool(nimStringToStdString(#), #, nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableBool*(name: string, default_value: bool, description: string): ConfigVariableBool {.importcpp: "ConfigVariableBool(nimStringToStdString(#), #, nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableBool*(name: string, default_value: bool): ConfigVariableBool {.importcpp: "ConfigVariableBool(nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableBool*(name: string, default_value: string, description: string, flags: int): ConfigVariableBool {.importcpp: "ConfigVariableBool(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableBool*(name: string, default_value: string, description: string): ConfigVariableBool {.importcpp: "ConfigVariableBool(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableBool*(name: string, default_value: string): ConfigVariableBool {.importcpp: "ConfigVariableBool(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc `typecast bool`*(this: ConfigVariableBool): bool {.importcpp: "#.operator typecast bool()".}

proc size*(this: ConfigVariableBool): clonglong {.importcpp: "#.size()".} ## \
## Returns the number of unique words in the variable.

proc `[]`*(this: ConfigVariableBool, n: clonglong): bool {.importcpp: "#.operator [](#)".}

proc setValue*(this: ConfigVariableBool, value: bool) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

proc getValue*(this: ConfigVariableBool): bool {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc getDefaultValue*(this: ConfigVariableBool): bool {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

proc getWord*(this: ConfigVariableBool, n: clonglong): bool {.importcpp: "#.get_word(#)".} ## \
## Returns the variable's nth value.

proc setWord*(this: ConfigVariableBool, n: clonglong, value: bool) {.importcpp: "#.set_word(#, #)".} ## \
## Reassigns the variable's nth value.  This makes a local copy of the
## variable's overall value.

proc initConfigVariableDouble*(param0: ConfigVariableDouble): ConfigVariableDouble {.importcpp: "ConfigVariableDouble(#)".}

proc initConfigVariableDouble*(name: string): ConfigVariableDouble {.importcpp: "ConfigVariableDouble(nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableDouble*(name: string, default_value: float64, description: string, flags: int): ConfigVariableDouble {.importcpp: "ConfigVariableDouble(nimStringToStdString(#), #, nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableDouble*(name: string, default_value: float64, description: string): ConfigVariableDouble {.importcpp: "ConfigVariableDouble(nimStringToStdString(#), #, nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableDouble*(name: string, default_value: float64): ConfigVariableDouble {.importcpp: "ConfigVariableDouble(nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableDouble*(name: string, default_value: string, description: string, flags: int): ConfigVariableDouble {.importcpp: "ConfigVariableDouble(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableDouble*(name: string, default_value: string, description: string): ConfigVariableDouble {.importcpp: "ConfigVariableDouble(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableDouble*(name: string, default_value: string): ConfigVariableDouble {.importcpp: "ConfigVariableDouble(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc `typecast double`*(this: ConfigVariableDouble): float64 {.importcpp: "#.operator typecast double()".}

proc size*(this: ConfigVariableDouble): clonglong {.importcpp: "#.size()".} ## \
## Returns the number of unique words in the variable.

proc `[]`*(this: ConfigVariableDouble, n: clonglong): float64 {.importcpp: "#.operator [](#)".}

proc setValue*(this: ConfigVariableDouble, value: float64) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

proc getValue*(this: ConfigVariableDouble): float64 {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc getDefaultValue*(this: ConfigVariableDouble): float64 {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

proc getWord*(this: ConfigVariableDouble, n: clonglong): float64 {.importcpp: "#.get_word(#)".} ## \
## Returns the variable's nth value.

proc setWord*(this: ConfigVariableDouble, n: clonglong, value: float64) {.importcpp: "#.set_word(#, #)".} ## \
## Reassigns the variable's nth value.  This makes a local copy of the
## variable's overall value.

proc initConfigVariableFilename*(param0: ConfigVariableFilename): ConfigVariableFilename {.importcpp: "ConfigVariableFilename(#)".}

proc initConfigVariableFilename*(name: string): ConfigVariableFilename {.importcpp: "ConfigVariableFilename(nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableFilename*(name: string, default_value: Filename, description: string, flags: int): ConfigVariableFilename {.importcpp: "ConfigVariableFilename(nimStringToStdString(#), #, nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableFilename*(name: string, default_value: Filename, description: string): ConfigVariableFilename {.importcpp: "ConfigVariableFilename(nimStringToStdString(#), #, nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableFilename*(name: string, default_value: Filename): ConfigVariableFilename {.importcpp: "ConfigVariableFilename(nimStringToStdString(#), #)", header: stringConversionCode.}

proc `typecast`*(this: ConfigVariableFilename): Filename {.importcpp: "#.operator typecast()".}

proc cStr*(this: ConfigVariableFilename): string {.importcpp: "nimStringFromStdString(#.c_str())", header: stringConversionCode.} ## \
## These methods help the ConfigVariableFilename act like a Filename object.

proc empty*(this: ConfigVariableFilename): bool {.importcpp: "#.empty()".}

proc length*(this: ConfigVariableFilename): clonglong {.importcpp: "#.length()".}

proc `[]`*(this: ConfigVariableFilename, n: clonglong): char {.importcpp: "#.operator [](#)".}

proc getFullpath*(this: ConfigVariableFilename): string {.importcpp: "nimStringFromStdString(#.get_fullpath())", header: stringConversionCode.} ## \
## Returns the entire filename: directory, basename, extension.  This is the
## same thing returned by the string typecast operator, so this function is a
## little redundant.

proc getDirname*(this: ConfigVariableFilename): string {.importcpp: "nimStringFromStdString(#.get_dirname())", header: stringConversionCode.} ## \
## Returns the directory part of the filename.  This is everything in the
## filename up to, but not including the rightmost slash.

proc getBasename*(this: ConfigVariableFilename): string {.importcpp: "nimStringFromStdString(#.get_basename())", header: stringConversionCode.} ## \
## Returns the basename part of the filename.  This is everything in the
## filename after the rightmost slash, including any extensions.

proc getFullpathWoExtension*(this: ConfigVariableFilename): string {.importcpp: "nimStringFromStdString(#.get_fullpath_wo_extension())", header: stringConversionCode.} ## \
## Returns the full filename--directory and basename parts--except for the
## extension.

proc getBasenameWoExtension*(this: ConfigVariableFilename): string {.importcpp: "nimStringFromStdString(#.get_basename_wo_extension())", header: stringConversionCode.} ## \
## Returns the basename part of the filename, without the file extension.

proc getExtension*(this: ConfigVariableFilename): string {.importcpp: "nimStringFromStdString(#.get_extension())", header: stringConversionCode.} ## \
## Returns the file extension.  This is everything after the rightmost dot, if
## there is one, or the empty string if there is not.

proc `==`*(this: ConfigVariableFilename, other: Filename): bool {.importcpp: "#.operator ==(#)".} ## \
## Comparison operators are handy.

proc `!=`*(this: ConfigVariableFilename, other: Filename): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: ConfigVariableFilename, other: Filename): bool {.importcpp: "#.operator <(#)".}

proc setValue*(this: ConfigVariableFilename, value: Filename) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

proc getValue*(this: ConfigVariableFilename): Filename {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc getDefaultValue*(this: ConfigVariableFilename): Filename {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

proc getWord*(this: ConfigVariableFilename, n: clonglong): Filename {.importcpp: "#.get_word(#)".} ## \
## Returns the variable's nth value.

proc setWord*(this: ConfigVariableFilename, n: clonglong, value: Filename) {.importcpp: "#.set_word(#, #)".} ## \
## Reassigns the variable's nth value.  This makes a local copy of the
## variable's overall value.

proc initConfigVariableInt*(param0: ConfigVariableInt): ConfigVariableInt {.importcpp: "ConfigVariableInt(#)".}

proc initConfigVariableInt*(name: string): ConfigVariableInt {.importcpp: "ConfigVariableInt(nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableInt*(name: string, default_value: int, description: string, flags: int): ConfigVariableInt {.importcpp: "ConfigVariableInt(nimStringToStdString(#), #, nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableInt*(name: string, default_value: int, description: string): ConfigVariableInt {.importcpp: "ConfigVariableInt(nimStringToStdString(#), #, nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableInt*(name: string, default_value: int): ConfigVariableInt {.importcpp: "ConfigVariableInt(nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableInt*(name: string, default_value: string, description: string, flags: int): ConfigVariableInt {.importcpp: "ConfigVariableInt(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableInt*(name: string, default_value: string, description: string): ConfigVariableInt {.importcpp: "ConfigVariableInt(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableInt*(name: string, default_value: string): ConfigVariableInt {.importcpp: "ConfigVariableInt(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc `typecast int`*(this: ConfigVariableInt): int {.importcpp: "#.operator typecast int()".}

proc size*(this: ConfigVariableInt): clonglong {.importcpp: "#.size()".} ## \
## Returns the number of unique words in the variable.

proc `[]`*(this: ConfigVariableInt, n: clonglong): int {.importcpp: "#.operator [](#)".}

proc setValue*(this: ConfigVariableInt, value: int) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

proc getValue*(this: ConfigVariableInt): int {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc getDefaultValue*(this: ConfigVariableInt): int {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

proc getWord*(this: ConfigVariableInt, n: clonglong): int {.importcpp: "#.get_word(#)".} ## \
## Returns the variable's nth value.

proc setWord*(this: ConfigVariableInt, n: clonglong, value: int) {.importcpp: "#.set_word(#, #)".} ## \
## Reassigns the variable's nth value.  This makes a local copy of the
## variable's overall value.

proc initConfigVariableInt64*(param0: ConfigVariableInt64): ConfigVariableInt64 {.importcpp: "ConfigVariableInt64(#)".}

proc initConfigVariableInt64*(name: string): ConfigVariableInt64 {.importcpp: "ConfigVariableInt64(nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableInt64*(name: string, default_value: clonglong, description: string, flags: int): ConfigVariableInt64 {.importcpp: "ConfigVariableInt64(nimStringToStdString(#), #, nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableInt64*(name: string, default_value: clonglong, description: string): ConfigVariableInt64 {.importcpp: "ConfigVariableInt64(nimStringToStdString(#), #, nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableInt64*(name: string, default_value: clonglong): ConfigVariableInt64 {.importcpp: "ConfigVariableInt64(nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableInt64*(name: string, default_value: string, description: string, flags: int): ConfigVariableInt64 {.importcpp: "ConfigVariableInt64(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableInt64*(name: string, default_value: string, description: string): ConfigVariableInt64 {.importcpp: "ConfigVariableInt64(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableInt64*(name: string, default_value: string): ConfigVariableInt64 {.importcpp: "ConfigVariableInt64(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc `typecast int64_t`*(this: ConfigVariableInt64): clonglong {.importcpp: "#.operator typecast int64_t()".}

proc size*(this: ConfigVariableInt64): clonglong {.importcpp: "#.size()".} ## \
## Returns the number of unique words in the variable.

proc `[]`*(this: ConfigVariableInt64, n: clonglong): clonglong {.importcpp: "#.operator [](#)".}

proc setValue*(this: ConfigVariableInt64, value: clonglong) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

proc getValue*(this: ConfigVariableInt64): clonglong {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc getDefaultValue*(this: ConfigVariableInt64): clonglong {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

proc getWord*(this: ConfigVariableInt64, n: clonglong): clonglong {.importcpp: "#.get_word(#)".} ## \
## Returns the variable's nth value.

proc setWord*(this: ConfigVariableInt64, n: clonglong, value: clonglong) {.importcpp: "#.set_word(#, #)".} ## \
## Reassigns the variable's nth value.  This makes a local copy of the
## variable's overall value.

proc initConfigVariableList*(param0: ConfigVariableList): ConfigVariableList {.importcpp: "ConfigVariableList(#)".}

proc initConfigVariableList*(name: string, description: string, flags: int): ConfigVariableList {.importcpp: "ConfigVariableList(nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableList*(name: string, description: string): ConfigVariableList {.importcpp: "ConfigVariableList(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableList*(name: string): ConfigVariableList {.importcpp: "ConfigVariableList(nimStringToStdString(#))", header: stringConversionCode.}

proc getNumValues*(this: ConfigVariableList): clonglong {.importcpp: "#.get_num_values()".} ## \
## Returns the number of values in the variable.

proc getStringValue*(this: ConfigVariableList, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_string_value(#))", header: stringConversionCode.} ## \
## Returns the nth value of the variable.

proc getNumUniqueValues*(this: ConfigVariableList): clonglong {.importcpp: "#.get_num_unique_values()".} ## \
## Returns the number of unique values in the variable.

proc getUniqueValue*(this: ConfigVariableList, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_unique_value(#))", header: stringConversionCode.} ## \
## Returns the nth unique value of the variable.

proc size*(this: ConfigVariableList): clonglong {.importcpp: "#.size()".} ## \
## Returns the number of unique values of the variable.

proc `[]`*(this: ConfigVariableList, n: clonglong): string {.importcpp: "nimStringFromStdString(#.operator [](#))", header: stringConversionCode.}

proc output*(this: ConfigVariableList, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: ConfigVariableList, `out`: ostream) {.importcpp: "#.write(#)".}

proc initConfigVariableSearchPath*(name: string, default_value: DSearchPath, description: string, flags: int): ConfigVariableSearchPath {.importcpp: "ConfigVariableSearchPath(nimStringToStdString(#), #, nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableSearchPath*(name: string, default_value: DSearchPath, description: string): ConfigVariableSearchPath {.importcpp: "ConfigVariableSearchPath(nimStringToStdString(#), #, nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableSearchPath*(name: string, description: string, flags: int): ConfigVariableSearchPath {.importcpp: "ConfigVariableSearchPath(nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableSearchPath*(name: string, description: string): ConfigVariableSearchPath {.importcpp: "ConfigVariableSearchPath(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableSearchPath*(name: string): ConfigVariableSearchPath {.importcpp: "ConfigVariableSearchPath(nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableSearchPath*(name: string, default_value: string, description: string, flags: int): ConfigVariableSearchPath {.importcpp: "ConfigVariableSearchPath(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableSearchPath*(name: string, default_value: string, description: string): ConfigVariableSearchPath {.importcpp: "ConfigVariableSearchPath(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc `typecast DSearchPath`*(this: ConfigVariableSearchPath): DSearchPath {.importcpp: "#.operator typecast DSearchPath()".}

proc getValue*(this: ConfigVariableSearchPath): DSearchPath {.importcpp: "#.get_value()".}

proc getDefaultValue*(this: ConfigVariableSearchPath): DSearchPath {.importcpp: "#.get_default_value()".}

proc clearLocalValue*(this: ConfigVariableSearchPath): bool {.importcpp: "#.clear_local_value()".} ## \
## Removes all the directories locally added to the search list, and restores
## it to its original form.

proc clear*(this: ConfigVariableSearchPath) {.importcpp: "#.clear()".} ## \
## Removes all the directories locally added to the search list, and restores
## it to its original form.

proc appendDirectory*(this: ConfigVariableSearchPath, directory: Filename) {.importcpp: "#.append_directory(#)".} ## \
## Adds a new directory to the end of the search list.

proc prependDirectory*(this: ConfigVariableSearchPath, directory: Filename) {.importcpp: "#.prepend_directory(#)".} ## \
## Adds a new directory to the front of the search list.

proc appendPath*(this: ConfigVariableSearchPath, path: DSearchPath) {.importcpp: "#.append_path(#)".} ## \
## Adds all of the directories listed in the search path to the end of the
## search list.

proc appendPath*(this: ConfigVariableSearchPath, path: string, separator: string) {.importcpp: "#.append_path(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds all of the directories listed in the search path to the end of the
## search list.

proc appendPath*(this: ConfigVariableSearchPath, path: string) {.importcpp: "#.append_path(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds all of the directories listed in the search path to the end of the
## search list.

proc prependPath*(this: ConfigVariableSearchPath, path: DSearchPath) {.importcpp: "#.prepend_path(#)".} ## \
## Adds all of the directories listed in the search path to the beginning of
## the search list.

proc isEmpty*(this: ConfigVariableSearchPath): bool {.importcpp: "#.is_empty()".} ## \
## Returns true if the search list is empty, false otherwise.

proc getNumDirectories*(this: ConfigVariableSearchPath): clonglong {.importcpp: "#.get_num_directories()".} ## \
## Returns the number of directories on the search list.

proc getDirectory*(this: ConfigVariableSearchPath, n: clonglong): Filename {.importcpp: "#.get_directory(#)".} ## \
## Returns the nth directory on the search list.

proc findFile*(this: ConfigVariableSearchPath, filename: Filename): Filename {.importcpp: "#.find_file(#)".} ## \
## Searches all the directories in the search list for the indicated file, in
## order.  Returns the full matching pathname of the first match if found, or
## the empty string if not found.

proc output*(this: ConfigVariableSearchPath, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: ConfigVariableSearchPath, `out`: ostream) {.importcpp: "#.write(#)".}

proc initConfigVariableString*(param0: ConfigVariableString): ConfigVariableString {.importcpp: "ConfigVariableString(#)".}

proc initConfigVariableString*(name: string): ConfigVariableString {.importcpp: "ConfigVariableString(nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableString*(name: string, default_value: string, description: string, flags: int): ConfigVariableString {.importcpp: "ConfigVariableString(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableString*(name: string, default_value: string, description: string): ConfigVariableString {.importcpp: "ConfigVariableString(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableString*(name: string, default_value: string): ConfigVariableString {.importcpp: "ConfigVariableString(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc `typecast`*(this: ConfigVariableString): string {.importcpp: "nimStringFromStdString(#.operator typecast())", header: stringConversionCode.}

proc cStr*(this: ConfigVariableString): string {.importcpp: "nimStringFromStdString(#.c_str())", header: stringConversionCode.} ## \
## These methods help the ConfigVariableString act like a C++ string object.

proc empty*(this: ConfigVariableString): bool {.importcpp: "#.empty()".}

proc length*(this: ConfigVariableString): clonglong {.importcpp: "#.length()".}

proc `[]`*(this: ConfigVariableString, n: clonglong): char {.importcpp: "#.operator [](#)".}

proc `==`*(this: ConfigVariableString, other: string): bool {.importcpp: "#.operator ==(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Comparison operators are handy.

proc `!=`*(this: ConfigVariableString, other: string): bool {.importcpp: "#.operator !=(nimStringToStdString(#))", header: stringConversionCode.}

proc `<`*(this: ConfigVariableString, other: string): bool {.importcpp: "#.operator <(nimStringToStdString(#))", header: stringConversionCode.}

proc setValue*(this: ConfigVariableString, value: string) {.importcpp: "#.set_value(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Reassigns the variable's local value.

proc getValue*(this: ConfigVariableString): string {.importcpp: "nimStringFromStdString(#.get_value())", header: stringConversionCode.} ## \
## Returns the variable's value.

proc getDefaultValue*(this: ConfigVariableString): string {.importcpp: "nimStringFromStdString(#.get_default_value())", header: stringConversionCode.} ## \
## Returns the variable's default value.

proc getWord*(this: ConfigVariableString, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_word(#))", header: stringConversionCode.} ## \
## Returns the variable's nth value.

proc setWord*(this: ConfigVariableString, n: clonglong, value: string) {.importcpp: "#.set_word(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Reassigns the variable's nth value.  This makes a local copy of the
## variable's overall value.

converter upcastToConfigFlags*(this: NotifyCategory): ConfigFlags {.importcpp: "#.upcast_to_ConfigFlags()".}

proc getFullname*(this: NotifyCategory): string {.importcpp: "nimStringFromStdString(#.get_fullname())", header: stringConversionCode.}

proc getBasename*(this: NotifyCategory): string {.importcpp: "nimStringFromStdString(#.get_basename())", header: stringConversionCode.}

proc getSeverity*(this: NotifyCategory): NotifySeverity {.importcpp: "#.get_severity()".}

proc setSeverity*(this: NotifyCategory, severity: NotifySeverity) {.importcpp: "#.set_severity(#)".} ## \
## Sets the severity level of messages that will be reported from this
## Category.  This allows any message of this severity level or higher.

proc isOn*(this: NotifyCategory, severity: NotifySeverity): bool {.importcpp: "#.is_on(#)".} ## \
## Returns true if messages of the indicated severity level ought to be
## reported for this Category.

proc isSpam*(this: NotifyCategory): bool {.importcpp: "#.is_spam()".} ## \
## When NOTIFY_DEBUG is not defined, the categories will never be set to
## "spam" or "debug" severities, and these methods are redefined to be
## static to make it more obvious to the compiler.  However, we still want
## to present a consistent interface to our scripting language, so during
## the interrogate pass (that is, when CPPPARSER is defined), we still
## pretend they're nonstatic.

proc isDebug*(this: NotifyCategory): bool {.importcpp: "#.is_debug()".} ## \
## A shorthand way to write is_on(NS_debug).

proc isInfo*(this: NotifyCategory): bool {.importcpp: "#.is_info()".} ## \
## A shorthand way to write is_on(NS_info).

proc isWarning*(this: NotifyCategory): bool {.importcpp: "#.is_warning()".} ## \
## A shorthand way to write is_on(NS_warning).

proc isError*(this: NotifyCategory): bool {.importcpp: "#.is_error()".} ## \
## A shorthand way to write is_on(NS_error).

proc isFatal*(this: NotifyCategory): bool {.importcpp: "#.is_fatal()".} ## \
## A shorthand way to write is_on(NS_fatal).

proc spam*(this: NotifyCategory, prefix: bool): ostream {.importcpp: "#.spam(#)".} ## \
## A shorthand way to write out(NS_spam).

proc spam*(this: NotifyCategory): ostream {.importcpp: "#.spam()".} ## \
## A shorthand way to write out(NS_spam).

proc debug*(this: NotifyCategory, prefix: bool): ostream {.importcpp: "#.debug(#)".} ## \
## A shorthand way to write out(NS_debug).

proc debug*(this: NotifyCategory): ostream {.importcpp: "#.debug()".} ## \
## A shorthand way to write out(NS_debug).

proc info*(this: NotifyCategory, prefix: bool): ostream {.importcpp: "#.info(#)".} ## \
## A shorthand way to write out(NS_info).

proc info*(this: NotifyCategory): ostream {.importcpp: "#.info()".} ## \
## A shorthand way to write out(NS_info).

proc warning*(this: NotifyCategory, prefix: bool): ostream {.importcpp: "#.warning(#)".} ## \
## A shorthand way to write out(NS_warning).

proc warning*(this: NotifyCategory): ostream {.importcpp: "#.warning()".} ## \
## A shorthand way to write out(NS_warning).

proc error*(this: NotifyCategory, prefix: bool): ostream {.importcpp: "#.error(#)".} ## \
## A shorthand way to write out(NS_error).

proc error*(this: NotifyCategory): ostream {.importcpp: "#.error()".} ## \
## A shorthand way to write out(NS_error).

proc fatal*(this: NotifyCategory, prefix: bool): ostream {.importcpp: "#.fatal(#)".} ## \
## A shorthand way to write out(NS_fatal).

proc fatal*(this: NotifyCategory): ostream {.importcpp: "#.fatal()".} ## \
## A shorthand way to write out(NS_fatal).

proc getNumChildren*(this: NotifyCategory): clonglong {.importcpp: "#.get_num_children()".} ## \
## Returns the number of child Categories of this particular Category.

proc getChild*(this: NotifyCategory, i: clonglong): NotifyCategory {.importcpp: "#.get_child(#)".} ## \
## Returns the nth child Category of this particular Category.

proc setServerDelta*(_: typedesc[NotifyCategory], delta: int) {.importcpp: "#NotifyCategory::set_server_delta(#)", header: "notifyCategory.h".} ## \
## Sets a global delta (in seconds) between the local time and the server's
## time, for the purpose of synchronizing the time stamps in the log messages
## of the client with that of a known server.

proc initNotifyCategory*(param0: NotifyCategory): NotifyCategory {.importcpp: "NotifyCategory(#)".}

proc initIDecryptStream*(): IDecryptStream {.importcpp: "IDecryptStream()".}

proc initIDecryptStream*(source: istream, owns_source: bool, password: string): IDecryptStream {.importcpp: "IDecryptStream(#, #, nimStringToStdString(#))", header: stringConversionCode.}

proc open*(this: IDecryptStream, source: istream, owns_source: bool, password: string): IDecryptStream {.importcpp: "#.open(#, #, nimStringToStdString(#))", header: stringConversionCode.}

proc close*(this: IDecryptStream): IDecryptStream {.importcpp: "#.close()".} ## \
## Resets the EncryptStream to empty, but does not actually close the source
## istream unless owns_source was true.

proc getAlgorithm*(this: IDecryptStream): string {.importcpp: "nimStringFromStdString(#.get_algorithm())", header: stringConversionCode.} ## \
## Returns the encryption algorithm that was read from the stream.

proc getKeyLength*(this: IDecryptStream): int {.importcpp: "#.get_key_length()".} ## \
## Returns the encryption key length, in bits, that was read from the stream.

proc getIterationCount*(this: IDecryptStream): int {.importcpp: "#.get_iteration_count()".} ## \
## Returns the value that was was read from the stream.

proc initOEncryptStream*(): OEncryptStream {.importcpp: "OEncryptStream()".}

proc initOEncryptStream*(dest: ostream, owns_dest: bool, password: string): OEncryptStream {.importcpp: "OEncryptStream(#, #, nimStringToStdString(#))", header: stringConversionCode.}

proc open*(this: OEncryptStream, dest: ostream, owns_dest: bool, password: string): OEncryptStream {.importcpp: "#.open(#, #, nimStringToStdString(#))", header: stringConversionCode.}

proc close*(this: OEncryptStream): OEncryptStream {.importcpp: "#.close()".} ## \
## Resets the EncryptStream to empty, but does not actually close the dest
## ostream unless owns_dest was true.

proc setAlgorithm*(this: OEncryptStream, algorithm: string) {.importcpp: "#.set_algorithm(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the encryption algorithm that should be used for future calls to
## open().  The default is whatever is specified by the encryption-algorithm
## config variable.  The complete set of available algorithms is defined by
## the current version of OpenSSL.
##
## If an invalid algorithm is specified, there is no immediate error return
## code, but open() will fail.

proc setKeyLength*(this: OEncryptStream, key_length: int) {.importcpp: "#.set_key_length(#)".} ## \
## Specifies the length of the key, in bits, that should be used to encrypt
## the stream in future calls to open().  The default is whatever is specified
## by the encryption-key-length config variable.
##
## If an invalid key_length for the chosen algorithm is specified, there is no
## immediate error return code, but open() will fail.

proc setIterationCount*(this: OEncryptStream, iteration_count: int) {.importcpp: "#.set_iteration_count(#)".} ## \
## Specifies the number of times to repeatedly hash the key before writing it
## to the stream in future calls to open().  Its purpose is to make it
## computationally more expensive for an attacker to search the key space
## exhaustively.  This should be a multiple of 1,000 and should not exceed
## about 65 million; the value 0 indicates just one application of the hashing
## algorithm.
##
## The default is whatever is specified by the encryption-iteration-count
## config variable.

proc initStreamReader*(copy: StreamReader): StreamReader {.importcpp: "StreamReader(#)".} ## \
## The copy constructor does not copy ownership of the stream.

proc initStreamReader*(`in`: istream, owns_stream: bool): StreamReader {.importcpp: "StreamReader(#, #)".} ## \
## If owns_stream is true, the stream pointer will be deleted when the
## StreamReader destructs.

proc getIstream*(this: StreamReader): istream {.importcpp: "#.get_istream()".} ## \
## Returns the stream in use.

proc getBool*(this: StreamReader): bool {.importcpp: "#.get_bool()".} ## \
## Extracts a boolean value.

proc getInt8*(this: StreamReader): char {.importcpp: "#.get_int8()".} ## \
## Extracts a signed 8-bit integer.

proc getUint8*(this: StreamReader): char {.importcpp: "#.get_uint8()".} ## \
## Extracts an unsigned 8-bit integer.

proc getInt16*(this: StreamReader): int {.importcpp: "#.get_int16()".} ## \
## Extracts a signed 16-bit integer.

proc getInt32*(this: StreamReader): int {.importcpp: "#.get_int32()".} ## \
## Extracts a signed 32-bit integer.

proc getInt64*(this: StreamReader): clonglong {.importcpp: "#.get_int64()".} ## \
## Extracts a signed 64-bit integer.

proc getUint16*(this: StreamReader): int {.importcpp: "#.get_uint16()".} ## \
## Extracts an unsigned 16-bit integer.

proc getUint32*(this: StreamReader): int {.importcpp: "#.get_uint32()".} ## \
## Extracts an unsigned 32-bit integer.

proc getUint64*(this: StreamReader): clonglong {.importcpp: "#.get_uint64()".} ## \
## Extracts an unsigned 64-bit integer.

proc getFloat32*(this: StreamReader): float32 {.importcpp: "#.get_float32()".} ## \
## Extracts a 32-bit single-precision floating-point number.  Since this kind
## of float is not necessarily portable across different architectures,
## special care is required.

proc getFloat64*(this: StreamReader): float64 {.importcpp: "#.get_float64()".} ## \
## Extracts a 64-bit floating-point number.

proc getBeInt16*(this: StreamReader): int {.importcpp: "#.get_be_int16()".} ## \
## Extracts a signed big-endian 16-bit integer.

proc getBeInt32*(this: StreamReader): int {.importcpp: "#.get_be_int32()".} ## \
## Extracts a signed big-endian 32-bit integer.

proc getBeInt64*(this: StreamReader): clonglong {.importcpp: "#.get_be_int64()".} ## \
## Extracts a signed big-endian 64-bit integer.

proc getBeUint16*(this: StreamReader): int {.importcpp: "#.get_be_uint16()".} ## \
## Extracts an unsigned big-endian 16-bit integer.

proc getBeUint32*(this: StreamReader): int {.importcpp: "#.get_be_uint32()".} ## \
## Extracts an unsigned big-endian 32-bit integer.

proc getBeUint64*(this: StreamReader): clonglong {.importcpp: "#.get_be_uint64()".} ## \
## Extracts an unsigned big-endian 64-bit integer.

proc getBeFloat32*(this: StreamReader): float32 {.importcpp: "#.get_be_float32()".} ## \
## Extracts a 32-bit single-precision big-endian floating-point number.  Since
## this kind of float is not necessarily portable across different
## architectures, special care is required.

proc getBeFloat64*(this: StreamReader): float64 {.importcpp: "#.get_be_float64()".} ## \
## Extracts a 64-bit big-endian floating-point number.

proc getString*(this: StreamReader): string {.importcpp: "nimStringFromStdString(#.get_string())", header: stringConversionCode.} ## \
## Extracts a variable-length string.

proc getString32*(this: StreamReader): string {.importcpp: "nimStringFromStdString(#.get_string32())", header: stringConversionCode.} ## \
## Extracts a variable-length string with a 32-bit length field.

proc getZString*(this: StreamReader): string {.importcpp: "nimStringFromStdString(#.get_z_string())", header: stringConversionCode.} ## \
## Extracts a variable-length string, as a NULL-terminated string.

proc getFixedString*(this: StreamReader, size: clonglong): string {.importcpp: "nimStringFromStdString(#.get_fixed_string(#))", header: stringConversionCode.} ## \
## Extracts a fixed-length string.  However, if a zero byte occurs within the
## string, it marks the end of the string.

proc skipBytes*(this: StreamReader, size: clonglong) {.importcpp: "#.skip_bytes(#)".} ## \
## Skips over the indicated number of bytes in the stream.

proc initStreamWriter*(copy: StreamWriter): StreamWriter {.importcpp: "StreamWriter(#)".} ## \
## The copy constructor does not copy ownership of the stream.

proc initStreamWriter*(`out`: ostream, owns_stream: bool): StreamWriter {.importcpp: "StreamWriter(#, #)".}

proc getOstream*(this: StreamWriter): ostream {.importcpp: "#.get_ostream()".} ## \
## Returns the stream in use.

proc addBool*(this: StreamWriter, value: bool) {.importcpp: "#.add_bool(#)".} ## \
## Adds a boolean value to the stream.

proc addInt8*(this: StreamWriter, value: char) {.importcpp: "#.add_int8(#)".} ## \
## Adds a signed 8-bit integer to the stream.

proc addUint8*(this: StreamWriter, value: char) {.importcpp: "#.add_uint8(#)".} ## \
## Adds an unsigned 8-bit integer to the stream.

proc addInt16*(this: StreamWriter, value: int) {.importcpp: "#.add_int16(#)".} ## \
## Adds a signed 16-bit integer to the stream.

proc addInt32*(this: StreamWriter, value: int) {.importcpp: "#.add_int32(#)".} ## \
## Adds a signed 32-bit integer to the stream.

proc addInt64*(this: StreamWriter, value: clonglong) {.importcpp: "#.add_int64(#)".} ## \
## Adds a signed 64-bit integer to the stream.

proc addUint16*(this: StreamWriter, value: int) {.importcpp: "#.add_uint16(#)".} ## \
## Adds an unsigned 16-bit integer to the stream.

proc addUint32*(this: StreamWriter, value: int) {.importcpp: "#.add_uint32(#)".} ## \
## Adds an unsigned 32-bit integer to the stream.

proc addUint64*(this: StreamWriter, value: clonglong) {.importcpp: "#.add_uint64(#)".} ## \
## Adds an unsigned 64-bit integer to the stream.

proc addFloat32*(this: StreamWriter, value: float32) {.importcpp: "#.add_float32(#)".} ## \
## Adds a 32-bit single-precision floating-point number to the stream.  Since
## this kind of float is not necessarily portable across different
## architectures, special care is required.

proc addFloat64*(this: StreamWriter, value: float64) {.importcpp: "#.add_float64(#)".} ## \
## Adds a 64-bit floating-point number to the stream.

proc addBeInt16*(this: StreamWriter, value: int) {.importcpp: "#.add_be_int16(#)".} ## \
## Adds a signed 16-bit big-endian integer to the streamWriter.

proc addBeInt32*(this: StreamWriter, value: int) {.importcpp: "#.add_be_int32(#)".} ## \
## Adds a signed 32-bit big-endian integer to the streamWriter.

proc addBeInt64*(this: StreamWriter, value: clonglong) {.importcpp: "#.add_be_int64(#)".} ## \
## Adds a signed 64-bit big-endian integer to the streamWriter.

proc addBeUint16*(this: StreamWriter, value: int) {.importcpp: "#.add_be_uint16(#)".} ## \
## Adds an unsigned 16-bit big-endian integer to the streamWriter.

proc addBeUint32*(this: StreamWriter, value: int) {.importcpp: "#.add_be_uint32(#)".} ## \
## Adds an unsigned 32-bit big-endian integer to the streamWriter.

proc addBeUint64*(this: StreamWriter, value: clonglong) {.importcpp: "#.add_be_uint64(#)".} ## \
## Adds an unsigned 64-bit big-endian integer to the streamWriter.

proc addBeFloat32*(this: StreamWriter, value: float32) {.importcpp: "#.add_be_float32(#)".} ## \
## Adds a 32-bit single-precision big-endian floating-point number to the
## stream.  Since this kind of float is not necessarily portable across
## different architectures, special care is required.

proc addBeFloat64*(this: StreamWriter, value: float64) {.importcpp: "#.add_be_float64(#)".} ## \
## Adds a 64-bit big-endian floating-point number to the streamWriter.

proc addString*(this: StreamWriter, str: string) {.importcpp: "#.add_string(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a variable-length string to the stream.  This actually adds a count
## followed by n bytes.

proc addString32*(this: StreamWriter, str: string) {.importcpp: "#.add_string32(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a variable-length string to the stream, using a 32-bit length field.

proc addZString*(this: StreamWriter, str: string) {.importcpp: "#.add_z_string(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a variable-length string to the stream, as a NULL-terminated string.

proc addFixedString*(this: StreamWriter, str: string, size: clonglong) {.importcpp: "#.add_fixed_string(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Adds a fixed-length string to the stream.  If the string given is less than
## the requested size, this will pad the string out with zeroes; if it is
## greater than the requested size, this will silently truncate the string.

proc padBytes*(this: StreamWriter, size: clonglong) {.importcpp: "#.pad_bytes(#)".} ## \
## Adds the indicated number of zero bytes to the stream.

proc flush*(this: StreamWriter) {.importcpp: "#.flush()".} ## \
## Calls flush() on the underlying stream.

proc write*(this: StreamWriter, str: string) {.importcpp: "#.write(nimStringToStdString(#))", header: stringConversionCode.} ## \
## A synonym of append_data().  This is useful when assigning the StreamWriter
## to sys.stderr and/or sys.stdout in Python.

proc acquire*(this: StreamWrapperBase) {.importcpp: "#.acquire()".} ## \
## Acquires the internal lock.
##
## User code should call this to take temporary possession of the stream and
## perform direct I/O operations on it, for instance to make several
## sequential atomic reads.  You may not call any of the StreamWrapper methods
## while the lock is held, other than release().
##
## Use with extreme caution!  This is a very low-level, non-recursive lock.
## You must call acquire() only once, and you must later call release()
## exactly once.  Failing to do so may result in a hard deadlock with no
## available debugging features.

proc release*(this: StreamWrapperBase) {.importcpp: "#.release()".} ## \
## Releases the internal lock.  Must be called exactly once following a call
## to acquire().  See the cautions with acquire().

converter upcastToStreamWrapperBase*(this: IStreamWrapper): StreamWrapperBase {.importcpp: "#.upcast_to_StreamWrapperBase()".}

proc initIStreamWrapper*(stream: istream): IStreamWrapper {.importcpp: "IStreamWrapper(#)".}

proc getIstream*(this: IStreamWrapper): istream {.importcpp: "#.get_istream()".} ## \
## Returns the istream this object is wrapping.

converter upcastToStreamWrapperBase*(this: OStreamWrapper): StreamWrapperBase {.importcpp: "#.upcast_to_StreamWrapperBase()".}

proc initOStreamWrapper*(stream: ostream): OStreamWrapper {.importcpp: "OStreamWrapper(#)".}

proc getOstream*(this: OStreamWrapper): ostream {.importcpp: "#.get_ostream()".} ## \
## Returns the ostream this object is wrapping.

converter upcastToIStreamWrapper*(this: StreamWrapper): IStreamWrapper {.importcpp: "#.upcast_to_IStreamWrapper()".}

converter upcastToOStreamWrapper*(this: StreamWrapper): OStreamWrapper {.importcpp: "#.upcast_to_OStreamWrapper()".}

proc initStreamWrapper*(stream: iostream): StreamWrapper {.importcpp: "StreamWrapper(#)".}

proc getIostream*(this: StreamWrapper): iostream {.importcpp: "#.get_iostream()".} ## \
## Returns the iostream this object is wrapping.

proc receiveDatagram*(this: SSReader, dg: Datagram): bool {.importcpp: "#->receive_datagram(#)".} ## \
## Receives a datagram over the socket by expecting a little-endian 16-bit
## byte count as a prefix.  If the socket stream is non-blocking, may return
## false if the data is not available; otherwise, returns false only if the
## socket closes.

proc isClosed*(this: SSReader): bool {.importcpp: "#->is_closed()".}

proc close*(this: SSReader) {.importcpp: "#->close()".}

proc setTcpHeaderSize*(this: SSReader, tcp_header_size: int) {.importcpp: "#->set_tcp_header_size(#)".} ## \
## Sets the header size for datagrams.  At the present, legal values for this
## are 0, 2, or 4; this specifies the number of bytes to use encode the
## datagram length at the start of each TCP datagram.  Sender and receiver
## must independently agree on this.

proc getTcpHeaderSize*(this: SSReader): int {.importcpp: "#->get_tcp_header_size()".} ## \
## Returns the header size for datagrams.  See set_tcp_header_size().

proc sendDatagram*(this: SSWriter, dg: Datagram): bool {.importcpp: "#->send_datagram(#)".} ## \
## Transmits the indicated datagram over the socket by prepending it with a
## little-endian 16-bit byte count.  Does not return until the data is sent or
## the connection is closed, even if the socket stream is non-blocking.

proc isClosed*(this: SSWriter): bool {.importcpp: "#->is_closed()".}

proc close*(this: SSWriter) {.importcpp: "#->close()".}

proc setCollectTcp*(this: SSWriter, collect_tcp: bool) {.importcpp: "#->set_collect_tcp(#)".} ## \
## Enables or disables "collect-tcp" mode.  In this mode, individual TCP
## packets are not sent immediately, but rather they are collected together
## and accumulated to be sent periodically as one larger TCP packet.  This
## cuts down on overhead from the TCP/IP protocol, especially if many small
## packets need to be sent on the same connection, but it introduces
## additional latency (since packets must be held before they can be sent).
##
## See set_collect_tcp_interval() to specify the interval of time for which to
## hold packets before sending them.
##
## If you enable this mode, you may also need to periodically call
## consider_flush() to flush the queue if no packets have been sent recently.

proc getCollectTcp*(this: SSWriter): bool {.importcpp: "#->get_collect_tcp()".} ## \
## Returns the current setting of "collect-tcp" mode.  See set_collect_tcp().

proc setCollectTcpInterval*(this: SSWriter, interval: float64) {.importcpp: "#->set_collect_tcp_interval(#)".} ## \
## Specifies the interval in time, in seconds, for which to hold TCP packets
## before sending all of the recently received packets at once.  This only has
## meaning if "collect-tcp" mode is enabled; see set_collect_tcp().

proc getCollectTcpInterval*(this: SSWriter): float64 {.importcpp: "#->get_collect_tcp_interval()".} ## \
## Returns the interval in time, in seconds, for which to hold TCP packets
## before sending all of the recently received packets at once.  This only has
## meaning if "collect-tcp" mode is enabled; see set_collect_tcp().

proc setTcpHeaderSize*(this: SSWriter, tcp_header_size: int) {.importcpp: "#->set_tcp_header_size(#)".} ## \
## Sets the header size for datagrams.  At the present, legal values for this
## are 0, 2, or 4; this specifies the number of bytes to use encode the
## datagram length at the start of each TCP datagram.  Sender and receiver
## must independently agree on this.

proc getTcpHeaderSize*(this: SSWriter): int {.importcpp: "#->get_tcp_header_size()".} ## \
## Returns the header size for datagrams.  See set_tcp_header_size().

proc considerFlush*(this: SSWriter): bool {.importcpp: "#->consider_flush()".} ## \
## Sends the most recently queued data if enough time has elapsed.  This only
## has meaning if set_collect_tcp() has been set to true.

proc flush*(this: SSWriter): bool {.importcpp: "#->flush()".} ## \
## Sends the most recently queued data now.  This only has meaning if
## set_collect_tcp() has been set to true.

converter upcastToIstream*(this: ISocketStream): istream {.importcpp: "((istream *)(#))".}

converter upcastToSSReader*(this: ISocketStream): SSReader {.importcpp: "((SSReader *)(#))".}

proc isClosed*(this: ISocketStream): bool {.importcpp: "#->is_closed()".}

proc close*(this: ISocketStream) {.importcpp: "#->close()".}

converter upcastToOstream*(this: OSocketStream): ostream {.importcpp: "#.upcast_to_ostream()".}

converter upcastToSSWriter*(this: OSocketStream): SSWriter {.importcpp: "#.upcast_to_SSWriter()".}

proc isClosed*(this: OSocketStream): bool {.importcpp: "#.is_closed()".}

proc close*(this: OSocketStream) {.importcpp: "#.close()".}

proc flush*(this: OSocketStream): bool {.importcpp: "#.flush()".} ## \
## Sends the most recently queued data now.  This only has meaning if
## set_collect_tcp() has been set to true.

converter upcastToIostream*(this: SocketStream): iostream {.importcpp: "#.upcast_to_iostream()".}

converter upcastToSSReader*(this: SocketStream): SSReader {.importcpp: "#.upcast_to_SSReader()".}

converter upcastToSSWriter*(this: SocketStream): SSWriter {.importcpp: "#.upcast_to_SSWriter()".}

proc isClosed*(this: SocketStream): bool {.importcpp: "#.is_closed()".}

proc close*(this: SocketStream) {.importcpp: "#.close()".}

proc setTcpHeaderSize*(this: SocketStream, tcp_header_size: int) {.importcpp: "#.set_tcp_header_size(#)".} ## \
## Sets the header size for datagrams.  At the present, legal values for this
## are 0, 2, or 4; this specifies the number of bytes to use encode the
## datagram length at the start of each TCP datagram.  Sender and receiver
## must independently agree on this.

proc getTcpHeaderSize*(this: SocketStream): int {.importcpp: "#.get_tcp_header_size()".} ## \
## Returns the header size for datagrams.  See set_tcp_header_size().

proc flush*(this: SocketStream): bool {.importcpp: "#.flush()".} ## \
## Sends the most recently queued data now.  This only has meaning if
## set_collect_tcp() has been set to true.

proc initURLSpec*(): URLSpec {.importcpp: "URLSpec()".}

proc initURLSpec*(param0: URLSpec): URLSpec {.importcpp: "URLSpec(#)".}

proc initURLSpec*(url: URLSpec, path: Filename): URLSpec {.importcpp: "URLSpec(#, #)".} ## \
## Creates a URLSpec by appending a path to the end of the old URLSpec,
## inserting an intervening forward slash if necessary.

proc initURLSpec*(url: string, server_name_expected: bool): URLSpec {.importcpp: "URLSpec(nimStringToStdString(#), #)", header: stringConversionCode.}

converter initURLSpec*(url: string): URLSpec {.importcpp: "URLSpec(nimStringToStdString(#))", header: stringConversionCode.}

proc `==`*(this: URLSpec, other: URLSpec): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: URLSpec, other: URLSpec): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: URLSpec, other: URLSpec): bool {.importcpp: "#.operator <(#)".}

proc compareTo*(this: URLSpec, other: URLSpec): int {.importcpp: "#.compare_to(#)".} ## \
## Returns a number less than zero if this URLSpec sorts before the other one,
## greater than zero if it sorts after, or zero if they are equivalent.

proc getHash*(this: URLSpec): clonglong {.importcpp: "#.get_hash()".}

proc hasScheme*(this: URLSpec): bool {.importcpp: "#.has_scheme()".} ## \
## Returns true if the URL specifies a scheme (e.g.  "http:"), false
## otherwise.

proc hasAuthority*(this: URLSpec): bool {.importcpp: "#.has_authority()".} ## \
## Returns true if the URL specifies an authority (this includes username,
## server, and/or port), false otherwise.

proc hasUsername*(this: URLSpec): bool {.importcpp: "#.has_username()".} ## \
## Returns true if the URL specifies a username (and/or password), false
## otherwise.

proc hasServer*(this: URLSpec): bool {.importcpp: "#.has_server()".} ## \
## Returns true if the URL specifies a server name, false otherwise.

proc hasPort*(this: URLSpec): bool {.importcpp: "#.has_port()".} ## \
## Returns true if the URL specifies a port number, false otherwise.

proc hasPath*(this: URLSpec): bool {.importcpp: "#.has_path()".} ## \
## Returns true if the URL includes a path specification (that is, the
## particular filename on the server to retrieve), false otherwise.

proc hasQuery*(this: URLSpec): bool {.importcpp: "#.has_query()".} ## \
## Returns true if the URL includes a query specification, false otherwise.

proc getScheme*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_scheme())", header: stringConversionCode.} ## \
## Returns the scheme specified by the URL, or empty string if no scheme is
## specified.

proc getAuthority*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_authority())", header: stringConversionCode.} ## \
## Returns the authority specified by the URL (this includes username, server,
## and/or port), or empty string if no authority is specified.

proc getUsername*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_username())", header: stringConversionCode.} ## \
## Returns the username specified by the URL, if any.  This might also include
## a password, e.g.  "username:password", although putting a password on the
## URL is probably a bad idea.

proc getServer*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_server())", header: stringConversionCode.} ## \
## Returns the server name specified by the URL, if any.  In case of an IPv6
## address, does not include the enclosing brackets.

proc getPortStr*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_port_str())", header: stringConversionCode.} ## \
## Returns the port specified by the URL as a string, or the empty string if
## no port is specified.  Compare this with get_port(), which returns a
## default port number if no port is specified.

proc getPort*(this: URLSpec): int {.importcpp: "#.get_port()".} ## \
## Returns the port number specified by the URL, or the default port if not
## specified.

proc getServerAndPort*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_server_and_port())", header: stringConversionCode.} ## \
## Returns a string consisting of the server name, followed by a colon,
## followed by the port number.  If the port number is not explicitly given in
## the URL, this string will include the implicit port number.
## If the server is an IPv6 address, it will be enclosed in square brackets.

proc isDefaultPort*(this: URLSpec): bool {.importcpp: "#.is_default_port()".} ## \
## Returns true if the port number encoded in this URL is the default port
## number for the scheme (or if there is no port number), or false if it is a
## nonstandard port.

proc getDefaultPortForScheme*(_: typedesc[URLSpec], scheme: string): int {.importcpp: "#URLSpec::get_default_port_for_scheme(nimStringToStdString(#))", header: "urlSpec.h".} ## \
## Returns the default port number for the indicated scheme, or 0 if there is
## no known default.

proc getPath*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_path())", header: stringConversionCode.} ## \
## Returns the path specified by the URL, or "/" if no path is specified.

proc getQuery*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_query())", header: stringConversionCode.} ## \
## Returns the query specified by the URL, or empty string if no query is
## specified.

proc getPathAndQuery*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_path_and_query())", header: stringConversionCode.} ## \
## Returns the path (or "/" if no path is specified), followed by the query if
## it is specified.

proc isSsl*(this: URLSpec): bool {.importcpp: "#.is_ssl()".} ## \
## Returns true if the URL's scheme specifies an SSL-secured protocol such as
## https, or false otherwise.

proc getUrl*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.get_url())", header: stringConversionCode.} ## \
## Returns the complete URL specification.

proc setScheme*(this: URLSpec, scheme: string) {.importcpp: "#.set_scheme(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the scheme part of the URL specification.

proc setAuthority*(this: URLSpec, authority: string) {.importcpp: "#.set_authority(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the authority part of the URL specification.  This includes the
## username, server, and port.

proc setUsername*(this: URLSpec, username: string) {.importcpp: "#.set_username(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the username part of the URL specification.

proc setServer*(this: URLSpec, server: string) {.importcpp: "#.set_server(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the server part of the URL specification.
## Unlike set_server_and_port, this method does not require IPv6 addresses to
## be enclosed in square brackets.

proc setPort*(this: URLSpec, port: string) {.importcpp: "#.set_port(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the port part of the URL specification.

proc setPort*(this: URLSpec, port: int) {.importcpp: "#.set_port(#)".} ## \
## Replaces the port part of the URL specification, given a numeric port
## number.

proc setServerAndPort*(this: URLSpec, server_and_port: string) {.importcpp: "#.set_server_and_port(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the server and port parts of the URL specification simultaneously.
## The input string should be of the form "server:port", or just "server" to
## make the port number implicit.
## Any IPv6 address must be enclosed in square brackets.

proc setPath*(this: URLSpec, path: string) {.importcpp: "#.set_path(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the path part of the URL specification.

proc setQuery*(this: URLSpec, query: string) {.importcpp: "#.set_query(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Replaces the query part of the URL specification.

proc setUrl*(this: URLSpec, url: string, server_name_expected: bool) {.importcpp: "#.set_url(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Completely replaces the URL with the indicated string.  If
## server_name_expected is true, it is a hint that an undecorated URL is
## probably a server name, not a local filename.

proc setUrl*(this: URLSpec, url: string) {.importcpp: "#.set_url(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Completely replaces the URL with the indicated string.  If
## server_name_expected is true, it is a hint that an undecorated URL is
## probably a server name, not a local filename.

proc `typecast`*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.operator typecast())", header: stringConversionCode.}

proc cStr*(this: URLSpec): string {.importcpp: "nimStringFromStdString(#.c_str())", header: stringConversionCode.}

proc empty*(this: URLSpec): bool {.importcpp: "#.empty()".} ## \
## Returns false if the URLSpec is valid (not empty), or true if it is an
## empty string.

proc `typecast bool`*(this: URLSpec): bool {.importcpp: "#.operator typecast bool()".}

proc length*(this: URLSpec): clonglong {.importcpp: "#.length()".}

proc size*(this: URLSpec): clonglong {.importcpp: "#.size()".}

proc `[]`*(this: URLSpec, n: clonglong): char {.importcpp: "#.operator [](#)".}

proc input*(this: URLSpec, `in`: istream): bool {.importcpp: "#.input(#)".}

proc output*(this: URLSpec, `out`: ostream) {.importcpp: "#.output(#)".}

proc quote*(_: typedesc[URLSpec], source: string, safe: string): string {.importcpp: "nimStringFromStdString(#URLSpec::quote(nimStringToStdString(#), nimStringToStdString(#)))", header: "urlSpec.h".} ## \
## Returns the source string with all "unsafe" characters quoted, making a
## string suitable for placing in a URL.  Letters, digits, and the underscore,
## comma, period, and hyphen characters, as well as any included in the safe
## string, are left alone; all others are converted to hex representation.

proc quote*(_: typedesc[URLSpec], source: string): string {.importcpp: "nimStringFromStdString(#URLSpec::quote(nimStringToStdString(#)))", header: "urlSpec.h".} ## \
## Returns the source string with all "unsafe" characters quoted, making a
## string suitable for placing in a URL.  Letters, digits, and the underscore,
## comma, period, and hyphen characters, as well as any included in the safe
## string, are left alone; all others are converted to hex representation.

proc quotePlus*(_: typedesc[URLSpec], source: string, safe: string): string {.importcpp: "nimStringFromStdString(#URLSpec::quote_plus(nimStringToStdString(#), nimStringToStdString(#)))", header: "urlSpec.h".} ## \
## Behaves like quote() with the additional behavior of replacing spaces with
## plus signs.

proc quotePlus*(_: typedesc[URLSpec], source: string): string {.importcpp: "nimStringFromStdString(#URLSpec::quote_plus(nimStringToStdString(#)))", header: "urlSpec.h".} ## \
## Behaves like quote() with the additional behavior of replacing spaces with
## plus signs.

proc unquote*(_: typedesc[URLSpec], source: string): string {.importcpp: "nimStringFromStdString(#URLSpec::unquote(nimStringToStdString(#)))", header: "urlSpec.h".} ## \
## Reverses the operation of quote(): converts escaped characters of the form
## "%xx" to their ascii equivalent.

proc unquotePlus*(_: typedesc[URLSpec], source: string): string {.importcpp: "nimStringFromStdString(#URLSpec::unquote_plus(nimStringToStdString(#)))", header: "urlSpec.h".} ## \
## Reverses the operation of quote_plus(): converts escaped characters of the
## form "%xx" to their ascii equivalent, and also converts plus signs to
## spaces.

proc initHTTPEnum*(): HTTPEnum {.importcpp: "HTTPEnum()".}

proc initHTTPEnum*(param0: HTTPEnum): HTTPEnum {.importcpp: "HTTPEnum(#)".}

proc initHTTPDate*(): HTTPDate {.importcpp: "HTTPDate()".}

proc initHTTPDate*(copy: HTTPDate): HTTPDate {.importcpp: "HTTPDate(#)".}

converter initHTTPDate*(format: string): HTTPDate {.importcpp: "HTTPDate(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Decodes the string into a sensible date.  Returns 0 (!is_valid()) if the
## string cannot be correctly decoded.

converter initHTTPDate*(time: time_t.Time): HTTPDate {.importcpp: "HTTPDate(#)".}

proc now*(_: typedesc[HTTPDate]): HTTPDate {.importcpp: "HTTPDate::now()", header: "httpDate.h".} ## \
## Returns an HTTPDate that represents the current time and date.

proc isValid*(this: HTTPDate): bool {.importcpp: "#.is_valid()".} ## \
## Returns true if the date is meaningful, or false if it is -1 (which
## generally indicates the source string could not be parsed.)

proc getString*(this: HTTPDate): string {.importcpp: "nimStringFromStdString(#.get_string())", header: stringConversionCode.}

proc getTime*(this: HTTPDate): time_t.Time {.importcpp: "#.get_time()".} ## \
## Returns the date as a C time_t value.

proc `==`*(this: HTTPDate, other: HTTPDate): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: HTTPDate, other: HTTPDate): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: HTTPDate, other: HTTPDate): bool {.importcpp: "#.operator <(#)".}

proc `>`*(this: HTTPDate, other: HTTPDate): bool {.importcpp: "#.operator >(#)".}

proc compareTo*(this: HTTPDate, other: HTTPDate): int {.importcpp: "#.compare_to(#)".} ## \
## Returns a number less than zero if this HTTPDate sorts before the other
## one, greater than zero if it sorts after, or zero if they are equivalent.

proc `+=`*(this: var HTTPDate, seconds: int): HTTPDate {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: var HTTPDate, seconds: int): HTTPDate {.importcpp: "#.operator -=(#)".}

proc `+`*(this: HTTPDate, seconds: int): HTTPDate {.importcpp: "#.operator +(#)".}

proc `-`*(this: HTTPDate, other: HTTPDate): int {.importcpp: "#.operator -(#)".}

proc `-`*(this: HTTPDate, seconds: int): HTTPDate {.importcpp: "#.operator -(#)".}

proc input*(this: HTTPDate, `in`: istream): bool {.importcpp: "#.input(#)".}

proc output*(this: HTTPDate, `out`: ostream) {.importcpp: "#.output(#)".}

proc initHTTPCookie*(): HTTPCookie {.importcpp: "HTTPCookie()".} ## \
## Constructs an empty cookie.

proc initHTTPCookie*(param0: HTTPCookie): HTTPCookie {.importcpp: "HTTPCookie(#)".}

proc initHTTPCookie*(format: string, url: URLSpec): HTTPCookie {.importcpp: "HTTPCookie(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Constructs a cookie according to the indicated string, presumably the tag
## of a Set-Cookie header.  There is no way to detect a formatting error in
## the string with this constructor.

proc initHTTPCookie*(name: string, path: string, domain: string): HTTPCookie {.importcpp: "HTTPCookie(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Constructs a cookie with the indicated name, path, and domain values, but
## no other data.  This is most useful for looking up an existing cookie in
## the HTTPClient.

proc setName*(this: HTTPCookie, name: string) {.importcpp: "#.set_name(nimStringToStdString(#))", header: stringConversionCode.}

proc getName*(this: HTTPCookie): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the cookie.  This is the key value specified by the
## server.

proc setValue*(this: HTTPCookie, value: string) {.importcpp: "#.set_value(nimStringToStdString(#))", header: stringConversionCode.}

proc getValue*(this: HTTPCookie): string {.importcpp: "nimStringFromStdString(#.get_value())", header: stringConversionCode.} ## \
## Returns the value of the cookie.  This is the arbitrary string associated
## with the cookie's name, as specified by the server.

proc setDomain*(this: HTTPCookie, domain: string) {.importcpp: "#.set_domain(nimStringToStdString(#))", header: stringConversionCode.}

proc getDomain*(this: HTTPCookie): string {.importcpp: "nimStringFromStdString(#.get_domain())", header: stringConversionCode.}

proc setPath*(this: HTTPCookie, path: string) {.importcpp: "#.set_path(nimStringToStdString(#))", header: stringConversionCode.}

proc getPath*(this: HTTPCookie): string {.importcpp: "nimStringFromStdString(#.get_path())", header: stringConversionCode.} ## \
## Returns the prefix of the URL paths on the server for which this cookie
## will be sent.

proc setExpires*(this: HTTPCookie, expires: HTTPDate) {.importcpp: "#.set_expires(#)".}

proc clearExpires*(this: HTTPCookie) {.importcpp: "#.clear_expires()".} ## \
## Removes the expiration date on the cookie.

proc hasExpires*(this: HTTPCookie): bool {.importcpp: "#.has_expires()".} ## \
## Returns true if the cookie has an expiration date, false otherwise.

proc getExpires*(this: HTTPCookie): HTTPDate {.importcpp: "#.get_expires()".} ## \
## Returns the expiration date of the cookie if it is set, or an invalid date
## if it is not.

proc setSecure*(this: HTTPCookie, flag: bool) {.importcpp: "#.set_secure(#)".}

proc getSecure*(this: HTTPCookie): bool {.importcpp: "#.get_secure()".} ## \
## Returns true if the server has indicated this is a "secure" cookie which
## should only be sent over an HTTPS channel.

proc `<`*(this: HTTPCookie, other: HTTPCookie): bool {.importcpp: "#.operator <(#)".}

proc updateFrom*(this: HTTPCookie, other: HTTPCookie) {.importcpp: "#.update_from(#)".} ## \
## Assuming the operator < method, above, has already evaluated these two
## cookies as equal, then assign the remaining values (value, expiration date,
## secure flag) from the indicated cookie.  This is guaranteed not to change
## the ordering of the cookie in a set, and so can be used to update an
## existing cookie within a set with new values.

proc parseSetCookie*(this: HTTPCookie, format: string, url: URLSpec): bool {.importcpp: "#.parse_set_cookie(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Separates out the parameter/value pairs of the Set-Cookie header and
## assigns the values of the cookie appropriate.  Returns true if the header
## is parsed correctly, false if something is not understood.

proc isExpired*(this: HTTPCookie, now: HTTPDate): bool {.importcpp: "#.is_expired(#)".} ## \
## Returns true if the cookie's expiration date is before the indicated date,
## false otherwise.

proc isExpired*(this: HTTPCookie): bool {.importcpp: "#.is_expired()".} ## \
## Returns true if the cookie's expiration date is before the indicated date,
## false otherwise.

proc matchesUrl*(this: HTTPCookie, url: URLSpec): bool {.importcpp: "#.matches_url(#)".} ## \
## Returns true if the cookie is appropriate to send with the indicated URL
## request, false otherwise.

proc output*(this: HTTPCookie, `out`: ostream) {.importcpp: "#.output(#)".}

proc newHTTPClient*(): HTTPClient {.importcpp: "new HTTPClient()".}

proc newHTTPClient*(copy: HTTPClient): HTTPClient {.importcpp: "new HTTPClient(#)".}

proc initRandomSeed*(_: typedesc[HTTPClient]) {.importcpp: "HTTPClient::init_random_seed()", header: "httpClient.h".} ## \
## This may be called once, presumably at the beginning of an application, to
## initialize OpenSSL's random seed.  On Windows, it is particularly important
## to call this at startup if you are going to be performing any https
## operations or otherwise use encryption, since the Windows algorithm for
## getting a random seed takes 2-3 seconds at startup, but can take 30 seconds
## or more after you have opened a 3-D graphics window and started rendering.
##
## There is no harm in calling this method multiple times, or in not calling
## it at all.

proc setProxySpec*(this: HTTPClient, proxy_spec: string) {.importcpp: "#->set_proxy_spec(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the complete set of proxies to use for all schemes.  This is
## either a semicolon-delimited set of hostname:ports, or a semicolon-
## delimited set of pairs of the form "scheme=hostname:port", or a
## combination.  Use the keyword DIRECT, or an empty string, to represent a
## direct connection.  A particular scheme and/or proxy host may be listed
## more than once.  This is a convenience function that can be used in place
## of explicit calls to add_proxy() for each scheme/proxy pair.

proc getProxySpec*(this: HTTPClient): string {.importcpp: "nimStringFromStdString(#->get_proxy_spec())", header: stringConversionCode.} ## \
## Returns the complete set of proxies to use for all schemes.  This is a
## string of the form specified by set_proxy_spec(), above.  Note that the
## string returned by this function may not be exactly the same as the string
## passed into set_proxy_spec(), since the string is regenerated from the
## internal storage structures and may therefore be reordered.

proc setDirectHostSpec*(this: HTTPClient, direct_host_spec: string) {.importcpp: "#->set_direct_host_spec(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the set of hosts that should be connected to directly, without
## using a proxy.  This is a semicolon-separated list of hostnames that may
## contain wildcard characters ("\*").

proc getDirectHostSpec*(this: HTTPClient): string {.importcpp: "nimStringFromStdString(#->get_direct_host_spec())", header: stringConversionCode.} ## \
## Returns the set of hosts that should be connected to directly, without
## using a proxy, as a semicolon-separated list of hostnames that may contain
## wildcard characters ("\*").

proc setTryAllDirect*(this: HTTPClient, try_all_direct: bool) {.importcpp: "#->set_try_all_direct(#)".} ## \
## If this is set true, then after a connection attempt through a proxy fails,
## we always try a direct connection, regardless of whether the host is listed
## on the direct_host_spec list.  If this is false, a direct attempt is not
## made when we have a proxy in effect, even if the proxy fails.

proc getTryAllDirect*(this: HTTPClient): bool {.importcpp: "#->get_try_all_direct()".} ## \
## Returns whether a failed connection through a proxy will be followed up by
## a direct connection attempt, false otherwise.

proc clearProxy*(this: HTTPClient) {.importcpp: "#->clear_proxy()".} ## \
## Resets the proxy spec to empty.  Subsequent calls to add_proxy() may be
## made to build up the set of proxy servers.

proc addProxy*(this: HTTPClient, scheme: string, proxy: URLSpec) {.importcpp: "#->add_proxy(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Adds the indicated proxy host as a proxy for communications on the given
## scheme.  Usually the scheme is "http" or "https".  It may be the empty
## string to indicate a general proxy.  The proxy string may be the empty URL
## to indicate a direct connection.

proc clearDirectHost*(this: HTTPClient) {.importcpp: "#->clear_direct_host()".} ## \
## Resets the set of direct hosts to empty.  Subsequent calls to
## add_direct_host() may be made to build up the list of hosts that do not
## require a proxy connection.

proc addDirectHost*(this: HTTPClient, hostname: string) {.importcpp: "#->add_direct_host(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds the indicated name to the set of hostnames that are connected to
## directly, without using a proxy.  This name may be either a DNS name or an
## IP address, and it may include the \* as a wildcard character.

proc getProxiesForUrl*(this: HTTPClient, url: URLSpec): string {.importcpp: "nimStringFromStdString(#->get_proxies_for_url(#))", header: stringConversionCode.} ## \
## Returns a semicolon-delimited list of proxies, in the order in which they
## should be tried, that are appropriate for the indicated URL.  The keyword
## DIRECT indicates a direct connection should be tried.

proc setUsername*(this: HTTPClient, server: string, realm: string, username: string) {.importcpp: "#->set_username(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the username:password string corresponding to a particular server
## and/or realm, when demanded by the server.  Either or both of the server or
## realm may be empty; if so, they match anything.  Also, the server may be
## set to the special string `"\*proxy"`, which will match any proxy server.
##
## If the username is set to the empty string, this clears the password for
## the particular server/realm pair.

proc getUsername*(this: HTTPClient, server: string, realm: string): string {.importcpp: "nimStringFromStdString(#->get_username(nimStringToStdString(#), nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Returns the username:password string set for this server/realm pair, or
## empty string if nothing has been set.  See set_username().

proc setCookie*(this: HTTPClient, cookie: HTTPCookie) {.importcpp: "#->set_cookie(#)".} ## \
## Stores the indicated cookie in the client's list of cookies, as if it had
## been received from a server.

proc clearCookie*(this: HTTPClient, cookie: HTTPCookie): bool {.importcpp: "#->clear_cookie(#)".} ## \
## Removes the cookie with the matching domain/path/name from the client's
## list of cookies.  Returns true if it was removed, false if the cookie was
## not matched.

proc clearAllCookies*(this: HTTPClient) {.importcpp: "#->clear_all_cookies()".} ## \
## Removes the all stored cookies from the client.

proc hasCookie*(this: HTTPClient, cookie: HTTPCookie): bool {.importcpp: "#->has_cookie(#)".} ## \
## Returns true if there is a cookie in the client matching the given cookie's
## domain/path/name, false otherwise.

proc getCookie*(this: HTTPClient, cookie: HTTPCookie): HTTPCookie {.importcpp: "#->get_cookie(#)".} ## \
## Looks up and returns the cookie in the client matching the given cookie's
## domain/path/name.  If there is no matching cookie, returns an empty cookie.

proc copyCookiesFrom*(this: HTTPClient, other: HTTPClient) {.importcpp: "#->copy_cookies_from(#)".} ## \
## Copies all the cookies from the indicated HTTPClient into this one.
## Existing cookies in this client are not affected, unless they are shadowed
## by the new cookies.

proc writeCookies*(this: HTTPClient, `out`: ostream) {.importcpp: "#->write_cookies(#)".} ## \
## Outputs the complete list of cookies stored on the client, for all domains,
## including the expired cookies (which will normally not be sent back to a
## host).

proc sendCookies*(this: HTTPClient, `out`: ostream, url: URLSpec) {.importcpp: "#->send_cookies(#, #)".} ## \
## Writes to the indicated ostream a "Cookie" header line for sending the
## cookies appropriate to the indicated URL along with an HTTP request.  This
## also removes expired cookies.

proc setClientCertificateFilename*(this: HTTPClient, filename: Filename) {.importcpp: "#->set_client_certificate_filename(#)".} ## \
## Sets the filename of the pem-formatted file that will be read for the
## client public and private keys if an SSL server requests a certificate.
## Either this or set_client_certificate_pem() may be used to specify a client
## certificate.

proc setClientCertificatePem*(this: HTTPClient, pem: string) {.importcpp: "#->set_client_certificate_pem(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the pem-formatted contents of the certificate that will be parsed for
## the client public and private keys if an SSL server requests a certificate.
## Either this or set_client_certificate_filename() may be used to specify a
## client certificate.

proc setClientCertificatePassphrase*(this: HTTPClient, passphrase: string) {.importcpp: "#->set_client_certificate_passphrase(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the passphrase used to decrypt the private key in the certificate
## named by set_client_certificate_filename() or set_client_certificate_pem().

proc loadClientCertificate*(this: HTTPClient): bool {.importcpp: "#->load_client_certificate()".} ## \
## Attempts to load the certificate named by set_client_certificate_filename()
## immediately, and returns true if successful, false otherwise.
##
## Normally this need not be explicitly called, since it will be called
## automatically if the server requests a certificate, but it may be useful to
## determine ahead of time if the certificate can be loaded correctly.

proc addPreapprovedServerCertificateFilename*(this: HTTPClient, url: URLSpec, filename: Filename): bool {.importcpp: "#->add_preapproved_server_certificate_filename(#, #)".} ## \
## Adds the certificate defined in the indicated PEM filename as a "pre-
## approved" certificate for the indicated server, defined by the hostname and
## port (only) from the given URL.
##
## If the server offers this particular certificate on a secure connection, it
## will be accepted without question.  This is particularly useful for
## communicating with a server using a known self-signed certificate.
##
## See also the similar add_preapproved_server_certificate_pem(), and the
## weaker add_preapproved_server_certificate_name().

proc addPreapprovedServerCertificatePem*(this: HTTPClient, url: URLSpec, pem: string): bool {.importcpp: "#->add_preapproved_server_certificate_pem(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds the certificate defined in the indicated data string, formatted as a
## PEM block, as a "pre-approved" certificate for the indicated server,
## defined by the hostname and port (only) from the given URL.
##
## If the server offers this particular certificate on a secure connection, it
## will be accepted without question.  This is particularly useful for
## communicating with a server using a known self-signed certificate.
##
## See also the similar add_preapproved_server_certificate_filename(), and the
## weaker add_preapproved_server_certificate_name().

proc addPreapprovedServerCertificateName*(this: HTTPClient, url: URLSpec, name: string): bool {.importcpp: "#->add_preapproved_server_certificate_name(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds the certificate \*name\* only, as a "pre-approved" certificate name for
## the indicated server, defined by the hostname and port (only) from the
## given URL.
##
## This is a weaker function than
## add_preapproved_server_certificate_filename().  This checks only the
## subject name of the certificate, without checking for a particular
## certificate by key.  This means that a variety of server certificates may
## match the indicated name.
##
## Because this is a weaker verification, it only applies to server
## certificates that are signed by a recognized certificate authority.  Thus,
## it cannot be used to pre-approve self-signed certificates, but it can be
## used to accept a server certificate offered by a different hostname than
## the one in the cert itself.
##
## The certificate name should be formatted in the form
## type0=value0/type1=value1/type2=...

proc clearPreapprovedServerCertificates*(this: HTTPClient, url: URLSpec) {.importcpp: "#->clear_preapproved_server_certificates(#)".} ## \
## Removes all preapproved server certificates for the indicated server and
## port.

proc clearAllPreapprovedServerCertificates*(this: HTTPClient) {.importcpp: "#->clear_all_preapproved_server_certificates()".} ## \
## Removes all preapproved server certificates for all servers.

proc getHttpVersionString*(this: HTTPClient): string {.importcpp: "nimStringFromStdString(#->get_http_version_string())", header: stringConversionCode.} ## \
## Returns the current HTTP version setting as a string, e.g.  "HTTP/1.0" or
## "HTTP/1.1".

proc loadCertificates*(this: HTTPClient, filename: Filename): bool {.importcpp: "#->load_certificates(#)".} ## \
## Reads the certificate(s) (delimited by -----BEGIN CERTIFICATE----- and
## -----END CERTIFICATE-----) from the indicated file and makes them known as
## trusted public keys for validating future connections.  Returns true on
## success, false otherwise.

proc setCipherList*(this: HTTPClient, cipher_list: string) {.importcpp: "#->set_cipher_list(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the set of ciphers that are to be made available for SSL
## connections.  This is a string as described in the ciphers(1) man page of
## the OpenSSL documentation (or see
## https://www.openssl.org/docs/man1.1.1/man1/ciphers.html ).  If this isn't
## specified, the default is provided by the Config file.  You may also specify
## "DEFAULT" to use the built-in OpenSSL default value.

proc getCipherList*(this: HTTPClient): string {.importcpp: "nimStringFromStdString(#->get_cipher_list())", header: stringConversionCode.} ## \
## Returns the set of ciphers as set by set_cipher_list().  See
## set_cipher_list().

proc makeChannel*(this: HTTPClient, persistent_connection: bool): HTTPChannel {.importcpp: "#->make_channel(#)".} ## \
## Returns a new HTTPChannel object that may be used for reading multiple
## documents using the same connection, for greater network efficiency than
## calling HTTPClient::get_document() repeatedly (which would force a new
## connection for each document).
##
## Also, HTTPChannel has some additional, less common interface methods than
## the basic interface methods that exist on HTTPClient; if you wish to call
## any of these methods you must first obtain an HTTPChannel.
##
## Pass true for persistent_connection to gain this network efficiency.  If,
## on the other hand, your intention is to use the channel to retrieve only
## one document, then pass false to inform the server that we will be dropping
## the connection after the first document.

proc postForm*(this: HTTPClient, url: URLSpec, body: string): HTTPChannel {.importcpp: "#->post_form(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Posts form data to a particular URL and retrieves the response.  Returns a
## new HTTPChannel object whether the document is successfully read or not;
## you can test is_valid() and get_return_code() to determine whether the
## document was retrieved.

proc getDocument*(this: HTTPClient, url: URLSpec): HTTPChannel {.importcpp: "#->get_document(#)".} ## \
## Opens the named document for reading.  Returns a new HTTPChannel object
## whether the document is successfully read or not; you can test is_valid()
## and get_return_code() to determine whether the document was retrieved.

proc getHeader*(this: HTTPClient, url: URLSpec): HTTPChannel {.importcpp: "#->get_header(#)".} ## \
## Like get_document(), except only the header associated with the document is
## retrieved.  This may be used to test for existence of the document; it
## might also return the size of the document (if the server gives us this
## information).

proc base64Encode*(_: typedesc[HTTPClient], s: string): string {.importcpp: "nimStringFromStdString(#HTTPClient::base64_encode(nimStringToStdString(#)))", header: "httpClient.h".} ## \
## Implements HTTPAuthorization::base64_encode().  This is provided here just
## as a convenient place to publish it for access by the scripting language;
## C++ code should probably use HTTPAuthorization directly.

proc base64Decode*(_: typedesc[HTTPClient], s: string): string {.importcpp: "nimStringFromStdString(#HTTPClient::base64_decode(nimStringToStdString(#)))", header: "httpClient.h".} ## \
## Implements HTTPAuthorization::base64_decode().  This is provided here just
## as a convenient place to publish it for access by the scripting language;
## C++ code should probably use HTTPAuthorization directly.

proc getGlobalPtr*(_: typedesc[HTTPClient]): HTTPClient {.importcpp: "HTTPClient::get_global_ptr()", header: "httpClient.h".} ## \
## Returns the default global HTTPClient.

proc initHTTPEntityTag*(): HTTPEntityTag {.importcpp: "HTTPEntityTag()".}

proc initHTTPEntityTag*(copy: HTTPEntityTag): HTTPEntityTag {.importcpp: "HTTPEntityTag(#)".}

proc initHTTPEntityTag*(weak: bool, tag: string): HTTPEntityTag {.importcpp: "HTTPEntityTag(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## This constructor accepts an explicit weak flag and a literal (not quoted)
## tag string.

converter initHTTPEntityTag*(text: string): HTTPEntityTag {.importcpp: "HTTPEntityTag(nimStringToStdString(#))", header: stringConversionCode.} ## \
## This constructor accepts a string as formatted from an HTTP server (e.g.
## the tag is quoted, with an optional W/ prefix.)

proc isWeak*(this: HTTPEntityTag): bool {.importcpp: "#.is_weak()".} ## \
## Returns true if the entity tag is marked as "weak". A consistent weak
## entity tag does not guarantee that its resource has not changed in any way,
## but it does promise that the resource has not changed in any semantically
## meaningful way.

proc getTag*(this: HTTPEntityTag): string {.importcpp: "nimStringFromStdString(#.get_tag())", header: stringConversionCode.} ## \
## Returns the tag as a literal string.

proc getString*(this: HTTPEntityTag): string {.importcpp: "nimStringFromStdString(#.get_string())", header: stringConversionCode.} ## \
## Returns the entity tag formatted for sending to an HTTP server (the tag is
## quoted, with a conditional W prefix).

proc strongEquiv*(this: HTTPEntityTag, other: HTTPEntityTag): bool {.importcpp: "#.strong_equiv(#)".} ## \
## Returns true if the two tags have "strong" equivalence: they are the same
## tag, and both are "strong".

proc weakEquiv*(this: HTTPEntityTag, other: HTTPEntityTag): bool {.importcpp: "#.weak_equiv(#)".} ## \
## Returns true if the two tags have "weak" equivalence: they are the same
## tag, and one or both may be "weak".

proc `==`*(this: HTTPEntityTag, other: HTTPEntityTag): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: HTTPEntityTag, other: HTTPEntityTag): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: HTTPEntityTag, other: HTTPEntityTag): bool {.importcpp: "#.operator <(#)".}

proc compareTo*(this: HTTPEntityTag, other: HTTPEntityTag): int {.importcpp: "#.compare_to(#)".} ## \
## Returns a number less than zero if this HTTPEntityTag sorts before the
## other one, greater than zero if it sorts after, or zero if they are
## equivalent.

proc output*(this: HTTPEntityTag, `out`: ostream) {.importcpp: "#.output(#)".}

proc initDocumentSpec*(): DocumentSpec {.importcpp: "DocumentSpec()".}

proc initDocumentSpec*(copy: DocumentSpec): DocumentSpec {.importcpp: "DocumentSpec(#)".}

converter initDocumentSpec*(url: URLSpec): DocumentSpec {.importcpp: "DocumentSpec(#)".}

converter initDocumentSpec*(url: string): DocumentSpec {.importcpp: "DocumentSpec(nimStringToStdString(#))", header: stringConversionCode.}

proc `==`*(this: DocumentSpec, other: DocumentSpec): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: DocumentSpec, other: DocumentSpec): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: DocumentSpec, other: DocumentSpec): bool {.importcpp: "#.operator <(#)".}

proc compareTo*(this: DocumentSpec, other: DocumentSpec): int {.importcpp: "#.compare_to(#)".}

proc setUrl*(this: DocumentSpec, url: URLSpec) {.importcpp: "#.set_url(#)".} ## \
## Changes the URL of the DocumentSpec without modifying its other properties.
## Normally this would be a strange thing to do, because the tag and date are
## usually strongly associated with the URL.  To get a DocumentSpec pointing
## to a new URL, you would normally create a new DocumentSpec object.

proc getUrl*(this: DocumentSpec): URLSpec {.importcpp: "#.get_url()".} ## \
## Retrieves the URL of the DocumentSpec.

proc setTag*(this: DocumentSpec, tag: HTTPEntityTag) {.importcpp: "#.set_tag(#)".} ## \
## Changes the identity tag associated with the DocumentSpec.

proc hasTag*(this: DocumentSpec): bool {.importcpp: "#.has_tag()".} ## \
## Returns true if an identity tag is associated with the DocumentSpec.

proc getTag*(this: DocumentSpec): HTTPEntityTag {.importcpp: "#.get_tag()".} ## \
## Returns the identity tag associated with the DocumentSpec, if there is one.
## It is an error to call this if has_tag() returns false.
##
## The identity tag is set by the HTTP server to uniquely refer to a
## particular version of a document.

proc clearTag*(this: DocumentSpec) {.importcpp: "#.clear_tag()".} ## \
## Removes the identity tag associated with the DocumentSpec, if there is one.

proc setDate*(this: DocumentSpec, date: HTTPDate) {.importcpp: "#.set_date(#)".} ## \
## Changes the last-modified date associated with the DocumentSpec.

proc hasDate*(this: DocumentSpec): bool {.importcpp: "#.has_date()".} ## \
## Returns true if a last-modified date is associated with the DocumentSpec.

proc getDate*(this: DocumentSpec): HTTPDate {.importcpp: "#.get_date()".} ## \
## Returns the last-modified date associated with the DocumentSpec, if there
## is one.  It is an error to call this if has_date() returns false.

proc clearDate*(this: DocumentSpec) {.importcpp: "#.clear_date()".} ## \
## Removes the last-modified date associated with the DocumentSpec, if there
## is one.

proc input*(this: DocumentSpec, `in`: istream): bool {.importcpp: "#.input(#)".} ## \
## Can be used to read in the DocumentSpec from a stream generated either by
## output() or write().  Returns true on success, false on failure.

proc output*(this: DocumentSpec, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: DocumentSpec, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: DocumentSpec, `out`: ostream) {.importcpp: "#.write(#)".}

proc getClient*(this: HTTPChannel): HTTPClient {.importcpp: "#->get_client()".} ## \
## Returns the HTTPClient object that owns this channel.

proc isValid*(this: HTTPChannel): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the last-requested document was successfully retrieved and
## is ready to be read, false otherwise.

proc isConnectionReady*(this: HTTPChannel): bool {.importcpp: "#->is_connection_ready()".} ## \
## Returns true if a connection has been established to the named server in a
## previous call to connect_to() or begin_connect_to(), false otherwise.

proc getUrl*(this: HTTPChannel): URLSpec {.importcpp: "#->get_url()".} ## \
## Returns the URL that was used to retrieve the most recent document:
## whatever URL was last passed to get_document() or get_header().  If a
## redirect has transparently occurred, this will return the new, redirected
## URL (the actual URL at which the document was located).

proc getDocumentSpec*(this: HTTPChannel): DocumentSpec {.importcpp: "#->get_document_spec()".} ## \
## Returns the DocumentSpec associated with the most recent document.  This
## includes its actual URL (following redirects) along with the identity tag
## and last-modified date, if supplied by the server.
##
## This structure may be saved and used to retrieve the same version of the
## document later, or to conditionally retrieve a newer version if it is
## available.

proc getHttpVersionString*(this: HTTPChannel): string {.importcpp: "nimStringFromStdString(#->get_http_version_string())", header: stringConversionCode.} ## \
## Returns the HTTP version number returned by the server, formatted as a
## string, e.g.  "HTTP/1.1".

proc getStatusCode*(this: HTTPChannel): int {.importcpp: "#->get_status_code()".} ## \
## Returns the HTML return code from the document retrieval request.  This
## will be in the 200 range if the document is successfully retrieved, or some
## other value in the case of an error.
##
## Some proxy errors during an https-over-proxy request would return the same
## status code as a different error that occurred on the host server.  To
## differentiate these cases, status codes that are returned by the proxy
## during the CONNECT phase (except code 407) are incremented by 1000.

proc getStatusString*(this: HTTPChannel): string {.importcpp: "nimStringFromStdString(#->get_status_string())", header: stringConversionCode.} ## \
## Returns the string as returned by the server describing the status code for
## humans.  This may or may not be meaningful.

proc getWwwRealm*(this: HTTPChannel): string {.importcpp: "nimStringFromStdString(#->get_www_realm())", header: stringConversionCode.} ## \
## If the document failed to connect because of a 401 (Authorization
## required), this method will return the "realm" returned by the server in
## which the requested document must be authenticated.  This string may be
## presented to the user to request an associated username and password (which
## then should be stored in HTTPClient::set_username()).

proc getProxyRealm*(this: HTTPChannel): string {.importcpp: "nimStringFromStdString(#->get_proxy_realm())", header: stringConversionCode.} ## \
## If the document failed to connect because of a 407 (Proxy authorization
## required), this method will return the "realm" returned by the proxy.  This
## string may be presented to the user to request an associated username and
## password (which then should be stored in HTTPClient::set_username()).

proc getRedirect*(this: HTTPChannel): URLSpec {.importcpp: "#->get_redirect()".} ## \
## If the document failed with a redirect code (300 series), this will
## generally contain the new URL the server wants us to try.  In many cases,
## the client will automatically follow redirects; if these are successful the
## client will return a successful code and get_redirect() will return empty,
## but get_url() will return the new, redirected URL.

proc getHeaderValue*(this: HTTPChannel, key: string): string {.importcpp: "nimStringFromStdString(#->get_header_value(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Returns the HTML header value associated with the indicated key, or empty
## string if the key was not defined in the message returned by the server.

proc getNumRedirectSteps*(this: HTTPChannel): int {.importcpp: "#->get_num_redirect_steps()".} ## \
## If the document automatically followed one or more redirects, this will
## return the number of redirects that were automatically followed.  Use
## get_redirect_step() to retrieve each URL in sequence.

proc getRedirectStep*(this: HTTPChannel, n: int): URLSpec {.importcpp: "#->get_redirect_step(#)".} ## \
## Use in conjunction with get_num_redirect_steps() to extract the chain of
## URL's that the channel was automatically redirected through to arrive at
## the final document.

proc setPersistentConnection*(this: HTTPChannel, persistent_connection: bool) {.importcpp: "#->set_persistent_connection(#)".} ## \
## Indicates whether the HTTPChannel should try to keep the connection to the
## server open and reuse that connection for multiple documents, or whether it
## should close the connection and open a new one for each request.  Set this
## true to keep the connections around when possible, false to recycle them.
##
## It makes most sense to set this false when the HTTPChannel will be used
## only once to retrieve a single document, true when you will be using the
## same HTTPChannel object to retrieve multiple documents.

proc getPersistentConnection*(this: HTTPChannel): bool {.importcpp: "#->get_persistent_connection()".} ## \
## Returns whether the HTTPChannel should try to keep the connection to the
## server open and reuse that connection for multiple documents, or whether it
## should close the connection and open a new one for each request.  See
## set_persistent_connection().

proc willCloseConnection*(this: HTTPChannel): bool {.importcpp: "#->will_close_connection()".} ## \
## Returns true if the server has indicated it will close the connection after
## this document has been read, or false if it will remain open (and future
## documents may be requested on the same connection).

proc setAllowProxy*(this: HTTPChannel, allow_proxy: bool) {.importcpp: "#->set_allow_proxy(#)".} ## \
## If this is true (the normal case), the HTTPClient will be consulted for
## information about the proxy to be used for each connection via this
## HTTPChannel.  If this has been set to false by the user, then all
## connections will be made directly, regardless of the proxy settings
## indicated on the HTTPClient.

proc getAllowProxy*(this: HTTPChannel): bool {.importcpp: "#->get_allow_proxy()".} ## \
## If this is true (the normal case), the HTTPClient will be consulted for
## information about the proxy to be used for each connection via this
## HTTPChannel.  If this has been set to false by the user, then all
## connections will be made directly, regardless of the proxy settings
## indicated on the HTTPClient.

proc setProxyTunnel*(this: HTTPChannel, proxy_tunnel: bool) {.importcpp: "#->set_proxy_tunnel(#)".} ## \
## Normally, a proxy is itself asked for ordinary URL's, and the proxy decides
## whether to hand the client a cached version of the document or to contact
## the server for a fresh version.  The proxy may also modify the headers and
## transfer encoding on the way.
##
## If this is set to true, then instead of asking for URL's from the proxy, we
## will ask the proxy to open a connection to the server (for instance, on
## port 80); if the proxy honors this request, then we contact the server
## directly through this connection to retrieve the document.  If the proxy
## does not honor the connect request, then the retrieve operation fails.
##
## SSL connections (e.g.  https), and connections through a Socks proxy, are
## always tunneled, regardless of the setting of this flag.

proc getProxyTunnel*(this: HTTPChannel): bool {.importcpp: "#->get_proxy_tunnel()".} ## \
## Returns true if connections always tunnel through a proxy, or false (the
## normal case) if we allow the proxy to serve up documents.  See
## set_proxy_tunnel().

proc setConnectTimeout*(this: HTTPChannel, timeout_seconds: float64) {.importcpp: "#->set_connect_timeout(#)".} ## \
## Sets the maximum length of time, in seconds, that the channel will wait
## before giving up on establishing a TCP connection.
##
## At present, this is used only for the nonblocking interfaces (e.g.
## begin_get_document(), begin_connect_to()), but it is used whether
## set_blocking_connect() is true or false.

proc getConnectTimeout*(this: HTTPChannel): float64 {.importcpp: "#->get_connect_timeout()".} ## \
## Returns the length of time, in seconds, to wait for a new nonblocking
## socket to connect.  See set_connect_timeout().

proc setBlockingConnect*(this: HTTPChannel, blocking_connect: bool) {.importcpp: "#->set_blocking_connect(#)".} ## \
## If this flag is true, a socket connect will block even for nonblocking I/O
## calls like begin_get_document(), begin_connect_to(), etc.  If false, a
## socket connect will not block for nonblocking I/O calls, but will block for
## blocking I/O calls (get_document(), connect_to(), etc.).
##
## Setting this true is useful when you want to use non-blocking I/O once you
## have established the connection, but you don't want to bother with polling
## for the initial connection.  It's also useful when you don't particularly
## care about non-blocking I/O, but you need to respect timeouts like
## connect_timeout and http_timeout.

proc getBlockingConnect*(this: HTTPChannel): bool {.importcpp: "#->get_blocking_connect()".} ## \
## If this flag is true, a socket connect will block even for nonblocking I/O
## calls like begin_get_document(), begin_connect_to(), etc.  If false, a
## socket connect will not block for nonblocking I/O calls, but will block for
## blocking I/O calls (get_document(), connect_to(), etc.).

proc setHttpTimeout*(this: HTTPChannel, timeout_seconds: float64) {.importcpp: "#->set_http_timeout(#)".} ## \
## Sets the maximum length of time, in seconds, that the channel will wait for
## the HTTP server to finish sending its response to our request.
##
## The timer starts counting after the TCP connection has been established
## (see set_connect_timeout(), above) and the request has been sent.
##
## At present, this is used only for the nonblocking interfaces (e.g.
## begin_get_document(), begin_connect_to()), but it is used whether
## set_blocking_connect() is true or false.

proc getHttpTimeout*(this: HTTPChannel): float64 {.importcpp: "#->get_http_timeout()".} ## \
## Returns the length of time, in seconds, to wait for the HTTP server to
## respond to our request.  See set_http_timeout().

proc setSkipBodySize*(this: HTTPChannel, skip_body_size: clonglong) {.importcpp: "#->set_skip_body_size(#)".} ## \
## Specifies the maximum number of bytes in a received (but unwanted) body
## that will be skipped past, in order to reset to a new request.
##
## That is, if this HTTPChannel requests a file via get_document(), but does
## not call download_to_ram(), download_to_file(), or open_read_body(), and
## instead immediately requests a new file, then the HTTPChannel has a choice
## whether to skip past the unwanted document, or to close the connection and
## open a new one.  If the number of bytes to skip is more than this
## threshold, the connection will be closed; otherwise, the data will simply
## be read and discarded.

proc getSkipBodySize*(this: HTTPChannel): clonglong {.importcpp: "#->get_skip_body_size()".} ## \
## Returns the maximum number of bytes in a received (but unwanted) body that
## will be skipped past, in order to reset to a new request.  See
## set_skip_body_size().

proc setIdleTimeout*(this: HTTPChannel, idle_timeout: float64) {.importcpp: "#->set_idle_timeout(#)".} ## \
## Specifies the amount of time, in seconds, in which a previously-established
## connection is allowed to remain open and unused.  If a previous connection
## has remained unused for at least this number of seconds, it will be closed
## and a new connection will be opened; otherwise, the same connection will be
## reused for the next request (for this particular HTTPChannel).

proc getIdleTimeout*(this: HTTPChannel): float64 {.importcpp: "#->get_idle_timeout()".} ## \
## Returns the amount of time, in seconds, in which an previously-established
## connection is allowed to remain open and unused.  See set_idle_timeout().

proc setDownloadThrottle*(this: HTTPChannel, download_throttle: bool) {.importcpp: "#->set_download_throttle(#)".} ## \
## Specifies whether nonblocking downloads (via download_to_file() or
## download_to_ram()) will be limited so as not to use all available
## bandwidth.
##
## If this is true, when a download has been started on this channel it will
## be invoked no more frequently than get_max_updates_per_second(), and the
## total bandwidth used by the download will be no more than
## get_max_bytes_per_second().  If this is false, downloads will proceed as
## fast as the server can send the data.
##
## This only has effect on the nonblocking I/O methods like
## begin_get_document(), etc.  The blocking methods like get_document() always
## use as much CPU and bandwidth as they can get.

proc getDownloadThrottle*(this: HTTPChannel): bool {.importcpp: "#->get_download_throttle()".} ## \
## Returns whether the nonblocking downloads will be bandwidth-limited.  See
## set_download_throttle().

proc setMaxBytesPerSecond*(this: HTTPChannel, max_bytes_per_second: float64) {.importcpp: "#->set_max_bytes_per_second(#)".} ## \
## When bandwidth throttling is in effect (see set_download_throttle()), this
## specifies the maximum number of bytes per second that may be consumed by
## this channel.

proc getMaxBytesPerSecond*(this: HTTPChannel): float64 {.importcpp: "#->get_max_bytes_per_second()".} ## \
## Returns the maximum number of bytes per second that may be consumed by this
## channel when get_download_throttle() is true.

proc setMaxUpdatesPerSecond*(this: HTTPChannel, max_updates_per_second: float64) {.importcpp: "#->set_max_updates_per_second(#)".} ## \
## When bandwidth throttling is in effect (see set_download_throttle()), this
## specifies the maximum number of times per second that run() will attempt to
## do any downloading at all.

proc getMaxUpdatesPerSecond*(this: HTTPChannel): float64 {.importcpp: "#->get_max_updates_per_second()".} ## \
## Returns the maximum number of times per second that run() will do anything
## at all, when get_download_throttle() is true.

proc setContentType*(this: HTTPChannel, content_type: string) {.importcpp: "#->set_content_type(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the Content-Type header, useful for applications that require
## different types of content, such as JSON.

proc getContentType*(this: HTTPChannel): string {.importcpp: "nimStringFromStdString(#->get_content_type())", header: stringConversionCode.} ## \
## Returns the value of the Content-Type header.

proc setExpectedFileSize*(this: HTTPChannel, file_size: clonglong) {.importcpp: "#->set_expected_file_size(#)".} ## \
## This may be called immediately after a call to get_document() or some
## related function to specify the expected size of the document we are
## retrieving, if we happen to know.  This is used as the return value to
## get_file_size() only in the case that the server does not tell us the
## actual file size.

proc getFileSize*(this: HTTPChannel): clonglong {.importcpp: "#->get_file_size()".} ## \
## Returns the size of the file, if it is known.  Returns the value set by
## set_expected_file_size() if the file size is not known, or 0 if this value
## was not set.
##
## If the file is dynamically generated, the size may not be available until a
## read has started (e.g.  open_read_body() has been called); and even then it
## may increase as more of the file is read due to the nature of HTTP/1.1
## requests which can change their minds midstream about how much data they're
## sending you.

proc isFileSizeKnown*(this: HTTPChannel): bool {.importcpp: "#->is_file_size_known()".} ## \
## Returns true if the size of the file we are currently retrieving was told
## us by the server and thus is reliably known, or false if the size reported
## by get_file_size() represents an educated guess (possibly as set by
## set_expected_file_size(), or as inferred from a chunked transfer encoding
## in progress).

proc getFirstByteRequested*(this: HTTPChannel): clonglong {.importcpp: "#->get_first_byte_requested()".} ## \
## Returns the first byte of the file requested by the request.  This will
## normally be 0 to indicate that the file is being requested from the
## beginning, but if the file was requested via a get_subdocument() call, this
## will contain the first_byte parameter from that call.

proc getLastByteRequested*(this: HTTPChannel): clonglong {.importcpp: "#->get_last_byte_requested()".} ## \
## Returns the last byte of the file requested by the request.  This will
## normally be 0 to indicate that the file is being requested to its last
## byte, but if the file was requested via a get_subdocument() call, this will
## contain the last_byte parameter from that call.

proc getFirstByteDelivered*(this: HTTPChannel): clonglong {.importcpp: "#->get_first_byte_delivered()".} ## \
## Returns the first byte of the file (that will be) delivered by the server
## in response to the current request.  Normally, this is the same as
## get_first_byte_requested(), but some servers will ignore a subdocument
## request and always return the whole file, in which case this value will be
## 0, regardless of what was requested to get_subdocument().

proc getLastByteDelivered*(this: HTTPChannel): clonglong {.importcpp: "#->get_last_byte_delivered()".} ## \
## Returns the last byte of the file (that will be) delivered by the server in
## response to the current request.  Normally, this is the same as
## get_last_byte_requested(), but some servers will ignore a subdocument
## request and always return the whole file, in which case this value will be
## 0, regardless of what was requested to get_subdocument().

proc writeHeaders*(this: HTTPChannel, `out`: ostream) {.importcpp: "#->write_headers(#)".} ## \
## Outputs a list of all headers defined by the server to the indicated output
## stream.

proc reset*(this: HTTPChannel) {.importcpp: "#->reset()".} ## \
## Stops whatever file transaction is currently in progress, closes the
## connection, and resets to begin anew.  You shouldn't ever need to call
## this, since the channel should be able to reset itself cleanly between
## requests, but it is provided in case you are an especially nervous type.
##
## Don't call this after every request unless you set
## set_persistent_connection() to false, since calling reset() rudely closes
## the connection regardless of whether we have told the server we intend to
## keep it open or not.

proc preserveStatus*(this: HTTPChannel) {.importcpp: "#->preserve_status()".} ## \
## Preserves the previous status code (presumably a failure) from the previous
## connection attempt.  If the subsequent connection attempt also fails, the
## returned status code will be the better of the previous code and the
## current code.
##
## This can be called to daisy-chain subsequent attempts to download the same
## document from different servers.  After all servers have been attempted,
## the final status code will reflect the attempt that most nearly succeeded.

proc clearExtraHeaders*(this: HTTPChannel) {.importcpp: "#->clear_extra_headers()".} ## \
## Resets the extra headers that were previously added via calls to
## send_extra_header().

proc sendExtraHeader*(this: HTTPChannel, key: string, value: string) {.importcpp: "#->send_extra_header(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies an additional key: value pair that is added into the header sent
## to the server with the next request.  This is passed along with no
## interpretation by the HTTPChannel code.  You may call this repeatedly to
## append multiple headers.
##
## This is persistent for one request only; it must be set again for each new
## request.

proc getDocument*(this: HTTPChannel, url: DocumentSpec): bool {.importcpp: "#->get_document(#)".} ## \
## Opens the named document for reading, if available.  Returns true if
## successful, false otherwise.

proc getSubdocument*(this: HTTPChannel, url: DocumentSpec, first_byte: clonglong, last_byte: clonglong): bool {.importcpp: "#->get_subdocument(#, #, #)".} ## \
## Retrieves only the specified byte range of the indicated document.  If
## last_byte is 0, it stands for the last byte of the document.  When a
## subdocument is requested, get_file_size() and get_bytes_downloaded() will
## report the number of bytes of the subdocument, not of the complete
## document.

proc getHeader*(this: HTTPChannel, url: DocumentSpec): bool {.importcpp: "#->get_header(#)".} ## \
## Like get_document(), except only the header associated with the document is
## retrieved.  This may be used to test for existence of the document; it
## might also return the size of the document (if the server gives us this
## information).

proc postForm*(this: HTTPChannel, url: DocumentSpec, body: string): bool {.importcpp: "#->post_form(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Posts form data to a particular URL and retrieves the response.

proc putDocument*(this: HTTPChannel, url: DocumentSpec, body: string): bool {.importcpp: "#->put_document(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Uploads the indicated body to the server to replace the indicated URL, if
## the server allows this.

proc deleteDocument*(this: HTTPChannel, url: DocumentSpec): bool {.importcpp: "#->delete_document(#)".} ## \
## Requests the server to remove the indicated URL.

proc getTrace*(this: HTTPChannel, url: DocumentSpec): bool {.importcpp: "#->get_trace(#)".} ## \
## Sends a TRACE message to the server, which should return back the same
## message as the server received it, allowing inspection of proxy hops, etc.

proc connectTo*(this: HTTPChannel, url: DocumentSpec): bool {.importcpp: "#->connect_to(#)".} ## \
## Establish a direct connection to the server and port indicated by the URL,
## but do not issue any HTTP requests.  If successful, the connection may then
## be taken to use for whatever purposes you like by calling get_connection().
##
## This establishes a blocking I/O socket.  Also see begin_connect_to().

proc getOptions*(this: HTTPChannel, url: DocumentSpec): bool {.importcpp: "#->get_options(#)".} ## \
## Sends an OPTIONS message to the server, which should query the available
## options, possibly in relation to a specified URL.

proc beginGetDocument*(this: HTTPChannel, url: DocumentSpec) {.importcpp: "#->begin_get_document(#)".} ## \
## Begins a non-blocking request to retrieve a given document.  This method
## will return immediately, even before a connection to the server has
## necessarily been established; you must then call run() from time to time
## until the return value of run() is false.  Then you may check is_valid()
## and get_status_code() to determine the status of your request.
##
## If a previous request had been pending, that request is discarded.

proc beginGetSubdocument*(this: HTTPChannel, url: DocumentSpec, first_byte: clonglong, last_byte: clonglong) {.importcpp: "#->begin_get_subdocument(#, #, #)".} ## \
## Begins a non-blocking request to retrieve only the specified byte range of
## the indicated document.  If last_byte is 0, it stands for the last byte of
## the document.  When a subdocument is requested, get_file_size() and
## get_bytes_downloaded() will report the number of bytes of the subdocument,
## not of the complete document.

proc beginGetHeader*(this: HTTPChannel, url: DocumentSpec) {.importcpp: "#->begin_get_header(#)".} ## \
## Begins a non-blocking request to retrieve a given header.  See
## begin_get_document() and get_header().

proc beginPostForm*(this: HTTPChannel, url: DocumentSpec, body: string) {.importcpp: "#->begin_post_form(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Posts form data to a particular URL and retrieves the response, all using
## non-blocking I/O.  See begin_get_document() and post_form().
##
## It is important to note that you \*must\* call run() repeatedly after calling
## this method until run() returns false, and you may not call any other
## document posting or retrieving methods using the HTTPChannel object in the
## interim, or your form data may not get posted.

proc run*(this: HTTPChannel): bool {.importcpp: "#->run()".} ## \
## This must be called from time to time when non-blocking I/O is in use.  It
## checks for data coming in on the socket and writes data out to the socket
## when possible, and does whatever processing is required towards completing
## the current task.
##
## The return value is true if the task is still pending (and run() will need
## to be called again in the future), or false if the current task is
## complete.

proc beginConnectTo*(this: HTTPChannel, url: DocumentSpec) {.importcpp: "#->begin_connect_to(#)".} ## \
## Begins a non-blocking request to establish a direct connection to the
## server and port indicated by the URL.  No HTTP requests will be issued
## beyond what is necessary to establish the connection.  When run() has
## finished, you may call is_connection_ready() to determine if the connection
## was successfully established.
##
## If successful, the connection may then be taken to use for whatever
## purposes you like by calling get_connection().
##
## This establishes a nonblocking I/O socket.  Also see connect_to().

proc openReadBody*(this: HTTPChannel): ISocketStream {.importcpp: "#->open_read_body()".} ## \
## Returns a newly-allocated istream suitable for reading the body of the
## document.  This may only be called immediately after a call to
## get_document() or post_form(), or after a call to run() has returned false.
##
## Note that, in nonblocking mode, the returned stream may report an early
## EOF, even before the actual end of file.  When this happens, you should
## call stream->is_closed() to determine whether you should attempt to read
## some more later.
##
## The user is responsible for passing the returned istream to
## close_read_body() later.

proc closeReadBody*(this: HTTPChannel, stream: istream) {.importcpp: "#->close_read_body(#)".} ## \
## Closes a file opened by a previous call to open_read_body().  This really
## just deletes the istream pointer, but it is recommended to use this
## interface instead of deleting it explicitly, to help work around compiler
## issues.

proc downloadToFile*(this: HTTPChannel, filename: Filename, subdocument_resumes: bool): bool {.importcpp: "#->download_to_file(#, #)".} ## \
## Specifies the name of a file to download the resulting document to.  This
## should be called immediately after get_document() or begin_get_document()
## or related functions.
##
## In the case of the blocking I/O methods like get_document(), this function
## will download the entire document to the file and return true if it was
## successfully downloaded, false otherwise.
##
## In the case of non-blocking I/O methods like begin_get_document(), this
## function simply indicates an intention to download to the indicated file.
## It returns true if the file can be opened for writing, false otherwise, but
## the contents will not be completely downloaded until run() has returned
## false.  At this time, it is possible that a communications error will have
## left a partial file, so is_download_complete() may be called to test this.
##
## If subdocument_resumes is true and the document in question was previously
## requested as a subdocument (i.e.  get_subdocument() with a first_byte value
## greater than zero), this will automatically seek to the appropriate byte
## within the file for writing the output.  In this case, the file must
## already exist and must have at least first_byte bytes in it.  If
## subdocument_resumes is false, a subdocument will always be downloaded
## beginning at the first byte of the file.

proc downloadToFile*(this: HTTPChannel, filename: Filename): bool {.importcpp: "#->download_to_file(#)".} ## \
## Specifies the name of a file to download the resulting document to.  This
## should be called immediately after get_document() or begin_get_document()
## or related functions.
##
## In the case of the blocking I/O methods like get_document(), this function
## will download the entire document to the file and return true if it was
## successfully downloaded, false otherwise.
##
## In the case of non-blocking I/O methods like begin_get_document(), this
## function simply indicates an intention to download to the indicated file.
## It returns true if the file can be opened for writing, false otherwise, but
## the contents will not be completely downloaded until run() has returned
## false.  At this time, it is possible that a communications error will have
## left a partial file, so is_download_complete() may be called to test this.
##
## If subdocument_resumes is true and the document in question was previously
## requested as a subdocument (i.e.  get_subdocument() with a first_byte value
## greater than zero), this will automatically seek to the appropriate byte
## within the file for writing the output.  In this case, the file must
## already exist and must have at least first_byte bytes in it.  If
## subdocument_resumes is false, a subdocument will always be downloaded
## beginning at the first byte of the file.

proc downloadToRam*(this: HTTPChannel, ramfile: Ramfile, subdocument_resumes: bool): bool {.importcpp: "#->download_to_ram(#, #)".} ## \
## Specifies a Ramfile object to download the resulting document to.  This
## should be called immediately after get_document() or begin_get_document()
## or related functions.
##
## In the case of the blocking I/O methods like get_document(), this function
## will download the entire document to the Ramfile and return true if it was
## successfully downloaded, false otherwise.
##
## In the case of non-blocking I/O methods like begin_get_document(), this
## function simply indicates an intention to download to the indicated
## Ramfile.  It returns true if the file can be opened for writing, false
## otherwise, but the contents will not be completely downloaded until run()
## has returned false.  At this time, it is possible that a communications
## error will have left a partial file, so is_download_complete() may be
## called to test this.
##
## If subdocument_resumes is true and the document in question was previously
## requested as a subdocument (i.e.  get_subdocument() with a first_byte value
## greater than zero), this will automatically seek to the appropriate byte
## within the Ramfile for writing the output.  In this case, the Ramfile must
## already have at least first_byte bytes in it.

proc downloadToRam*(this: HTTPChannel, ramfile: Ramfile): bool {.importcpp: "#->download_to_ram(#)".} ## \
## Specifies a Ramfile object to download the resulting document to.  This
## should be called immediately after get_document() or begin_get_document()
## or related functions.
##
## In the case of the blocking I/O methods like get_document(), this function
## will download the entire document to the Ramfile and return true if it was
## successfully downloaded, false otherwise.
##
## In the case of non-blocking I/O methods like begin_get_document(), this
## function simply indicates an intention to download to the indicated
## Ramfile.  It returns true if the file can be opened for writing, false
## otherwise, but the contents will not be completely downloaded until run()
## has returned false.  At this time, it is possible that a communications
## error will have left a partial file, so is_download_complete() may be
## called to test this.
##
## If subdocument_resumes is true and the document in question was previously
## requested as a subdocument (i.e.  get_subdocument() with a first_byte value
## greater than zero), this will automatically seek to the appropriate byte
## within the Ramfile for writing the output.  In this case, the Ramfile must
## already have at least first_byte bytes in it.

proc downloadToStream*(this: HTTPChannel, strm: ostream, subdocument_resumes: bool): bool {.importcpp: "#->download_to_stream(#, #)".} ## \
## Specifies the name of an ostream to download the resulting document to.
## This should be called immediately after get_document() or
## begin_get_document() or related functions.
##
## In the case of the blocking I/O methods like get_document(), this function
## will download the entire document to the file and return true if it was
## successfully downloaded, false otherwise.
##
## In the case of non-blocking I/O methods like begin_get_document(), this
## function simply indicates an intention to download to the indicated file.
## It returns true if the file can be opened for writing, false otherwise, but
## the contents will not be completely downloaded until run() has returned
## false.  At this time, it is possible that a communications error will have
## left a partial file, so is_download_complete() may be called to test this.
##
## If subdocument_resumes is true and the document in question was previously
## requested as a subdocument (i.e.  get_subdocument() with a first_byte value
## greater than zero), this will automatically seek to the appropriate byte
## within the file for writing the output.  In this case, the file must
## already exist and must have at least first_byte bytes in it.  If
## subdocument_resumes is false, a subdocument will always be downloaded
## beginning at the first byte of the file.

proc downloadToStream*(this: HTTPChannel, strm: ostream): bool {.importcpp: "#->download_to_stream(#)".} ## \
## Specifies the name of an ostream to download the resulting document to.
## This should be called immediately after get_document() or
## begin_get_document() or related functions.
##
## In the case of the blocking I/O methods like get_document(), this function
## will download the entire document to the file and return true if it was
## successfully downloaded, false otherwise.
##
## In the case of non-blocking I/O methods like begin_get_document(), this
## function simply indicates an intention to download to the indicated file.
## It returns true if the file can be opened for writing, false otherwise, but
## the contents will not be completely downloaded until run() has returned
## false.  At this time, it is possible that a communications error will have
## left a partial file, so is_download_complete() may be called to test this.
##
## If subdocument_resumes is true and the document in question was previously
## requested as a subdocument (i.e.  get_subdocument() with a first_byte value
## greater than zero), this will automatically seek to the appropriate byte
## within the file for writing the output.  In this case, the file must
## already exist and must have at least first_byte bytes in it.  If
## subdocument_resumes is false, a subdocument will always be downloaded
## beginning at the first byte of the file.

proc getConnection*(this: HTTPChannel): SocketStream {.importcpp: "#->get_connection()".} ## \
## Returns the connection that was established via a previous call to
## connect_to() or begin_connect_to(), or NULL if the connection attempt
## failed or if those methods have not recently been called.
##
## This stream has been allocated from the free store.  It is the user's
## responsibility to delete this pointer when finished with it.

proc getBytesDownloaded*(this: HTTPChannel): clonglong {.importcpp: "#->get_bytes_downloaded()".} ## \
## Returns the number of bytes downloaded during the last (or current)
## download_to_file() or download_to_ram operation().  This can be used in
## conjunction with get_file_size() to report the percent complete (but be
## careful, since get_file_size() may return 0 if the server has not told us
## the size of the file).

proc getBytesRequested*(this: HTTPChannel): clonglong {.importcpp: "#->get_bytes_requested()".} ## \
## When download throttling is in effect (set_download_throttle() has been set
## to true) and non-blocking I/O methods (like begin_get_document()) are used,
## this returns the number of bytes "requested" from the server so far: that
## is, the theoretical maximum value for get_bytes_downloaded(), if the server
## has been keeping up with our demand.
##
## If this number is less than get_bytes_downloaded(), then the server has not
## been supplying bytes fast enough to meet our own download throttle rate.
##
## When download throttling is not in effect, or when the blocking I/O methods
## (like get_document(), etc.) are used, this returns 0.

proc isDownloadComplete*(this: HTTPChannel): bool {.importcpp: "#->is_download_complete()".} ## \
## Returns true when a download_to() or download_to_ram() has executed and the
## file has been fully downloaded.  If this still returns false after
## processing has completed, there was an error in transmission.
##
## Note that simply testing is_download_complete() does not prove that the
## requested document was successfully retrieved--you might have just
## downloaded the "404 not found" stub (for instance) that a server would
## provide in response to some error condition.  You should also check
## is_valid() to prove that the file you expected has been successfully
## retrieved.

converter getClassType*(_: typedesc[HTTPChannel]): TypeHandle {.importcpp: "HTTPChannel::get_class_type()", header: "httpChannel.h".}

proc newHTTPChannel*(param0: HTTPChannel): HTTPChannel {.importcpp: "new HTTPChannel(#)".}

proc initDecompressor*(): Decompressor {.importcpp: "Decompressor()".}

proc initDecompressor*(param0: Decompressor): Decompressor {.importcpp: "Decompressor(#)".}

proc initiate*(this: Decompressor, source_file: Filename): int {.importcpp: "#.initiate(#)".} ## \
## Begins a background decompression of the named file (whose filename must
## end in ".pz") to a new file without the .pz extension.  The source file is
## removed after successful completion.

proc initiate*(this: Decompressor, source_file: Filename, dest_file: Filename): int {.importcpp: "#.initiate(#, #)".} ## \
## Begins a background decompression from the named source file to the named
## destination file.  The source file is removed after successful completion.

proc run*(this: Decompressor): int {.importcpp: "#.run()".} ## \
## Called each frame to do the next bit of work in the background task.
## Returns EU_ok if a chunk is completed but there is more to go, or
## EU_success when we're all done.  Any other return value indicates an error.

proc decompress*(this: Decompressor, source_file: Filename): bool {.importcpp: "#.decompress(#)".} ## \
## Performs a foreground decompression of the named file; does not return
## until the decompression is complete.

proc decompress*(this: Decompressor, source_and_dest_file: Ramfile): bool {.importcpp: "#.decompress(#)".} ## \
## Does an in-memory decompression of the indicated Ramfile.  The decompressed
## contents are written back into the same Ramfile on completion.

proc getProgress*(this: Decompressor): float32 {.importcpp: "#.get_progress()".} ## \
## Returns the ratio through the decompression step in the background.

proc initDownloadDb*(): DownloadDb {.importcpp: "DownloadDb()".} ## \
## Primarily used for testing.

proc initDownloadDb*(param0: DownloadDb): DownloadDb {.importcpp: "DownloadDb(#)".}

proc initDownloadDb*(server_file: Filename, client_file: Filename): DownloadDb {.importcpp: "DownloadDb(#, #)".} ## \
## Create a download db with these client and server dbs

proc initDownloadDb*(server_file: Ramfile, client_file: Filename): DownloadDb {.importcpp: "DownloadDb(#, #)".} ## \
## Create a download db with these client and server dbs

proc output*(this: DownloadDb, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: DownloadDb, `out`: ostream) {.importcpp: "#.write(#)".}

proc writeVersionMap*(this: DownloadDb, `out`: ostream) {.importcpp: "#.write_version_map(#)".}

proc writeClientDb*(this: DownloadDb, file: Filename): bool {.importcpp: "#.write_client_db(#)".} ## \
## Write a database file

proc writeServerDb*(this: DownloadDb, file: Filename): bool {.importcpp: "#.write_server_db(#)".}

proc getClientNumMultifiles*(this: DownloadDb): int {.importcpp: "#.get_client_num_multifiles()".}

proc getServerNumMultifiles*(this: DownloadDb): int {.importcpp: "#.get_server_num_multifiles()".}

proc getClientMultifileName*(this: DownloadDb, index: int): string {.importcpp: "nimStringFromStdString(#.get_client_multifile_name(#))", header: stringConversionCode.}

proc getServerMultifileName*(this: DownloadDb, index: int): string {.importcpp: "nimStringFromStdString(#.get_server_multifile_name(#))", header: stringConversionCode.}

proc getClientMultifileSize*(this: DownloadDb, mfname: string): int {.importcpp: "#.get_client_multifile_size(nimStringToStdString(#))", header: stringConversionCode.}

proc setClientMultifileSize*(this: DownloadDb, mfname: string, size: int) {.importcpp: "#.set_client_multifile_size(nimStringToStdString(#), #)", header: stringConversionCode.}

proc setClientMultifileDeltaSize*(this: DownloadDb, mfname: string, size: int): int {.importcpp: "#.set_client_multifile_delta_size(nimStringToStdString(#), #)", header: stringConversionCode.}

proc getServerMultifileSize*(this: DownloadDb, mfname: string): int {.importcpp: "#.get_server_multifile_size(nimStringToStdString(#))", header: stringConversionCode.}

proc setServerMultifileSize*(this: DownloadDb, mfname: string, size: int) {.importcpp: "#.set_server_multifile_size(nimStringToStdString(#), #)", header: stringConversionCode.}

proc getClientMultifilePhase*(this: DownloadDb, mfname: string): float32 {.importcpp: "#.get_client_multifile_phase(nimStringToStdString(#))", header: stringConversionCode.}

proc getServerMultifilePhase*(this: DownloadDb, mfname: string): float32 {.importcpp: "#.get_server_multifile_phase(nimStringToStdString(#))", header: stringConversionCode.}

proc setClientMultifileIncomplete*(this: DownloadDb, mfname: string) {.importcpp: "#.set_client_multifile_incomplete(nimStringToStdString(#))", header: stringConversionCode.}

proc setClientMultifileComplete*(this: DownloadDb, mfname: string) {.importcpp: "#.set_client_multifile_complete(nimStringToStdString(#))", header: stringConversionCode.}

proc setClientMultifileDecompressed*(this: DownloadDb, mfname: string) {.importcpp: "#.set_client_multifile_decompressed(nimStringToStdString(#))", header: stringConversionCode.}

proc setClientMultifileExtracted*(this: DownloadDb, mfname: string) {.importcpp: "#.set_client_multifile_extracted(nimStringToStdString(#))", header: stringConversionCode.}

proc getServerNumFiles*(this: DownloadDb, mfname: string): int {.importcpp: "#.get_server_num_files(nimStringToStdString(#))", header: stringConversionCode.}

proc getServerFileName*(this: DownloadDb, mfname: string, index: int): string {.importcpp: "nimStringFromStdString(#.get_server_file_name(nimStringToStdString(#), #))", header: stringConversionCode.}

proc clientMultifileExists*(this: DownloadDb, mfname: string): bool {.importcpp: "#.client_multifile_exists(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Queries from the Launcher

proc clientMultifileComplete*(this: DownloadDb, mfname: string): bool {.importcpp: "#.client_multifile_complete(nimStringToStdString(#))", header: stringConversionCode.} ## \
## A multifile is complete when it is completely downloaded.  Note: it may
## already be decompressed or extracted and it is still complete

proc clientMultifileDecompressed*(this: DownloadDb, mfname: string): bool {.importcpp: "#.client_multifile_decompressed(nimStringToStdString(#))", header: stringConversionCode.}

proc clientMultifileExtracted*(this: DownloadDb, mfname: string): bool {.importcpp: "#.client_multifile_extracted(nimStringToStdString(#))", header: stringConversionCode.}

proc getClientMultifileHash*(this: DownloadDb, mfname: string): HashVal {.importcpp: "#.get_client_multifile_hash(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Return the hash value of the file we are working on

proc setClientMultifileHash*(this: DownloadDb, mfname: string, val: HashVal) {.importcpp: "#.set_client_multifile_hash(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Set the hash value of file we are working on

proc getServerMultifileHash*(this: DownloadDb, mfname: string): HashVal {.importcpp: "#.get_server_multifile_hash(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Return the hash value of the server file

proc setServerMultifileHash*(this: DownloadDb, mfname: string, val: HashVal) {.importcpp: "#.set_server_multifile_hash(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Set the hash value of file we are working on

proc deleteClientMultifile*(this: DownloadDb, mfname: string) {.importcpp: "#.delete_client_multifile(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Operations on multifiles

proc addClientMultifile*(this: DownloadDb, server_mfname: string) {.importcpp: "#.add_client_multifile(nimStringToStdString(#))", header: stringConversionCode.}

proc expandClientMultifile*(this: DownloadDb, mfname: string) {.importcpp: "#.expand_client_multifile(nimStringToStdString(#))", header: stringConversionCode.}

proc createNewServerDb*(this: DownloadDb) {.importcpp: "#.create_new_server_db()".} ## \
## Used on the server side makefiles to create a new clean server db

proc serverAddMultifile*(this: DownloadDb, mfname: string, phase: float32, size: int, status: int) {.importcpp: "#.server_add_multifile(nimStringToStdString(#), #, #, #)", header: stringConversionCode.}

proc serverAddFile*(this: DownloadDb, mfname: string, fname: string) {.importcpp: "#.server_add_file(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc addVersion*(this: DownloadDb, name: Filename, hash: HashVal, version: int) {.importcpp: "#.add_version(#, #, #)".} ## \
## Appends a new version of the file onto the end of the list, or changes the
## hash associated with a version previously added.
##
## Note: version numbers start at 1

proc insertNewVersion*(this: DownloadDb, name: Filename, hash: HashVal) {.importcpp: "#.insert_new_version(#, #)".} ## \
## Inserts a new version 1 copy of the file, sliding all the other versions up
## by one.

proc hasVersion*(this: DownloadDb, name: Filename): bool {.importcpp: "#.has_version(#)".} ## \
## Returns true if the indicated file has version information, false
## otherwise.  Some files recorded in the database may not bother to track
## versions.

proc getNumVersions*(this: DownloadDb, name: Filename): int {.importcpp: "#.get_num_versions(#)".} ## \
## Returns the number of versions stored for the indicated file.

proc setNumVersions*(this: DownloadDb, name: Filename, num_versions: int) {.importcpp: "#.set_num_versions(#, #)".} ## \
## Reduces the number of versions of a particular file stored in the ddb by
## throwing away all versions higher than the indicated index.

proc getVersion*(this: DownloadDb, name: Filename, hash: HashVal): int {.importcpp: "#.get_version(#, #)".} ## \
## Returns the version number of this particular file, determined by looking
## up the hash generated from the file.  Returns -1 if the version number
## cannot be determined.

proc getHash*(this: DownloadDb, name: Filename, version: int): HashVal {.importcpp: "#.get_hash(#, #)".} ## \
## Returns the MD5 hash associated with the indicated version of the indicated
## file.

proc checkCrc*(name: Filename): int {.importcpp: "check_crc(#)".}

proc checkAdler*(name: Filename): int {.importcpp: "check_adler(#)".}

proc initExtractor*(): Extractor {.importcpp: "Extractor()".}

proc setMultifile*(this: Extractor, multifile_name: Filename): bool {.importcpp: "#.set_multifile(#)".} ## \
## Specifies the filename of the Multifile that the Extractor will read.
## Returns true on success, false if the mulifile name is invalid.

proc setExtractDir*(this: Extractor, extract_dir: Filename) {.importcpp: "#.set_extract_dir(#)".} ## \
## Specifies the directory into which all extracted subfiles will be written.
## Relative paths of subfiles within the Multifile will be written as relative
## paths to this directory.

proc reset*(this: Extractor) {.importcpp: "#.reset()".} ## \
## Interrupts the Extractor in the middle of its business and makes it ready
## to accept a new list of subfiles to extract.

proc requestSubfile*(this: Extractor, subfile_name: Filename): bool {.importcpp: "#.request_subfile(#)".} ## \
## Requests a particular subfile to be extracted when step() or run() is
## called.  Returns true if the subfile exists, false otherwise.

proc requestAllSubfiles*(this: Extractor): int {.importcpp: "#.request_all_subfiles()".} ## \
## Requests all subfiles in the Multifile to be extracted.  Returns the number
## requested.

proc step*(this: Extractor): int {.importcpp: "#.step()".} ## \
## After all of the requests have been made via request_file() or
## request_all_subfiles(), call step() repeatedly until it stops returning
## EU_ok.
##
## step() extracts the next small unit of data from the Multifile.  Returns
## EU_ok if progress is continuing, EU_error_abort if there is a problem, or
## EU_success when the last piece has been extracted.
##
## Also see run().

proc getProgress*(this: Extractor): float32 {.importcpp: "#.get_progress()".} ## \
## Returns the fraction of the Multifile extracted so far.

proc run*(this: Extractor): bool {.importcpp: "#.run()".} ## \
## A convenience function to extract the Multifile all at once, when you don't
## care about doing it in the background.
##
## First, call request_file() or request_all_files() to specify the files you
## would like to extract, then call run() to do the extraction.  Also see
## step() for when you would like the extraction to happen as a background
## task.

proc initMultiplexStream*(): MultiplexStream {.importcpp: "MultiplexStream()".}

proc addOstream*(this: MultiplexStream, `out`: ostream, delete_later: bool) {.importcpp: "#.add_ostream(#, #)".} ## \
## Adds the indicated generic ostream to the multiplex output.  The ostream
## will receive whatever data is sent to the pipe.

proc addOstream*(this: MultiplexStream, `out`: ostream) {.importcpp: "#.add_ostream(#)".} ## \
## Adds the indicated generic ostream to the multiplex output.  The ostream
## will receive whatever data is sent to the pipe.

proc addStandardOutput*(this: MultiplexStream) {.importcpp: "#.add_standard_output()".} ## \
## Adds the standard output channel.

proc addFile*(this: MultiplexStream, file: Filename): bool {.importcpp: "#.add_file(#)".} ## \
## Adds the given file to the multiplex output.  The file is opened in append
## mode with line buffering.  Returns false if the file cannot be opened.

proc addSystemDebug*(this: MultiplexStream) {.importcpp: "#.add_system_debug()".} ## \
## Adds the system debug output the the multiplex output.  This may map to a
## syslog or some such os-specific output system.  It may do nothing on a
## particular system.
##
## Presently, this maps only to OutputDebugString() on Windows.

proc flush*(this: MultiplexStream) {.importcpp: "#.flush()".} ## \
## Forces out all output that hasn't yet been written.

converter getClassType*(_: typedesc[VirtualFileHTTP]): TypeHandle {.importcpp: "VirtualFileHTTP::get_class_type()", header: "virtualFileHTTP.h".}

proc newVirtualFileMountHTTP*(root: URLSpec, http: HTTPClient): VirtualFileMountHTTP {.importcpp: "new VirtualFileMountHTTP(#, #)".}

proc newVirtualFileMountHTTP*(root: URLSpec): VirtualFileMountHTTP {.importcpp: "new VirtualFileMountHTTP(#)".}

proc getHttpClient*(this: VirtualFileMountHTTP): HTTPClient {.importcpp: "#->get_http_client()".} ## \
## Returns the HTTPClient object that services this mount point.

proc getRoot*(this: VirtualFileMountHTTP): URLSpec {.importcpp: "#->get_root()".} ## \
## Returns the URL that represents the root of this mount point.

proc reloadVfsMountUrl*(_: typedesc[VirtualFileMountHTTP]) {.importcpp: "VirtualFileMountHTTP::reload_vfs_mount_url()", header: "virtualFileMountHTTP.h".} ## \
## Reads all of the vfs-mount-url lines in the Config.prc file and replaces
## the mount settings to match them.
##
## This will mount any url's mentioned in the config file, and unmount and
## unmount any url's no longer mentioned in the config file.  Normally, it is
## called automatically at startup, and need not be called again, unless you
## have fiddled with some config settings.

converter getClassType*(_: typedesc[VirtualFileMountHTTP]): TypeHandle {.importcpp: "VirtualFileMountHTTP::get_class_type()", header: "virtualFileMountHTTP.h".}

proc newPatcher*(): Patcher {.importcpp: "new Patcher()".}

proc newPatcher*(param0: Patcher): Patcher {.importcpp: "new Patcher(#)".}

proc newPatcher*(buffer: Buffer): Patcher {.importcpp: "new Patcher(#)".}

proc initiate*(this: Patcher, patch: Filename, infile: Filename): int {.importcpp: "#->initiate(#, #)".}

proc run*(this: Patcher): int {.importcpp: "#->run()".}

proc getProgress*(this: Patcher): float32 {.importcpp: "#->get_progress()".}

proc initStringStream*(): StringStream {.importcpp: "StringStream()".}

proc clearData*(this: StringStream) {.importcpp: "#.clear_data()".} ## \
## Empties the buffer.

proc getDataSize*(this: StringStream): clonglong {.importcpp: "#.get_data_size()".} ## \
## Returns the number of characters available to be read from the data stream.

proc isNull*(this: PointerToVoid): bool {.importcpp: "#.is_null()".} ## \
## Returns true if the PointerTo is a NULL pointer, false otherwise.  (Direct
## comparison to a NULL pointer also works.)

proc getHash*(this: PointerToVoid): clonglong {.importcpp: "#.get_hash()".}

proc isTracking*(_: typedesc[MemoryUsage]): bool {.importcpp: "MemoryUsage::is_tracking()", header: "memoryUsage.h".} ## \
## Returns true if the MemoryUsage object is currently tracking memory (e.g.
## track-memory-usage is configured #t).

proc isCounting*(_: typedesc[MemoryUsage]): bool {.importcpp: "MemoryUsage::is_counting()", header: "memoryUsage.h".} ## \
## Returns true if the MemoryUsage object is currently at least counting
## memory (e.g.  this is a Windows debug build), even if it's not fully
## tracking it.

proc getCurrentCppSize*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_current_cpp_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes of allocated memory consumed by C++
## objects, not including the memory previously frozen.

proc getTotalCppSize*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_total_cpp_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes of allocated memory consumed by C++
## objects, including the memory previously frozen.

proc getPandaHeapSingleSize*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_panda_heap_single_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes allocated from the heap from code within
## Panda, for individual objects.

proc getPandaHeapArraySize*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_panda_heap_array_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes allocated from the heap from code within
## Panda, for arrays.

proc getPandaHeapOverhead*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_panda_heap_overhead()", header: "memoryUsage.h".} ## \
## Returns the extra bytes allocated from the system that are not immediately
## used for holding allocated objects.  This can only be determined if
## ALTERNATIVE_MALLOC is enabled.

proc getPandaMmapSize*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_panda_mmap_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes allocated from the virtual memory pool
## from code within Panda.

proc getExternalSize*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_external_size()", header: "memoryUsage.h".} ## \
## Returns the total number of bytes of allocated memory in the heap that
## Panda didn't seem to be responsible for.  This includes a few bytes for
## very low-level objects (like ConfigVariables) that cannot use Panda memory
## tracking because they are so very low-level.
##
## This also includes all of the memory that might have been allocated by a
## high-level interpreter, like Python.
##
## This number is only available if Panda is able to hook into the actual heap
## callback.

proc getTotalSize*(_: typedesc[MemoryUsage]): clonglong {.importcpp: "MemoryUsage::get_total_size()", header: "memoryUsage.h".} ## \
## Returns the total size of allocated memory consumed by the process, as
## nearly as can be determined.

proc getNumPointers*(_: typedesc[MemoryUsage]): int {.importcpp: "MemoryUsage::get_num_pointers()", header: "memoryUsage.h".} ## \
## Returns the number of pointers currently active.

proc getPointers*(_: typedesc[MemoryUsage], result: MemoryUsagePointers) {.importcpp: "#MemoryUsage::get_pointers(#)", header: "memoryUsage.h".} ## \
## Fills the indicated MemoryUsagePointers with the set of all pointers
## currently active.

proc getPointersOfType*(_: typedesc[MemoryUsage], result: MemoryUsagePointers, `type`: TypeHandle) {.importcpp: "#MemoryUsage::get_pointers_of_type(#, #)", header: "memoryUsage.h".} ## \
## Fills the indicated MemoryUsagePointers with the set of all pointers of the
## indicated type currently active.

proc getPointersOfAge*(_: typedesc[MemoryUsage], result: MemoryUsagePointers, `from`: float64, to: float64) {.importcpp: "#MemoryUsage::get_pointers_of_age(#, #, #)", header: "memoryUsage.h".} ## \
## Fills the indicated MemoryUsagePointers with the set of all pointers that
## were allocated within the range of the indicated number of seconds ago.

proc getPointersWithZeroCount*(_: typedesc[MemoryUsage], result: MemoryUsagePointers) {.importcpp: "#MemoryUsage::get_pointers_with_zero_count(#)", header: "memoryUsage.h".} ## \
## Fills the indicated MemoryUsagePointers with the set of all currently
## active pointers (that is, pointers allocated since the last call to
## freeze(), and not yet freed) that have a zero reference count.
##
## Generally, an undeleted pointer with a zero reference count means its
## reference count has never been incremented beyond zero (since once it has
## been incremented, the only way it can return to zero would free the
## pointer).  This may include objects that are allocated statically or on the
## stack, which are never intended to be deleted.  Or, it might represent a
## programmer or compiler error.
##
## This function has the side-effect of incrementing each of their reference
## counts by one, thus preventing them from ever being freed--but since they
## hadn't been freed anyway, probably no additional harm is done.

proc freeze*(_: typedesc[MemoryUsage]) {.importcpp: "MemoryUsage::freeze()", header: "memoryUsage.h".} ## \
## 'Freezes' all pointers currently stored so that they are no longer
## reported; only newly allocate pointers from this point on will appear in
## future information requests.  This makes it easier to differentiate between
## continuous leaks and one-time memory allocations.

proc showCurrentTypes*(_: typedesc[MemoryUsage]) {.importcpp: "MemoryUsage::show_current_types()", header: "memoryUsage.h".} ## \
## Shows the breakdown of types of all of the active pointers.

proc showTrendTypes*(_: typedesc[MemoryUsage]) {.importcpp: "MemoryUsage::show_trend_types()", header: "memoryUsage.h".} ## \
## Shows the breakdown of types of all of the pointers allocated and freed
## since the last call to freeze().

proc showCurrentAges*(_: typedesc[MemoryUsage]) {.importcpp: "MemoryUsage::show_current_ages()", header: "memoryUsage.h".} ## \
## Shows the breakdown of ages of all of the active pointers.

proc showTrendAges*(_: typedesc[MemoryUsage]) {.importcpp: "MemoryUsage::show_trend_ages()", header: "memoryUsage.h".} ## \
## Shows the breakdown of ages of all of the pointers allocated and freed
## since the last call to freeze().

proc initMemoryUsage*(param0: MemoryUsage): MemoryUsage {.importcpp: "MemoryUsage(#)".}

proc getRefCount*(this: ReferenceCount): int {.importcpp: "#->get_ref_count()".} ## \
## Returns the current reference count.

proc unref*(this: ReferenceCount): bool {.importcpp: "#->unref()".} ## \
## Explicitly decrements the reference count.  Note that the object will not
## be implicitly deleted by unref() simply because the reference count drops
## to zero.  (Having a member function delete itself is problematic.) However,
## see the helper function unref_delete().
##
## User code should avoid using ref() and unref() directly, which can result
## in missed reference counts.  Instead, let a PointerTo object manage the
## reference counting automatically.
##
## This function is const, even though it changes the object, because
## generally fiddling with an object's reference count isn't considered part
## of fiddling with the object.  An object might be const in other ways, but
## we still need to accurately count the number of references to it.
##
## The return value is true if the new reference count is nonzero, false if it
## is zero.

proc testRefCountIntegrity*(this: ReferenceCount): bool {.importcpp: "#->test_ref_count_integrity()".} ## \
## Does some easy checks to make sure that the reference count isn't
## completely bogus.  Returns true if ok, false otherwise.

proc testRefCountNonzero*(this: ReferenceCount): bool {.importcpp: "#->test_ref_count_nonzero()".} ## \
## Does some easy checks to make sure that the reference count isn't zero, or
## completely bogus.  Returns true if ok, false otherwise.

converter getClassType*(_: typedesc[ReferenceCount]): TypeHandle {.importcpp: "ReferenceCount::get_class_type()", header: "referenceCount.h".}

proc getLength*(this: Buffer): int {.importcpp: "#->get_length()".}

proc newBuffer*(param0: Buffer): Buffer {.importcpp: "new Buffer(#)".}

proc compressString*(source: string, compression_level: int): string {.importcpp: "nimStringFromStdString(compress_string(nimStringToStdString(#), #))", header: stringConversionCode.}

proc decompressString*(source: string): string {.importcpp: "nimStringFromStdString(decompress_string(nimStringToStdString(#)))", header: stringConversionCode.}

proc compressFile*(source: Filename, dest: Filename, compression_level: int): bool {.importcpp: "compress_file(#, #, #)".}

proc decompressFile*(source: Filename, dest: Filename): bool {.importcpp: "decompress_file(#, #)".}

proc compressStream*(source: istream, dest: ostream, compression_level: int): bool {.importcpp: "compress_stream(#, #, #)".}

proc decompressStream*(source: istream, dest: ostream): bool {.importcpp: "decompress_stream(#, #)".}

proc copyStream*(source: istream, dest: ostream): bool {.importcpp: "copy_stream(#, #)".}

proc addLevel*(this: PStatCollectorForwardBase, level: float64) {.importcpp: "#->add_level(#)".}

proc getNodeRefCount*(this: NodeReferenceCount): int {.importcpp: "#->get_node_ref_count()".} ## \
## Returns the current reference count.

proc nodeRef*(this: NodeReferenceCount) {.importcpp: "#->node_ref()".} ## \
## Explicitly increments the node reference count and the normal reference
## count simultaneously.

proc nodeUnref*(this: NodeReferenceCount): bool {.importcpp: "#->node_unref()".} ## \
## Explicitly decrements the node reference count and the normal reference
## count simultaneously.
##
## The return value is true if the new reference count is nonzero, false if it
## is zero.

proc testRefCountIntegrity*(this: NodeReferenceCount): bool {.importcpp: "#->test_ref_count_integrity()".} ## \
## Does some easy checks to make sure that the reference count isn't
## completely bogus.

proc nodeUnrefOnly*(this: NodeReferenceCount) {.importcpp: "#->node_unref_only()".} ## \
## Decrements the node reference count without affecting the normal reference
## count.  Intended to be called by derived classes only, presumably to
## reimplement node_unref().

converter getClassType*(_: typedesc[NodeReferenceCount]): TypeHandle {.importcpp: "NodeReferenceCount::get_class_type()", header: "nodeReferenceCount.h".}

proc initDatagram*(): Datagram {.importcpp: "Datagram()".}

proc initDatagram*(copy: Datagram): Datagram {.importcpp: "Datagram(#)".}

proc clear*(this: Datagram) {.importcpp: "#.clear()".} ## \
## Resets the datagram to empty, in preparation for building up a new
## datagram.

proc dumpHex*(this: Datagram, `out`: ostream, indent: int) {.importcpp: "#.dump_hex(#, #)".} ## \
## Writes a representation of the entire datagram contents, as a sequence of
## hex (and ASCII) values.

proc dumpHex*(this: Datagram, `out`: ostream) {.importcpp: "#.dump_hex(#)".} ## \
## Writes a representation of the entire datagram contents, as a sequence of
## hex (and ASCII) values.

proc addBool*(this: Datagram, value: bool) {.importcpp: "#.add_bool(#)".} ## \
## Adds a boolean value to the datagram.

proc addInt8*(this: Datagram, value: char) {.importcpp: "#.add_int8(#)".} ## \
## Adds a signed 8-bit integer to the datagram.

proc addUint8*(this: Datagram, value: char) {.importcpp: "#.add_uint8(#)".} ## \
## Adds an unsigned 8-bit integer to the datagram.

proc addInt16*(this: Datagram, value: int) {.importcpp: "#.add_int16(#)".} ## \
## Adds a signed 16-bit integer to the datagram.

proc addInt32*(this: Datagram, value: int) {.importcpp: "#.add_int32(#)".} ## \
## Adds a signed 32-bit integer to the datagram.

proc addInt64*(this: Datagram, value: clonglong) {.importcpp: "#.add_int64(#)".} ## \
## Adds a signed 64-bit integer to the datagram.

proc addUint16*(this: Datagram, value: int) {.importcpp: "#.add_uint16(#)".} ## \
## Adds an unsigned 16-bit integer to the datagram.

proc addUint32*(this: Datagram, value: int) {.importcpp: "#.add_uint32(#)".} ## \
## Adds an unsigned 32-bit integer to the datagram.

proc addUint64*(this: Datagram, value: clonglong) {.importcpp: "#.add_uint64(#)".} ## \
## Adds an unsigned 64-bit integer to the datagram.

proc addFloat32*(this: Datagram, value: float32) {.importcpp: "#.add_float32(#)".} ## \
## Adds a 32-bit single-precision floating-point number to the datagram.
## Since this kind of float is not necessarily portable across different
## architectures, special care is required.

proc addFloat64*(this: Datagram, value: float64) {.importcpp: "#.add_float64(#)".} ## \
## Adds a 64-bit floating-point number to the datagram.

proc addStdfloat*(this: Datagram, value: float32) {.importcpp: "#.add_stdfloat(#)".} ## \
## Adds either a 32-bit or a 64-bit floating-point number, according to
## set_stdfloat_double().

proc addBeInt16*(this: Datagram, value: int) {.importcpp: "#.add_be_int16(#)".} ## \
## These functions pack numbers big-endian, in case that's desired.

proc addBeInt32*(this: Datagram, value: int) {.importcpp: "#.add_be_int32(#)".} ## \
## Adds a signed 32-bit big-endian integer to the datagram.

proc addBeInt64*(this: Datagram, value: clonglong) {.importcpp: "#.add_be_int64(#)".} ## \
## Adds a signed 64-bit big-endian integer to the datagram.

proc addBeUint16*(this: Datagram, value: int) {.importcpp: "#.add_be_uint16(#)".} ## \
## Adds an unsigned 16-bit big-endian integer to the datagram.

proc addBeUint32*(this: Datagram, value: int) {.importcpp: "#.add_be_uint32(#)".} ## \
## Adds an unsigned 32-bit big-endian integer to the datagram.

proc addBeUint64*(this: Datagram, value: clonglong) {.importcpp: "#.add_be_uint64(#)".} ## \
## Adds an unsigned 64-bit big-endian integer to the datagram.

proc addBeFloat32*(this: Datagram, value: float32) {.importcpp: "#.add_be_float32(#)".} ## \
## Adds a 32-bit single-precision big-endian floating-point number to the
## datagram.

proc addBeFloat64*(this: Datagram, value: float64) {.importcpp: "#.add_be_float64(#)".} ## \
## Adds a 64-bit big-endian floating-point number to the datagram.

proc addString*(this: Datagram, str: string) {.importcpp: "#.add_string(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a variable-length string to the datagram.  This actually adds a count
## followed by n bytes.

proc addString32*(this: Datagram, str: string) {.importcpp: "#.add_string32(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a variable-length string to the datagram, using a 32-bit length field
## to allow very long strings.

proc addZString*(this: Datagram, str: string) {.importcpp: "#.add_z_string(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a variable-length string to the datagram, as a NULL-terminated string.

proc addFixedString*(this: Datagram, str: string, size: clonglong) {.importcpp: "#.add_fixed_string(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Adds a fixed-length string to the datagram.  If the string given is less
## than the requested size, this will pad the string out with zeroes; if it is
## greater than the requested size, this will silently truncate the string.

proc addWstring*(this: Datagram, str: string) {.importcpp: "#.add_wstring(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a variable-length wstring to the datagram.

proc padBytes*(this: Datagram, size: clonglong) {.importcpp: "#.pad_bytes(#)".} ## \
## Adds the indicated number of zero bytes to the datagram.

proc getLength*(this: Datagram): clonglong {.importcpp: "#.get_length()".} ## \
## Returns the number of bytes in the datagram.

proc setStdfloatDouble*(this: Datagram, stdfloat_double: bool) {.importcpp: "#.set_stdfloat_double(#)".} ## \
## Changes the stdfloat_double flag, which defines the operation performed by
## add_stdfloat() and DatagramIterator::get_stdfloat().  When this is true,
## add_stdfloat() adds a 64-bit floating-point number; when it is false, it
## adds a 32-bit floating-point number.  The default is based on the
## STDFLOAT_DOUBLE compilation flag.

proc getStdfloatDouble*(this: Datagram): bool {.importcpp: "#.get_stdfloat_double()".} ## \
## Returns the stdfloat_double flag.  See set_stdfloat_double().

proc `==`*(this: Datagram, other: Datagram): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: Datagram, other: Datagram): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: Datagram, other: Datagram): bool {.importcpp: "#.operator <(#)".}

proc output*(this: Datagram, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Write a string representation of this instance to <out>.

proc write*(this: Datagram, `out`: ostream, indent: int) {.importcpp: "#.write(#, #)".} ## \
## Write a string representation of this instance to <out>.

proc write*(this: Datagram, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Write a string representation of this instance to <out>.

converter getClassType*(_: typedesc[Datagram]): TypeHandle {.importcpp: "Datagram::get_class_type()", header: "datagram.h".}

proc getDatagram*(this: DatagramGenerator, data: Datagram): bool {.importcpp: "#->get_datagram(#)".}

proc saveDatagram*(this: DatagramGenerator, info: SubfileInfo): bool {.importcpp: "#->save_datagram(#)".} ## \
## Skips over the next datagram without extracting it, but saves the relevant
## file information in the SubfileInfo object so that its data may be read
## later.  For non-file-based datagram generators, this may mean creating a
## temporary file and copying the contents of the datagram to disk.
##
## Returns true on success, false on failure or if this method is
## unimplemented.

proc isEof*(this: DatagramGenerator): bool {.importcpp: "#->is_eof()".}

proc isError*(this: DatagramGenerator): bool {.importcpp: "#->is_error()".}

proc getFilename*(this: DatagramGenerator): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the filename that provides the source for these datagrams, if any,
## or empty string if the datagrams do not originate from a file on disk.

proc getTimestamp*(this: DatagramGenerator): time_t.Time {.importcpp: "#->get_timestamp()".} ## \
## Returns the on-disk timestamp of the file that was read, at the time it was
## opened, if that is available, or 0 if it is not.

proc getFile*(this: DatagramGenerator): FileReference {.importcpp: "deconstify(#->get_file())", header: deconstifyCode.} ## \
## Returns the FileReference that provides the source for these datagrams, if
## any, or NULL if the datagrams do not originate from a file on disk.

proc getVfile*(this: DatagramGenerator): VirtualFile {.importcpp: "#->get_vfile()".} ## \
## Returns the VirtualFile that provides the source for these datagrams, if
## any, or NULL if the datagrams do not originate from a VirtualFile.

proc getFilePos*(this: DatagramGenerator): clonglong {.importcpp: "#->get_file_pos()".} ## \
## Returns the current file position within the data stream, if any, or 0 if
## the file position is not meaningful or cannot be determined.
##
## For DatagramGenerators that return a meaningful file position, this will be
## pointing to the first byte following the datagram returned after a call to
## get_datagram().

proc initDatagramIterator*(): DatagramIterator {.importcpp: "DatagramIterator()".}

proc initDatagramIterator*(datagram: Datagram, offset: clonglong): DatagramIterator {.importcpp: "DatagramIterator(#, #)".}

converter initDatagramIterator*(datagram: Datagram): DatagramIterator {.importcpp: "DatagramIterator(#)".}

proc initDatagramIterator*(param0: DatagramIterator): DatagramIterator {.importcpp: "DatagramIterator(#)".}

proc getBool*(this: DatagramIterator): bool {.importcpp: "#.get_bool()".} ## \
## Extracts a boolean value.

proc getInt8*(this: DatagramIterator): char {.importcpp: "#.get_int8()".} ## \
## Extracts a signed 8-bit integer.

proc getUint8*(this: DatagramIterator): char {.importcpp: "#.get_uint8()".} ## \
## Extracts an unsigned 8-bit integer.

proc getInt16*(this: DatagramIterator): int {.importcpp: "#.get_int16()".} ## \
## Extracts a signed 16-bit integer.

proc getInt32*(this: DatagramIterator): int {.importcpp: "#.get_int32()".} ## \
## Extracts a signed 32-bit integer.

proc getInt64*(this: DatagramIterator): clonglong {.importcpp: "#.get_int64()".} ## \
## Extracts a signed 64-bit integer.

proc getUint16*(this: DatagramIterator): int {.importcpp: "#.get_uint16()".} ## \
## Extracts an unsigned 16-bit integer.

proc getUint32*(this: DatagramIterator): int {.importcpp: "#.get_uint32()".} ## \
## Extracts an unsigned 32-bit integer.

proc getUint64*(this: DatagramIterator): clonglong {.importcpp: "#.get_uint64()".} ## \
## Extracts an unsigned 64-bit integer.

proc getFloat32*(this: DatagramIterator): float32 {.importcpp: "#.get_float32()".} ## \
## Extracts a 32-bit single-precision floating-point number.

proc getFloat64*(this: DatagramIterator): float64 {.importcpp: "#.get_float64()".} ## \
## Extracts a 64-bit floating-point number.

proc getStdfloat*(this: DatagramIterator): float32 {.importcpp: "#.get_stdfloat()".} ## \
## Extracts either a 32-bit or a 64-bit floating-point number, according to
## Datagram::set_stdfloat_double().

proc getBeInt16*(this: DatagramIterator): int {.importcpp: "#.get_be_int16()".} ## \
## Extracts a signed 16-bit big-endian integer.

proc getBeInt32*(this: DatagramIterator): int {.importcpp: "#.get_be_int32()".} ## \
## Extracts a signed 32-bit big-endian integer.

proc getBeInt64*(this: DatagramIterator): clonglong {.importcpp: "#.get_be_int64()".} ## \
## Extracts a signed 64-bit big-endian integer.

proc getBeUint16*(this: DatagramIterator): int {.importcpp: "#.get_be_uint16()".} ## \
## Extracts an unsigned 16-bit big-endian integer.

proc getBeUint32*(this: DatagramIterator): int {.importcpp: "#.get_be_uint32()".} ## \
## Extracts an unsigned 32-bit big-endian integer.

proc getBeUint64*(this: DatagramIterator): clonglong {.importcpp: "#.get_be_uint64()".} ## \
## Extracts an unsigned 64-bit big-endian integer.

proc getBeFloat32*(this: DatagramIterator): float32 {.importcpp: "#.get_be_float32()".} ## \
## Extracts a 32-bit big-endian single-precision floating-point number.

proc getBeFloat64*(this: DatagramIterator): float64 {.importcpp: "#.get_be_float64()".} ## \
## Extracts a 64-bit big-endian floating-point number.

proc getString*(this: DatagramIterator): string {.importcpp: "nimStringFromStdString(#.get_string())", header: stringConversionCode.} ## \
## Extracts a variable-length string.

proc getString32*(this: DatagramIterator): string {.importcpp: "nimStringFromStdString(#.get_string32())", header: stringConversionCode.} ## \
## Extracts a variable-length string with a 32-bit length field.

proc getZString*(this: DatagramIterator): string {.importcpp: "nimStringFromStdString(#.get_z_string())", header: stringConversionCode.} ## \
## Extracts a variable-length string, as a NULL-terminated string.

proc getFixedString*(this: DatagramIterator, size: clonglong): string {.importcpp: "nimStringFromStdString(#.get_fixed_string(#))", header: stringConversionCode.} ## \
## Extracts a fixed-length string.  However, if a zero byte occurs within the
## string, it marks the end of the string.

proc getWstring*(this: DatagramIterator): string {.importcpp: "nimStringFromStdString(#.get_wstring())", header: stringConversionCode.} ## \
## Extracts a variable-length wstring (with a 32-bit length field).

proc skipBytes*(this: DatagramIterator, size: clonglong) {.importcpp: "#.skip_bytes(#)".} ## \
## Skips over the indicated number of bytes in the datagram.

proc getRemainingSize*(this: DatagramIterator): clonglong {.importcpp: "#.get_remaining_size()".} ## \
## Return the bytes left in the datagram.

proc getDatagram*(this: DatagramIterator): Datagram {.importcpp: "#.get_datagram()".} ## \
## Return the datagram of this iterator.

proc getCurrentIndex*(this: DatagramIterator): clonglong {.importcpp: "#.get_current_index()".} ## \
## Returns the current position within the datagram of the next piece of data
## to extract.

proc output*(this: DatagramIterator, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Write a string representation of this instance to <out>.

proc write*(this: DatagramIterator, `out`: ostream, indent: int) {.importcpp: "#.write(#, #)".} ## \
## Write a string representation of this instance to <out>.

proc write*(this: DatagramIterator, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Write a string representation of this instance to <out>.

converter getClassType*(_: typedesc[DatagramIterator]): TypeHandle {.importcpp: "DatagramIterator::get_class_type()", header: "datagramIterator.h".}

proc putDatagram*(this: DatagramSink, data: Datagram): bool {.importcpp: "#->put_datagram(#)".}

proc copyDatagram*(this: DatagramSink, result: SubfileInfo, filename: Filename): bool {.importcpp: "#->copy_datagram(#, #)".} ## \
## Copies the file data from the entire indicated file (via the vfs) as the
## next datagram.  This is intended to support potentially very large
## datagrams.
##
## Returns true on success, false on failure or if this method is
## unimplemented.  On true, fills "result" with the information that
## references the copied file, if possible.

proc copyDatagram*(this: DatagramSink, result: SubfileInfo, source: SubfileInfo): bool {.importcpp: "#->copy_datagram(#, #)".} ## \
## Copies the file data from the range of the indicated file (outside of the
## vfs) as the next datagram.  This is intended to support potentially very
## large datagrams.
##
## Returns true on success, false on failure or if this method is
## unimplemented.  On true, fills "result" with the information that
## references the copied file, if possible.

proc isError*(this: DatagramSink): bool {.importcpp: "#->is_error()".}

proc flush*(this: DatagramSink) {.importcpp: "#->flush()".}

proc getFilename*(this: DatagramSink): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the filename that provides the target for these datagrams, if any,
## or empty string if the datagrams do not get written to a file on disk.

proc getFile*(this: DatagramSink): FileReference {.importcpp: "deconstify(#->get_file())", header: deconstifyCode.} ## \
## Returns the FileReference that provides the target for these datagrams, if
## any, or NULL if the datagrams do not written to a file on disk.

proc getFilePos*(this: DatagramSink): clonglong {.importcpp: "#->get_file_pos()".} ## \
## Returns the current file position within the data stream, if any, or 0 if
## the file position is not meaningful or cannot be determined.
##
## For DatagramSinks that return a meaningful file position, this will be
## pointing to the first byte following the datagram returned after a call to
## put_datagram().

converter upcastToTypedObject*(this: TypedReferenceCount): TypedObject {.importcpp: "((TypedObject *)(TypedReferenceCount *)(#))".}

converter upcastToReferenceCount*(this: TypedReferenceCount): ReferenceCount {.importcpp: "(PT(ReferenceCount)(#))".}

converter getClassType*(_: typedesc[TypedReferenceCount]): TypeHandle {.importcpp: "TypedReferenceCount::get_class_type()", header: "typedReferenceCount.h".}

proc newFileReference*(param0: FileReference): FileReference {.importcpp: "new FileReference(#)".}

proc newFileReference*(filename: Filename): FileReference {.importcpp: "new FileReference(#)".}

proc getFilename*(this: FileReference): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the filename of the reference.

converter getClassType*(_: typedesc[FileReference]): TypeHandle {.importcpp: "FileReference::get_class_type()", header: "fileReference.h".}

proc encryptString*(source: string, password: string, algorithm: string, key_length: int, iteration_count: int): string {.importcpp: "nimStringFromStdString(encrypt_string(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#), #, #))", header: stringConversionCode.}

proc encryptString*(source: string, password: string, algorithm: string, key_length: int): string {.importcpp: "nimStringFromStdString(encrypt_string(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#), #))", header: stringConversionCode.}

proc encryptString*(source: string, password: string, algorithm: string): string {.importcpp: "nimStringFromStdString(encrypt_string(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#)))", header: stringConversionCode.}

proc encryptString*(source: string, password: string): string {.importcpp: "nimStringFromStdString(encrypt_string(nimStringToStdString(#), nimStringToStdString(#)))", header: stringConversionCode.}

proc decryptString*(source: string, password: string): string {.importcpp: "nimStringFromStdString(decrypt_string(nimStringToStdString(#), nimStringToStdString(#)))", header: stringConversionCode.}

proc encryptFile*(source: Filename, dest: Filename, password: string, algorithm: string, key_length: int, iteration_count: int): bool {.importcpp: "encrypt_file(#, #, nimStringToStdString(#), nimStringToStdString(#), #, #)", header: stringConversionCode.}

proc encryptFile*(source: Filename, dest: Filename, password: string, algorithm: string, key_length: int): bool {.importcpp: "encrypt_file(#, #, nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc encryptFile*(source: Filename, dest: Filename, password: string, algorithm: string): bool {.importcpp: "encrypt_file(#, #, nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc encryptFile*(source: Filename, dest: Filename, password: string): bool {.importcpp: "encrypt_file(#, #, nimStringToStdString(#))", header: stringConversionCode.}

proc decryptFile*(source: Filename, dest: Filename, password: string): bool {.importcpp: "decrypt_file(#, #, nimStringToStdString(#))", header: stringConversionCode.}

proc encryptStream*(source: istream, dest: ostream, password: string, algorithm: string, key_length: int, iteration_count: int): bool {.importcpp: "encrypt_stream(#, #, nimStringToStdString(#), nimStringToStdString(#), #, #)", header: stringConversionCode.}

proc encryptStream*(source: istream, dest: ostream, password: string, algorithm: string, key_length: int): bool {.importcpp: "encrypt_stream(#, #, nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc encryptStream*(source: istream, dest: ostream, password: string, algorithm: string): bool {.importcpp: "encrypt_stream(#, #, nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc encryptStream*(source: istream, dest: ostream, password: string): bool {.importcpp: "encrypt_stream(#, #, nimStringToStdString(#))", header: stringConversionCode.}

proc decryptStream*(source: istream, dest: ostream, password: string): bool {.importcpp: "decrypt_stream(#, #, nimStringToStdString(#))", header: stringConversionCode.}

proc errorToText*(err: ErrorUtilCode): string {.importcpp: "nimStringFromStdString(error_to_text(#))", header: stringConversionCode.}

proc getWriteError*(): int {.importcpp: "get_write_error()".}

proc handleSocketError*(): string {.importcpp: "nimStringFromStdString(handle_socket_error())", header: stringConversionCode.}

proc getNetworkError*(): int {.importcpp: "get_network_error()".}

proc initRamfile*(): Ramfile {.importcpp: "Ramfile()".}

proc initRamfile*(param0: Ramfile): Ramfile {.importcpp: "Ramfile(#)".}

proc seek*(this: Ramfile, pos: clonglong) {.importcpp: "#.seek(#)".} ## \
## Moves the data pointer to the indicated byte position.  It is not an error
## to move the pointer past the end of data.

proc tell*(this: Ramfile): clonglong {.importcpp: "#.tell()".} ## \
## Returns the current data pointer position as a byte offset from the
## beginning of the stream.

proc getDataSize*(this: Ramfile): clonglong {.importcpp: "#.get_data_size()".} ## \
## Returns the size of the entire buffer contents.

proc clear*(this: Ramfile) {.importcpp: "#.clear()".} ## \
## Empties the current buffer contents.

proc initHashVal*(): HashVal {.importcpp: "HashVal()".}

proc initHashVal*(copy: HashVal): HashVal {.importcpp: "HashVal(#)".}

proc `==`*(this: HashVal, other: HashVal): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: HashVal, other: HashVal): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: HashVal, other: HashVal): bool {.importcpp: "#.operator <(#)".}

proc compareTo*(this: HashVal, other: HashVal): int {.importcpp: "#.compare_to(#)".}

proc mergeWith*(this: HashVal, other: HashVal) {.importcpp: "#.merge_with(#)".} ## \
## Generates a new HashVal representing the xor of this one and the other one.

proc outputDec*(this: HashVal, `out`: ostream) {.importcpp: "#.output_dec(#)".} ## \
## Outputs the HashVal as four unsigned decimal integers.

proc inputDec*(this: HashVal, `in`: istream) {.importcpp: "#.input_dec(#)".} ## \
## Inputs the HashVal as four unsigned decimal integers.

proc outputHex*(this: HashVal, `out`: ostream) {.importcpp: "#.output_hex(#)".} ## \
## Outputs the HashVal as a 32-digit hexadecimal number.

proc inputHex*(this: HashVal, `in`: istream) {.importcpp: "#.input_hex(#)".} ## \
## Inputs the HashVal as a 32-digit hexadecimal number.

proc outputBinary*(this: HashVal, `out`: ostream) {.importcpp: "#.output_binary(#)".} ## \
## Outputs the HashVal as a binary stream of bytes in order.  This is not the
## same order generated by write_stream().

proc inputBinary*(this: HashVal, `in`: istream) {.importcpp: "#.input_binary(#)".} ## \
## Inputs the HashVal as a binary stream of bytes in order.  This is not the
## same order expected by read_stream().

proc output*(this: HashVal, `out`: ostream) {.importcpp: "#.output(#)".}

proc asDec*(this: HashVal): string {.importcpp: "nimStringFromStdString(#.as_dec())", header: stringConversionCode.} ## \
## Returns the HashVal as a string with four decimal numbers.

proc setFromDec*(this: HashVal, text: string): bool {.importcpp: "#.set_from_dec(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the HashVal from a string with four decimal numbers.  Returns true if
## valid, false otherwise.

proc asHex*(this: HashVal): string {.importcpp: "nimStringFromStdString(#.as_hex())", header: stringConversionCode.} ## \
## Returns the HashVal as a 32-byte hexadecimal string.

proc setFromHex*(this: HashVal, text: string): bool {.importcpp: "#.set_from_hex(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the HashVal from a 32-byte hexademical string.  Returns true if
## successful, false otherwise.

proc writeDatagram*(this: HashVal, destination: Datagram) {.importcpp: "#.write_datagram(#)".}

proc readDatagram*(this: HashVal, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".}

proc writeStream*(this: HashVal, destination: StreamWriter) {.importcpp: "#.write_stream(#)".}

proc readStream*(this: HashVal, source: StreamReader) {.importcpp: "#.read_stream(#)".}

proc hashFile*(this: HashVal, filename: Filename): bool {.importcpp: "#.hash_file(#)".} ## \
## Generates the hash value from the indicated file.  Returns true on success,
## false if the file cannot be read.  This method is only defined if we have
## the OpenSSL library (which provides md5 functionality) available.

proc hashStream*(this: HashVal, stream: istream): bool {.importcpp: "#.hash_stream(#)".} ## \
## Generates the hash value from the indicated file.  Returns true on success,
## false if the file cannot be read.  This method is only defined if we have
## the OpenSSL library (which provides md5 functionality) available.

proc hashRamfile*(this: HashVal, ramfile: Ramfile) {.importcpp: "#.hash_ramfile(#)".} ## \
## Generates the hash value by hashing the indicated data.  This method is
## only defined if we have the OpenSSL library (which provides md5
## functionality) available.

proc hashString*(this: HashVal, data: string) {.importcpp: "#.hash_string(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Generates the hash value by hashing the indicated data.  This method is
## only defined if we have the OpenSSL library (which provides md5
## functionality) available.

proc hashBuffer*(this: HashVal, buffer: string, length: int) {.importcpp: "#.hash_buffer(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Generates the hash value by hashing the indicated data.  This method is
## only defined if we have the OpenSSL library (which provides md5
## functionality) available.

proc initMemoryUsagePointers*(): MemoryUsagePointers {.importcpp: "MemoryUsagePointers()".}

proc initMemoryUsagePointers*(param0: MemoryUsagePointers): MemoryUsagePointers {.importcpp: "MemoryUsagePointers(#)".}

proc getNumPointers*(this: MemoryUsagePointers): clonglong {.importcpp: "#.get_num_pointers()".} ## \
## Returns the number of pointers in the set.

proc getPointer*(this: MemoryUsagePointers, n: clonglong): ReferenceCount {.importcpp: "#.get_pointer(#)".} ## \
## Returns the nth pointer of the set.

proc getTypedPointer*(this: MemoryUsagePointers, n: clonglong): TypedObject {.importcpp: "#.get_typed_pointer(#)".} ## \
## Returns the nth pointer of the set, typecast to a TypedObject if possible.
## If the pointer is not a TypedObject or if the cast cannot be made, returns
## nullptr.

proc getType*(this: MemoryUsagePointers, n: clonglong): TypeHandle {.importcpp: "#.get_type(#)".} ## \
## Returns the actual type of the nth pointer, if it is known.

proc getTypeName*(this: MemoryUsagePointers, n: clonglong): string {.importcpp: "nimStringFromStdString(#.get_type_name(#))", header: stringConversionCode.} ## \
## Returns the type name of the nth pointer, if it is known.

proc getAge*(this: MemoryUsagePointers, n: clonglong): float64 {.importcpp: "#.get_age(#)".} ## \
## Returns the age of the nth pointer: the number of seconds elapsed between
## the time it was allocated and the time it was added to this set via a call
## to MemoryUsage::get_pointers().

proc clear*(this: MemoryUsagePointers) {.importcpp: "#.clear()".} ## \
## Empties the set of pointers.

proc output*(this: MemoryUsagePointers, `out`: ostream) {.importcpp: "#.output(#)".}

proc initISubStream*(): ISubStream {.importcpp: "ISubStream()".}

proc initISubStream*(source: IStreamWrapper, start: clonglong, `end`: clonglong): ISubStream {.importcpp: "ISubStream(#, #, #)".}

proc open*(this: ISubStream, source: IStreamWrapper, start: clonglong, `end`: clonglong): ISubStream {.importcpp: "#.open(#, #, #)".} ## \
## Starts the SubStream reading from the indicated source, with the first
## character being the character at position "start" within the source, for
## end - start total characters.  The character at "end" within the source
## will never be read; this will appear to be EOF.
##
## If end is zero, it indicates that the ISubStream will continue until the
## end of the source stream.

proc close*(this: ISubStream): ISubStream {.importcpp: "#.close()".} ## \
## Resets the SubStream to empty, but does not actually close the source
## istream.

proc initOSubStream*(): OSubStream {.importcpp: "OSubStream()".}

proc initOSubStream*(dest: OStreamWrapper, start: clonglong, `end`: clonglong, append: bool): OSubStream {.importcpp: "OSubStream(#, #, #, #)".}

proc initOSubStream*(dest: OStreamWrapper, start: clonglong, `end`: clonglong): OSubStream {.importcpp: "OSubStream(#, #, #)".}

proc open*(this: OSubStream, dest: OStreamWrapper, start: clonglong, `end`: clonglong, append: bool): OSubStream {.importcpp: "#.open(#, #, #, #)".} ## \
## Starts the SubStream reading from the indicated dest, with the first
## character being the character at position "start" within the dest, for end
## - start total characters.  The character at "end" within the dest will
## never be read; this will appear to be EOF.
##
## If end is zero, it indicates that the OSubStream will continue until the
## end of the dest stream.

proc open*(this: OSubStream, dest: OStreamWrapper, start: clonglong, `end`: clonglong): OSubStream {.importcpp: "#.open(#, #, #)".} ## \
## Starts the SubStream reading from the indicated dest, with the first
## character being the character at position "start" within the dest, for end
## - start total characters.  The character at "end" within the dest will
## never be read; this will appear to be EOF.
##
## If end is zero, it indicates that the OSubStream will continue until the
## end of the dest stream.

proc close*(this: OSubStream): OSubStream {.importcpp: "#.close()".} ## \
## Resets the SubStream to empty, but does not actually close the dest
## ostream.

proc initSubStream*(): SubStream {.importcpp: "SubStream()".}

proc initSubStream*(nested: StreamWrapper, start: clonglong, `end`: clonglong, append: bool): SubStream {.importcpp: "SubStream(#, #, #, #)".}

proc initSubStream*(nested: StreamWrapper, start: clonglong, `end`: clonglong): SubStream {.importcpp: "SubStream(#, #, #)".}

proc open*(this: SubStream, nested: StreamWrapper, start: clonglong, `end`: clonglong, append: bool): SubStream {.importcpp: "#.open(#, #, #, #)".} ## \
## Starts the SubStream reading and writing from the indicated nested stream,
## within the indicated range.  "end" is the first character outside of the
## range.
##
## If end is zero, it indicates that the SubStream will continue until the end
## of the nested stream.

proc open*(this: SubStream, nested: StreamWrapper, start: clonglong, `end`: clonglong): SubStream {.importcpp: "#.open(#, #, #)".} ## \
## Starts the SubStream reading and writing from the indicated nested stream,
## within the indicated range.  "end" is the first character outside of the
## range.
##
## If end is zero, it indicates that the SubStream will continue until the end
## of the nested stream.

proc close*(this: SubStream): SubStream {.importcpp: "#.close()".} ## \
## Resets the SubStream to empty, but does not actually close the nested
## ostream.

proc newMultifile*(): Multifile {.importcpp: "new Multifile()".}

proc openRead*(this: Multifile, multifile_name: Filename, offset: clonglong): bool {.importcpp: "#->open_read(#, #)".} ## \
## Opens the named Multifile on disk for reading.  The Multifile index is read
## in, and the list of subfiles becomes available; individual subfiles may
## then be extracted or read, but the list of subfiles may not be modified.
##
## Also see the version of open_read() which accepts an istream.  Returns true
## on success, false on failure.

proc openRead*(this: Multifile, multifile_name: Filename): bool {.importcpp: "#->open_read(#)".} ## \
## Opens the named Multifile on disk for reading.  The Multifile index is read
## in, and the list of subfiles becomes available; individual subfiles may
## then be extracted or read, but the list of subfiles may not be modified.
##
## Also see the version of open_read() which accepts an istream.  Returns true
## on success, false on failure.

proc openRead*(this: Multifile, multifile_stream: IStreamWrapper, owns_pointer: bool, offset: clonglong): bool {.importcpp: "#->open_read(#, #, #)".} ## \
## Opens an anonymous Multifile for reading using an istream.  There must be
## seek functionality via seekg() and tellg() on the istream.
##
## If owns_pointer is true, then the Multifile assumes ownership of the stream
## pointer and will delete it when the multifile is closed, including if this
## function returns false.

proc openRead*(this: Multifile, multifile_stream: IStreamWrapper, owns_pointer: bool): bool {.importcpp: "#->open_read(#, #)".} ## \
## Opens an anonymous Multifile for reading using an istream.  There must be
## seek functionality via seekg() and tellg() on the istream.
##
## If owns_pointer is true, then the Multifile assumes ownership of the stream
## pointer and will delete it when the multifile is closed, including if this
## function returns false.

proc openRead*(this: Multifile, multifile_stream: IStreamWrapper): bool {.importcpp: "#->open_read(#)".} ## \
## Opens an anonymous Multifile for reading using an istream.  There must be
## seek functionality via seekg() and tellg() on the istream.
##
## If owns_pointer is true, then the Multifile assumes ownership of the stream
## pointer and will delete it when the multifile is closed, including if this
## function returns false.

proc openWrite*(this: Multifile, multifile_name: Filename): bool {.importcpp: "#->open_write(#)".} ## \
## Opens the named Multifile on disk for writing.  If there already exists a
## file by that name, it is truncated.  The Multifile is then prepared for
## accepting a brand new set of subfiles, which will be written to the
## indicated filename.  Individual subfiles may not be extracted or read.
##
## Also see the version of open_write() which accepts an ostream.  Returns
## true on success, false on failure.

proc openWrite*(this: Multifile, multifile_stream: ostream, owns_pointer: bool): bool {.importcpp: "#->open_write(#, #)".} ## \
## Opens an anonymous Multifile for writing using an ostream.  There must be
## seek functionality via seekp() and tellp() on the pstream.
##
## If owns_pointer is true, then the Multifile assumes ownership of the stream
## pointer and will delete it when the multifile is closed, including if this
## function returns false.

proc openWrite*(this: Multifile, multifile_stream: ostream): bool {.importcpp: "#->open_write(#)".} ## \
## Opens an anonymous Multifile for writing using an ostream.  There must be
## seek functionality via seekp() and tellp() on the pstream.
##
## If owns_pointer is true, then the Multifile assumes ownership of the stream
## pointer and will delete it when the multifile is closed, including if this
## function returns false.

proc openReadWrite*(this: Multifile, multifile_name: Filename): bool {.importcpp: "#->open_read_write(#)".} ## \
## Opens the named Multifile on disk for reading and writing.  If there
## already exists a file by that name, its index is read.  Subfiles may be
## added or removed, and the resulting changes will be written to the named
## file.
##
## Also see the version of open_read_write() which accepts an iostream.
## Returns true on success, false on failure.

proc openReadWrite*(this: Multifile, multifile_stream: iostream, owns_pointer: bool): bool {.importcpp: "#->open_read_write(#, #)".} ## \
## Opens an anonymous Multifile for reading and writing using an iostream.
## There must be seek functionality via seekg()/seekp() and tellg()/tellp() on
## the iostream.
##
## If owns_pointer is true, then the Multifile assumes ownership of the stream
## pointer and will delete it when the multifile is closed, including if this
## function returns false.

proc openReadWrite*(this: Multifile, multifile_stream: iostream): bool {.importcpp: "#->open_read_write(#)".} ## \
## Opens an anonymous Multifile for reading and writing using an iostream.
## There must be seek functionality via seekg()/seekp() and tellg()/tellp() on
## the iostream.
##
## If owns_pointer is true, then the Multifile assumes ownership of the stream
## pointer and will delete it when the multifile is closed, including if this
## function returns false.

proc close*(this: Multifile) {.importcpp: "#->close()".} ## \
## Closes the Multifile if it is open.  All changes are flushed to disk, and
## the file becomes invalid for further operations until the next call to
## open().

proc getMultifileName*(this: Multifile): Filename {.importcpp: "#->get_multifile_name()".} ## \
## Returns the filename of the Multifile, if it is available.

proc setMultifileName*(this: Multifile, multifile_name: Filename) {.importcpp: "#->set_multifile_name(#)".} ## \
## Replaces the filename of the Multifile.  This is primarily used for
## documentation purposes only; changing this name does not open the indicated
## file.  See open_read() or open_write() for that.

proc isReadValid*(this: Multifile): bool {.importcpp: "#->is_read_valid()".} ## \
## Returns true if the Multifile has been opened for read mode and there have
## been no errors, and individual Subfile contents may be extracted.

proc isWriteValid*(this: Multifile): bool {.importcpp: "#->is_write_valid()".} ## \
## Returns true if the Multifile has been opened for write mode and there have
## been no errors, and Subfiles may be added or removed from the Multifile.

proc needsRepack*(this: Multifile): bool {.importcpp: "#->needs_repack()".} ## \
## Returns true if the Multifile index is suboptimal and should be repacked.
## Call repack() to achieve this.

proc getTimestamp*(this: Multifile): time_t.Time {.importcpp: "#->get_timestamp()".} ## \
## Returns the modification timestamp of the overall Multifile.  This
## indicates the most recent date at which subfiles were added or removed from
## the Multifile.  Note that it is logically possible for an individual
## subfile to have a more recent timestamp than the overall timestamp.

proc setTimestamp*(this: Multifile, timestamp: time_t.Time) {.importcpp: "#->set_timestamp(#)".} ## \
## Changes the overall mudification timestamp of the multifile.  Note that this
## will be reset to the current time every time you modify a subfile.
## Only set this if you know what you are doing!

proc setRecordTimestamp*(this: Multifile, record_timestamp: bool) {.importcpp: "#->set_record_timestamp(#)".} ## \
## Sets the flag indicating whether timestamps should be recorded within the
## Multifile or not.  The default is true, indicating the Multifile will
## record timestamps for the overall file and also for each subfile.
##
## If this is false, the Multifile will not record timestamps internally.  In
## this case, the return value from get_timestamp() or get_subfile_timestamp()
## will be estimations.
##
## You may want to set this false to minimize the bitwise difference between
## independently-generated Multifiles.

proc getRecordTimestamp*(this: Multifile): bool {.importcpp: "#->get_record_timestamp()".} ## \
## Returns the flag indicating whether timestamps should be recorded within
## the Multifile or not.  See set_record_timestamp().

proc setScaleFactor*(this: Multifile, scale_factor: clonglong) {.importcpp: "#->set_scale_factor(#)".} ## \
## Changes the internal scale factor for this Multifile.
##
## This is normally 1, but it may be set to any arbitrary value (greater than
## zero) to support Multifile archives that exceed 4GB, if necessary.
## (Individual subfiles may still not exceed 4GB.)
##
## All addresses within the file are rounded up to the next multiple of
## _scale_factor, and zeros are written to the file to fill the resulting
## gaps.  Then the address is divided by _scale_factor and written out as a
## 32-bit integer.  Thus, setting a scale factor of 2 supports up to 8GB
## files, 3 supports 12GB files, etc.
##
## Calling this function on an already-existing Multifile will have no
## immediate effect until a future call to repack() or close() (or until the
## Multifile is destructed).

proc getScaleFactor*(this: Multifile): clonglong {.importcpp: "#->get_scale_factor()".} ## \
## Returns the internal scale factor for this Multifile.  See
## set_scale_factor().

proc setEncryptionFlag*(this: Multifile, flag: bool) {.importcpp: "#->set_encryption_flag(#)".} ## \
## Sets the flag indicating whether subsequently-added subfiles should be
## encrypted before writing them to the multifile.  If true, subfiles will be
## encrypted; if false (the default), they will be written without encryption.
##
## When true, subfiles will be encrypted with the password specified by
## set_encryption_password().  It is possible to apply a different password to
## different files, but the resulting file can't be mounted via VFS.

proc getEncryptionFlag*(this: Multifile): bool {.importcpp: "#->get_encryption_flag()".} ## \
## Returns the flag indicating whether subsequently-added subfiles should be
## encrypted before writing them to the multifile.  See set_encryption_flag().

proc setEncryptionPassword*(this: Multifile, encryption_password: string) {.importcpp: "#->set_encryption_password(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the password that will be used to encrypt subfiles subsequently
## added to the multifile, if the encryption flag is also set true (see
## set_encryption_flag()).
##
## It is possible to apply a different password to different files, but the
## resulting file can't be mounted via VFS.  Changing this value may cause an
## implicit call to flush().

proc getEncryptionPassword*(this: Multifile): string {.importcpp: "nimStringFromStdString(#->get_encryption_password())", header: stringConversionCode.} ## \
## Returns the password that will be used to encrypt subfiles subsequently
## added to the multifile.  See set_encryption_password().

proc setEncryptionAlgorithm*(this: Multifile, encryption_algorithm: string) {.importcpp: "#->set_encryption_algorithm(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the encryption algorithm that should be used for future calls to
## add_subfile().  The default is whatever is specified by the encryption-
## algorithm config variable.  The complete set of available algorithms is
## defined by the current version of OpenSSL.
##
## If an invalid algorithm is specified, there is no immediate error return
## code, but flush() will fail and the file will be invalid.
##
## It is possible to apply a different encryption algorithm to different
## files, and unlike the password, this does not interfere with mounting the
## multifile via VFS.  Changing this value may cause an implicit call to
## flush().

proc getEncryptionAlgorithm*(this: Multifile): string {.importcpp: "nimStringFromStdString(#->get_encryption_algorithm())", header: stringConversionCode.} ## \
## Returns the encryption algorithm that was specified by
## set_encryption_algorithm().

proc setEncryptionKeyLength*(this: Multifile, encryption_key_length: int) {.importcpp: "#->set_encryption_key_length(#)".} ## \
## Specifies the length of the key, in bits, that should be used to encrypt
## the stream in future calls to add_subfile().  The default is whatever is
## specified by the encryption-key-length config variable.
##
## If an invalid key_length for the chosen algorithm is specified, there is no
## immediate error return code, but flush() will fail and the file will be
## invalid.
##
## It is possible to apply a different key length to different files, and
## unlike the password, this does not interfere with mounting the multifile
## via VFS. Changing this value may cause an implicit call to flush().

proc getEncryptionKeyLength*(this: Multifile): int {.importcpp: "#->get_encryption_key_length()".} ## \
## Returns the encryption key length, in bits, that was specified by
## set_encryption_key_length().

proc setEncryptionIterationCount*(this: Multifile, encryption_iteration_count: int) {.importcpp: "#->set_encryption_iteration_count(#)".} ## \
## Specifies the number of times to repeatedly hash the key before writing it
## to the stream in future calls to add_subfile().  Its purpose is to make it
## computationally more expensive for an attacker to search the key space
## exhaustively.  This should be a multiple of 1,000 and should not exceed
## about 65 million; the value 0 indicates just one application of the hashing
## algorithm.
##
## The default is whatever is specified by the multifile-encryption-iteration-
## count config variable.
##
## It is possible to apply a different iteration count to different files, and
## unlike the password, this does not interfere with mounting the multifile
## via VFS.  Changing this value causes an implicit call to flush().

proc getEncryptionIterationCount*(this: Multifile): int {.importcpp: "#->get_encryption_iteration_count()".} ## \
## Returns the value that was specified by set_encryption_iteration_count().

proc addSubfile*(this: Multifile, subfile_name: string, filename: Filename, compression_level: int): string {.importcpp: "nimStringFromStdString(#->add_subfile(nimStringToStdString(#), #, #))", header: stringConversionCode.} ## \
## Adds a file on disk as a subfile to the Multifile.  The file named by
## filename will be read and added to the Multifile at the next call to
## flush().  If there already exists a subfile with the indicated name, it is
## replaced without examining its contents (but see also update_subfile).
##
## Either Filename:::set_binary() or set_text() must have been called
## previously to specify the nature of the source file.  If set_text() was
## called, the text flag will be set on the subfile.
##
## Returns the subfile name on success (it might have been modified slightly),
## or empty string on failure.

proc addSubfile*(this: Multifile, subfile_name: string, subfile_data: istream, compression_level: int): string {.importcpp: "nimStringFromStdString(#->add_subfile(nimStringToStdString(#), #, #))", header: stringConversionCode.} ## \
## Adds a file from a stream as a subfile to the Multifile.  The indicated
## istream will be read and its contents added to the Multifile at the next
## call to flush(). The file will be added as a binary subfile.
##
## Note that the istream must remain untouched and unused by any other code
## until flush() is called.  At that time, the Multifile will read the entire
## contents of the istream from the current file position to the end of the
## file.  Subsequently, the Multifile will \*not\* close or delete the istream.
## It is the caller's responsibility to ensure that the istream pointer does
## not destruct during the lifetime of the Multifile.
##
## Returns the subfile name on success (it might have been modified slightly),
## or empty string on failure.

proc updateSubfile*(this: Multifile, subfile_name: string, filename: Filename, compression_level: int): string {.importcpp: "nimStringFromStdString(#->update_subfile(nimStringToStdString(#), #, #))", header: stringConversionCode.} ## \
## Adds a file on disk to the subfile.  If a subfile already exists with the
## same name, its contents are compared byte-for-byte to the disk file, and it
## is replaced only if it is different; otherwise, the multifile is left
## unchanged.
##
## Either Filename:::set_binary() or set_text() must have been called
## previously to specify the nature of the source file.  If set_text() was
## called, the text flag will be set on the subfile.

proc addSignature*(this: Multifile, certificate: Filename, chain: Filename, pkey: Filename, password: string): bool {.importcpp: "#->add_signature(#, #, #, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a new signature to the Multifile.  This signature associates the
## indicated certificate with the current contents of the Multifile.  When the
## Multifile is read later, the signature will still be present only if the
## Multifile is unchanged; any subsequent changes to the Multifile will
## automatically invalidate and remove the signature.
##
## The chain filename may be empty if the certificate does not require an
## authenticating certificate chain (e.g.  because it is self-signed).
##
## The specified private key must match the certificate, and the Multifile
## must be open in read-write mode.  The private key is only used for
## generating the signature; it is not written to the Multifile and cannot be
## retrieved from the Multifile later.  (However, the certificate \*can\* be
## retrieved from the Multifile later, to identify the entity that created the
## signature.)
##
## This implicitly causes a repack() operation if one is needed.  Returns true
## on success, false on failure.
##
## This flavor of add_signature() reads the certificate and private key from a
## PEM-formatted file, for instance as generated by the openssl command.  If
## the private key file is password-encrypted, the third parameter will be
## used as the password to decrypt it.

proc addSignature*(this: Multifile, certificate: Filename, chain: Filename, pkey: Filename): bool {.importcpp: "#->add_signature(#, #, #)".} ## \
## Adds a new signature to the Multifile.  This signature associates the
## indicated certificate with the current contents of the Multifile.  When the
## Multifile is read later, the signature will still be present only if the
## Multifile is unchanged; any subsequent changes to the Multifile will
## automatically invalidate and remove the signature.
##
## The chain filename may be empty if the certificate does not require an
## authenticating certificate chain (e.g.  because it is self-signed).
##
## The specified private key must match the certificate, and the Multifile
## must be open in read-write mode.  The private key is only used for
## generating the signature; it is not written to the Multifile and cannot be
## retrieved from the Multifile later.  (However, the certificate \*can\* be
## retrieved from the Multifile later, to identify the entity that created the
## signature.)
##
## This implicitly causes a repack() operation if one is needed.  Returns true
## on success, false on failure.
##
## This flavor of add_signature() reads the certificate and private key from a
## PEM-formatted file, for instance as generated by the openssl command.  If
## the private key file is password-encrypted, the third parameter will be
## used as the password to decrypt it.

proc addSignature*(this: Multifile, composite: Filename, password: string): bool {.importcpp: "#->add_signature(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a new signature to the Multifile.  This signature associates the
## indicated certificate with the current contents of the Multifile.  When the
## Multifile is read later, the signature will still be present only if the
## Multifile is unchanged; any subsequent changes to the Multifile will
## automatically invalidate and remove the signature.
##
## This flavor of add_signature() reads the certificate, private key, and
## certificate chain from the same PEM-formatted file.  It takes the first
## private key found as the intended key, and then uses the first certificate
## found that matches that key as the signing certificate.  Any other
## certificates in the file are taken to be part of the chain.

proc addSignature*(this: Multifile, composite: Filename): bool {.importcpp: "#->add_signature(#)".} ## \
## Adds a new signature to the Multifile.  This signature associates the
## indicated certificate with the current contents of the Multifile.  When the
## Multifile is read later, the signature will still be present only if the
## Multifile is unchanged; any subsequent changes to the Multifile will
## automatically invalidate and remove the signature.
##
## This flavor of add_signature() reads the certificate, private key, and
## certificate chain from the same PEM-formatted file.  It takes the first
## private key found as the intended key, and then uses the first certificate
## found that matches that key as the signing certificate.  Any other
## certificates in the file are taken to be part of the chain.

proc getNumSignatures*(this: Multifile): int {.importcpp: "#->get_num_signatures()".} ## \
## Returns the number of matching signatures found on the Multifile.  These
## signatures may be iterated via get_signature() and related methods.
##
## A signature on this list is guaranteed to match the Multifile contents,
## proving that the Multifile has been unmodified since the signature was
## applied.  However, this does not guarantee that the certificate itself is
## actually from who it says it is from; only that it matches the Multifile
## contents.  See validate_signature_certificate() to authenticate a
## particular certificate.

proc getSignatureSubjectName*(this: Multifile, n: int): string {.importcpp: "nimStringFromStdString(#->get_signature_subject_name(#))", header: stringConversionCode.} ## \
## Returns the "subject name" for the nth signature found on the Multifile.
## This is a string formatted according to RFC2253 that should more-or-less
## identify a particular certificate; when paired with the public key (see
## get_signature_public_key()), it can uniquely identify a certificate.  See
## the comments in get_num_signatures().

proc getSignatureFriendlyName*(this: Multifile, n: int): string {.importcpp: "nimStringFromStdString(#->get_signature_friendly_name(#))", header: stringConversionCode.} ## \
## Returns a "friendly name" for the nth signature found on the Multifile.
## This attempts to extract out the most meaningful part of the subject name.
## It returns the emailAddress, if it is defined; otherwise, it returns the
## commonName.
##
## See the comments in get_num_signatures().

proc getSignaturePublicKey*(this: Multifile, n: int): string {.importcpp: "nimStringFromStdString(#->get_signature_public_key(#))", header: stringConversionCode.} ## \
## Returns the public key used for the nth signature found on the Multifile.
## This is encoded in DER form and returned as a string of hex digits.
##
## This can be used, in conjunction with the subject name (see
## get_signature_subject_name()), to uniquely identify a particular
## certificate and its subsequent reissues.  See the comments in
## get_num_signatures().

proc printSignatureCertificate*(this: Multifile, n: int, `out`: ostream) {.importcpp: "#->print_signature_certificate(#, #)".} ## \
## Writes the certificate for the nth signature, in user-readable verbose
## form, to the indicated stream.  See the comments in get_num_signatures().

proc writeSignatureCertificate*(this: Multifile, n: int, `out`: ostream) {.importcpp: "#->write_signature_certificate(#, #)".} ## \
## Writes the certificate for the nth signature, in PEM form, to the indicated
## stream.  See the comments in get_num_signatures().

proc validateSignatureCertificate*(this: Multifile, n: int): int {.importcpp: "#->validate_signature_certificate(#)".} ## \
## Checks that the certificate used for the nth signature is a valid,
## authorized certificate with some known certificate authority.  Returns 0 if
## it is valid, -1 if there is some error, or the corresponding OpenSSL error
## code if it is invalid, out-of-date, or self-signed.

proc flush*(this: Multifile): bool {.importcpp: "#->flush()".} ## \
## Writes all contents of the Multifile to disk.  Until flush() is called,
## add_subfile() and remove_subfile() do not actually do anything to disk.  At
## this point, all of the recently-added subfiles are read and their contents
## are added to the end of the Multifile, and the recently-removed subfiles
## are marked gone from the Multifile.
##
## This may result in a suboptimal index.  To guarantee that the index is
## written at the beginning of the file, call repack() instead of flush().
##
## It is not necessary to call flush() explicitly unless you are concerned
## about reading the recently-added subfiles immediately.
##
## Returns true on success, false on failure.

proc repack*(this: Multifile): bool {.importcpp: "#->repack()".} ## \
## Forces a complete rewrite of the Multifile and all of its contents, so that
## its index will appear at the beginning of the file with all of the subfiles
## listed in alphabetical order.  This is considered optimal for reading, and
## is the standard configuration; but it is not essential to do this.
##
## It is only valid to call this if the Multifile was opened using
## open_read_write() and an explicit filename, rather than an iostream.  Also,
## we must have write permission to the directory containing the Multifile.
##
## Returns true on success, false on failure.

proc getNumSubfiles*(this: Multifile): int {.importcpp: "#->get_num_subfiles()".} ## \
## Returns the number of subfiles within the Multifile.  The subfiles may be
## accessed in alphabetical order by iterating through [0 ..
## get_num_subfiles()).

proc findSubfile*(this: Multifile, subfile_name: string): int {.importcpp: "#->find_subfile(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the index of the subfile with the indicated name, or -1 if the
## named subfile is not within the Multifile.

proc hasDirectory*(this: Multifile, subfile_name: string): bool {.importcpp: "#->has_directory(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if the indicated subfile name is the directory prefix to one
## or more files within the Multifile.  That is, the Multifile contains at
## least one file named "subfile_name/...".

proc removeSubfile*(this: Multifile, index: int) {.importcpp: "#->remove_subfile(#)".} ## \
## Removes the nth subfile from the Multifile.  This will cause all subsequent
## index numbers to decrease by one.  The file will not actually be removed
## from the disk until the next call to flush().
##
## Note that this does not actually remove the data from the indicated
## subfile; it simply removes it from the index.  The Multifile will not be
## reduced in size after this operation, until the next call to repack().

proc removeSubfile*(this: Multifile, subfile_name: string): bool {.importcpp: "#->remove_subfile(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes the named subfile from the Multifile, if it exists; returns true if
## successfully removed, or false if it did not exist in the first place.  The
## file will not actually be removed from the disk until the next call to
## flush().
##
## Note that this does not actually remove the data from the indicated
## subfile; it simply removes it from the index.  The Multifile will not be
## reduced in size after this operation, until the next call to repack().

proc getSubfileName*(this: Multifile, index: int): string {.importcpp: "nimStringFromStdString(#->get_subfile_name(#))", header: stringConversionCode.} ## \
## Returns the name of the nth subfile.

proc getSubfileLength*(this: Multifile, index: int): clonglong {.importcpp: "#->get_subfile_length(#)".} ## \
## Returns the uncompressed data length of the nth subfile.  This might return
## 0 if the subfile has recently been added and flush() has not yet been
## called.

proc getSubfileTimestamp*(this: Multifile, index: int): time_t.Time {.importcpp: "#->get_subfile_timestamp(#)".} ## \
## Returns the modification time of the nth subfile.  If this is called on an
## older .mf file, which did not store individual timestamps in the file (or
## if get_record_timestamp() is false), this will return the modification time
## of the overall multifile.

proc isSubfileCompressed*(this: Multifile, index: int): bool {.importcpp: "#->is_subfile_compressed(#)".} ## \
## Returns true if the indicated subfile has been compressed when stored
## within the archive, false otherwise.

proc isSubfileEncrypted*(this: Multifile, index: int): bool {.importcpp: "#->is_subfile_encrypted(#)".} ## \
## Returns true if the indicated subfile has been encrypted when stored within
## the archive, false otherwise.

proc isSubfileText*(this: Multifile, index: int): bool {.importcpp: "#->is_subfile_text(#)".} ## \
## Returns true if the indicated subfile represents text data, or false if it
## represents binary data.  If the file is text data, it may have been
## processed by end-of-line conversion when it was added.  (But the actual
## bits in the multifile will represent the standard Unix end-of-line
## convention, e.g.  \n instead of \r\n.)

proc getIndexEnd*(this: Multifile): clonglong {.importcpp: "#->get_index_end()".} ## \
## Returns the first byte that is guaranteed to follow any index byte already
## written to disk in the Multifile.
##
## This number is largely meaningless in many cases, but if needs_repack() is
## false, and the file is flushed, this will indicate the number of bytes in
## the header + index.  Everything at this byte position and later will be
## actual data.

proc getSubfileInternalStart*(this: Multifile, index: int): clonglong {.importcpp: "#->get_subfile_internal_start(#)".} ## \
## Returns the starting byte position within the Multifile at which the
## indicated subfile begins.  This may be used, with
## get_subfile_internal_length(), for low-level access to the subfile, but
## usually it is better to use open_read_subfile() instead (which
## automatically decrypts and/or uncompresses the subfile data).

proc getSubfileInternalLength*(this: Multifile, index: int): clonglong {.importcpp: "#->get_subfile_internal_length(#)".} ## \
## Returns the number of bytes the indicated subfile consumes within the
## archive.  For compressed subfiles, this will generally be smaller than
## get_subfile_length(); for encrypted (but noncompressed) subfiles, it may be
## slightly different, for noncompressed and nonencrypted subfiles, it will be
## equal.

proc openReadSubfile*(this: Multifile, index: int): istream {.importcpp: "#->open_read_subfile(#)".} ## \
## Returns an istream that may be used to read the indicated subfile.  You may
## seek() within this istream to your heart's content; even though it will be
## a reference to the already-opened pfstream of the Multifile itself, byte 0
## appears to be the beginning of the subfile and EOF appears to be the end of
## the subfile.
##
## The returned istream will have been allocated via new; you should pass the
## pointer to close_read_subfile() when you are finished with it to delete it
## and release its resources.
##
## Any future calls to repack() or close() (or the Multifile destructor) will
## invalidate all currently open subfile pointers.
##
## The return value will be NULL if the stream cannot be opened for some
## reason.

proc closeReadSubfile*(_: typedesc[Multifile], stream: istream) {.importcpp: "#Multifile::close_read_subfile(#)", header: "multifile.h".} ## \
## Closes a file opened by a previous call to open_read_subfile().  This
## really just deletes the istream pointer, but it is recommended to use this
## interface instead of deleting it explicitly, to help work around compiler
## issues.

proc extractSubfile*(this: Multifile, index: int, filename: Filename): bool {.importcpp: "#->extract_subfile(#, #)".} ## \
## Extracts the nth subfile into a file with the given name.

proc extractSubfileTo*(this: Multifile, index: int, `out`: ostream): bool {.importcpp: "#->extract_subfile_to(#, #)".} ## \
## Extracts the nth subfile to the indicated ostream.

proc compareSubfile*(this: Multifile, index: int, filename: Filename): bool {.importcpp: "#->compare_subfile(#, #)".} ## \
## Performs a byte-for-byte comparison of the indicated file on disk with the
## nth subfile.  Returns true if the files are equivalent, or false if they
## are different (or the file is missing).
##
## If Filename::set_binary() or set_text() has already been called, it
## specifies the nature of the source file.  If this is different from the
## text flag of the subfile, the comparison will always return false.  If this
## has not been specified, it will be set from the text flag of the subfile.

proc output*(this: Multifile, `out`: ostream) {.importcpp: "#->output(#)".}

proc ls*(this: Multifile, `out`: ostream) {.importcpp: "#->ls(#)".} ## \
## Shows a list of all subfiles within the Multifile.

proc ls*(this: Multifile) {.importcpp: "#->ls()".} ## \
## Shows a list of all subfiles within the Multifile.

proc getMagicNumber*(_: typedesc[Multifile]): string {.importcpp: "nimStringFromStdString(Multifile::get_magic_number())", header: "multifile.h".} ## \
## Returns a string with the first n bytes written to a Multifile, to identify
## it as a Multifile.

proc setHeaderPrefix*(this: Multifile, header_prefix: string) {.importcpp: "#->set_header_prefix(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the string which is written to the Multifile before the Multifile
## header.  This string must begin with a hash mark and end with a newline
## character; and if it includes embedded newline characters, each one must be
## followed by a hash mark.  If these conditions are not initially true, the
## string will be modified as necessary to make it so.
##
## This is primarily useful as a simple hack to allow p3d applications to be
## run directly from the command line on Unix-like systems.
##
## The return value is true if successful, or false on failure (for instance,
## because the header prefix violates the above rules).

proc getHeaderPrefix*(this: Multifile): string {.importcpp: "nimStringFromStdString(#->get_header_prefix())", header: stringConversionCode.} ## \
## Returns the string that preceded the Multifile header on the file, if any.
## See set_header_prefix().

proc newNamable*(param0: Namable): Namable {.importcpp: "new Namable(#)".}

proc newNamable*(initial_name: string): Namable {.importcpp: "new Namable(nimStringToStdString(#))", header: stringConversionCode.}

proc newNamable*(): Namable {.importcpp: "new Namable()".}

proc setName*(this: Namable, name: string) {.importcpp: "#->set_name(nimStringToStdString(#))", header: stringConversionCode.}

proc clearName*(this: Namable) {.importcpp: "#->clear_name()".} ## \
## Resets the Namable's name to empty.

proc hasName*(this: Namable): bool {.importcpp: "#->has_name()".} ## \
## Returns true if the Namable has a nonempty name set, false if the name is
## empty.

proc getName*(this: Namable): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.}

proc output*(this: Namable, `out`: ostream) {.importcpp: "#->output(#)".} ## \
## Outputs the Namable.  This function simply writes the name to the output
## stream; most Namable derivatives will probably redefine this.

converter getClassType*(_: typedesc[Namable]): TypeHandle {.importcpp: "Namable::get_class_type()", header: "namable.h".}

proc clearCertificates*(this: OpenSSLWrapper) {.importcpp: "#.clear_certificates()".} ## \
## Removes all the certificates from the global store, including the compiled-
## in certificates loaded from ca_bundle_data.c.  You can add new certificates
## by calling load_certificates().

proc loadCertificates*(this: OpenSSLWrapper, filename: Filename): int {.importcpp: "#.load_certificates(#)".} ## \
## Reads the PEM-formatted certificate(s) (delimited by -----BEGIN
## CERTIFICATE----- and -----END CERTIFICATE-----) from the indicated file and
## adds them to the global store object, retrieved via get_x509_store().
##
## Returns the number of certificates read on success, or 0 on failure.
##
## You should call this only with trusted, locally-stored certificates; not
## with certificates received from an untrusted source.

proc loadCertificatesFromPemRam*(this: OpenSSLWrapper, data: string, data_size: clonglong): int {.importcpp: "#.load_certificates_from_pem_ram(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Reads a chain of trusted certificates from the indicated data buffer and
## adds them to the X509_STORE object.  The data buffer should be PEM-
## formatted.  Returns the number of certificates read on success, or 0 on
## failure.
##
## You should call this only with trusted, locally-stored certificates; not
## with certificates received from an untrusted source.

proc loadCertificatesFromPemRam*(this: OpenSSLWrapper, data: string): int {.importcpp: "#.load_certificates_from_pem_ram(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Reads a chain of trusted certificates from the indicated data buffer and
## adds them to the X509_STORE object.  The data buffer should be PEM-
## formatted.  Returns the number of certificates read on success, or 0 on
## failure.
##
## You should call this only with trusted, locally-stored certificates; not
## with certificates received from an untrusted source.

proc loadCertificatesFromDerRam*(this: OpenSSLWrapper, data: string, data_size: clonglong): int {.importcpp: "#.load_certificates_from_der_ram(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Reads a chain of trusted certificates from the indicated data buffer and
## adds them to the X509_STORE object.  The data buffer should be DER-
## formatted.  Returns the number of certificates read on success, or 0 on
## failure.
##
## You should call this only with trusted, locally-stored certificates; not
## with certificates received from an untrusted source.

proc loadCertificatesFromDerRam*(this: OpenSSLWrapper, data: string): int {.importcpp: "#.load_certificates_from_der_ram(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Reads a chain of trusted certificates from the indicated data buffer and
## adds them to the X509_STORE object.  The data buffer should be DER-
## formatted.  Returns the number of certificates read on success, or 0 on
## failure.
##
## You should call this only with trusted, locally-stored certificates; not
## with certificates received from an untrusted source.

proc notifySslErrors*(this: OpenSSLWrapper) {.importcpp: "#.notify_ssl_errors()".} ## \
## A convenience function that is itself a wrapper around the OpenSSL
## convenience function to output the recent OpenSSL errors.  This function
## sends the error string to express_cat.warning().  If REPORT_OPENSSL_ERRORS
## is not defined, the function does nothing.

proc notifyDebugSslErrors*(this: OpenSSLWrapper) {.importcpp: "#.notify_debug_ssl_errors()".} ## \
## As notify_ssl_errors(), but sends the output to debug instead of warning.

proc getGlobalPtr*(_: typedesc[OpenSSLWrapper]): OpenSSLWrapper {.importcpp: "OpenSSLWrapper::get_global_ptr()", header: "openSSLWrapper.h".}

proc initSubfileInfo*(): SubfileInfo {.importcpp: "SubfileInfo()".}

proc initSubfileInfo*(file: FileReference, start: clonglong, size: clonglong): SubfileInfo {.importcpp: "SubfileInfo(#, #, #)".}

proc initSubfileInfo*(filename: Filename, start: clonglong, size: clonglong): SubfileInfo {.importcpp: "SubfileInfo(#, #, #)".}

proc initSubfileInfo*(copy: SubfileInfo): SubfileInfo {.importcpp: "SubfileInfo(#)".}

proc isEmpty*(this: SubfileInfo): bool {.importcpp: "#.is_empty()".} ## \
## Returns true if this SubfileInfo doesn't define any file, false if it has
## real data.

proc getFile*(this: SubfileInfo): FileReference {.importcpp: "#.get_file()".} ## \
## Returns the FileReference that represents this file.

proc getFilename*(this: SubfileInfo): Filename {.importcpp: "#.get_filename()".} ## \
## A shortcut to the filename.

proc getStart*(this: SubfileInfo): clonglong {.importcpp: "#.get_start()".} ## \
## Returns the offset within the file at which this file data begins.

proc getSize*(this: SubfileInfo): clonglong {.importcpp: "#.get_size()".} ## \
## Returns the number of consecutive bytes, beginning at get_start(), that
## correspond to this file data.

proc output*(this: SubfileInfo, `out`: ostream) {.importcpp: "#.output(#)".}

proc getFileSystem*(this: VirtualFile): VirtualFileSystem {.importcpp: "#->get_file_system()".}

proc getFilename*(this: VirtualFile): Filename {.importcpp: "#->get_filename()".}

proc getOriginalFilename*(this: VirtualFile): Filename {.importcpp: "#->get_original_filename()".} ## \
## Returns the original filename as it was used to locate this VirtualFile.
## This is usually, but not always, the same string returned by
## get_filename().

proc hasFile*(this: VirtualFile): bool {.importcpp: "#->has_file()".} ## \
## Returns true if this file exists, false otherwise.

proc isDirectory*(this: VirtualFile): bool {.importcpp: "#->is_directory()".} ## \
## Returns true if this file represents a directory (and scan_directory() may
## be called), false otherwise.

proc isRegularFile*(this: VirtualFile): bool {.importcpp: "#->is_regular_file()".} ## \
## Returns true if this file represents a regular file (and read_file() may be
## called), false otherwise.

proc isWritable*(this: VirtualFile): bool {.importcpp: "#->is_writable()".} ## \
## Returns true if this file may be written to, which implies write_file() may
## be called (unless it is a directory instead of a regular file).

proc deleteFile*(this: VirtualFile): bool {.importcpp: "#->delete_file()".} ## \
## Attempts to delete this file or directory.  This can remove a single file
## or an empty directory.  It will not remove a nonempty directory.  Returns
## true on success, false on failure.

proc renameFile*(this: VirtualFile, new_file: VirtualFile): bool {.importcpp: "#->rename_file(#)".} ## \
## Attempts to move or rename this file or directory.  If the original file is
## an ordinary file, it will quietly replace any already-existing file in the
## new filename (but not a directory).  If the original file is a directory,
## the new filename must not already exist.
##
## If the file is a directory, the new filename must be within the same mount
## point.  If the file is an ordinary file, the new filename may be anywhere;
## but if it is not within the same mount point then the rename operation is
## automatically performed as a two-step copy-and-delete operation.

proc copyFile*(this: VirtualFile, new_file: VirtualFile): bool {.importcpp: "#->copy_file(#)".} ## \
## Attempts to copy the contents of this file to the indicated file.  Returns
## true on success, false on failure.

proc scanDirectory*(this: VirtualFile): VirtualFileList {.importcpp: "#->scan_directory()".} ## \
## If the file represents a directory (that is, is_directory() returns true),
## this returns the list of files within the directory at the current time.
## Returns NULL if the file is not a directory or if the directory cannot be
## read.

proc output*(this: VirtualFile, `out`: ostream) {.importcpp: "#->output(#)".}

proc ls*(this: VirtualFile, `out`: ostream) {.importcpp: "#->ls(#)".} ## \
## If the file represents a directory, lists its contents.

proc ls*(this: VirtualFile) {.importcpp: "#->ls()".} ## \
## If the file represents a directory, lists its contents.

proc lsAll*(this: VirtualFile, `out`: ostream) {.importcpp: "#->ls_all(#)".} ## \
## If the file represents a directory, recursively lists its contents and
## those of all subdirectories.

proc lsAll*(this: VirtualFile) {.importcpp: "#->ls_all()".} ## \
## If the file represents a directory, recursively lists its contents and
## those of all subdirectories.

proc openReadFile*(this: VirtualFile, auto_unwrap: bool): istream {.importcpp: "#->open_read_file(#)".} ## \
## Opens the file for reading.  Returns a newly allocated istream on success
## (which you should eventually delete when you are done reading). Returns
## NULL on failure.

proc closeReadFile*(this: VirtualFile, stream: istream) {.importcpp: "#->close_read_file(#)".} ## \
## Closes a file opened by a previous call to open_read_file().  This really
## just deletes the istream pointer, but it is recommended to use this
## interface instead of deleting it explicitly, to help work around compiler
## issues.

proc wasReadSuccessful*(this: VirtualFile): bool {.importcpp: "#->was_read_successful()".} ## \
## Call this method after a reading the istream returned by open_read_file()
## to completion.  If it returns true, the file was read completely and
## without error; if it returns false, there may have been some errors or a
## truncated file read.  This is particularly likely if the stream is a
## VirtualFileHTTP.

proc openWriteFile*(this: VirtualFile, auto_wrap: bool, truncate: bool): ostream {.importcpp: "#->open_write_file(#, #)".} ## \
## Opens the file for writing.  Returns a newly allocated ostream on success
## (which you should eventually delete when you are done writing). Returns
## NULL on failure.

proc openAppendFile*(this: VirtualFile): ostream {.importcpp: "#->open_append_file()".} ## \
## Works like open_write_file(), but the file is opened in append mode.  Like
## open_write_file, the returned pointer should eventually be passed to
## close_write_file().

proc closeWriteFile*(this: VirtualFile, stream: ostream) {.importcpp: "#->close_write_file(#)".} ## \
## Closes a file opened by a previous call to open_write_file().  This really
## just deletes the ostream pointer, but it is recommended to use this
## interface instead of deleting it explicitly, to help work around compiler
## issues.

proc openReadWriteFile*(this: VirtualFile, truncate: bool): iostream {.importcpp: "#->open_read_write_file(#)".} ## \
## Opens the file for writing.  Returns a newly allocated iostream on success
## (which you should eventually delete when you are done writing). Returns
## NULL on failure.

proc openReadAppendFile*(this: VirtualFile): iostream {.importcpp: "#->open_read_append_file()".} ## \
## Works like open_read_write_file(), but the file is opened in append mode.
## Like open_read_write_file, the returned pointer should eventually be passed
## to close_read_write_file().

proc closeReadWriteFile*(this: VirtualFile, stream: iostream) {.importcpp: "#->close_read_write_file(#)".} ## \
## Closes a file opened by a previous call to open_read_write_file().  This
## really just deletes the iostream pointer, but it is recommended to use this
## interface instead of deleting it explicitly, to help work around compiler
## issues.

proc getFileSize*(this: VirtualFile): clonglong {.importcpp: "#->get_file_size()".} ## \
## Returns the current size on disk (or wherever it is) of the file before it
## has been opened.

proc getFileSize*(this: VirtualFile, stream: istream): clonglong {.importcpp: "#->get_file_size(#)".} ## \
## Returns the current size on disk (or wherever it is) of the already-open
## file.  Pass in the stream that was returned by open_read_file(); some
## implementations may require this stream to determine the size.

proc getTimestamp*(this: VirtualFile): time_t.Time {.importcpp: "#->get_timestamp()".} ## \
## Returns a time_t value that represents the time the file was last modified,
## to within whatever precision the operating system records this information
## (on a Windows95 system, for instance, this may only be accurate to within 2
## seconds).
##
## If the timestamp cannot be determined, either because it is not supported
## by the operating system or because there is some error (such as file not
## found), returns 0.

proc getSystemInfo*(this: VirtualFile, info: SubfileInfo): bool {.importcpp: "#->get_system_info(#)".} ## \
## Populates the SubfileInfo structure with the data representing where the
## file actually resides on disk, if this is knowable.  Returns true if the
## file might reside on disk, and the info is populated, or false if it does
## not (or it is not known where the file resides), in which case the info is
## meaningless.

converter getClassType*(_: typedesc[VirtualFile]): TypeHandle {.importcpp: "VirtualFile::get_class_type()", header: "virtualFile.h".}

converter getClassType*(_: typedesc[VirtualFileComposite]): TypeHandle {.importcpp: "VirtualFileComposite::get_class_type()", header: "virtualFileComposite.h".}

proc getFileSystem*(this: VirtualFileMount): VirtualFileSystem {.importcpp: "#->get_file_system()".} ## \
## Returns the file system this mount object is attached to.

proc getMountPoint*(this: VirtualFileMount): Filename {.importcpp: "#->get_mount_point()".} ## \
## Returns the name of the directory within the virtual file system that this
## mount object is attached to.  This directory name will end with a slash.

proc getMountFlags*(this: VirtualFileMount): int {.importcpp: "#->get_mount_flags()".} ## \
## Returns the set of flags passed by the user to the
## VirtualFileSystem::mount() command.

proc output*(this: VirtualFileMount, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: VirtualFileMount, `out`: ostream) {.importcpp: "#->write(#)".}

converter getClassType*(_: typedesc[VirtualFileMount]): TypeHandle {.importcpp: "VirtualFileMount::get_class_type()", header: "virtualFileMount.h".}

proc newVirtualFileMountMultifile*(multifile: Multifile): VirtualFileMountMultifile {.importcpp: "new VirtualFileMountMultifile(#)".}

proc getMultifile*(this: VirtualFileMountMultifile): Multifile {.importcpp: "#->get_multifile()".} ## \
## Returns the Multifile pointer that this mount object is based on.

converter getClassType*(_: typedesc[VirtualFileMountMultifile]): TypeHandle {.importcpp: "VirtualFileMountMultifile::get_class_type()", header: "virtualFileMountMultifile.h".}

proc newVirtualFileMountRamdisk*(): VirtualFileMountRamdisk {.importcpp: "new VirtualFileMountRamdisk()".}

converter getClassType*(_: typedesc[VirtualFileMountRamdisk]): TypeHandle {.importcpp: "VirtualFileMountRamdisk::get_class_type()", header: "virtualFileMountRamdisk.h".}

proc newVirtualFileMountSystem*(physical_filename: Filename): VirtualFileMountSystem {.importcpp: "new VirtualFileMountSystem(#)".}

proc getPhysicalFilename*(this: VirtualFileMountSystem): Filename {.importcpp: "#->get_physical_filename()".} ## \
## Returns the name of the source file on the OS filesystem of the directory
## or file that is mounted.

converter getClassType*(_: typedesc[VirtualFileMountSystem]): TypeHandle {.importcpp: "VirtualFileMountSystem::get_class_type()", header: "virtualFileMountSystem.h".}

proc getMount*(this: VirtualFileSimple): VirtualFileMount {.importcpp: "#->get_mount()".} ## \
## Returns the VirtualFileMount this file is associated with.

proc isImplicitPzFile*(this: VirtualFileSimple): bool {.importcpp: "#->is_implicit_pz_file()".} ## \
## Returns true if this file is a .pz file that should be implicitly
## decompressed on load, or false if it is not a .pz file or if it should not
## be decompressed.

converter getClassType*(_: typedesc[VirtualFileSimple]): TypeHandle {.importcpp: "VirtualFileSimple::get_class_type()", header: "virtualFileSimple.h".}

proc newTemporaryFile*(filename: Filename): TemporaryFile {.importcpp: "new TemporaryFile(#)".}

proc newTemporaryFile*(param0: TemporaryFile): TemporaryFile {.importcpp: "new TemporaryFile(#)".}

converter getClassType*(_: typedesc[TemporaryFile]): TypeHandle {.importcpp: "TemporaryFile::get_class_type()", header: "temporaryFile.h".}

proc initIDecompressStream*(): IDecompressStream {.importcpp: "IDecompressStream()".}

proc initIDecompressStream*(source: istream, owns_source: bool): IDecompressStream {.importcpp: "IDecompressStream(#, #)".}

proc open*(this: IDecompressStream, source: istream, owns_source: bool): IDecompressStream {.importcpp: "#.open(#, #)".}

proc close*(this: IDecompressStream): IDecompressStream {.importcpp: "#.close()".} ## \
## Resets the ZStream to empty, but does not actually close the source istream
## unless owns_source was true.

proc initOCompressStream*(): OCompressStream {.importcpp: "OCompressStream()".}

proc initOCompressStream*(dest: ostream, owns_dest: bool, compression_level: int): OCompressStream {.importcpp: "OCompressStream(#, #, #)".}

proc initOCompressStream*(dest: ostream, owns_dest: bool): OCompressStream {.importcpp: "OCompressStream(#, #)".}

proc open*(this: OCompressStream, dest: ostream, owns_dest: bool, compression_level: int): OCompressStream {.importcpp: "#.open(#, #, #)".}

proc open*(this: OCompressStream, dest: ostream, owns_dest: bool): OCompressStream {.importcpp: "#.open(#, #)".}

proc close*(this: OCompressStream): OCompressStream {.importcpp: "#.close()".} ## \
## Resets the ZStream to empty, but does not actually close the dest ostream
## unless owns_dest was true.

proc getNumFiles*(this: VirtualFileList): clonglong {.importcpp: "#->get_num_files()".} ## \
## Returns the number of files in the list.

proc getFile*(this: VirtualFileList, n: clonglong): VirtualFile {.importcpp: "#->get_file(#)".} ## \
## Returns the nth file in the list.

proc `[]`*(this: VirtualFileList, n: clonglong): VirtualFile {.importcpp: "#->operator [](#)".} ## \
## Returns the nth file in the list.

proc size*(this: VirtualFileList): clonglong {.importcpp: "#->size()".} ## \
## Returns the number of files in the list.

proc `+=`*(this: var VirtualFileList, other: VirtualFileList): VirtualFileList {.importcpp: "#->operator +=(#)".}

proc `+`*(this: VirtualFileList, other: VirtualFileList): VirtualFileList {.importcpp: "#->operator +(#)".}

proc newVirtualFileList*(param0: VirtualFileList): VirtualFileList {.importcpp: "new VirtualFileList(#)".}

proc initVirtualFileSystem*(): VirtualFileSystem {.importcpp: "VirtualFileSystem()".}

proc mount*(this: VirtualFileSystem, physical_filename: Filename, mount_point: Filename, flags: int, password: string): bool {.importcpp: "#.mount(#, #, #, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Mounts the indicated system file or directory at the given mount point.  If
## the named file is a directory, mounts the directory.  If the named file is
## a Multifile, mounts it as a Multifile.  Returns true on success, false on
## failure.
##
## A given system directory may be mounted to multiple different mount point,
## and the same mount point may share multiple system directories.  In the
## case of ambiguities (that is, two different files with exactly the same
## full pathname), the most-recently mounted system wins.
##
## The filename specified as the first parameter must refer to a real,
## physical filename on disk; it cannot be a virtual file already appearing
## within the vfs filespace.  However, it is possible to mount such a file;
## see mount_loop() for this.
##
## Note that a mounted VirtualFileSystem directory is fully case-sensitive,
## unlike the native Windows file system, so you must refer to files within
## the virtual file system with exactly the right case.

proc mount*(this: VirtualFileSystem, physical_filename: Filename, mount_point: Filename, flags: int): bool {.importcpp: "#.mount(#, #, #)".} ## \
## Mounts the indicated system file or directory at the given mount point.  If
## the named file is a directory, mounts the directory.  If the named file is
## a Multifile, mounts it as a Multifile.  Returns true on success, false on
## failure.
##
## A given system directory may be mounted to multiple different mount point,
## and the same mount point may share multiple system directories.  In the
## case of ambiguities (that is, two different files with exactly the same
## full pathname), the most-recently mounted system wins.
##
## The filename specified as the first parameter must refer to a real,
## physical filename on disk; it cannot be a virtual file already appearing
## within the vfs filespace.  However, it is possible to mount such a file;
## see mount_loop() for this.
##
## Note that a mounted VirtualFileSystem directory is fully case-sensitive,
## unlike the native Windows file system, so you must refer to files within
## the virtual file system with exactly the right case.

proc mount*(this: VirtualFileSystem, multifile: Multifile, mount_point: Filename, flags: int): bool {.importcpp: "#.mount(#, #, #)".} ## \
## Mounts the indicated Multifile at the given mount point.

proc mount*(this: VirtualFileSystem, mount: VirtualFileMount, mount_point: Filename, flags: int): bool {.importcpp: "#.mount(#, #, #)".} ## \
## Adds the given VirtualFileMount object to the mount list.  This is a lower-
## level function than the other flavors of mount(); it requires you to create
## a VirtualFileMount object specifically.

proc mountLoop*(this: VirtualFileSystem, virtual_filename: Filename, mount_point: Filename, flags: int, password: string): bool {.importcpp: "#.mount_loop(#, #, #, nimStringToStdString(#))", header: stringConversionCode.} ## \
## This is similar to mount(), but it receives the name of a Multifile that
## already appears within the virtual file system.  It can be used to mount a
## Multifile that is itself hosted within a virtually-mounted Multifile.
##
## This interface can also be used to mount physical files (that appear within
## the virtual filespace), but it cannot be used to mount directories.  Use
## mount() if you need to mount a directory.
##
## Note that there is additional overhead, in the form of additional buffer
## copies of the data, for recursively mounting a multifile like this.

proc mountLoop*(this: VirtualFileSystem, virtual_filename: Filename, mount_point: Filename, flags: int): bool {.importcpp: "#.mount_loop(#, #, #)".} ## \
## This is similar to mount(), but it receives the name of a Multifile that
## already appears within the virtual file system.  It can be used to mount a
## Multifile that is itself hosted within a virtually-mounted Multifile.
##
## This interface can also be used to mount physical files (that appear within
## the virtual filespace), but it cannot be used to mount directories.  Use
## mount() if you need to mount a directory.
##
## Note that there is additional overhead, in the form of additional buffer
## copies of the data, for recursively mounting a multifile like this.

proc unmount*(this: VirtualFileSystem, physical_filename: Filename): int {.importcpp: "#.unmount(#)".} ## \
## Unmounts all appearances of the indicated directory name or multifile name
## from the file system.  Returns the number of appearances unmounted.

proc unmount*(this: VirtualFileSystem, multifile: Multifile): int {.importcpp: "#.unmount(#)".} ## \
## Unmounts all appearances of the indicated Multifile from the file system.
## Returns the number of appearances unmounted.

proc unmount*(this: VirtualFileSystem, mount: VirtualFileMount): int {.importcpp: "#.unmount(#)".} ## \
## Unmounts the indicated VirtualFileMount object from the file system.
## Returns the number of appearances unmounted.

proc unmountPoint*(this: VirtualFileSystem, mount_point: Filename): int {.importcpp: "#.unmount_point(#)".} ## \
## Unmounts all systems attached to the given mount point from the file
## system.  Returns the number of appearances unmounted.

proc unmountAll*(this: VirtualFileSystem): int {.importcpp: "#.unmount_all()".} ## \
## Unmounts all files from the file system.  Returns the number of systems
## unmounted.

proc getNumMounts*(this: VirtualFileSystem): int {.importcpp: "#.get_num_mounts()".} ## \
## Returns the number of individual mounts in the system.

proc getMount*(this: VirtualFileSystem, n: int): VirtualFileMount {.importcpp: "#.get_mount(#)".} ## \
## Returns the nth mount in the system.

proc chdir*(this: VirtualFileSystem, new_directory: Filename): bool {.importcpp: "#.chdir(#)".} ## \
## Changes the current directory.  This is used to resolve relative pathnames
## in get_file() and/or find_file().  Returns true if successful, false
## otherwise.

proc getCwd*(this: VirtualFileSystem): Filename {.importcpp: "#.get_cwd()".} ## \
## Returns the current directory name.  See chdir().

proc makeDirectory*(this: VirtualFileSystem, filename: Filename): bool {.importcpp: "#.make_directory(#)".} ## \
## Attempts to create a directory within the file system.  Returns true on
## success, false on failure (for instance, because the parent directory does
## not exist, or is read-only).  If the directory already existed prior to
## this call, returns true.

proc makeDirectoryFull*(this: VirtualFileSystem, filename: Filename): bool {.importcpp: "#.make_directory_full(#)".} ## \
## Attempts to create a directory within the file system.  Will also create
## any intervening directories needed.  Returns true on success, false on
## failure.

proc getFile*(this: VirtualFileSystem, filename: Filename, status_only: bool): VirtualFile {.importcpp: "#.get_file(#, #)".} ## \
## Looks up the file by the indicated name in the file system.  Returns a
## VirtualFile pointer representing the file if it is found, or NULL if it is
## not.
##
## If status_only is true, the file will be checked for existence and length
## and so on, but the returned file's contents cannot be read.  This is an
## optimization which is especially important for certain mount types, for
## instance HTTP, for which opening a file to determine its status is
## substantially less expensive than opening it to read its contents.

proc getFile*(this: VirtualFileSystem, filename: Filename): VirtualFile {.importcpp: "#.get_file(#)".} ## \
## Looks up the file by the indicated name in the file system.  Returns a
## VirtualFile pointer representing the file if it is found, or NULL if it is
## not.
##
## If status_only is true, the file will be checked for existence and length
## and so on, but the returned file's contents cannot be read.  This is an
## optimization which is especially important for certain mount types, for
## instance HTTP, for which opening a file to determine its status is
## substantially less expensive than opening it to read its contents.

proc createFile*(this: VirtualFileSystem, filename: Filename): VirtualFile {.importcpp: "#.create_file(#)".} ## \
## Attempts to create a file by the indicated name in the filesystem, if
## possible, and returns it.  If a file by this name already exists, returns
## the same thing as get_file().  If the filename is located within a read-
## only directory, or the directory doesn't exist, returns NULL.

proc findFile*(this: VirtualFileSystem, filename: Filename, searchpath: DSearchPath, status_only: bool): VirtualFile {.importcpp: "#.find_file(#, #, #)".} ## \
## Uses the indicated search path to find the file within the file system.
## Returns the first occurrence of the file found, or NULL if the file cannot
## be found.

proc findFile*(this: VirtualFileSystem, filename: Filename, searchpath: DSearchPath): VirtualFile {.importcpp: "#.find_file(#, #)".} ## \
## Uses the indicated search path to find the file within the file system.
## Returns the first occurrence of the file found, or NULL if the file cannot
## be found.

proc deleteFile*(this: VirtualFileSystem, filename: Filename): bool {.importcpp: "#.delete_file(#)".} ## \
## Attempts to delete the indicated file or directory.  This can remove a
## single file or an empty directory.  It will not remove a nonempty
## directory.  Returns true on success, false on failure.

proc renameFile*(this: VirtualFileSystem, orig_filename: Filename, new_filename: Filename): bool {.importcpp: "#.rename_file(#, #)".} ## \
## Attempts to move or rename the indicated file or directory.  If the
## original file is an ordinary file, it will quietly replace any already-
## existing file in the new filename (but not a directory).  If the original
## file is a directory, the new filename must not already exist.
##
## If the file is a directory, the new filename must be within the same mount
## point.  If the file is an ordinary file, the new filename may be anywhere;
## but if it is not within the same mount point then the rename operation is
## automatically performed as a two-step copy-and-delete operation.

proc copyFile*(this: VirtualFileSystem, orig_filename: Filename, new_filename: Filename): bool {.importcpp: "#.copy_file(#, #)".} ## \
## Attempts to copy the contents of the indicated file to the indicated file.
## Returns true on success, false on failure.

proc resolveFilename*(this: VirtualFileSystem, filename: Filename, searchpath: DSearchPath, default_extension: string): bool {.importcpp: "#.resolve_filename(#, #, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Searches the given search path for the filename.  If it is found, updates
## the filename to the full pathname found and returns true; otherwise,
## returns false.

proc resolveFilename*(this: VirtualFileSystem, filename: Filename, searchpath: DSearchPath): bool {.importcpp: "#.resolve_filename(#, #)".} ## \
## Searches the given search path for the filename.  If it is found, updates
## the filename to the full pathname found and returns true; otherwise,
## returns false.

proc exists*(this: VirtualFileSystem, filename: Filename): bool {.importcpp: "#.exists(#)".} ## \
## Convenience function; returns true if the named file exists.

proc isDirectory*(this: VirtualFileSystem, filename: Filename): bool {.importcpp: "#.is_directory(#)".} ## \
## Convenience function; returns true if the named file exists and is a
## directory.

proc isRegularFile*(this: VirtualFileSystem, filename: Filename): bool {.importcpp: "#.is_regular_file(#)".} ## \
## Convenience function; returns true if the named file exists and is a
## regular file.

proc scanDirectory*(this: VirtualFileSystem, filename: Filename): VirtualFileList {.importcpp: "#.scan_directory(#)".} ## \
## If the file represents a directory (that is, is_directory() returns true),
## this returns the list of files within the directory at the current time.
## Returns NULL if the file is not a directory or if the directory cannot be
## read.

proc ls*(this: VirtualFileSystem, filename: Filename) {.importcpp: "#.ls(#)".} ## \
## Convenience function; lists the files within the indicated directory.

proc lsAll*(this: VirtualFileSystem, filename: Filename) {.importcpp: "#.ls_all(#)".} ## \
## Convenience function; lists the files within the indicated directory, and
## all files below, recursively.

proc write*(this: VirtualFileSystem, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Print debugging information.  (e.g.  from Python or gdb prompt).

proc getGlobalPtr*(_: typedesc[VirtualFileSystem]): VirtualFileSystem {.importcpp: "VirtualFileSystem::get_global_ptr()", header: "virtualFileSystem.h".} ## \
## Returns the default global VirtualFileSystem.  You may create your own
## personal VirtualFileSystem objects and use them for whatever you like, but
## Panda will attempt to load models and stuff from this default object.
##
## Initially, the global VirtualFileSystem is set up to mount the OS
## filesystem to root; i.e.  it is equivalent to the OS filesystem.  This may
## be subsequently adjusted by the user.

proc openReadFile*(this: VirtualFileSystem, filename: Filename, auto_unwrap: bool): istream {.importcpp: "#.open_read_file(#, #)".} ## \
## Convenience function; returns a newly allocated istream if the file exists
## and can be read, or NULL otherwise.  Does not return an invalid istream.
##
## If auto_unwrap is true, an explicitly-named .pz file is automatically
## decompressed and the decompressed contents are returned.  This is different
## than vfs-implicit-pz, which will automatically decompress a file if the
## extension .pz is \*not\* given.

proc closeReadFile*(_: typedesc[VirtualFileSystem], stream: istream) {.importcpp: "#VirtualFileSystem::close_read_file(#)", header: "virtualFileSystem.h".} ## \
## Closes a file opened by a previous call to open_read_file().  This really
## just deletes the istream pointer, but it is recommended to use this
## interface instead of deleting it explicitly, to help work around compiler
## issues.

proc openWriteFile*(this: VirtualFileSystem, filename: Filename, auto_wrap: bool, truncate: bool): ostream {.importcpp: "#.open_write_file(#, #, #)".} ## \
## Convenience function; returns a newly allocated ostream if the file exists
## and can be written, or NULL otherwise.  Does not return an invalid ostream.
##
## If auto_wrap is true, an explicitly-named .pz file is automatically
## compressed while writing.  If truncate is true, the file is truncated to
## zero length before writing.

proc openAppendFile*(this: VirtualFileSystem, filename: Filename): ostream {.importcpp: "#.open_append_file(#)".} ## \
## Works like open_write_file(), but the file is opened in append mode.  Like
## open_write_file, the returned pointer should eventually be passed to
## close_write_file().

proc closeWriteFile*(_: typedesc[VirtualFileSystem], stream: ostream) {.importcpp: "#VirtualFileSystem::close_write_file(#)", header: "virtualFileSystem.h".} ## \
## Closes a file opened by a previous call to open_write_file().  This really
## just deletes the ostream pointer, but it is recommended to use this
## interface instead of deleting it explicitly, to help work around compiler
## issues.

proc openReadWriteFile*(this: VirtualFileSystem, filename: Filename, truncate: bool): iostream {.importcpp: "#.open_read_write_file(#, #)".} ## \
## Convenience function; returns a newly allocated iostream if the file exists
## and can be written, or NULL otherwise.  Does not return an invalid
## iostream.

proc openReadAppendFile*(this: VirtualFileSystem, filename: Filename): iostream {.importcpp: "#.open_read_append_file(#)".} ## \
## Works like open_read_write_file(), but the file is opened in append mode.
## Like open_read_write_file, the returned pointer should eventually be passed
## to close_read_write_file().

proc closeReadWriteFile*(_: typedesc[VirtualFileSystem], stream: iostream) {.importcpp: "#VirtualFileSystem::close_read_write_file(#)", header: "virtualFileSystem.h".} ## \
## Closes a file opened by a previous call to open_read_write_file().  This
## really just deletes the iostream pointer, but it is recommended to use this
## interface instead of deleting it explicitly, to help work around compiler
## issues.

proc getLongTime*(this: TrueClock): float64 {.importcpp: "#.get_long_time()".} ## \
## get_long_time() returns the most accurate timer we have over a long
## interval.  It may not be very precise for measuring short intervals, but
## it should not drift substantially over the long haul.

proc getShortTime*(this: TrueClock): float64 {.importcpp: "#.get_short_time()".} ## \
## get_short_time() returns the most precise timer we have over a short
## interval.  It may tend to drift over the long haul, but it should have
## lots of digits to measure short intervals very precisely.

proc getShortRawTime*(this: TrueClock): float64 {.importcpp: "#.get_short_raw_time()".} ## \
## get_short_raw_time() is like get_short_time(), but does not apply any
## corrections (e.g.  paranoid-clock) to the result returned by the OS.

proc getErrorCount*(this: TrueClock): int {.importcpp: "#.get_error_count()".} ## \
## Returns the number of clock errors that have been detected.  Each time a
## clock error is detected, in which the value returned by either of the above
## methods is suspect, the value returned by this method will be incremented.
## Applications can monitor this value and react, for instance, by
## resynchronizing their clocks each time this value changes.

proc getGlobalPtr*(_: typedesc[TrueClock]): TrueClock {.importcpp: "TrueClock::get_global_ptr()", header: "trueClock.h".} ## \
## Returns a pointer to the one TrueClock object in the world.

proc setCpuAffinity*(this: TrueClock, mask: int): bool {.importcpp: "#.set_cpu_affinity(#)".}

proc initPatchfile*(): Patchfile {.importcpp: "Patchfile()".} ## \
## Create a patch file and initializes internal data

proc initPatchfile*(buffer: Buffer): Patchfile {.importcpp: "Patchfile(#)".} ## \
## Create patch file with buffer to patch

proc build*(this: Patchfile, file_orig: Filename, file_new: Filename, patch_name: Filename): bool {.importcpp: "#.build(#, #, #)".} ## \
## This implementation uses the "greedy differencing algorithm" described in
## the masters thesis "Differential Compression: A Generalized Solution for
## Binary Files" by Randal C. Burns (p.13). For an original file of size M and
## a new file of size N, this algorithm is O(M) in space and O(M\*N) (worst-
## case) in time.  return false on error

proc readHeader*(this: Patchfile, patch_file: Filename): int {.importcpp: "#.read_header(#)".} ## \
## Opens the patch file for reading, and gets the header information from the
## file but does not begin to do any real work.  This can be used to query the
## data stored in the patch.

proc initiate*(this: Patchfile, patch_file: Filename, file: Filename): int {.importcpp: "#.initiate(#, #)".} ## \
## Set up to apply the patch to the file (original file and patch are
## destroyed in the process).

proc initiate*(this: Patchfile, patch_file: Filename, orig_file: Filename, target_file: Filename): int {.importcpp: "#.initiate(#, #, #)".} ## \
## Set up to apply the patch to the file.  In this form, neither the original
## file nor the patch file are destroyed.

proc run*(this: Patchfile): int {.importcpp: "#.run()".} ## \
## Perform one buffer's worth of patching.
## Returns one of the following values:
## @li @c EU_ok : while patching
## @li @c EU_success : when done
## @li @c EU_error_abort : Patching has not been initiated
## @li @c EU_error_file_invalid : file is corrupted
## @li @c EU_error_invalid_checksum : incompatible patch file
## @li @c EU_error_write_file_rename : could not rename file

proc apply*(this: Patchfile, patch_file: Filename, file: Filename): bool {.importcpp: "#.apply(#, #)".} ## \
## Patches the entire file in one call returns true on success and false on
## error
##
## This version will delete the patch file and overwrite the original file.

proc apply*(this: Patchfile, patch_file: Filename, orig_file: Filename, target_file: Filename): bool {.importcpp: "#.apply(#, #, #)".} ## \
## Patches the entire file in one call returns true on success and false on
## error
##
## This version will not delete any files.

proc getProgress*(this: Patchfile): float32 {.importcpp: "#.get_progress()".} ## \
## Returns a value in the range 0..1, representing the amount of progress
## through the patchfile, during a session.

proc setAllowMultifile*(this: Patchfile, allow_multifile: bool) {.importcpp: "#.set_allow_multifile(#)".} ## \
## If this flag is set true, the Patchfile will make a special case for
## patching Panda Multifiles, if detected, and attempt to patch them on a
## subfile-by-subfile basis.  If this flag is false, the Patchfile will always
## patch the file on a full-file basis.
##
## This has effect only when building patches; it is not used for applying
## patches.

proc getAllowMultifile*(this: Patchfile): bool {.importcpp: "#.get_allow_multifile()".} ## \
## See set_allow_multifile().

proc setFootprintLength*(this: Patchfile, length: int) {.importcpp: "#.set_footprint_length(#)".}

proc getFootprintLength*(this: Patchfile): int {.importcpp: "#.get_footprint_length()".}

proc resetFootprintLength*(this: Patchfile) {.importcpp: "#.reset_footprint_length()".}

proc hasSourceHash*(this: Patchfile): bool {.importcpp: "#.has_source_hash()".} ## \
## Returns true if the MD5 hash for the source file is known.  (Some early
## versions of the patch file did not store this information.)

proc getSourceHash*(this: Patchfile): HashVal {.importcpp: "#.get_source_hash()".} ## \
## Returns the MD5 hash for the source file.

proc getResultHash*(this: Patchfile): HashVal {.importcpp: "#.get_result_hash()".} ## \
## Returns the MD5 hash for the file after the patch has been applied.

proc passwordHash*(password: string, salt: string, iters: int, keylen: int): string {.importcpp: "nimStringFromStdString(password_hash(nimStringToStdString(#), nimStringToStdString(#), #, #))", header: stringConversionCode.}

proc initProfileTimer*(other: ProfileTimer): ProfileTimer {.importcpp: "ProfileTimer(#)".}

proc initProfileTimer*(name: string, maxEntries: int): ProfileTimer {.importcpp: "ProfileTimer(nimStringToStdString(#), #)", header: stringConversionCode.}

proc initProfileTimer*(name: string): ProfileTimer {.importcpp: "ProfileTimer(nimStringToStdString(#))", header: stringConversionCode.}

proc initProfileTimer*(): ProfileTimer {.importcpp: "ProfileTimer()".}

proc init*(this: ProfileTimer, name: string, maxEntries: int) {.importcpp: "#.init(nimStringToStdString(#), #)", header: stringConversionCode.}

proc init*(this: ProfileTimer, name: string) {.importcpp: "#.init(nimStringToStdString(#))", header: stringConversionCode.}

proc on*(this: ProfileTimer) {.importcpp: "#.on()".}

proc mark*(this: ProfileTimer, tag: string) {.importcpp: "#.mark(nimStringToStdString(#))", header: stringConversionCode.}

proc off*(this: ProfileTimer) {.importcpp: "#.off()".}

proc off*(this: ProfileTimer, tag: string) {.importcpp: "#.off(nimStringToStdString(#))", header: stringConversionCode.}

proc getTotalTime*(this: ProfileTimer): float64 {.importcpp: "#.getTotalTime()".} ## \
## Don't call any of the following during timing: (Because they are slow,
## not because anything will break).

proc consolidateAllTo*(_: typedesc[ProfileTimer], `out`: ostream) {.importcpp: "#ProfileTimer::consolidateAllTo(#)", header: "profileTimer.h".}

proc consolidateAllTo*(_: typedesc[ProfileTimer]) {.importcpp: "ProfileTimer::consolidateAllTo()", header: "profileTimer.h".}

proc consolidateTo*(this: ProfileTimer, `out`: ostream) {.importcpp: "#.consolidateTo(#)".}

proc consolidateTo*(this: ProfileTimer) {.importcpp: "#.consolidateTo()".}

proc printAllTo*(_: typedesc[ProfileTimer], `out`: ostream) {.importcpp: "#ProfileTimer::printAllTo(#)", header: "profileTimer.h".}

proc printAllTo*(_: typedesc[ProfileTimer]) {.importcpp: "ProfileTimer::printAllTo()", header: "profileTimer.h".}

proc printTo*(this: ProfileTimer, `out`: ostream) {.importcpp: "#.printTo(#)".}

proc printTo*(this: ProfileTimer) {.importcpp: "#.printTo()".}

proc wasDeleted*(this: WeakPointerToVoid): bool {.importcpp: "#.was_deleted()".} ## \
## Returns true if the object we are pointing to has been deleted, false
## otherwise.  If this returns true, it means that the pointer can not yet be
## reused, but it does not guarantee that it can be safely accessed.  See the
## lock() method for a safe way to access the underlying pointer.
##
## This will always return true for a null pointer, unlike is_valid_pointer().

proc isValidPointer*(this: WeakPointerToVoid): bool {.importcpp: "#.is_valid_pointer()".} ## \
## Returns true if the pointer is not null and the object has not been
## deleted.  See was_deleted() for caveats.

proc setStringValue*(_: typedesc[WindowsRegistry], key: string, name: string, value: string): bool {.importcpp: "#WindowsRegistry::set_string_value(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: "windowsRegistry.h".} ## \
## Sets the registry key to the indicated value as a string.  The supplied
## string value is automatically converted from whatever encoding is set by
## TextEncoder::set_default_encoding() and written as a Unicode string.  The
## registry key must already exist prior to calling this function.

proc setIntValue*(_: typedesc[WindowsRegistry], key: string, name: string, value: int): bool {.importcpp: "#WindowsRegistry::set_int_value(nimStringToStdString(#), nimStringToStdString(#), #)", header: "windowsRegistry.h".} ## \
## Sets the registry key to the indicated value as an integer.  The registry
## key must already exist prior to calling this function.

proc getStringValue*(_: typedesc[WindowsRegistry], key: string, name: string, default_value: string): string {.importcpp: "nimStringFromStdString(#WindowsRegistry::get_string_value(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#)))", header: "windowsRegistry.h".} ## \
## Returns the value associated with the indicated registry key, assuming it
## is a string value.  The string value is automatically encoded using
## TextEncoder::get_default_encoding().  If the key is not defined or is not a
## string type value, default_value is returned instead.

proc getIntValue*(_: typedesc[WindowsRegistry], key: string, name: string, default_value: int): int {.importcpp: "#WindowsRegistry::get_int_value(nimStringToStdString(#), nimStringToStdString(#), #)", header: "windowsRegistry.h".} ## \
## Returns the value associated with the indicated registry key, assuming it
## is an integer value.  If the key is not defined or is not an integer type
## value, default_value is returned instead.

proc initWindowsRegistry*(): WindowsRegistry {.importcpp: "WindowsRegistry()".}

proc initWindowsRegistry*(param0: WindowsRegistry): WindowsRegistry {.importcpp: "WindowsRegistry(#)".}

proc isRecording*(this: RecorderBase): bool {.importcpp: "#->is_recording()".} ## \
## Returns true if this recorder is presently recording data for saving to a
## session file, false otherwise.  If this is true, record_data() will be
## called from time to time.

proc isPlaying*(this: RecorderBase): bool {.importcpp: "#->is_playing()".} ## \
## Returns true if this recorder is presently playing back data from session
## file, false otherwise.  If this is true, play_data() will be called from
## time to time.

converter getClassType*(_: typedesc[RecorderBase]): TypeHandle {.importcpp: "RecorderBase::get_class_type()", header: "recorderBase.h".}

converter upcastToDataNode*(this: MouseRecorder): DataNode {.importcpp: "(PT(DataNode)(#))".}

converter upcastToRecorderBase*(this: MouseRecorder): RecorderBase {.importcpp: "((RecorderBase *)(MouseRecorder *)(#))".}

proc newMouseRecorder*(name: string): MouseRecorder {.importcpp: "new MouseRecorder(nimStringToStdString(#))", header: stringConversionCode.}

converter getClassType*(_: typedesc[MouseRecorder]): TypeHandle {.importcpp: "MouseRecorder::get_class_type()", header: "mouseRecorder.h".}

proc newRecorderController*(): RecorderController {.importcpp: "new RecorderController()".}

proc beginRecord*(this: RecorderController, filename: Filename): bool {.importcpp: "#->begin_record(#)".} ## \
## Begins recording data to the indicated filename.  All of the recorders in
## use should already have been added.

proc beginPlayback*(this: RecorderController, filename: Filename): bool {.importcpp: "#->begin_playback(#)".} ## \
## Begins playing back data from the indicated filename.  All of the recorders
## in use should already have been added, although this may define additional
## recorders if they are present in the file (these new recorders will not be
## used).  This may also undefine recorders that were previously added but are
## not present in the file.

proc close*(this: RecorderController) {.importcpp: "#->close()".} ## \
## Finishes recording data to the indicated filename.

proc getStartTime*(this: RecorderController): time_t.Time {.importcpp: "#->get_start_time()".} ## \
## Returns the time (and date) at which the current session was originally
## recorded (or, in recording mode, the time at which the current session
## began).

proc setRandomSeed*(this: RecorderController, random_seed: int) {.importcpp: "#->set_random_seed(#)".} ## \
## Indicates an arbitrary number to be recorded in the session file as a
## random seed, should the application wish to take advantage of it.  This
## must be set before begin_record() is called.

proc getRandomSeed*(this: RecorderController): int {.importcpp: "#->get_random_seed()".} ## \
## Returns the random seed that was set by a previous call to
## set_random_seed(), or the number read from the session file after
## begin_playback() has been called.

proc isRecording*(this: RecorderController): bool {.importcpp: "#->is_recording()".} ## \
## Returns true if the controller has been opened for output, false otherwise.

proc isPlaying*(this: RecorderController): bool {.importcpp: "#->is_playing()".} ## \
## Returns true if the controller has been opened for input, false otherwise.

proc isOpen*(this: RecorderController): bool {.importcpp: "#->is_open()".} ## \
## Returns true if the controller has been opened for either input or output,
## false otherwise.

proc getFilename*(this: RecorderController): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the filename that was passed to the most recent call to
## begin_record() or begin_playback().

proc isError*(this: RecorderController): bool {.importcpp: "#->is_error()".} ## \
## Returns true if the controller has been opened for input or output output
## and there is an error on the stream, or false if the controller is closed
## or if there is no problem.

proc getClockOffset*(this: RecorderController): float64 {.importcpp: "#->get_clock_offset()".} ## \
## Returns the delta offset between the actual frame time and the frame time
## written to the log.  This is essentially the time at which the recording
## (or playback) started.

proc getFrameOffset*(this: RecorderController): int {.importcpp: "#->get_frame_offset()".} ## \
## Returns the delta offset between the actual frame count and the frame count
## written to the log.  This is essentially the frame number at which the
## recording (or playback) started.

proc addRecorder*(this: RecorderController, name: string, recorder: RecorderBase) {.importcpp: "#->add_recorder(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Adds the named recorder to the set of recorders that are in use.
##
## If the controller is in recording mode, the named recorder will begin
## recording its status to the session file.  If the controller is in playback
## mode and the name and type matches a recorder in the session file, the
## recorder will begin receiving data.

proc hasRecorder*(this: RecorderController, name: string): bool {.importcpp: "#->has_recorder(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if the named recorder has been added to the table by a
## previous call to add_recorder(), false otherwise.
##
## If the controller is in playback mode, this will also return false for a
## recorder that was found in the session file but was never explicitly added
## via add_recorder(); see get_recorder().

proc getRecorder*(this: RecorderController, name: string): RecorderBase {.importcpp: "#->get_recorder(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the recorder with the indicated name, or NULL if there is no such
## recorder.
##
## If the controller is in playback mode, this may return the recorder
## matching the indicated name as read from the session file, even if it was
## never added to the table by the user.  In this case, has_recorder() may
## return false, but get_recorder() will return a non-NULL value.

proc removeRecorder*(this: RecorderController, name: string): bool {.importcpp: "#->remove_recorder(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes the named recorder from the table.  Returns true if successful,
## false if there was no such recorder.
##
## If the controller is in recording mode, the named recorder will stop
## recording.  If the controller is in playback mode, the named recorder will
## disassociate itself from the session file (but if the session file still
## has data for this name, a default recorder will take its place to decode
## the data from the session file).

proc setFrameTie*(this: RecorderController, frame_tie: bool) {.importcpp: "#->set_frame_tie(#)".} ## \
## Sets the frame_tie flag.
##
## When this is true, sessions are played back frame-for-frame, based on the
## frame count of the recorded session.  This gives the most accurate
## playback, but the playback rate will vary according to the frame rate of
## the playback machine.
##
## When this is false, sessions are played back at real time, based on the
## clock of the recorded session.  This may introduce playback discrepencies
## if the frames do not fall at exactly the same times as they did in the
## original.

proc getFrameTie*(this: RecorderController): bool {.importcpp: "#->get_frame_tie()".} ## \
## See set_frame_tie().

proc recordFrame*(this: RecorderController) {.importcpp: "#->record_frame()".} ## \
## Gets the next frame of data from all of the active recorders and adds it to
## the output file.

proc playFrame*(this: RecorderController) {.importcpp: "#->play_frame()".} ## \
## Gets the next frame of data from all of the active recorders and adds it to
## the output file.

converter getClassType*(_: typedesc[RecorderController]): TypeHandle {.importcpp: "RecorderController::get_class_type()", header: "recorderController.h".}

converter upcastToRecorderBase*(this: SocketStreamRecorder): RecorderBase {.importcpp: "((RecorderBase *)(SocketStreamRecorder *)(#))".}

converter upcastToReferenceCount*(this: SocketStreamRecorder): ReferenceCount {.importcpp: "(PT(ReferenceCount)(#))".}

proc newSocketStreamRecorder*(): SocketStreamRecorder {.importcpp: "new SocketStreamRecorder()".}

proc newSocketStreamRecorder*(stream: SocketStream, owns_stream: bool): SocketStreamRecorder {.importcpp: "new SocketStreamRecorder(#, #)".}

proc receiveDatagram*(this: SocketStreamRecorder, dg: Datagram): bool {.importcpp: "#->receive_datagram(#)".} ## \
## Receives a datagram over the socket by expecting a little-endian 16-bit
## byte count as a prefix.  If the socket stream is non-blocking, may return
## false if the data is not available; otherwise, returns false only if the
## socket closes.

proc sendDatagram*(this: SocketStreamRecorder, dg: Datagram): bool {.importcpp: "#->send_datagram(#)".} ## \
## See SocketStream::send_datagram().

proc isClosed*(this: SocketStreamRecorder): bool {.importcpp: "#->is_closed()".} ## \
## See SocketStream::is_closed().

proc close*(this: SocketStreamRecorder) {.importcpp: "#->close()".} ## \
## See SocketStream::close().

proc setCollectTcp*(this: SocketStreamRecorder, collect_tcp: bool) {.importcpp: "#->set_collect_tcp(#)".} ## \
## See SocketStream::set_collect_tcp().

proc getCollectTcp*(this: SocketStreamRecorder): bool {.importcpp: "#->get_collect_tcp()".} ## \
## See SocketStream::get_collect_tcp().

proc setCollectTcpInterval*(this: SocketStreamRecorder, interval: float64) {.importcpp: "#->set_collect_tcp_interval(#)".} ## \
## See SocketStream::set_collect_tcp_interval().

proc getCollectTcpInterval*(this: SocketStreamRecorder): float64 {.importcpp: "#->get_collect_tcp_interval()".} ## \
## See SocketStream::get_collect_tcp_interval().

proc considerFlush*(this: SocketStreamRecorder): bool {.importcpp: "#->consider_flush()".} ## \
## See SocketStream::consider_flush()

proc flush*(this: SocketStreamRecorder): bool {.importcpp: "#->flush()".} ## \
## See SocketStream::flush()

converter getClassType*(_: typedesc[SocketStreamRecorder]): TypeHandle {.importcpp: "SocketStreamRecorder::get_class_type()", header: "socketStreamRecorder.h".}

converter upcastToLight*(this: LightNode): Light {.importcpp: "((Light *)(LightNode *)(#))".}

converter upcastToPandaNode*(this: LightNode): PandaNode {.importcpp: "(PT(PandaNode)(#))".}

proc output*(this: LightNode, `out`: ostream) {.importcpp: "#->output(#)".} ## \
## We have to explicitly publish these because they resolve the multiple
## inheritance.

proc write*(this: LightNode, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: LightNode, `out`: ostream) {.importcpp: "#->write(#)".}

converter getClassType*(_: typedesc[LightNode]): TypeHandle {.importcpp: "LightNode::get_class_type()", header: "lightNode.h".}

proc newAmbientLight*(name: string): AmbientLight {.importcpp: "new AmbientLight(nimStringToStdString(#))", header: stringConversionCode.}

converter getClassType*(_: typedesc[AmbientLight]): TypeHandle {.importcpp: "AmbientLight::get_class_type()", header: "ambientLight.h".}

proc newCallbackNode*(name: string): CallbackNode {.importcpp: "new CallbackNode(nimStringToStdString(#))", header: stringConversionCode.}

proc setCullCallback*(this: CallbackNode, `object`: CallbackObject) {.importcpp: "#->set_cull_callback(#)".} ## \
## Sets the CallbackObject that will be notified when this node is visited
## during the cull traversal.  This callback will be made during the cull
## thread.
##
## The cull traversal is responsible for determining which nodes are visible
## and within the view frustum, and for accumulating state and transform, and
## generally building up the list of CullableObjects that are to be eventually
## passed to the draw traversal for rendering.
##
## At the time the cull traversal callback is made, the node has been
## determined to be visible and it has passed the bounding-volume test, so it
## lies within the view frustum.
##
## The callback is passed an instance of a NodeCullCallbackData, which
## contains pointers to the CullTraverser and CullTraverserData--enough data
## to examine the current node and its place within the scene graph.  The
## callback \*replaces\* the normal cull behavior, so if your callback does
## nothing, the cull traversal will not continue below this node.  If you wish
## the cull traversal to continue to visit this node and below, you must call
## cbdata->upcall() from your callback.

proc clearCullCallback*(this: CallbackNode) {.importcpp: "#->clear_cull_callback()".} ## \
## Removes the callback set by an earlier call to set_cull_callback().

proc getCullCallback*(this: CallbackNode): CallbackObject {.importcpp: "#->get_cull_callback()".} ## \
## Returns the CallbackObject set by set_cull_callback().

proc setDrawCallback*(this: CallbackNode, `object`: CallbackObject) {.importcpp: "#->set_draw_callback(#)".} ## \
## Sets the CallbackObject that will be notified when this node is visited
## during the draw traversal.  This callback will be made during the draw
## thread.
##
## The draw traversal is responsible for actually issuing the commands to the
## graphics engine to draw primitives.  Its job is to walk through the list of
## CullableObjects build up by the cull traversal, as quickly as possible,
## issuing the appropriate commands to draw each one.
##
## At the time the draw traversal callback is made, the graphics state has
## been loaded with the correct modelview transform and render state, and the
## primitives (if any) in this node are ready to be drawn.
##
## The callback is passed an instance of a GeomDrawCallbackData, which
## contains pointers to the current state and transform, as well as the
## current GSG.  There is a Geom pointer as well, but it will always be NULL
## to this callback, since the CallbackNode does not itself contain any Geoms.

proc clearDrawCallback*(this: CallbackNode) {.importcpp: "#->clear_draw_callback()".} ## \
## Removes the callback set by an earlier call to set_draw_callback().

proc getDrawCallback*(this: CallbackNode): CallbackObject {.importcpp: "#->get_draw_callback()".} ## \
## Returns the CallbackObject set by set_draw_callback().

converter getClassType*(_: typedesc[CallbackNode]): TypeHandle {.importcpp: "CallbackNode::get_class_type()", header: "callbackNode.h".}

proc newComputeNode*(name: string): ComputeNode {.importcpp: "new ComputeNode(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates a ComputeNode with the given name.  Use add_dispatch and  also
## assign a shader using a ShaderAttrib.

proc addDispatch*(this: ComputeNode, num_groups: LVecBase3i) {.importcpp: "#->add_dispatch(#)".} ## \
## Adds a dispatch command with the given number of work groups in the X, Y,
## and Z dimensions.  Any of these values may be set to 1 if the respective
## dimension should not be used.

proc addDispatch*(this: ComputeNode, num_groups_x: int, num_groups_y: int, num_groups_z: int) {.importcpp: "#->add_dispatch(#, #, #)".} ## \
## Adds a dispatch command with the given number of work groups in the X, Y,
## and Z dimensions.  Any of these values may be set to 1 if the respective
## dimension should not be used.

proc getNumDispatches*(this: ComputeNode): clonglong {.importcpp: "#->get_num_dispatches()".} ## \
## Returns the number of times add_dispatch has been called on this object.

proc getDispatch*(this: ComputeNode, i: clonglong): LVecBase3i {.importcpp: "#->get_dispatch(#)".} ## \
## Returns the group counts of the nth dispatch associated with this object.

proc setDispatch*(this: ComputeNode, i: clonglong, num_groups: LVecBase3i) {.importcpp: "#->set_dispatch(#, #)".} ## \
## Sets the group counts of the nth dispatch associated with this object.

proc insertDispatch*(this: ComputeNode, i: clonglong, num_groups: LVecBase3i) {.importcpp: "#->insert_dispatch(#, #)".} ## \
## Inserts a dispatch command with the given number of work groups in the X,
## Y, and Z dimensions at the given position in the list of dispatch commands.
## Any of these values may be set to 1 if the respective dimension should not
## be used.

proc removeDispatch*(this: ComputeNode, i: clonglong) {.importcpp: "#->remove_dispatch(#)".} ## \
## Erases the given dispatch index from the list.

proc clearDispatches*(this: ComputeNode) {.importcpp: "#->clear_dispatches()".} ## \
## Removes all dispatch commands.

converter getClassType*(_: typedesc[ComputeNode]): TypeHandle {.importcpp: "ComputeNode::get_class_type()", header: "computeNode.h".}

converter upcastToLight*(this: LightLensNode): Light {.importcpp: "((Light *)(LightLensNode *)(#))".}

converter upcastToCamera*(this: LightLensNode): Camera {.importcpp: "(PT(Camera)(#))".}

proc hasSpecularColor*(this: LightLensNode): bool {.importcpp: "#->has_specular_color()".} ## \
## Returns true if this light defines a specular color, false if the specular
## color is derived automatically from the light color.

proc isShadowCaster*(this: LightLensNode): bool {.importcpp: "#->is_shadow_caster()".} ## \
## Returns whether this light is configured to cast shadows or not.

proc setShadowCaster*(this: LightLensNode, caster: bool) {.importcpp: "#->set_shadow_caster(#)".} ## \
## Sets the flag indicating whether this light should cast shadows or not.
## This is the variant without buffer size, meaning that the current buffer
## size will be kept (512x512 is the default). Note that enabling shadows will
## require the shader generator to be enabled on the scene.

proc setShadowCaster*(this: LightLensNode, caster: bool, buffer_xsize: int, buffer_ysize: int, sort: int) {.importcpp: "#->set_shadow_caster(#, #, #, #)".} ## \
## Sets the flag indicating whether this light should cast shadows or not.
## The xsize and ysize parameters specify the size of the shadow buffer that
## will be set up, the sort parameter specifies the sort.  Note that enabling
## shadows will require the shader generator to be enabled on the scene.

proc setShadowCaster*(this: LightLensNode, caster: bool, buffer_xsize: int, buffer_ysize: int) {.importcpp: "#->set_shadow_caster(#, #, #)".} ## \
## Sets the flag indicating whether this light should cast shadows or not.
## The xsize and ysize parameters specify the size of the shadow buffer that
## will be set up, the sort parameter specifies the sort.  Note that enabling
## shadows will require the shader generator to be enabled on the scene.

proc getShadowBufferSort*(this: LightLensNode): int {.importcpp: "#->get_shadow_buffer_sort()".} ## \
## Returns the sort of the shadow buffer to be created for this light source.

proc getShadowBufferSize*(this: LightLensNode): LVecBase2i {.importcpp: "#->get_shadow_buffer_size()".} ## \
## Returns the size of the shadow buffer to be created for this light source.

proc setShadowBufferSize*(this: LightLensNode, size: LVecBase2i) {.importcpp: "#->set_shadow_buffer_size(#)".} ## \
## Sets the size of the shadow buffer to be created for this light source.

proc getShadowBuffer*(this: LightLensNode, gsg: GraphicsStateGuardianBase): GraphicsOutputBase {.importcpp: "#->get_shadow_buffer(#)".} ## \
## Returns the buffer that has been constructed for a given GSG, or NULL if no
## such buffer has (yet) been constructed.  This should be used for debugging
## only, you will not need to call this normally.

proc output*(this: LightLensNode, `out`: ostream) {.importcpp: "#->output(#)".} ## \
## We have to explicitly publish these because they resolve the multiple
## inheritance.

proc write*(this: LightLensNode, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: LightLensNode, `out`: ostream) {.importcpp: "#->write(#)".}

converter getClassType*(_: typedesc[LightLensNode]): TypeHandle {.importcpp: "LightLensNode::get_class_type()", header: "lightLensNode.h".}

proc newDirectionalLight*(name: string): DirectionalLight {.importcpp: "new DirectionalLight(nimStringToStdString(#))", header: stringConversionCode.}

proc setSpecularColor*(this: DirectionalLight, color: LColor) {.importcpp: "#->set_specular_color(#)".} ## \
## Sets the color of specular highlights generated by the light.

proc clearSpecularColor*(this: DirectionalLight) {.importcpp: "#->clear_specular_color()".} ## \
## Clears a custom specular color setting, meaning that the specular color
## will now come from the color.

proc getPoint*(this: DirectionalLight): LPoint3 {.importcpp: "#->get_point()".} ## \
## Returns the point in space at which the light is located.  This is local to
## the coordinate space in which the light is assigned.
##
## This actually has no bearing on the visual effect of the light, since the
## light is rendered as if it were infinitely far away.  This is only used to
## create a visible representation of the light.

proc setPoint*(this: DirectionalLight, point: LPoint3) {.importcpp: "#->set_point(#)".} ## \
## Sets the point in space at which the light is located.

proc getDirection*(this: DirectionalLight): LVector3 {.importcpp: "#->get_direction()".} ## \
## Returns the direction in which the light is aimed.  This is local to the
## coordinate space in which the light is assigned.

proc setDirection*(this: DirectionalLight, direction: LVector3) {.importcpp: "#->set_direction(#)".} ## \
## Sets the direction in which the light is aimed.

converter getClassType*(_: typedesc[DirectionalLight]): TypeHandle {.importcpp: "DirectionalLight::get_class_type()", header: "directionalLight.h".}

proc newLODNode*(name: string): LODNode {.importcpp: "new LODNode(nimStringToStdString(#))", header: stringConversionCode.}

proc makeDefaultLod*(_: typedesc[LODNode], name: string): LODNode {.importcpp: "#LODNode::make_default_lod(nimStringToStdString(#))", header: "lodNode.h".} ## \
## Creates a new LODNode of the type specified by the default-lod-type config
## variable.

proc addSwitch*(this: LODNode, `in`: float32, `out`: float32) {.importcpp: "#->add_switch(#, #)".} ## \
## Adds a switch range to the LODNode.  This implies that the corresponding
## child node has been parented to the node.
##
## The sense of in vs.  out distances is as if the object were coming towards
## you from far away: it switches "in" at the far distance, and switches "out"
## at the close distance.  Thus, "in" should be larger than "out".

proc setSwitch*(this: LODNode, index: int, `in`: float32, `out`: float32): bool {.importcpp: "#->set_switch(#, #, #)".} ## \
## Changes the switching range of a particular child of the LODNode.  See
## add_switch().

proc clearSwitches*(this: LODNode) {.importcpp: "#->clear_switches()".} ## \
## Removes the set of switching ranges for the LODNode, presumably in
## conjunction with removing all of its children.  See add_switch().

proc getNumSwitches*(this: LODNode): int {.importcpp: "#->get_num_switches()".} ## \
## Returns the number of switch ranges added to the LODNode.  This should
## correspond to the number of children of the node in order for the LODNode
## to function correctly.

proc getIn*(this: LODNode, index: int): float32 {.importcpp: "#->get_in(#)".} ## \
## Returns the "in" distance of the indicated switch range.  This should be
## larger than the "out" distance of the same range.

proc getOut*(this: LODNode, index: int): float32 {.importcpp: "#->get_out(#)".} ## \
## Returns the "out" distance of the indicated switch range.  This should be
## smaller than the "in" distance of the same range.

proc getLowestSwitch*(this: LODNode): int {.importcpp: "#->get_lowest_switch()".} ## \
## Returns the index number of the child with the lowest level of detail; that
## is, the one that is designed to be seen from the farthest away.  This is
## usually the first child, but it is not necessarily so.

proc getHighestSwitch*(this: LODNode): int {.importcpp: "#->get_highest_switch()".} ## \
## Returns the index number of the child with the highest level of detail;
## that is, the one that is designed to be seen from the closest to the
## camera.  This is usually the last child, but it is not necessarily so.

proc forceSwitch*(this: LODNode, index: int) {.importcpp: "#->force_switch(#)".} ## \
## Forces the LODNode to show the indicated level instead of the level that
## would normally be shown based on the distance from the camera.

proc clearForceSwitch*(this: LODNode) {.importcpp: "#->clear_force_switch()".} ## \
## Undoes the effect of a previous call to force_switch() and releases the
## LODNode to once again display the normal level.

proc setLodScale*(this: LODNode, value: float32) {.importcpp: "#->set_lod_scale(#)".} ## \
## Sets the multiplier for lod distances.  A higher value means you'll see
## farther switchs than normal

proc getLodScale*(this: LODNode): float32 {.importcpp: "#->get_lod_scale()".} ## \
## Returns the multiplier for lod distances

proc setCenter*(this: LODNode, center: LPoint3) {.importcpp: "#->set_center(#)".} ## \
## Specifies the center of the LOD.  This is the point that is compared to the
## camera (in camera space) to determine the particular LOD that should be
## chosen.

proc getCenter*(this: LODNode): LPoint3 {.importcpp: "#->get_center()".} ## \
## Returns the center of the LOD.  This is the point that is compared to the
## camera (in camera space) to determine the particular LOD that should be
## chosen.

proc showSwitch*(this: LODNode, index: int) {.importcpp: "#->show_switch(#)".} ## \
## This is provided as a debugging aid.  show_switch() will put the LODNode
## into a special mode where rather than computing and drawing the appropriate
## level of the LOD, a ring is drawn around the LODNode center indicating the
## switch distances from the camera for the indicated level, and the geometry
## of the indicated level is drawn in wireframe.
##
## Multiple different levels can be visualized this way at once.  Call
## hide_switch() or hide_all_switches() to undo this mode and restore the
## LODNode to its normal behavior.

proc showSwitch*(this: LODNode, index: int, color: LColor) {.importcpp: "#->show_switch(#, #)".} ## \
## This is provided as a debugging aid.  show_switch() will put the LODNode
## into a special mode where rather than computing and drawing the appropriate
## level of the LOD, a ring is drawn around the LODNode center indicating the
## switch distances from the camera for the indicated level, and the geometry
## of the indicated level is drawn in wireframe.
##
## Multiple different levels can be visualized this way at once.  Call
## hide_switch() or hide_all_switches() to undo this mode and restore the
## LODNode to its normal behavior.

proc hideSwitch*(this: LODNode, index: int) {.importcpp: "#->hide_switch(#)".} ## \
## Disables a previous call to show_switch().

proc showAllSwitches*(this: LODNode) {.importcpp: "#->show_all_switches()".} ## \
## Shows all levels in their default colors.

proc hideAllSwitches*(this: LODNode) {.importcpp: "#->hide_all_switches()".} ## \
## Hides all levels, restoring the LODNode to normal operation.

proc isAnyShown*(this: LODNode): bool {.importcpp: "#->is_any_shown()".} ## \
## Returns true if any switch has been shown with show_switch(), indicating
## the LODNode is in debug show mode; or false if it is in the normal mode.

proc verifyChildBounds*(this: LODNode): bool {.importcpp: "#->verify_child_bounds()".} ## \
## Returns true if the bounding volumes for the geometry of each fhild node
## entirely fits within the switch_in radius for that child, or false
## otherwise.  It is almost always a mistake for the geometry of an LOD level
## to be larger than its switch_in radius.

converter getClassType*(_: typedesc[LODNode]): TypeHandle {.importcpp: "LODNode::get_class_type()", header: "lodNode.h".}

proc newFadeLODNode*(name: string): FadeLODNode {.importcpp: "new FadeLODNode(nimStringToStdString(#))", header: stringConversionCode.}

proc setFadeTime*(this: FadeLODNode, t: float32) {.importcpp: "#->set_fade_time(#)".} ## \
## set the time taken to complete an LOD switch

proc getFadeTime*(this: FadeLODNode): float32 {.importcpp: "#->get_fade_time()".} ## \
## get the time taken to complete an LOD switch

proc setFadeBin*(this: FadeLODNode, name: string, draw_order: int) {.importcpp: "#->set_fade_bin(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Specifies the cull bin and draw order that is assigned to the fading part
## of the geometry during a transition.

proc getFadeBinName*(this: FadeLODNode): string {.importcpp: "nimStringFromStdString(#->get_fade_bin_name())", header: stringConversionCode.} ## \
## Returns the cull bin that is assigned to the fading part of the geometry
## during a transition.

proc getFadeBinDrawOrder*(this: FadeLODNode): int {.importcpp: "#->get_fade_bin_draw_order()".} ## \
## Returns the draw order that is assigned (along with the bin name) to the
## fading part of the geometry during a transition.

proc setFadeStateOverride*(this: FadeLODNode, override: int) {.importcpp: "#->set_fade_state_override(#)".} ## \
## Specifies the override value that is applied to the state changes necessary
## to apply the fade effect.  This should be larger than any attrib overrides
## on the fading geometry.

proc getFadeStateOverride*(this: FadeLODNode): int {.importcpp: "#->get_fade_state_override()".} ## \
## Returns the override value that is applied to the state changes necessary
## to apply the fade effect.  This should be larger than any attrib overrides
## on the fading geometry.

converter getClassType*(_: typedesc[FadeLODNode]): TypeHandle {.importcpp: "FadeLODNode::get_class_type()", header: "fadeLodNode.h".}

proc getTrav*(this: NodeCullCallbackData): CullTraverser {.importcpp: "#.get_trav()".} ## \
## Returns the CullTraverser in use at the time of the callback.  This object
## contains data that does not change during the traversal, such as the
## DisplayRegion and Camera in use.

proc getData*(this: NodeCullCallbackData): CullTraverserData {.importcpp: "#.get_data()".} ## \
## Returns the CullTraverserData in use at the time of the callback.  This
## object contains data that changes at each node of the traversal, such as
## the current node and the current net transform to that node.

converter getClassType*(_: typedesc[NodeCullCallbackData]): TypeHandle {.importcpp: "NodeCullCallbackData::get_class_type()", header: "nodeCullCallbackData.h".}

proc newPointLight*(name: string): PointLight {.importcpp: "new PointLight(nimStringToStdString(#))", header: stringConversionCode.}

proc setSpecularColor*(this: PointLight, color: LColor) {.importcpp: "#->set_specular_color(#)".} ## \
## Sets the color of specular highlights generated by the light.

proc clearSpecularColor*(this: PointLight) {.importcpp: "#->clear_specular_color()".} ## \
## Clears a custom specular color setting, meaning that the specular color
## will now come from the color.

proc setAttenuation*(this: PointLight, attenuation: LVecBase3) {.importcpp: "#->set_attenuation(#)".} ## \
## Sets the terms of the attenuation equation for the light.  These are, in
## order, the constant, linear, and quadratic terms based on the distance from
## the point to the vertex.

proc getMaxDistance*(this: PointLight): float32 {.importcpp: "#->get_max_distance()".} ## \
## Returns the maximum distance at which the light has any effect, as previously
## specified by set_max_distance.

proc setMaxDistance*(this: PointLight, max_distance: float32) {.importcpp: "#->set_max_distance(#)".} ## \
## Sets the radius of the light's sphere of influence.  Beyond this distance, the
## light may be attenuated to zero, if this is supported by the shader.

proc getPoint*(this: PointLight): LPoint3 {.importcpp: "#->get_point()".} ## \
## Returns the point in space at which the light is located.  This is local to
## the coordinate space in which the light is assigned, and is usually 0.

proc setPoint*(this: PointLight, point: LPoint3) {.importcpp: "#->set_point(#)".} ## \
## Sets the point in space at which the light is located.  Usually 0.

converter getClassType*(_: typedesc[PointLight]): TypeHandle {.importcpp: "PointLight::get_class_type()", header: "pointLight.h".}

proc newRectangleLight*(name: string): RectangleLight {.importcpp: "new RectangleLight(nimStringToStdString(#))", header: stringConversionCode.}

proc getMaxDistance*(this: RectangleLight): float32 {.importcpp: "#->get_max_distance()".} ## \
## Returns the maximum distance at which the light has any effect, as previously
## specified by set_max_distance.

proc setMaxDistance*(this: RectangleLight, max_distance: float32) {.importcpp: "#->set_max_distance(#)".} ## \
## Sets the radius of the light's sphere of influence.  Beyond this distance, the
## light may be attenuated to zero, if this is supported by the shader.

converter getClassType*(_: typedesc[RectangleLight]): TypeHandle {.importcpp: "RectangleLight::get_class_type()", header: "rectangleLight.h".}

proc newSelectiveChildNode*(name: string): SelectiveChildNode {.importcpp: "new SelectiveChildNode(nimStringToStdString(#))", header: stringConversionCode.}

converter getClassType*(_: typedesc[SelectiveChildNode]): TypeHandle {.importcpp: "SelectiveChildNode::get_class_type()", header: "selectiveChildNode.h".}

converter upcastToSelectiveChildNode*(this: SequenceNode): SelectiveChildNode {.importcpp: "(PT(SelectiveChildNode)(#))".}

converter upcastToAnimInterface*(this: SequenceNode): AnimInterface {.importcpp: "((AnimInterface *)(SequenceNode *)(#))".}

proc newSequenceNode*(name: string): SequenceNode {.importcpp: "new SequenceNode(nimStringToStdString(#))", header: stringConversionCode.}

proc getNumFrames*(this: SequenceNode): int {.importcpp: "#->get_num_frames()".} ## \
## Returns the number of frames in the animation.  This is a property of the
## animation and may not be directly adjusted by the user (although it may
## change without warning with certain kinds of animations, since this is a
## virtual method that may be overridden).

proc setFrameRate*(this: SequenceNode, frame_rate: float64) {.importcpp: "#->set_frame_rate(#)".} ## \
## Changes the advertised frame rate of the SequenceNode.  This can be used in
## conjunction with get_play_rate() to change the effective frame rate of the
## node.

converter getClassType*(_: typedesc[SequenceNode]): TypeHandle {.importcpp: "SequenceNode::get_class_type()", header: "sequenceNode.h".}

proc newShaderGenerator*(gsg: GraphicsStateGuardianBase): ShaderGenerator {.importcpp: "new ShaderGenerator(#)".} ## \
## Create a ShaderGenerator.  This has no state, except possibly to cache
## certain results.  The parameter that must be passed is the GSG to which the
## shader generator belongs.

proc newShaderGenerator*(param0: ShaderGenerator): ShaderGenerator {.importcpp: "new ShaderGenerator(#)".}

proc synthesizeShader*(this: ShaderGenerator, rs: RenderState, anim: GeomVertexAnimationSpec): ShaderAttrib {.importcpp: "deconstify(#->synthesize_shader(#, #))", header: deconstifyCode.} ## \
## This is the routine that implements the next-gen fixed function pipeline by
## synthesizing a shader.  It also takes care of setting up any buffers needed
## to produce the requested effects.
##
## Currently supports:
## - flat colors
## - vertex colors
## - lighting
## - normal maps, even multiple
## - gloss maps, but not multiple
## - glow maps, but not multiple
## - materials, but not updates to materials
## - 2D textures
## - all texture stage modes, including combine modes
## - color scale attrib
## - light ramps (for cartoon shading)
## - shadow mapping
## - most texgen modes
## - texmatrix
## - 1D/2D/3D textures, cube textures, 2D tex arrays
## - linear/exp/exp2 fog
## - animation
##
## Potential optimizations
## - omit attenuation calculations if attenuation off

proc rehashGeneratedShaders*(this: ShaderGenerator) {.importcpp: "#->rehash_generated_shaders()".} ## \
## Rehashes all the states with generated shaders, removing the ones that are
## no longer fresh.
##
## Call this if certain state has changed in such a way as to require a rerun
## of the shader generator.  This should be rare because in most cases, the
## shader generator will automatically regenerate shaders as necessary.
##
## @since 1.10.0

proc clearGeneratedShaders*(this: ShaderGenerator) {.importcpp: "#->clear_generated_shaders()".} ## \
## Removes all previously generated shaders, requiring all shaders to be
## regenerated.  Does not clear cache of compiled shaders.
##
## @since 1.10.0

converter getClassType*(_: typedesc[ShaderGenerator]): TypeHandle {.importcpp: "ShaderGenerator::get_class_type()", header: "shaderGenerator.h".}

proc newSphereLight*(name: string): SphereLight {.importcpp: "new SphereLight(nimStringToStdString(#))", header: stringConversionCode.}

proc getRadius*(this: SphereLight): float32 {.importcpp: "#->get_radius()".} ## \
## Returns the radius of the sphere.

proc setRadius*(this: SphereLight, radius: float32) {.importcpp: "#->set_radius(#)".} ## \
## Sets the radius of the sphere.

converter getClassType*(_: typedesc[SphereLight]): TypeHandle {.importcpp: "SphereLight::get_class_type()", header: "sphereLight.h".}

proc newSpotlight*(name: string): Spotlight {.importcpp: "new Spotlight(nimStringToStdString(#))", header: stringConversionCode.}

proc setExponent*(this: Spotlight, exponent: float32) {.importcpp: "#->set_exponent(#)".} ## \
## Sets the exponent that controls the amount of light falloff from the center
## of the spotlight.  The light is attenuated by the cosine of the angle
## between the direction of the light and the direction of the point being
## lighted, raised to the power of this exponent.  Thus, higher exponents
## result in a more focused light source, regardless of the field-of-view of
## the lens.

proc setSpecularColor*(this: Spotlight, color: LColor) {.importcpp: "#->set_specular_color(#)".} ## \
## Sets the color of specular highlights generated by the light.

proc clearSpecularColor*(this: Spotlight) {.importcpp: "#->clear_specular_color()".} ## \
## Clears a custom specular color setting, meaning that the specular color
## will now come from the color.

proc setAttenuation*(this: Spotlight, attenuation: LVecBase3) {.importcpp: "#->set_attenuation(#)".} ## \
## Sets the terms of the attenuation equation for the light.  These are, in
## order, the constant, linear, and quadratic terms based on the distance from
## the point to the vertex.

proc getMaxDistance*(this: Spotlight): float32 {.importcpp: "#->get_max_distance()".} ## \
## Returns the maximum distance at which the light has any effect, as previously
## specified by set_max_distance.

proc setMaxDistance*(this: Spotlight, max_distance: float32) {.importcpp: "#->set_max_distance(#)".} ## \
## Sets the radius of the light's sphere of influence.  Beyond this distance, the
## light may be attenuated to zero, if this is supported by the shader.

proc makeSpot*(_: typedesc[Spotlight], pixel_width: int, full_radius: float32, fg: LColor, bg: LColor): Texture {.importcpp: "#Spotlight::make_spot(#, #, #, #)", header: "spotlight.h".} ## \
## Returns a newly-generated Texture that renders a circular spot image as
## might be cast from the spotlight.  This may be projected onto target
## geometry (for instance, via NodePath::project_texture()) instead of
## actually enabling the light itself, as a cheesy way to make a high-
## resolution spot appear on the geometry.
##
## pixel_width specifies the height and width of the new texture in pixels,
## full_radius is a value in the range 0..1 that indicates the relative size
## of the fully bright center spot, and fg and bg are the colors of the
## interior and exterior of the spot, respectively.

converter getClassType*(_: typedesc[Spotlight]): TypeHandle {.importcpp: "Spotlight::get_class_type()", header: "spotlight.h".}

proc newSwitchNode*(name: string): SwitchNode {.importcpp: "new SwitchNode(nimStringToStdString(#))", header: stringConversionCode.}

proc setVisibleChild*(this: SwitchNode, index: int) {.importcpp: "#->set_visible_child(#)".} ## \
## Specifies the particular child of this node, by index, that will be
## visible.

proc getVisibleChild*(this: SwitchNode): int {.importcpp: "#->get_visible_child()".} ## \
## Returns the index of the child that should be visible.

converter getClassType*(_: typedesc[SwitchNode]): TypeHandle {.importcpp: "SwitchNode::get_class_type()", header: "switchNode.h".}

proc newUvScrollNode*(name: string): UvScrollNode {.importcpp: "new UvScrollNode(nimStringToStdString(#))", header: stringConversionCode.}

proc newUvScrollNode*(name: string, u_speed: float32, v_speed: float32, w_speed: float32, r_speed: float32): UvScrollNode {.importcpp: "new UvScrollNode(nimStringToStdString(#), #, #, #, #)", header: stringConversionCode.}

proc setUSpeed*(this: UvScrollNode, u_speed: float32) {.importcpp: "#->set_u_speed(#)".}

proc setVSpeed*(this: UvScrollNode, v_speed: float32) {.importcpp: "#->set_v_speed(#)".}

proc setWSpeed*(this: UvScrollNode, w_speed: float32) {.importcpp: "#->set_w_speed(#)".}

proc setRSpeed*(this: UvScrollNode, r_speed: float32) {.importcpp: "#->set_r_speed(#)".}

proc getUSpeed*(this: UvScrollNode): float32 {.importcpp: "#->get_u_speed()".}

proc getVSpeed*(this: UvScrollNode): float32 {.importcpp: "#->get_v_speed()".}

proc getWSpeed*(this: UvScrollNode): float32 {.importcpp: "#->get_w_speed()".}

proc getRSpeed*(this: UvScrollNode): float32 {.importcpp: "#->get_r_speed()".}

converter getClassType*(_: typedesc[UvScrollNode]): TypeHandle {.importcpp: "UvScrollNode::get_class_type()", header: "uvScrollNode.h".}

proc initSceneGraphAnalyzer*(): SceneGraphAnalyzer {.importcpp: "SceneGraphAnalyzer()".}

proc initSceneGraphAnalyzer*(param0: SceneGraphAnalyzer): SceneGraphAnalyzer {.importcpp: "SceneGraphAnalyzer(#)".}

proc clear*(this: SceneGraphAnalyzer) {.importcpp: "#.clear()".} ## \
## Resets all of the data in the analyzer in preparation for a new run.

proc addNode*(this: SceneGraphAnalyzer, node: PandaNode) {.importcpp: "#.add_node(#)".} ## \
## Adds a new node to the set of data for analysis.  Normally, this would only
## be called once, and passed the top of the scene graph, but it's possible to
## repeatedly pass in subgraphs to get an analysis of all the graphs together.

proc write*(this: SceneGraphAnalyzer, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Describes all the data collected.

proc write*(this: SceneGraphAnalyzer, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Describes all the data collected.

proc getNumNodes*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_nodes()".}

proc getNumInstances*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_instances()".}

proc getNumTransforms*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_transforms()".}

proc getNumNodesWithAttribs*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_nodes_with_attribs()".}

proc getNumLodNodes*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_lod_nodes()".}

proc getNumGeomNodes*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_geom_nodes()".}

proc getNumGeoms*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_geoms()".}

proc getNumGeomVertexDatas*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_geom_vertex_datas()".}

proc getNumGeomVertexFormats*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_geom_vertex_formats()".}

proc getVertexDataSize*(this: SceneGraphAnalyzer): clonglong {.importcpp: "#.get_vertex_data_size()".}

proc getNumVertices*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_vertices()".}

proc getNumNormals*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_normals()".}

proc getNumColors*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_colors()".}

proc getNumTexcoords*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_texcoords()".}

proc getNumTris*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_tris()".}

proc getNumLines*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_lines()".}

proc getNumPoints*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_points()".}

proc getNumPatches*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_patches()".}

proc getNumIndividualTris*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_individual_tris()".}

proc getNumTristrips*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_tristrips()".}

proc getNumTrianglesInStrips*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_triangles_in_strips()".}

proc getNumTrifans*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_trifans()".}

proc getNumTrianglesInFans*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_triangles_in_fans()".}

proc getNumVerticesInPatches*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_vertices_in_patches()".}

proc getTextureBytes*(this: SceneGraphAnalyzer): clonglong {.importcpp: "#.get_texture_bytes()".}

proc getNumLongNormals*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_long_normals()".}

proc getNumShortNormals*(this: SceneGraphAnalyzer): int {.importcpp: "#.get_num_short_normals()".}

proc getTotalNormalLength*(this: SceneGraphAnalyzer): float32 {.importcpp: "#.get_total_normal_length()".}

proc `!=`*(this: TransformState, other: TransformState): bool {.importcpp: "#->operator !=(#)".}

proc compareTo*(this: TransformState, other: TransformState): int {.importcpp: "#->compare_to(#)".} ## \
## Provides an arbitrary ordering among all unique TransformStates, so we can
## store the essentially different ones in a big set and throw away the rest.
##
## Note that if this returns 0, it doesn't necessarily imply that operator ==
## returns true; it uses a very slightly different comparison threshold.

proc compareTo*(this: TransformState, other: TransformState, uniquify_matrix: bool): int {.importcpp: "#->compare_to(#, #)".} ## \
## Provides an arbitrary ordering among all unique TransformStates, so we can
## store the essentially different ones in a big set and throw away the rest.
##
## Note that if this returns 0, it doesn't necessarily imply that operator ==
## returns true; it uses a very slightly different comparison threshold.
##
## If uniquify_matrix is true, then matrix-defined TransformStates are also
## uniqified.  If uniquify_matrix is false, then only component-defined
## TransformStates are uniquified, which is less expensive.

proc `==`*(this: TransformState, other: TransformState): bool {.importcpp: "#->operator ==(#)".}

proc getHash*(this: TransformState): clonglong {.importcpp: "#->get_hash()".} ## \
## Returns a suitable hash value for phash_map.

proc makeIdentity*(_: typedesc[TransformState]): TransformState {.importcpp: "deconstify(TransformState::make_identity())", header: "transformState.h".} ## \
## Constructs an identity transform.

proc makeInvalid*(_: typedesc[TransformState]): TransformState {.importcpp: "deconstify(TransformState::make_invalid())", header: "transformState.h".} ## \
## Constructs an invalid transform; for instance, the result of inverting a
## singular matrix.

proc makePos*(_: typedesc[TransformState], pos: LVecBase3): TransformState {.importcpp: "deconstify(#TransformState::make_pos(#))", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc makeHpr*(_: typedesc[TransformState], hpr: LVecBase3): TransformState {.importcpp: "deconstify(#TransformState::make_hpr(#))", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc makeQuat*(_: typedesc[TransformState], quat: LQuaternion): TransformState {.importcpp: "deconstify(#TransformState::make_quat(#))", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc makePosHpr*(_: typedesc[TransformState], pos: LVecBase3, hpr: LVecBase3): TransformState {.importcpp: "deconstify(#TransformState::make_pos_hpr(#, #))", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc makeScale*(_: typedesc[TransformState], scale: LVecBase3): TransformState {.importcpp: "deconstify(#TransformState::make_scale(#))", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc makeScale*(_: typedesc[TransformState], scale: float32): TransformState {.importcpp: "deconstify(#TransformState::make_scale(#))", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc makeShear*(_: typedesc[TransformState], shear: LVecBase3): TransformState {.importcpp: "deconstify(#TransformState::make_shear(#))", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc makePosHprScale*(_: typedesc[TransformState], pos: LVecBase3, hpr: LVecBase3, scale: LVecBase3): TransformState {.importcpp: "deconstify(#TransformState::make_pos_hpr_scale(#, #, #))", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc makePosQuatScale*(_: typedesc[TransformState], pos: LVecBase3, quat: LQuaternion, scale: LVecBase3): TransformState {.importcpp: "deconstify(#TransformState::make_pos_quat_scale(#, #, #))", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc makePosHprScaleShear*(_: typedesc[TransformState], pos: LVecBase3, hpr: LVecBase3, scale: LVecBase3, shear: LVecBase3): TransformState {.importcpp: "deconstify(#TransformState::make_pos_hpr_scale_shear(#, #, #, #))", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc makePosQuatScaleShear*(_: typedesc[TransformState], pos: LVecBase3, quat: LQuaternion, scale: LVecBase3, shear: LVecBase3): TransformState {.importcpp: "deconstify(#TransformState::make_pos_quat_scale_shear(#, #, #, #))", header: "transformState.h".} ## \
## Makes a new TransformState with the specified components.

proc makeMat*(_: typedesc[TransformState], mat: LMatrix4): TransformState {.importcpp: "deconstify(#TransformState::make_mat(#))", header: "transformState.h".} ## \
## Makes a new TransformState with the specified transformation matrix.

proc makePos2d*(_: typedesc[TransformState], pos: LVecBase2): TransformState {.importcpp: "deconstify(#TransformState::make_pos2d(#))", header: "transformState.h".} ## \
## Makes a new 2-d TransformState with the specified components.

proc makeRotate2d*(_: typedesc[TransformState], rotate: float32): TransformState {.importcpp: "deconstify(#TransformState::make_rotate2d(#))", header: "transformState.h".} ## \
## Makes a new 2-d TransformState with the specified components.

proc makePosRotate2d*(_: typedesc[TransformState], pos: LVecBase2, rotate: float32): TransformState {.importcpp: "deconstify(#TransformState::make_pos_rotate2d(#, #))", header: "transformState.h".} ## \
## Makes a new 2-d TransformState with the specified components.

proc makeScale2d*(_: typedesc[TransformState], scale: LVecBase2): TransformState {.importcpp: "deconstify(#TransformState::make_scale2d(#))", header: "transformState.h".} ## \
## Makes a new 2-d TransformState with the specified components.

proc makeScale2d*(_: typedesc[TransformState], scale: float32): TransformState {.importcpp: "deconstify(#TransformState::make_scale2d(#))", header: "transformState.h".} ## \
## Makes a new 2-d TransformState with the specified components.

proc makeShear2d*(_: typedesc[TransformState], shear: float32): TransformState {.importcpp: "deconstify(#TransformState::make_shear2d(#))", header: "transformState.h".} ## \
## Makes a new 2-d TransformState with the specified components.

proc makePosRotateScale2d*(_: typedesc[TransformState], pos: LVecBase2, rotate: float32, scale: LVecBase2): TransformState {.importcpp: "deconstify(#TransformState::make_pos_rotate_scale2d(#, #, #))", header: "transformState.h".} ## \
## Makes a new 2-d TransformState with the specified components.

proc makePosRotateScaleShear2d*(_: typedesc[TransformState], pos: LVecBase2, rotate: float32, scale: LVecBase2, shear: float32): TransformState {.importcpp: "deconstify(#TransformState::make_pos_rotate_scale_shear2d(#, #, #, #))", header: "transformState.h".} ## \
## Makes a new two-dimensional TransformState with the specified components.

proc makeMat3*(_: typedesc[TransformState], mat: LMatrix3): TransformState {.importcpp: "deconstify(#TransformState::make_mat3(#))", header: "transformState.h".} ## \
## Makes a new two-dimensional TransformState with the specified 3x3
## transformation matrix.

proc isIdentity*(this: TransformState): bool {.importcpp: "#->is_identity()".} ## \
## Returns true if the transform represents the identity matrix, false
## otherwise.

proc isInvalid*(this: TransformState): bool {.importcpp: "#->is_invalid()".} ## \
## Returns true if the transform represents an invalid matrix, for instance
## the result of inverting a singular matrix, or false if the transform is
## valid.

proc isSingular*(this: TransformState): bool {.importcpp: "#->is_singular()".} ## \
## Returns true if the transform represents a singular transform (that is, it
## has a zero scale, and it cannot be inverted), or false otherwise.

proc is2d*(this: TransformState): bool {.importcpp: "#->is_2d()".} ## \
## Returns true if the transform has been constructed entirely using the 2-d
## transform operations, e.g.  make_pos2d(), and therefore operates strictly
## in two-dimensional space on X and Y only.

proc hasComponents*(this: TransformState): bool {.importcpp: "#->has_components()".} ## \
## Returns true if the transform can be described by separate pos, hpr, and
## scale components.  Most transforms we use in everyday life can be so
## described, but some kinds of transforms (for instance, those involving a
## skew) cannot.
##
## This is not related to whether the transform was originally described
## componentwise.  Even a transform that was constructed with a 4x4 may return
## true here if the matrix is a simple affine matrix with no skew.
##
## If this returns true, you may safely call get_hpr() and get_scale() to
## retrieve the components.  (You may always safely call get_pos() whether
## this returns true or false.)

proc componentsGiven*(this: TransformState): bool {.importcpp: "#->components_given()".} ## \
## Returns true if the transform was specified componentwise, or false if it
## was specified with a general 4x4 matrix.  If this is true, the components
## returned by get_pos() and get_scale() will be exactly those that were set;
## otherwise, these functions will return computed values.  If this is true,
## the rotation may have been set either with a hpr trio or with a quaternion;
## hpr_given() or quat_given() can resolve the difference.

proc hprGiven*(this: TransformState): bool {.importcpp: "#->hpr_given()".} ## \
## Returns true if the rotation was specified via a trio of Euler angles,
## false otherwise.  If this is true, get_hpr() will be exactly as set;
## otherwise, it will return a computed value.

proc quatGiven*(this: TransformState): bool {.importcpp: "#->quat_given()".} ## \
## Returns true if the rotation was specified via a quaternion, false
## otherwise.  If this is true, get_quat() will be exactly as set; otherwise,
## it will return a computed value.

proc hasPos*(this: TransformState): bool {.importcpp: "#->has_pos()".} ## \
## Returns true if the transform's pos component can be extracted out
## separately.  This is generally always true, unless the transform is invalid
## (i.e.  is_invalid() returns true).

proc hasHpr*(this: TransformState): bool {.importcpp: "#->has_hpr()".} ## \
## Returns true if the transform's rotation component can be extracted out
## separately and described as a set of Euler angles.  This is generally true
## only when has_components() is true.

proc hasQuat*(this: TransformState): bool {.importcpp: "#->has_quat()".} ## \
## Returns true if the transform's rotation component can be extracted out
## separately and described as a quaternion.  This is generally true only when
## has_components() is true.

proc hasScale*(this: TransformState): bool {.importcpp: "#->has_scale()".} ## \
## Returns true if the transform's scale component can be extracted out
## separately.  This is generally true only when has_components() is true.

proc hasIdentityScale*(this: TransformState): bool {.importcpp: "#->has_identity_scale()".} ## \
## Returns true if the scale is uniform 1.0, or false if the scale has some
## real value.

proc hasUniformScale*(this: TransformState): bool {.importcpp: "#->has_uniform_scale()".} ## \
## Returns true if the scale is uniform across all three axes (and therefore
## can be expressed as a single number), or false if the transform has a
## different scale in different dimensions.

proc hasShear*(this: TransformState): bool {.importcpp: "#->has_shear()".} ## \
## Returns true if the transform's shear component can be extracted out
## separately.  This is generally true only when has_components() is true.

proc hasNonzeroShear*(this: TransformState): bool {.importcpp: "#->has_nonzero_shear()".} ## \
## Returns true if the shear component is non-zero, false if it is zero or if
## the matrix cannot be decomposed.

proc hasMat*(this: TransformState): bool {.importcpp: "#->has_mat()".} ## \
## Returns true if the transform can be described as a matrix.  This is
## generally always true, unless is_invalid() is true.

proc getPos*(this: TransformState): LPoint3 {.importcpp: "#->get_pos()".} ## \
## Returns the pos component of the transform.  It is an error to call this if
## has_pos() returned false.

proc getHpr*(this: TransformState): LVecBase3 {.importcpp: "#->get_hpr()".} ## \
## Returns the rotation component of the transform as a trio of Euler angles.
## It is an error to call this if has_components() returned false.

proc getQuat*(this: TransformState): LQuaternion {.importcpp: "#->get_quat()".} ## \
## Returns the rotation component of the transform as a quaternion.  The
## return value will be normalized if a normalized quaternion was given to the
## constructor (or if the quaternion was computed implicitly); it will be non-
## normalized if a non-normalized quaternion was given to the constructor.
## See also get_norm_quat().
##
## It is an error to call this if has_components() returned false.

proc getNormQuat*(this: TransformState): LQuaternion {.importcpp: "#->get_norm_quat()".} ## \
## Returns the rotation component of the transform as a quaternion.  Unlike
## the result of get_quat(), the return value of this method is guaranteed to
## be normalized.  It is an error to call this if has_components() returned
## false.

proc getScale*(this: TransformState): LVecBase3 {.importcpp: "#->get_scale()".} ## \
## Returns the scale component of the transform.  It is an error to call this
## if has_components() returned false.

proc getUniformScale*(this: TransformState): float32 {.importcpp: "#->get_uniform_scale()".} ## \
## Returns the scale component of the transform, as a single number.  It is an
## error to call this if has_uniform_scale() returned false.

proc getShear*(this: TransformState): LVecBase3 {.importcpp: "#->get_shear()".} ## \
## Returns the shear component of the transform.  It is an error to call this
## if has_components() returned false.

proc getMat*(this: TransformState): LMatrix4 {.importcpp: "#->get_mat()".} ## \
## Returns the matrix that describes the transform.

proc getPos2d*(this: TransformState): LVecBase2 {.importcpp: "#->get_pos2d()".} ## \
## Returns the pos component of the 2-d transform.  It is an error to call
## this if has_pos() or is_2d() returned false.

proc getRotate2d*(this: TransformState): float32 {.importcpp: "#->get_rotate2d()".} ## \
## Returns the rotation component of the 2-d transform as an angle in degrees
## clockwise about the origin.  It is an error to call this if
## has_components() or is_2d() returned false.

proc getScale2d*(this: TransformState): LVecBase2 {.importcpp: "#->get_scale2d()".} ## \
## Returns the scale component of the 2-d transform.  It is an error to call
## this if has_components() or is_2d() returned false.

proc getShear2d*(this: TransformState): float32 {.importcpp: "#->get_shear2d()".} ## \
## Returns the shear component of the 2-d transform.  It is an error to call
## this if has_components() or is_2d() returned false.

proc getMat3*(this: TransformState): LMatrix3 {.importcpp: "#->get_mat3()".} ## \
## Returns the 3x3 matrix that describes the 2-d transform.  It is an error to
## call this if is_2d() returned false.

proc setPos*(this: TransformState, pos: LVecBase3): TransformState {.importcpp: "deconstify(#->set_pos(#))", header: deconstifyCode.} ## \
## Returns a new TransformState object that represents the original
## TransformState with its pos component replaced with the indicated value.

proc setHpr*(this: TransformState, hpr: LVecBase3): TransformState {.importcpp: "deconstify(#->set_hpr(#))", header: deconstifyCode.} ## \
## Returns a new TransformState object that represents the original
## TransformState with its rotation component replaced with the indicated
## value, if possible.

proc setQuat*(this: TransformState, quat: LQuaternion): TransformState {.importcpp: "deconstify(#->set_quat(#))", header: deconstifyCode.} ## \
## Returns a new TransformState object that represents the original
## TransformState with its rotation component replaced with the indicated
## value, if possible.

proc setScale*(this: TransformState, scale: LVecBase3): TransformState {.importcpp: "deconstify(#->set_scale(#))", header: deconstifyCode.} ## \
## Returns a new TransformState object that represents the original
## TransformState with its scale component replaced with the indicated value,
## if possible.

proc setShear*(this: TransformState, shear: LVecBase3): TransformState {.importcpp: "deconstify(#->set_shear(#))", header: deconstifyCode.} ## \
## Returns a new TransformState object that represents the original
## TransformState with its shear component replaced with the indicated value,
## if possible.

proc setPos2d*(this: TransformState, pos: LVecBase2): TransformState {.importcpp: "deconstify(#->set_pos2d(#))", header: deconstifyCode.} ## \
## Returns a new TransformState object that represents the original 2-d
## TransformState with its pos component replaced with the indicated value.

proc setRotate2d*(this: TransformState, rotate: float32): TransformState {.importcpp: "deconstify(#->set_rotate2d(#))", header: deconstifyCode.} ## \
## Returns a new TransformState object that represents the original 2-d
## TransformState with its rotation component replaced with the indicated
## value, if possible.

proc setScale2d*(this: TransformState, scale: LVecBase2): TransformState {.importcpp: "deconstify(#->set_scale2d(#))", header: deconstifyCode.} ## \
## Returns a new TransformState object that represents the original 2-d
## TransformState with its scale component replaced with the indicated value,
## if possible.

proc setShear2d*(this: TransformState, shear: float32): TransformState {.importcpp: "deconstify(#->set_shear2d(#))", header: deconstifyCode.} ## \
## Returns a new TransformState object that represents the original 2-d
## TransformState with its shear component replaced with the indicated value,
## if possible.

proc compose*(this: TransformState, other: TransformState): TransformState {.importcpp: "deconstify(#->compose(#))", header: deconstifyCode.} ## \
## Returns a new TransformState object that represents the composition of this
## state with the other state.
##
## The result of this operation is cached, and will be retained as long as
## both this TransformState object and the other TransformState object
## continue to exist.  Should one of them destruct, the cached entry will be
## removed, and its pointer will be allowed to destruct as well.

proc invertCompose*(this: TransformState, other: TransformState): TransformState {.importcpp: "deconstify(#->invert_compose(#))", header: deconstifyCode.} ## \
## Returns a new TransformState object that represents the composition of this
## state's inverse with the other state.
##
## This is similar to compose(), but is particularly useful for computing the
## relative state of a node as viewed from some other node.

proc getInverse*(this: TransformState): TransformState {.importcpp: "deconstify(#->get_inverse())", header: deconstifyCode.} ## \
## Returns the inverse of this transform.  If you are going to immediately
## compose this result with another TransformState, it is faster to do it in
## one operation with invert_compose().

proc getUnique*(this: TransformState): TransformState {.importcpp: "deconstify(#->get_unique())", header: deconstifyCode.} ## \
## Returns the pointer to the unique TransformState in the cache that is
## equivalent to this one.  This may be the same pointer as this object, or it
## may be a different pointer; but it will be an equivalent object, and it
## will be a shared pointer.  This may be called from time to time to improve
## cache benefits.

proc getGeomRendering*(this: TransformState, geom_rendering: int): int {.importcpp: "#->get_geom_rendering(#)".} ## \
## Returns the union of the Geom::GeomRendering bits that will be required
## once this TransformState is applied to a geom which includes the indicated
## geom_rendering bits.  The RenderState's get_geom_rendering() should already
## have been applied.

proc cacheRef*(this: TransformState) {.importcpp: "#->cache_ref()".} ## \
## Overrides this method to update PStats appropriately.

proc cacheUnref*(this: TransformState): bool {.importcpp: "#->cache_unref()".} ## \
## Overrides this method to update PStats appropriately.

proc nodeRef*(this: TransformState) {.importcpp: "#->node_ref()".} ## \
## Overrides this method to update PStats appropriately.

proc nodeUnref*(this: TransformState): bool {.importcpp: "#->node_unref()".} ## \
## Overrides this method to update PStats appropriately.

proc getCompositionCacheNumEntries*(this: TransformState): clonglong {.importcpp: "#->get_composition_cache_num_entries()".} ## \
## Returns the number of entries in the composition cache for this
## TransformState.  This is the number of other TransformStates whose
## composition with this one has been cached.  This number is not useful for
## any practical reason other than performance analysis.

proc getInvertCompositionCacheNumEntries*(this: TransformState): clonglong {.importcpp: "#->get_invert_composition_cache_num_entries()".} ## \
## Returns the number of entries in the invert_composition cache for this
## TransformState.  This is similar to the composition cache, but it records
## cache entries for the invert_compose() operation.  See
## get_composition_cache_num_entries().

proc getCompositionCacheSize*(this: TransformState): clonglong {.importcpp: "#->get_composition_cache_size()".} ## \
## Returns the number of slots in the composition cache for this
## TransformState.  You may use this as an upper bound when walking through
## all of the composition cache results via get_composition_cache_source() or
## result().
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc getCompositionCacheSource*(this: TransformState, n: clonglong): TransformState {.importcpp: "deconstify(#->get_composition_cache_source(#))", header: deconstifyCode.} ## \
## Returns the source TransformState of the nth element in the composition
## cache.  Returns NULL if there doesn't happen to be an entry in the nth
## element.  See get_composition_cache_result().
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc getCompositionCacheResult*(this: TransformState, n: clonglong): TransformState {.importcpp: "deconstify(#->get_composition_cache_result(#))", header: deconstifyCode.} ## \
## Returns the result TransformState of the nth element in the composition
## cache.  Returns NULL if there doesn't happen to be an entry in the nth
## element.
##
## In general, a->compose(a->get_composition_cache_source(n)) ==
## a->get_composition_cache_result(n).
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc getInvertCompositionCacheSize*(this: TransformState): clonglong {.importcpp: "#->get_invert_composition_cache_size()".} ## \
## Returns the number of slots in the composition cache for this
## TransformState.  You may use this as an upper bound when walking through
## all of the composition cache results via
## get_invert_composition_cache_source() or result().
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc getInvertCompositionCacheSource*(this: TransformState, n: clonglong): TransformState {.importcpp: "deconstify(#->get_invert_composition_cache_source(#))", header: deconstifyCode.} ## \
## Returns the source TransformState of the nth element in the invert
## composition cache.  Returns NULL if there doesn't happen to be an entry in
## the nth element.  See get_invert_composition_cache_result().
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc getInvertCompositionCacheResult*(this: TransformState, n: clonglong): TransformState {.importcpp: "deconstify(#->get_invert_composition_cache_result(#))", header: deconstifyCode.} ## \
## Returns the result TransformState of the nth element in the invert
## composition cache.  Returns NULL if there doesn't happen to be an entry in
## the nth element.
##
## In general, a->invert_compose(a->get_invert_composition_cache_source(n)) ==
## a->get_invert_composition_cache_result(n).
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc validateCompositionCache*(this: TransformState): bool {.importcpp: "#->validate_composition_cache()".} ## \
## Returns true if the composition cache and invert composition cache for this
## particular TransformState are self-consistent and valid, false otherwise.

proc output*(this: TransformState, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: TransformState, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc writeCompositionCache*(this: TransformState, `out`: ostream, indent_level: int) {.importcpp: "#->write_composition_cache(#, #)".} ## \
## Writes a brief description of the composition cache and invert composition
## cache to the indicated ostream.  This is not useful except for performance
## analysis, to examine the cache structure.

proc getNumStates*(_: typedesc[TransformState]): int {.importcpp: "TransformState::get_num_states()", header: "transformState.h".} ## \
## Returns the total number of unique TransformState objects allocated in the
## world.  This will go up and down during normal operations.

proc getNumUnusedStates*(_: typedesc[TransformState]): int {.importcpp: "TransformState::get_num_unused_states()", header: "transformState.h".} ## \
## Returns the total number of TransformState objects that have been allocated
## but have no references outside of the internal TransformState cache.
##
## A nonzero return value is not necessarily indicative of leaked references;
## it is normal for two TransformState objects, both of which have references
## held outside the cache, to have the result of their composition stored
## within the cache.  This result will be retained within the cache until one
## of the base TransformStates is released.
##
## Use list_cycles() to get an idea of the number of actual "leaked"
## TransformState objects.

proc clearCache*(_: typedesc[TransformState]): int {.importcpp: "TransformState::clear_cache()", header: "transformState.h".} ## \
## Empties the cache of composed TransformStates.  This makes every
## TransformState forget what results when it is composed with other
## TransformStates.
##
## This will eliminate any TransformState objects that have been allocated but
## have no references outside of the internal TransformState map.  It will not
## eliminate TransformState objects that are still in use.
##
## Nowadays, this method should not be necessary, as reference-count cycles in
## the composition cache should be automatically detected and broken.
##
## The return value is the number of TransformStates freed by this operation.

proc garbageCollect*(_: typedesc[TransformState]): int {.importcpp: "TransformState::garbage_collect()", header: "transformState.h".} ## \
## Performs a garbage-collection cycle.  This must be called periodically if
## garbage-collect-states is true to ensure that TransformStates get cleaned
## up appropriately.  It does no harm to call it even if this variable is not
## true, but there is probably no advantage in that case.

proc listCycles*(_: typedesc[TransformState], `out`: ostream) {.importcpp: "#TransformState::list_cycles(#)", header: "transformState.h".} ## \
## Detects all of the reference-count cycles in the cache and reports them to
## standard output.
##
## These cycles may be inadvertently created when state compositions cycle
## back to a starting point.  Nowadays, these cycles should be automatically
## detected and broken, so this method should never list any cycles unless
## there is a bug in that detection logic.
##
## The cycles listed here are not leaks in the strictest sense of the word,
## since they can be reclaimed by a call to clear_cache(); but they will not
## be reclaimed automatically.

proc listStates*(_: typedesc[TransformState], `out`: ostream) {.importcpp: "#TransformState::list_states(#)", header: "transformState.h".} ## \
## Lists all of the TransformStates in the cache to the output stream, one per
## line.  This can be quite a lot of output if the cache is large, so be
## prepared.

proc validateStates*(_: typedesc[TransformState]): bool {.importcpp: "TransformState::validate_states()", header: "transformState.h".} ## \
## Ensures that the cache is still stored in sorted order, and that none of
## the cache elements have been inadvertently deleted.  Returns true if so,
## false if there is a problem (which implies someone has modified one of the
## supposedly-const TransformState objects).

converter getClassType*(_: typedesc[TransformState]): TypeHandle {.importcpp: "TransformState::get_class_type()", header: "transformState.h".}

proc getSlot*(this: RenderAttribRegistry, type_handle: TypeHandle): int {.importcpp: "#.get_slot(#)".} ## \
## Returns the slot number assigned to the indicated TypeHandle, or 0 if no
## slot number has been assigned.

proc getMaxSlots*(_: typedesc[RenderAttribRegistry]): int {.importcpp: "RenderAttribRegistry::get_max_slots()", header: "renderAttribRegistry.h".}

proc getNumSlots*(this: RenderAttribRegistry): int {.importcpp: "#.get_num_slots()".} ## \
## Returns the number of RenderAttrib slots that have been allocated.  This is
## one more than the highest slot number in use.

proc getSlotType*(this: RenderAttribRegistry, slot: int): TypeHandle {.importcpp: "#.get_slot_type(#)".} ## \
## Returns the TypeHandle associated with slot n.

proc getSlotSort*(this: RenderAttribRegistry, slot: int): int {.importcpp: "#.get_slot_sort(#)".} ## \
## Returns the sort number associated with slot n.

proc setSlotSort*(this: RenderAttribRegistry, slot: int, sort: int) {.importcpp: "#.set_slot_sort(#, #)".} ## \
## Changes the sort number associated with slot n.

proc getSlotDefault*(this: RenderAttribRegistry, slot: int): RenderAttrib {.importcpp: "#.get_slot_default(#)".} ## \
## Returns the default RenderAttrib object associated with slot n.  This is
## the attrib that should be applied in the absence of any other attrib of
## this type.

proc getNumSortedSlots*(this: RenderAttribRegistry): int {.importcpp: "#.get_num_sorted_slots()".} ## \
## Returns the number of entries in the sorted_slots list.

proc getSortedSlot*(this: RenderAttribRegistry, n: int): int {.importcpp: "#.get_sorted_slot(#)".} ## \
## Returns the nth slot in sorted order.  By traversing this list, you will
## retrieve all the slot numbers in order according to their registered sort
## value.

proc getGlobalPtr*(_: typedesc[RenderAttribRegistry]): RenderAttribRegistry {.importcpp: "RenderAttribRegistry::get_global_ptr()", header: "renderAttribRegistry.h".}

proc compose*(this: RenderAttrib, other: RenderAttrib): RenderAttrib {.importcpp: "deconstify(#->compose(#))", header: deconstifyCode.} ## \
## Returns a new RenderAttrib object that represents the composition of this
## attrib with the other attrib.  In most cases, this is the same as the other
## attrib; a compose b produces b.  Some kinds of attributes, like a
## TextureTransform, for instance, might produce a new result: a compose b
## produces c.

proc invertCompose*(this: RenderAttrib, other: RenderAttrib): RenderAttrib {.importcpp: "deconstify(#->invert_compose(#))", header: deconstifyCode.} ## \
## Returns a new RenderAttrib object that represents the composition of the
## inverse of this attrib with the other attrib.  In most cases, this is the
## same as the other attrib; !a compose b produces b.  Some kinds of
## attributes, like a TextureTransform, for instance, might produce a new
## result: !a compose b produces c.
##
## This is similar to compose() except that the source attrib is inverted
## first.  This is used to compute the relative attribute for one node as
## viewed from some other node, which is especially useful for transform-type
## attributes.

proc lowerAttribCanOverride*(this: RenderAttrib): bool {.importcpp: "#->lower_attrib_can_override()".} ## \
## Intended to be overridden by derived RenderAttrib types to specify how two
## consecutive RenderAttrib objects of the same type interact.
##
## This should return false if a RenderAttrib on a higher node will compose
## into a RenderAttrib on a lower node that has a higher override value, or
## true if the lower RenderAttrib will completely replace the state.
##
## The default behavior is false: normally, a RenderAttrib in the graph cannot
## completely override a RenderAttrib above it, regardless of its override
## value--instead, the two attribs are composed.  But for some kinds of
## RenderAttribs, it is useful to allow this kind of override.
##
## This method only handles the one special case of a lower RenderAttrib with
## a higher override value.  If the higher RenderAttrib has a higher override
## value, it always completely overrides.  And if both RenderAttribs have the
## same override value, they are always composed.

proc compareTo*(this: RenderAttrib, other: RenderAttrib): int {.importcpp: "#->compare_to(#)".} ## \
## Provides an arbitrary ordering among all unique RenderAttribs, so we can
## store the essentially different ones in a big set and throw away the rest.
##
## This method is not needed outside of the RenderAttrib class because all
## equivalent RenderAttrib objects are guaranteed to share the same pointer;
## thus, a pointer comparison is always sufficient.

proc getHash*(this: RenderAttrib): clonglong {.importcpp: "#->get_hash()".} ## \
## Returns a suitable hash value for phash_map.

proc getUnique*(this: RenderAttrib): RenderAttrib {.importcpp: "deconstify(#->get_unique())", header: deconstifyCode.} ## \
## Returns the pointer to the unique RenderAttrib in the cache that is
## equivalent to this one.  This may be the same pointer as this object, or it
## may be a different pointer; but it will be an equivalent object, and it
## will be a shared pointer.  This may be called from time to time to improve
## cache benefits.

proc output*(this: RenderAttrib, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: RenderAttrib, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc getNumAttribs*(_: typedesc[RenderAttrib]): int {.importcpp: "RenderAttrib::get_num_attribs()", header: "renderAttrib.h".} ## \
## Returns the total number of unique RenderAttrib objects allocated in the
## world.  This will go up and down during normal operations.

proc listAttribs*(_: typedesc[RenderAttrib], `out`: ostream) {.importcpp: "#RenderAttrib::list_attribs(#)", header: "renderAttrib.h".} ## \
## Lists all of the RenderAttribs in the cache to the output stream, one per
## line.  This can be quite a lot of output if the cache is large, so be
## prepared.

proc garbageCollect*(_: typedesc[RenderAttrib]): int {.importcpp: "RenderAttrib::garbage_collect()", header: "renderAttrib.h".} ## \
## Performs a garbage-collection cycle.  This is called automatically from
## RenderState::garbage_collect(); see that method for more information.

proc validateAttribs*(_: typedesc[RenderAttrib]): bool {.importcpp: "RenderAttrib::validate_attribs()", header: "renderAttrib.h".} ## \
## Ensures that the cache is still stored in sorted order.  Returns true if
## so, false if there is a problem (which implies someone has modified one of
## the supposedly-const RenderAttrib objects).

proc getSlot*(this: RenderAttrib): int {.importcpp: "#->get_slot()".}

converter getClassType*(_: typedesc[RenderAttrib]): TypeHandle {.importcpp: "RenderAttrib::get_class_type()", header: "renderAttrib.h".}

proc makeDefault*(_: typedesc[RenderModeAttrib]): RenderAttrib {.importcpp: "deconstify(RenderModeAttrib::make_default())", header: "renderModeAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc getThickness*(this: RenderModeAttrib): float32 {.importcpp: "#->get_thickness()".} ## \
## Returns the line width or point thickness.  This is only relevant when
## rendering points or lines, such as when the mode is M_wireframe or M_point
## (or when rendering actual points or lines primitives in M_polygon mode).

proc getPerspective*(this: RenderModeAttrib): bool {.importcpp: "#->get_perspective()".} ## \
## Returns the perspective flag.  When this is true, the point thickness
## represented by get_thickness() is actually a width in 3-d units, and the
## points should scale according to perspective.  When it is false, the
## default, the point thickness is actually a width in pixels, and points are
## a uniform size regardless of distance from the camera.

proc getWireframeColor*(this: RenderModeAttrib): LColor {.importcpp: "#->get_wireframe_color()".} ## \
## Returns the color that is used in M_filled_wireframe mode to distinguish
## the wireframe from the rest of the geometry.

proc getGeomRendering*(this: RenderModeAttrib, geom_rendering: int): int {.importcpp: "#->get_geom_rendering(#)".} ## \
## Returns the union of the Geom::GeomRendering bits that will be required
## once this RenderModeAttrib is applied to a geom which includes the
## indicated geom_rendering bits.

proc getClassSlot*(_: typedesc[RenderModeAttrib]): int {.importcpp: "RenderModeAttrib::get_class_slot()", header: "renderModeAttrib.h".}

converter getClassType*(_: typedesc[RenderModeAttrib]): TypeHandle {.importcpp: "RenderModeAttrib::get_class_type()", header: "renderModeAttrib.h".}

proc make*(_: typedesc[TexMatrixAttrib]): RenderAttrib {.importcpp: "deconstify(TexMatrixAttrib::make())", header: "texMatrixAttrib.h".} ## \
## Constructs a TexMatrixAttrib that applies no stages at all.

proc make*(_: typedesc[TexMatrixAttrib], mat: LMatrix4): RenderAttrib {.importcpp: "deconstify(#TexMatrixAttrib::make(#))", header: "texMatrixAttrib.h".} ## \
## Constructs a TexMatrixAttrib that applies the indicated matrix to the
## default texture stage.  This interface is deprecated.
##
## @deprecated Use the constructor that takes a TextureStage instead.

proc make*(_: typedesc[TexMatrixAttrib], stage: TextureStage, transform: TransformState): RenderAttrib {.importcpp: "deconstify(#TexMatrixAttrib::make(#, #))", header: "texMatrixAttrib.h".} ## \
## Constructs a TexMatrixAttrib that applies the indicated transform to the
## named texture stage.

proc makeDefault*(_: typedesc[TexMatrixAttrib]): RenderAttrib {.importcpp: "deconstify(TexMatrixAttrib::make_default())", header: "texMatrixAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc addStage*(this: TexMatrixAttrib, stage: TextureStage, transform: TransformState, override: int): RenderAttrib {.importcpp: "deconstify(#->add_stage(#, #, #))", header: deconstifyCode.} ## \
## Returns a new TexMatrixAttrib just like this one, with the indicated
## transform for the given stage.  If this stage already exists, its transform
## is replaced.

proc addStage*(this: TexMatrixAttrib, stage: TextureStage, transform: TransformState): RenderAttrib {.importcpp: "deconstify(#->add_stage(#, #))", header: deconstifyCode.} ## \
## Returns a new TexMatrixAttrib just like this one, with the indicated
## transform for the given stage.  If this stage already exists, its transform
## is replaced.

proc removeStage*(this: TexMatrixAttrib, stage: TextureStage): RenderAttrib {.importcpp: "deconstify(#->remove_stage(#))", header: deconstifyCode.} ## \
## Returns a new TexMatrixAttrib just like this one, with the indicated stage
## removed.

proc isEmpty*(this: TexMatrixAttrib): bool {.importcpp: "#->is_empty()".} ## \
## Returns true if no stages are defined in the TexMatrixAttrib, false if at
## least one is.

proc hasStage*(this: TexMatrixAttrib, stage: TextureStage): bool {.importcpp: "#->has_stage(#)".} ## \
## Returns true if there is a transform associated with the indicated stage,
## or false otherwise (in which case get_transform(stage) will return the
## identity transform).

proc getNumStages*(this: TexMatrixAttrib): int {.importcpp: "#->get_num_stages()".} ## \
## Returns the number of stages that are represented by this attrib.

proc getStage*(this: TexMatrixAttrib, n: int): TextureStage {.importcpp: "#->get_stage(#)".} ## \
## Returns the nth stage that is represented by this attrib.  The
## TextureStages are in no particular order.

proc getMat*(this: TexMatrixAttrib): LMatrix4 {.importcpp: "#->get_mat()".} ## \
## Returns the transformation matrix associated with the default texture
## stage.

proc getMat*(this: TexMatrixAttrib, stage: TextureStage): LMatrix4 {.importcpp: "#->get_mat(#)".} ## \
## Returns the transformation matrix associated with the indicated texture
## stage, or identity matrix if nothing is associated with the indicated
## stage.

proc getTransform*(this: TexMatrixAttrib, stage: TextureStage): TransformState {.importcpp: "deconstify(#->get_transform(#))", header: deconstifyCode.} ## \
## Returns the transformation associated with the indicated texture stage, or
## identity matrix if nothing is associated with the indicated stage.

proc getOverride*(this: TexMatrixAttrib, stage: TextureStage): int {.importcpp: "#->get_override(#)".} ## \
## Returns the override value associated with the indicated stage.

proc getGeomRendering*(this: TexMatrixAttrib, geom_rendering: int): int {.importcpp: "#->get_geom_rendering(#)".} ## \
## Returns the union of the Geom::GeomRendering bits that will be required
## once this TexMatrixAttrib is applied to a geom which includes the indicated
## geom_rendering bits.

proc getClassSlot*(_: typedesc[TexMatrixAttrib]): int {.importcpp: "TexMatrixAttrib::get_class_slot()", header: "texMatrixAttrib.h".}

converter getClassType*(_: typedesc[TexMatrixAttrib]): TypeHandle {.importcpp: "TexMatrixAttrib::get_class_type()", header: "texMatrixAttrib.h".}

proc compareTo*(this: RenderState, other: RenderState): int {.importcpp: "#->compare_to(#)".} ## \
## Provides an arbitrary ordering among all unique RenderStates, so we can
## store the essentially different ones in a big set and throw away the rest.
##
## This method is not needed outside of the RenderState class because all
## equivalent RenderState objects are guaranteed to share the same pointer;
## thus, a pointer comparison is always sufficient.

proc compareSort*(this: RenderState, other: RenderState): int {.importcpp: "#->compare_sort(#)".} ## \
## Returns -1, 0, or 1 according to the relative sorting of these two
## RenderStates, with regards to rendering performance, so that "heavier"
## RenderAttribs (as defined by RenderAttribRegistry::get_slot_sort()) are
## more likely to be grouped together.  This is not related to the sorting
## order defined by compare_to.

proc compareMask*(this: RenderState, other: RenderState, compare_mask: BitMask32): int {.importcpp: "#->compare_mask(#, #)".} ## \
## This version of compare_to takes a slot mask that indicates which
## attributes to include in the comparison.  Unlike compare_to, this method
## compares the attributes by pointer.

proc getHash*(this: RenderState): clonglong {.importcpp: "#->get_hash()".} ## \
## Returns a suitable hash value for phash_map.

proc isEmpty*(this: RenderState): bool {.importcpp: "#->is_empty()".} ## \
## Returns true if the state is empty, false otherwise.

proc hasCullCallback*(this: RenderState): bool {.importcpp: "#->has_cull_callback()".} ## \
## Returns true if any of the RenderAttribs in this state request a
## cull_callback(), false if none of them do.

proc cullCallback*(this: RenderState, trav: CullTraverser, data: CullTraverserData): bool {.importcpp: "#->cull_callback(#, #)".} ## \
## Calls cull_callback() on each attrib.  If any attrib returns false,
## interrupts the list and returns false immediately; otherwise, completes the
## list and returns true.

proc makeEmpty*(_: typedesc[RenderState]): RenderState {.importcpp: "deconstify(RenderState::make_empty())", header: "renderState.h".} ## \
## Returns a RenderState with no attributes set.

proc make*(_: typedesc[RenderState], attrib1: RenderAttrib, attrib2: RenderAttrib, attrib3: RenderAttrib, attrib4: RenderAttrib, attrib5: RenderAttrib, override: int): RenderState {.importcpp: "deconstify(#RenderState::make(#, #, #, #, #, #))", header: "renderState.h".} ## \
## Returns a RenderState with five attributes set.

proc make*(_: typedesc[RenderState], attrib1: RenderAttrib, attrib2: RenderAttrib, attrib3: RenderAttrib, attrib4: RenderAttrib, attrib5: RenderAttrib): RenderState {.importcpp: "deconstify(#RenderState::make(#, #, #, #, #))", header: "renderState.h".} ## \
## Returns a RenderState with five attributes set.

proc make*(_: typedesc[RenderState], attrib1: RenderAttrib, attrib2: RenderAttrib, attrib3: RenderAttrib, attrib4: RenderAttrib, override: int): RenderState {.importcpp: "deconstify(#RenderState::make(#, #, #, #, #))", header: "renderState.h".} ## \
## Returns a RenderState with four attributes set.

proc make*(_: typedesc[RenderState], attrib1: RenderAttrib, attrib2: RenderAttrib, attrib3: RenderAttrib, attrib4: RenderAttrib): RenderState {.importcpp: "deconstify(#RenderState::make(#, #, #, #))", header: "renderState.h".} ## \
## Returns a RenderState with four attributes set.

proc make*(_: typedesc[RenderState], attrib1: RenderAttrib, attrib2: RenderAttrib, attrib3: RenderAttrib, override: int): RenderState {.importcpp: "deconstify(#RenderState::make(#, #, #, #))", header: "renderState.h".} ## \
## Returns a RenderState with three attributes set.

proc make*(_: typedesc[RenderState], attrib1: RenderAttrib, attrib2: RenderAttrib, attrib3: RenderAttrib): RenderState {.importcpp: "deconstify(#RenderState::make(#, #, #))", header: "renderState.h".} ## \
## Returns a RenderState with three attributes set.

proc make*(_: typedesc[RenderState], attrib1: RenderAttrib, attrib2: RenderAttrib, override: int): RenderState {.importcpp: "deconstify(#RenderState::make(#, #, #))", header: "renderState.h".} ## \
## Returns a RenderState with two attributes set.

proc make*(_: typedesc[RenderState], attrib1: RenderAttrib, attrib2: RenderAttrib): RenderState {.importcpp: "deconstify(#RenderState::make(#, #))", header: "renderState.h".} ## \
## Returns a RenderState with two attributes set.

proc make*(_: typedesc[RenderState], attrib: RenderAttrib, override: int): RenderState {.importcpp: "deconstify(#RenderState::make(#, #))", header: "renderState.h".} ## \
## Returns a RenderState with one attribute set.

proc make*(_: typedesc[RenderState], attrib: RenderAttrib): RenderState {.importcpp: "deconstify(#RenderState::make(#))", header: "renderState.h".} ## \
## Returns a RenderState with one attribute set.

proc compose*(this: RenderState, other: RenderState): RenderState {.importcpp: "deconstify(#->compose(#))", header: deconstifyCode.} ## \
## Returns a new RenderState object that represents the composition of this
## state with the other state.
##
## The result of this operation is cached, and will be retained as long as
## both this RenderState object and the other RenderState object continue to
## exist.  Should one of them destruct, the cached entry will be removed, and
## its pointer will be allowed to destruct as well.

proc invertCompose*(this: RenderState, other: RenderState): RenderState {.importcpp: "deconstify(#->invert_compose(#))", header: deconstifyCode.} ## \
## Returns a new RenderState object that represents the composition of this
## state's inverse with the other state.
##
## This is similar to compose(), but is particularly useful for computing the
## relative state of a node as viewed from some other node.

proc addAttrib*(this: RenderState, attrib: RenderAttrib, override: int): RenderState {.importcpp: "deconstify(#->add_attrib(#, #))", header: deconstifyCode.} ## \
## Returns a new RenderState object that represents the same as the source
## state, with the new RenderAttrib added.  If there is already a RenderAttrib
## with the same type, it is replaced (unless the override is lower).

proc addAttrib*(this: RenderState, attrib: RenderAttrib): RenderState {.importcpp: "deconstify(#->add_attrib(#))", header: deconstifyCode.} ## \
## Returns a new RenderState object that represents the same as the source
## state, with the new RenderAttrib added.  If there is already a RenderAttrib
## with the same type, it is replaced (unless the override is lower).

proc setAttrib*(this: RenderState, attrib: RenderAttrib): RenderState {.importcpp: "deconstify(#->set_attrib(#))", header: deconstifyCode.} ## \
## Returns a new RenderState object that represents the same as the source
## state, with the new RenderAttrib added.  If there is already a RenderAttrib
## with the same type, it is replaced unconditionally.  The override is not
## changed.

proc setAttrib*(this: RenderState, attrib: RenderAttrib, override: int): RenderState {.importcpp: "deconstify(#->set_attrib(#, #))", header: deconstifyCode.} ## \
## Returns a new RenderState object that represents the same as the source
## state, with the new RenderAttrib added.  If there is already a RenderAttrib
## with the same type, it is replaced unconditionally.  The override is also
## replaced unconditionally.

proc removeAttrib*(this: RenderState, `type`: TypeHandle): RenderState {.importcpp: "deconstify(#->remove_attrib(#))", header: deconstifyCode.} ## \
## Returns a new RenderState object that represents the same as the source
## state, with the indicated RenderAttrib removed.

proc removeAttrib*(this: RenderState, slot: int): RenderState {.importcpp: "deconstify(#->remove_attrib(#))", header: deconstifyCode.} ## \
## Returns a new RenderState object that represents the same as the source
## state, with the indicated RenderAttrib removed.

proc adjustAllPriorities*(this: RenderState, adjustment: int): RenderState {.importcpp: "deconstify(#->adjust_all_priorities(#))", header: deconstifyCode.} ## \
## Returns a new RenderState object that represents the same as the source
## state, with all attributes' override values incremented (or decremented, if
## negative) by the indicated amount.  If the override would drop below zero,
## it is set to zero.

proc hasAttrib*(this: RenderState, `type`: TypeHandle): bool {.importcpp: "#->has_attrib(#)".} ## \
## Returns true if an attrib of the indicated type is present, false
## otherwise.

proc hasAttrib*(this: RenderState, slot: int): bool {.importcpp: "#->has_attrib(#)".} ## \
## Returns true if an attrib of the indicated type is present, false
## otherwise.

proc getAttrib*(this: RenderState, `type`: TypeHandle): RenderAttrib {.importcpp: "deconstify(#->get_attrib(#))", header: deconstifyCode.} ## \
## Looks for a RenderAttrib of the indicated type in the state, and returns it
## if it is found, or NULL if it is not.

proc getAttrib*(this: RenderState, slot: int): RenderAttrib {.importcpp: "deconstify(#->get_attrib(#))", header: deconstifyCode.} ## \
## Returns the RenderAttrib with the indicated slot index, or NULL if there is
## no such RenderAttrib in the state.

proc getAttribDef*(this: RenderState, slot: int): RenderAttrib {.importcpp: "deconstify(#->get_attrib_def(#))", header: deconstifyCode.} ## \
## Returns the RenderAttrib with the indicated slot index, or the default
## attrib for that slot if there is no such RenderAttrib in the state.

proc getOverride*(this: RenderState, `type`: TypeHandle): int {.importcpp: "#->get_override(#)".} ## \
## Looks for a RenderAttrib of the indicated type in the state, and returns
## its override value if it is found, or 0 if it is not.

proc getOverride*(this: RenderState, slot: int): int {.importcpp: "#->get_override(#)".} ## \
## Looks for a RenderAttrib of the indicated type in the state, and returns
## its override value if it is found, or 0 if it is not.

proc getUnique*(this: RenderState): RenderState {.importcpp: "deconstify(#->get_unique())", header: deconstifyCode.} ## \
## Returns the pointer to the unique RenderState in the cache that is
## equivalent to this one.  This may be the same pointer as this object, or it
## may be a different pointer; but it will be an equivalent object, and it
## will be a shared pointer.  This may be called from time to time to improve
## cache benefits.

proc cacheRef*(this: RenderState) {.importcpp: "#->cache_ref()".} ## \
## Overrides this method to update PStats appropriately.

proc cacheUnref*(this: RenderState): bool {.importcpp: "#->cache_unref()".} ## \
## Overrides this method to update PStats appropriately.

proc nodeRef*(this: RenderState) {.importcpp: "#->node_ref()".} ## \
## Overrides this method to update PStats appropriately.

proc nodeUnref*(this: RenderState): bool {.importcpp: "#->node_unref()".} ## \
## Overrides this method to update PStats appropriately.

proc getCompositionCacheNumEntries*(this: RenderState): clonglong {.importcpp: "#->get_composition_cache_num_entries()".} ## \
## Returns the number of entries in the composition cache for this
## RenderState.  This is the number of other RenderStates whose composition
## with this one has been cached.  This number is not useful for any practical
## reason other than performance analysis.

proc getInvertCompositionCacheNumEntries*(this: RenderState): clonglong {.importcpp: "#->get_invert_composition_cache_num_entries()".} ## \
## Returns the number of entries in the invert_composition cache for this
## RenderState.  This is similar to the composition cache, but it records
## cache entries for the invert_compose() operation.  See
## get_composition_cache_num_entries().

proc getCompositionCacheSize*(this: RenderState): clonglong {.importcpp: "#->get_composition_cache_size()".} ## \
## Returns the number of slots in the composition cache for this RenderState.
## You may use this as an upper bound when walking through all of the
## composition cache results via get_composition_cache_source() or result().
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc getCompositionCacheSource*(this: RenderState, n: clonglong): RenderState {.importcpp: "deconstify(#->get_composition_cache_source(#))", header: deconstifyCode.} ## \
## Returns the source RenderState of the nth element in the composition cache.
## Returns NULL if there doesn't happen to be an entry in the nth element.
## See get_composition_cache_result().
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc getCompositionCacheResult*(this: RenderState, n: clonglong): RenderState {.importcpp: "deconstify(#->get_composition_cache_result(#))", header: deconstifyCode.} ## \
## Returns the result RenderState of the nth element in the composition cache.
## Returns NULL if there doesn't happen to be an entry in the nth element.
##
## In general, a->compose(a->get_composition_cache_source(n)) ==
## a->get_composition_cache_result(n).
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc getInvertCompositionCacheSize*(this: RenderState): clonglong {.importcpp: "#->get_invert_composition_cache_size()".} ## \
## Returns the number of slots in the composition cache for this RenderState.
## You may use this as an upper bound when walking through all of the
## composition cache results via get_invert_composition_cache_source() or
## result().
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc getInvertCompositionCacheSource*(this: RenderState, n: clonglong): RenderState {.importcpp: "deconstify(#->get_invert_composition_cache_source(#))", header: deconstifyCode.} ## \
## Returns the source RenderState of the nth element in the invert composition
## cache.  Returns NULL if there doesn't happen to be an entry in the nth
## element.  See get_invert_composition_cache_result().
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc getInvertCompositionCacheResult*(this: RenderState, n: clonglong): RenderState {.importcpp: "deconstify(#->get_invert_composition_cache_result(#))", header: deconstifyCode.} ## \
## Returns the result RenderState of the nth element in the invert composition
## cache.  Returns NULL if there doesn't happen to be an entry in the nth
## element.
##
## In general, a->invert_compose(a->get_invert_composition_cache_source(n)) ==
## a->get_invert_composition_cache_result(n).
##
## This has no practical value other than for examining the cache for
## performance analysis.

proc output*(this: RenderState, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: RenderState, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc getMaxPriority*(_: typedesc[RenderState]): int {.importcpp: "RenderState::get_max_priority()", header: "renderState.h".} ## \
## Returns the maximum priority number (sometimes called override) that may be
## set on any node.  This may or may not be enforced, but the scene graph code
## assumes that no priority numbers will be larger than this, and some effects
## may not work properly if you use a larger number.

proc getNumStates*(_: typedesc[RenderState]): int {.importcpp: "RenderState::get_num_states()", header: "renderState.h".} ## \
## Returns the total number of unique RenderState objects allocated in the
## world.  This will go up and down during normal operations.

proc getNumUnusedStates*(_: typedesc[RenderState]): int {.importcpp: "RenderState::get_num_unused_states()", header: "renderState.h".} ## \
## Returns the total number of RenderState objects that have been allocated
## but have no references outside of the internal RenderState cache.
##
## A nonzero return value is not necessarily indicative of leaked references;
## it is normal for two RenderState objects, both of which have references
## held outside the cache, to have to result of their composition stored
## within the cache.  This result will be retained within the cache until one
## of the base RenderStates is released.
##
## Use list_cycles() to get an idea of the number of actual "leaked"
## RenderState objects.

proc clearCache*(_: typedesc[RenderState]): int {.importcpp: "RenderState::clear_cache()", header: "renderState.h".} ## \
## Empties the cache of composed RenderStates.  This makes every RenderState
## forget what results when it is composed with other RenderStates.
##
## This will eliminate any RenderState objects that have been allocated but
## have no references outside of the internal RenderState map.  It will not
## eliminate RenderState objects that are still in use.
##
## Nowadays, this method should not be necessary, as reference-count cycles in
## the composition cache should be automatically detected and broken.
##
## The return value is the number of RenderStates freed by this operation.

proc clearMungerCache*(_: typedesc[RenderState]) {.importcpp: "RenderState::clear_munger_cache()", header: "renderState.h".} ## \
## Completely empties the cache of state + gsg -> munger, for all states and
## all gsg's.  Normally there is no need to empty this cache.

proc garbageCollect*(_: typedesc[RenderState]): int {.importcpp: "RenderState::garbage_collect()", header: "renderState.h".} ## \
## Performs a garbage-collection cycle.  This must be called periodically if
## garbage-collect-states is true to ensure that RenderStates get cleaned up
## appropriately.  It does no harm to call it even if this variable is not
## true, but there is probably no advantage in that case.
##
## This automatically calls RenderAttrib::garbage_collect() as well.

proc listCycles*(_: typedesc[RenderState], `out`: ostream) {.importcpp: "#RenderState::list_cycles(#)", header: "renderState.h".} ## \
## Detects all of the reference-count cycles in the cache and reports them to
## standard output.
##
## These cycles may be inadvertently created when state compositions cycle
## back to a starting point.  Nowadays, these cycles should be automatically
## detected and broken, so this method should never list any cycles unless
## there is a bug in that detection logic.
##
## The cycles listed here are not leaks in the strictest sense of the word,
## since they can be reclaimed by a call to clear_cache(); but they will not
## be reclaimed automatically.

proc listStates*(_: typedesc[RenderState], `out`: ostream) {.importcpp: "#RenderState::list_states(#)", header: "renderState.h".} ## \
## Lists all of the RenderStates in the cache to the output stream, one per
## line.  This can be quite a lot of output if the cache is large, so be
## prepared.

proc validateStates*(_: typedesc[RenderState]): bool {.importcpp: "RenderState::validate_states()", header: "renderState.h".} ## \
## Ensures that the cache is still stored in sorted order, and that none of
## the cache elements have been inadvertently deleted.  Returns true if so,
## false if there is a problem (which implies someone has modified one of the
## supposedly-const RenderState objects).

proc getDrawOrder*(this: RenderState): int {.importcpp: "#->get_draw_order()".} ## \
## Returns the draw order indicated by the CullBinAttrib, if any, associated
## by this state (or 0 if there is no CullBinAttrib).  See get_bin_index().

proc getBinIndex*(this: RenderState): int {.importcpp: "#->get_bin_index()".} ## \
## Returns the bin index indicated by the CullBinAttrib, if any, associated by
## this state (or the default bin index if there is no CullBinAttrib).  This
## function is provided as an optimization for determining this at render
## time.

proc getGeomRendering*(this: RenderState, geom_rendering: int): int {.importcpp: "#->get_geom_rendering(#)".} ## \
## Returns the union of the Geom::GeomRendering bits that will be required
## once this RenderState is applied to a geom which includes the indicated
## geom_rendering bits.

converter getClassType*(_: typedesc[RenderState]): TypeHandle {.importcpp: "RenderState::get_class_type()", header: "renderState.h".}

proc makeDefault*(_: typedesc[AlphaTestAttrib]): RenderAttrib {.importcpp: "deconstify(AlphaTestAttrib::make_default())", header: "alphaTestAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc getReferenceAlpha*(this: AlphaTestAttrib): float32 {.importcpp: "#->get_reference_alpha()".} ## \
## Returns the alpha reference value.

proc getClassSlot*(_: typedesc[AlphaTestAttrib]): int {.importcpp: "AlphaTestAttrib::get_class_slot()", header: "alphaTestAttrib.h".}

converter getClassType*(_: typedesc[AlphaTestAttrib]): TypeHandle {.importcpp: "AlphaTestAttrib::get_class_type()", header: "alphaTestAttrib.h".}

proc make*(_: typedesc[AntialiasAttrib], mode: int): RenderAttrib {.importcpp: "deconstify(#AntialiasAttrib::make(#))", header: "antialiasAttrib.h".} ## \
## Constructs a new AntialiasAttrib object.
##
## The mode should be either M_none, M_auto, or a union of any or all of
## M_point, M_line, M_polygon, and M_multisample.  Also, in addition to the
## above choices, it may include either of M_better of M_faster to specify a
## performance/quality tradeoff hint.
##
## If M_none is specified, no antialiasing is performed.
##
## If M_multisample is specified, it means to use the special framebuffer
## multisample bits for antialiasing, if it is available.  If so, the M_point,
## M_line, and M_polygon modes are ignored.  This advanced antialiasing mode
## is only available on certain graphics hardware.  If it is not available,
## the M_multisample bit is ignored (and the other modes may be used instead,
## if specified).
##
## M_point, M_line, and/or M_polygon specify per-primitive smoothing.  When
## enabled, M_point and M_line may force transparency on.  M_polygon requires
## a frame buffer that includes an alpha channel, and it works best if the
## primitives are sorted front-to-back.
##
## If M_auto is specified, M_multisample is selected if it is available,
## otherwise M_polygon is selected, unless drawing lines or points, in which
## case M_line or M_point is selected (these two generally produce better
## results than M_multisample)

proc makeDefault*(_: typedesc[AntialiasAttrib]): RenderAttrib {.importcpp: "deconstify(AntialiasAttrib::make_default())", header: "antialiasAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc getMode*(this: AntialiasAttrib): int {.importcpp: "#->get_mode()".} ## \
## Returns the specified antialias mode.

proc getModeType*(this: AntialiasAttrib): int {.importcpp: "#->get_mode_type()".} ## \
## Returns the specified antialias mode, with the quality bits masked out.
## This therefore indicates only the requested type of antialiasing: M_none,
## M_auto, or some specific combination.

proc getModeQuality*(this: AntialiasAttrib): int {.importcpp: "#->get_mode_quality()".} ## \
## Returns the specified antialias mode, with the type bits masked out.  This
## therefore indicates only the requested quality settings: one of M_faster,
## M_better, M_dont_care, or zero (unspecified).

proc getClassSlot*(_: typedesc[AntialiasAttrib]): int {.importcpp: "AntialiasAttrib::get_class_slot()", header: "antialiasAttrib.h".}

converter getClassType*(_: typedesc[AntialiasAttrib]): TypeHandle {.importcpp: "AntialiasAttrib::get_class_type()", header: "antialiasAttrib.h".}

proc compareTo*(this: RenderEffect, other: RenderEffect): int {.importcpp: "#->compare_to(#)".} ## \
## Provides an arbitrary ordering among all unique RenderEffects, so we can
## store the essentially different ones in a big set and throw away the rest.
##
## This method is not needed outside of the RenderEffect class because all
## equivalent RenderEffect objects are guaranteed to share the same pointer;
## thus, a pointer comparison is always sufficient.

proc output*(this: RenderEffect, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: RenderEffect, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc getNumEffects*(_: typedesc[RenderEffect]): int {.importcpp: "RenderEffect::get_num_effects()", header: "renderEffect.h".} ## \
## Returns the total number of unique RenderEffect objects allocated in the
## world.  This will go up and down during normal operations.

proc listEffects*(_: typedesc[RenderEffect], `out`: ostream) {.importcpp: "#RenderEffect::list_effects(#)", header: "renderEffect.h".} ## \
## Lists all of the RenderEffects in the cache to the output stream, one per
## line.  This can be quite a lot of output if the cache is large, so be
## prepared.

proc validateEffects*(_: typedesc[RenderEffect]): bool {.importcpp: "RenderEffect::validate_effects()", header: "renderEffect.h".} ## \
## Ensures that the cache is still stored in sorted order.  Returns true if
## so, false if there is a problem (which implies someone has modified one of
## the supposedly-const RenderEffect objects).

converter getClassType*(_: typedesc[RenderEffect]): TypeHandle {.importcpp: "RenderEffect::get_class_type()", header: "renderEffect.h".}

proc `<`*(this: RenderEffects, other: RenderEffects): bool {.importcpp: "#->operator <(#)".}

proc isEmpty*(this: RenderEffects): bool {.importcpp: "#->is_empty()".} ## \
## Returns true if the state is empty, false otherwise.

proc getNumEffects*(this: RenderEffects): clonglong {.importcpp: "#->get_num_effects()".} ## \
## Returns the number of separate effects indicated in the state.
## @deprecated in Python, use len(effects) instead, or effects.size() in C++.

proc getEffect*(this: RenderEffects, `type`: TypeHandle): RenderEffect {.importcpp: "deconstify(#->get_effect(#))", header: deconstifyCode.} ## \
## Looks for a RenderEffect of the indicated type in the state, and returns it
## if it is found, or NULL if it is not.

proc getEffect*(this: RenderEffects, n: clonglong): RenderEffect {.importcpp: "deconstify(#->get_effect(#))", header: deconstifyCode.} ## \
## Returns the nth effect in the state.

proc size*(this: RenderEffects): clonglong {.importcpp: "#->size()".} ## \
## Returns the number of separate effects indicated in the state.

proc `[]`*(this: RenderEffects, `type`: TypeHandle): RenderEffect {.importcpp: "deconstify(#->operator [](#))", header: deconstifyCode.} ## \
## Returns the effect in the state with the given type.

proc `[]`*(this: RenderEffects, n: clonglong): RenderEffect {.importcpp: "deconstify(#->operator [](#))", header: deconstifyCode.} ## \
## Returns the nth effect in the state.

proc findEffect*(this: RenderEffects, `type`: TypeHandle): int {.importcpp: "#->find_effect(#)".} ## \
## Searches for an effect with the indicated type in the state, and returns
## its index if it is found, or -1 if it is not.

proc makeEmpty*(_: typedesc[RenderEffects]): RenderEffects {.importcpp: "deconstify(RenderEffects::make_empty())", header: "renderEffects.h".} ## \
## Returns a RenderEffects with no effects set.

proc make*(_: typedesc[RenderEffects], effect: RenderEffect): RenderEffects {.importcpp: "deconstify(#RenderEffects::make(#))", header: "renderEffects.h".} ## \
## Returns a RenderEffects with one effect set.

proc make*(_: typedesc[RenderEffects], effect1: RenderEffect, effect2: RenderEffect): RenderEffects {.importcpp: "deconstify(#RenderEffects::make(#, #))", header: "renderEffects.h".} ## \
## Returns a RenderEffects with two effects set.

proc make*(_: typedesc[RenderEffects], effect1: RenderEffect, effect2: RenderEffect, effect3: RenderEffect): RenderEffects {.importcpp: "deconstify(#RenderEffects::make(#, #, #))", header: "renderEffects.h".} ## \
## Returns a RenderEffects with three effects set.

proc make*(_: typedesc[RenderEffects], effect1: RenderEffect, effect2: RenderEffect, effect3: RenderEffect, effect4: RenderEffect): RenderEffects {.importcpp: "deconstify(#RenderEffects::make(#, #, #, #))", header: "renderEffects.h".} ## \
## Returns a RenderEffects with four effects set.

proc addEffect*(this: RenderEffects, effect: RenderEffect): RenderEffects {.importcpp: "deconstify(#->add_effect(#))", header: deconstifyCode.} ## \
## Returns a new RenderEffects object that represents the same as the source
## state, with the new RenderEffect added.  If there is already a RenderEffect
## with the same type, it is replaced.

proc removeEffect*(this: RenderEffects, `type`: TypeHandle): RenderEffects {.importcpp: "deconstify(#->remove_effect(#))", header: deconstifyCode.} ## \
## Returns a new RenderEffects object that represents the same as the source
## state, with the indicated RenderEffect removed.

proc output*(this: RenderEffects, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: RenderEffects, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc getNumStates*(_: typedesc[RenderEffects]): int {.importcpp: "RenderEffects::get_num_states()", header: "renderEffects.h".} ## \
## Returns the total number of unique RenderEffects objects allocated in the
## world.  This will go up and down during normal operations.

proc listStates*(_: typedesc[RenderEffects], `out`: ostream) {.importcpp: "#RenderEffects::list_states(#)", header: "renderEffects.h".} ## \
## Lists all of the RenderEffects in the cache to the output stream, one per
## line.  This can be quite a lot of output if the cache is large, so be
## prepared.

proc validateStates*(_: typedesc[RenderEffects]): bool {.importcpp: "RenderEffects::validate_states()", header: "renderEffects.h".} ## \
## Ensures that the cache is still stored in sorted order.  Returns true if
## so, false if there is a problem (which implies someone has modified one of
## the supposedly-const RenderEffects objects).

converter getClassType*(_: typedesc[RenderEffects]): TypeHandle {.importcpp: "RenderEffects::get_class_type()", header: "renderEffects.h".}

converter upcastToTypedWritableReferenceCount*(this: PandaNode): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcastToNamable*(this: PandaNode): Namable {.importcpp: "((Namable *)(PandaNode *)(#))".}

proc newPandaNode*(name: string): PandaNode {.importcpp: "new PandaNode(nimStringToStdString(#))", header: stringConversionCode.}

proc combineWith*(this: PandaNode, other: PandaNode): PandaNode {.importcpp: "#->combine_with(#)".} ## \
## Collapses this PandaNode with the other PandaNode, if possible, and returns
## a pointer to the combined PandaNode, or NULL if the two PandaNodes cannot
## safely be combined.
##
## The return value may be this, other, or a new PandaNode altogether.
##
## This function is called from GraphReducer::flatten(), and need not deal
## with children; its job is just to decide whether to collapse the two
## PandaNodes and what the collapsed PandaNode should look like.

proc makeCopy*(this: PandaNode): PandaNode {.importcpp: "#->make_copy()".} ## \
## Returns a newly-allocated PandaNode that is a shallow copy of this one.  It
## will be a different pointer, but its internal data may or may not be shared
## with that of the original PandaNode.  No children will be copied.

proc copySubgraph*(this: PandaNode, current_thread: Thread): PandaNode {.importcpp: "#->copy_subgraph(#)".} ## \
## Allocates and returns a complete copy of this PandaNode and the entire
## scene graph rooted at this PandaNode.  Some data may still be shared from
## the original (e.g.  vertex index tables), but nothing that will impede
## normal use of the PandaNode.

proc copySubgraph*(this: PandaNode): PandaNode {.importcpp: "#->copy_subgraph()".} ## \
## Allocates and returns a complete copy of this PandaNode and the entire
## scene graph rooted at this PandaNode.  Some data may still be shared from
## the original (e.g.  vertex index tables), but nothing that will impede
## normal use of the PandaNode.

proc getNumParents*(this: PandaNode, current_thread: Thread): int {.importcpp: "#->get_num_parents(#)".} ## \
## Returns the number of parent nodes this node has.  If this number is
## greater than 1, the node has been multiply instanced.  The order of the
## parent nodes is not meaningful and is not related to the order in which the
## node was instanced to them.

proc getNumParents*(this: PandaNode): int {.importcpp: "#->get_num_parents()".} ## \
## Returns the number of parent nodes this node has.  If this number is
## greater than 1, the node has been multiply instanced.  The order of the
## parent nodes is not meaningful and is not related to the order in which the
## node was instanced to them.

proc getParent*(this: PandaNode, n: int, current_thread: Thread): PandaNode {.importcpp: "#->get_parent(#, #)".} ## \
## Returns the nth parent node of this node.  See get_num_parents().  Also see
## get_parents(), if your intention is to iterate through the complete list of
## parents; get_parents() is preferable in this case.

proc getParent*(this: PandaNode, n: int): PandaNode {.importcpp: "#->get_parent(#)".} ## \
## Returns the nth parent node of this node.  See get_num_parents().  Also see
## get_parents(), if your intention is to iterate through the complete list of
## parents; get_parents() is preferable in this case.

proc findParent*(this: PandaNode, node: PandaNode, current_thread: Thread): int {.importcpp: "#->find_parent(#, #)".} ## \
## Returns the index of the indicated parent node, if it is a parent, or -1 if
## it is not.

proc findParent*(this: PandaNode, node: PandaNode): int {.importcpp: "#->find_parent(#)".} ## \
## Returns the index of the indicated parent node, if it is a parent, or -1 if
## it is not.

proc getNumChildren*(this: PandaNode, current_thread: Thread): int {.importcpp: "#->get_num_children(#)".} ## \
## Returns the number of child nodes this node has.  The order of the child
## nodes \*is\* meaningful and is based on the sort number that was passed to
## add_child(), and also on the order in which the nodes were added.

proc getNumChildren*(this: PandaNode): int {.importcpp: "#->get_num_children()".} ## \
## Returns the number of child nodes this node has.  The order of the child
## nodes \*is\* meaningful and is based on the sort number that was passed to
## add_child(), and also on the order in which the nodes were added.

proc getChild*(this: PandaNode, n: int, current_thread: Thread): PandaNode {.importcpp: "#->get_child(#, #)".} ## \
## Returns the nth child node of this node.  See get_num_children().  Also see
## get_children(), if your intention is to iterate through the complete list
## of children; get_children() is preferable in this case.

proc getChild*(this: PandaNode, n: int): PandaNode {.importcpp: "#->get_child(#)".} ## \
## Returns the nth child node of this node.  See get_num_children().  Also see
## get_children(), if your intention is to iterate through the complete list
## of children; get_children() is preferable in this case.

proc getChildSort*(this: PandaNode, n: int, current_thread: Thread): int {.importcpp: "#->get_child_sort(#, #)".} ## \
## Returns the sort index of the nth child node of this node (that is, the
## number that was passed to add_child()).  See get_num_children().

proc getChildSort*(this: PandaNode, n: int): int {.importcpp: "#->get_child_sort(#)".} ## \
## Returns the sort index of the nth child node of this node (that is, the
## number that was passed to add_child()).  See get_num_children().

proc findChild*(this: PandaNode, node: PandaNode, current_thread: Thread): int {.importcpp: "#->find_child(#, #)".} ## \
## Returns the index of the indicated child node, if it is a child, or -1 if
## it is not.

proc findChild*(this: PandaNode, node: PandaNode): int {.importcpp: "#->find_child(#)".} ## \
## Returns the index of the indicated child node, if it is a child, or -1 if
## it is not.

proc countNumDescendants*(this: PandaNode): int {.importcpp: "#->count_num_descendants()".} ## \
## Returns the number of nodes at and below this level.

proc addChild*(this: PandaNode, child_node: PandaNode, sort: int, current_thread: Thread) {.importcpp: "#->add_child(#, #, #)".} ## \
## Adds a new child to the node.  The child is added in the relative position
## indicated by sort; if all children have the same sort index, the child is
## added at the end.
##
## If the same child is added to a node more than once, the previous instance
## is first removed.

proc addChild*(this: PandaNode, child_node: PandaNode, sort: int) {.importcpp: "#->add_child(#, #)".} ## \
## Adds a new child to the node.  The child is added in the relative position
## indicated by sort; if all children have the same sort index, the child is
## added at the end.
##
## If the same child is added to a node more than once, the previous instance
## is first removed.

proc addChild*(this: PandaNode, child_node: PandaNode) {.importcpp: "#->add_child(#)".} ## \
## Adds a new child to the node.  The child is added in the relative position
## indicated by sort; if all children have the same sort index, the child is
## added at the end.
##
## If the same child is added to a node more than once, the previous instance
## is first removed.

proc removeChild*(this: PandaNode, child_node: PandaNode, current_thread: Thread): bool {.importcpp: "#->remove_child(#, #)".} ## \
## Removes the indicated child from the node.  Returns true if the child was
## removed, false if it was not already a child of the node.  This will also
## successfully remove the child if it had been stashed.

proc removeChild*(this: PandaNode, child_node: PandaNode): bool {.importcpp: "#->remove_child(#)".} ## \
## Removes the indicated child from the node.  Returns true if the child was
## removed, false if it was not already a child of the node.  This will also
## successfully remove the child if it had been stashed.

proc removeChild*(this: PandaNode, child_index: int, current_thread: Thread) {.importcpp: "#->remove_child(#, #)".} ## \
## Removes the nth child from the node.

proc removeChild*(this: PandaNode, child_index: int) {.importcpp: "#->remove_child(#)".} ## \
## Removes the nth child from the node.

proc replaceChild*(this: PandaNode, orig_child: PandaNode, new_child: PandaNode, current_thread: Thread): bool {.importcpp: "#->replace_child(#, #, #)".} ## \
## Searches for the orig_child node in the node's list of children, and
## replaces it with the new_child instead.  Returns true if the replacement is
## made, or false if the node is not a child or if there is some other
## problem.

proc replaceChild*(this: PandaNode, orig_child: PandaNode, new_child: PandaNode): bool {.importcpp: "#->replace_child(#, #)".} ## \
## Searches for the orig_child node in the node's list of children, and
## replaces it with the new_child instead.  Returns true if the replacement is
## made, or false if the node is not a child or if there is some other
## problem.

proc stashChild*(this: PandaNode, child_node: PandaNode, current_thread: Thread): bool {.importcpp: "#->stash_child(#, #)".} ## \
## Stashes the indicated child node.  This removes the child from the list of
## active children and puts it on a special list of stashed children.  This
## child node no longer contributes to the bounding volume of the PandaNode,
## and is not visited in normal traversals.  It is invisible and uncollidable.
## The child may later be restored by calling unstash_child().
##
## This function returns true if the child node was successfully stashed, or
## false if it was not a child of the node in the first place (e.g.  it was
## previously stashed).

proc stashChild*(this: PandaNode, child_node: PandaNode): bool {.importcpp: "#->stash_child(#)".} ## \
## Stashes the indicated child node.  This removes the child from the list of
## active children and puts it on a special list of stashed children.  This
## child node no longer contributes to the bounding volume of the PandaNode,
## and is not visited in normal traversals.  It is invisible and uncollidable.
## The child may later be restored by calling unstash_child().
##
## This function returns true if the child node was successfully stashed, or
## false if it was not a child of the node in the first place (e.g.  it was
## previously stashed).

proc stashChild*(this: PandaNode, child_index: int, current_thread: Thread) {.importcpp: "#->stash_child(#, #)".} ## \
## Stashes the indicated child node.  This removes the child from the list of
## active children and puts it on a special list of stashed children.  This
## child node no longer contributes to the bounding volume of the PandaNode,
## and is not visited in normal traversals.  It is invisible and uncollidable.
## The child may later be restored by calling unstash_child().
##
## This can only be called from the top pipeline stage (i.e.  from App).

proc stashChild*(this: PandaNode, child_index: int) {.importcpp: "#->stash_child(#)".} ## \
## Stashes the indicated child node.  This removes the child from the list of
## active children and puts it on a special list of stashed children.  This
## child node no longer contributes to the bounding volume of the PandaNode,
## and is not visited in normal traversals.  It is invisible and uncollidable.
## The child may later be restored by calling unstash_child().
##
## This can only be called from the top pipeline stage (i.e.  from App).

proc unstashChild*(this: PandaNode, child_node: PandaNode, current_thread: Thread): bool {.importcpp: "#->unstash_child(#, #)".} ## \
## Returns the indicated stashed node to normal child status.  This removes
## the child from the list of stashed children and puts it on the normal list
## of active children.  This child node once again contributes to the bounding
## volume of the PandaNode, and will be visited in normal traversals.  It is
## visible and collidable.
##
## This function returns true if the child node was successfully stashed, or
## false if it was not a child of the node in the first place (e.g.  it was
## previously stashed).

proc unstashChild*(this: PandaNode, child_node: PandaNode): bool {.importcpp: "#->unstash_child(#)".} ## \
## Returns the indicated stashed node to normal child status.  This removes
## the child from the list of stashed children and puts it on the normal list
## of active children.  This child node once again contributes to the bounding
## volume of the PandaNode, and will be visited in normal traversals.  It is
## visible and collidable.
##
## This function returns true if the child node was successfully stashed, or
## false if it was not a child of the node in the first place (e.g.  it was
## previously stashed).

proc unstashChild*(this: PandaNode, stashed_index: int, current_thread: Thread) {.importcpp: "#->unstash_child(#, #)".} ## \
## Returns the indicated stashed node to normal child status.  This removes
## the child from the list of stashed children and puts it on the normal list
## of active children.  This child node once again contributes to the bounding
## volume of the PandaNode, and will be visited in normal traversals.  It is
## visible and collidable.
##
## This can only be called from the top pipeline stage (i.e.  from App).

proc unstashChild*(this: PandaNode, stashed_index: int) {.importcpp: "#->unstash_child(#)".} ## \
## Returns the indicated stashed node to normal child status.  This removes
## the child from the list of stashed children and puts it on the normal list
## of active children.  This child node once again contributes to the bounding
## volume of the PandaNode, and will be visited in normal traversals.  It is
## visible and collidable.
##
## This can only be called from the top pipeline stage (i.e.  from App).

proc getNumStashed*(this: PandaNode, current_thread: Thread): int {.importcpp: "#->get_num_stashed(#)".} ## \
## Returns the number of stashed nodes this node has.  These are former
## children of the node that have been moved to the special stashed list via
## stash_child().

proc getNumStashed*(this: PandaNode): int {.importcpp: "#->get_num_stashed()".} ## \
## Returns the number of stashed nodes this node has.  These are former
## children of the node that have been moved to the special stashed list via
## stash_child().

proc getStashed*(this: PandaNode, n: int, current_thread: Thread): PandaNode {.importcpp: "#->get_stashed(#, #)".} ## \
## Returns the nth stashed child of this node.  See get_num_stashed().  Also
## see get_stashed(), if your intention is to iterate through the complete
## list of stashed children; get_stashed() is preferable in this case.

proc getStashed*(this: PandaNode, n: int): PandaNode {.importcpp: "#->get_stashed(#)".} ## \
## Returns the nth stashed child of this node.  See get_num_stashed().  Also
## see get_stashed(), if your intention is to iterate through the complete
## list of stashed children; get_stashed() is preferable in this case.

proc getStashedSort*(this: PandaNode, n: int, current_thread: Thread): int {.importcpp: "#->get_stashed_sort(#, #)".} ## \
## Returns the sort index of the nth stashed node of this node (that is, the
## number that was passed to add_child()).  See get_num_stashed().

proc getStashedSort*(this: PandaNode, n: int): int {.importcpp: "#->get_stashed_sort(#)".} ## \
## Returns the sort index of the nth stashed node of this node (that is, the
## number that was passed to add_child()).  See get_num_stashed().

proc findStashed*(this: PandaNode, node: PandaNode, current_thread: Thread): int {.importcpp: "#->find_stashed(#, #)".} ## \
## Returns the index of the indicated stashed node, if it is a stashed child,
## or -1 if it is not.

proc findStashed*(this: PandaNode, node: PandaNode): int {.importcpp: "#->find_stashed(#)".} ## \
## Returns the index of the indicated stashed node, if it is a stashed child,
## or -1 if it is not.

proc addStashed*(this: PandaNode, child_node: PandaNode, sort: int, current_thread: Thread) {.importcpp: "#->add_stashed(#, #, #)".} ## \
## Adds a new child to the node, directly as a stashed child.  The child is
## not added in the normal sense, but will be revealed if unstash_child() is
## called on it later.
##
## If the same child is added to a node more than once, the previous instance
## is first removed.
##
## This can only be called from the top pipeline stage (i.e.  from App).

proc addStashed*(this: PandaNode, child_node: PandaNode, sort: int) {.importcpp: "#->add_stashed(#, #)".} ## \
## Adds a new child to the node, directly as a stashed child.  The child is
## not added in the normal sense, but will be revealed if unstash_child() is
## called on it later.
##
## If the same child is added to a node more than once, the previous instance
## is first removed.
##
## This can only be called from the top pipeline stage (i.e.  from App).

proc addStashed*(this: PandaNode, child_node: PandaNode) {.importcpp: "#->add_stashed(#)".} ## \
## Adds a new child to the node, directly as a stashed child.  The child is
## not added in the normal sense, but will be revealed if unstash_child() is
## called on it later.
##
## If the same child is added to a node more than once, the previous instance
## is first removed.
##
## This can only be called from the top pipeline stage (i.e.  from App).

proc removeStashed*(this: PandaNode, child_index: int, current_thread: Thread) {.importcpp: "#->remove_stashed(#, #)".} ## \
## Removes the nth stashed child from the node.

proc removeStashed*(this: PandaNode, child_index: int) {.importcpp: "#->remove_stashed(#)".} ## \
## Removes the nth stashed child from the node.

proc removeAllChildren*(this: PandaNode, current_thread: Thread) {.importcpp: "#->remove_all_children(#)".} ## \
## Removes all the children from the node at once, including stashed children.
##
## This can only be called from the top pipeline stage (i.e.  from App).

proc removeAllChildren*(this: PandaNode) {.importcpp: "#->remove_all_children()".} ## \
## Removes all the children from the node at once, including stashed children.
##
## This can only be called from the top pipeline stage (i.e.  from App).

proc stealChildren*(this: PandaNode, other: PandaNode, current_thread: Thread) {.importcpp: "#->steal_children(#, #)".} ## \
## Moves all the children from the other node onto this node.
##
## Any NodePaths to child nodes of the other node are truncated, rather than
## moved to the new parent.

proc stealChildren*(this: PandaNode, other: PandaNode) {.importcpp: "#->steal_children(#)".} ## \
## Moves all the children from the other node onto this node.
##
## Any NodePaths to child nodes of the other node are truncated, rather than
## moved to the new parent.

proc copyChildren*(this: PandaNode, other: PandaNode, current_thread: Thread) {.importcpp: "#->copy_children(#, #)".} ## \
## Makes another instance of all the children of the other node, copying them
## to this node.

proc copyChildren*(this: PandaNode, other: PandaNode) {.importcpp: "#->copy_children(#)".} ## \
## Makes another instance of all the children of the other node, copying them
## to this node.

proc setAttrib*(this: PandaNode, attrib: RenderAttrib, override: int) {.importcpp: "#->set_attrib(#, #)".} ## \
## Adds the indicated render attribute to the scene graph on this node.  This
## attribute will now apply to this node and everything below.  If there was
## already an attribute of the same type, it is replaced.

proc setAttrib*(this: PandaNode, attrib: RenderAttrib) {.importcpp: "#->set_attrib(#)".} ## \
## Adds the indicated render attribute to the scene graph on this node.  This
## attribute will now apply to this node and everything below.  If there was
## already an attribute of the same type, it is replaced.

proc getAttrib*(this: PandaNode, `type`: TypeHandle): RenderAttrib {.importcpp: "deconstify(#->get_attrib(#))", header: deconstifyCode.} ## \
## Returns the render attribute of the indicated type, if it is defined on the
## node, or NULL if it is not.  This checks only what is set on this
## particular node level, and has nothing to do with what render attributes
## may be inherited from parent nodes.

proc getAttrib*(this: PandaNode, slot: int): RenderAttrib {.importcpp: "deconstify(#->get_attrib(#))", header: deconstifyCode.} ## \
## Returns the render attribute of the indicated type, if it is defined on the
## node, or NULL if it is not.  This checks only what is set on this
## particular node level, and has nothing to do with what render attributes
## may be inherited from parent nodes.

proc hasAttrib*(this: PandaNode, `type`: TypeHandle): bool {.importcpp: "#->has_attrib(#)".} ## \
## Returns true if there is a render attribute of the indicated type defined
## on this node, or false if there is not.

proc hasAttrib*(this: PandaNode, slot: int): bool {.importcpp: "#->has_attrib(#)".} ## \
## Returns true if there is a render attribute of the indicated type defined
## on this node, or false if there is not.

proc clearAttrib*(this: PandaNode, `type`: TypeHandle) {.importcpp: "#->clear_attrib(#)".} ## \
## Removes the render attribute of the given type from this node.  This node,
## and the subgraph below, will now inherit the indicated render attribute
## from the nodes above this one.

proc clearAttrib*(this: PandaNode, slot: int) {.importcpp: "#->clear_attrib(#)".} ## \
## Removes the render attribute of the given type from this node.  This node,
## and the subgraph below, will now inherit the indicated render attribute
## from the nodes above this one.

proc setEffect*(this: PandaNode, effect: RenderEffect) {.importcpp: "#->set_effect(#)".} ## \
## Adds the indicated render effect to the scene graph on this node.  If there
## was already an effect of the same type, it is replaced.

proc getEffect*(this: PandaNode, `type`: TypeHandle): RenderEffect {.importcpp: "deconstify(#->get_effect(#))", header: deconstifyCode.} ## \
## Returns the render effect of the indicated type, if it is defined on the
## node, or NULL if it is not.

proc hasEffect*(this: PandaNode, `type`: TypeHandle): bool {.importcpp: "#->has_effect(#)".} ## \
## Returns true if there is a render effect of the indicated type defined on
## this node, or false if there is not.

proc clearEffect*(this: PandaNode, `type`: TypeHandle) {.importcpp: "#->clear_effect(#)".} ## \
## Removes the render effect of the given type from this node.

proc setState*(this: PandaNode, state: RenderState, current_thread: Thread) {.importcpp: "#->set_state(#, #)".} ## \
## Sets the complete RenderState that will be applied to all nodes at this
## level and below.  (The actual state that will be applied to lower nodes is
## based on the composition of RenderStates from above this node as well).
## This completely replaces whatever has been set on this node via repeated
## calls to set_attrib().

proc setState*(this: PandaNode, state: RenderState) {.importcpp: "#->set_state(#)".} ## \
## Sets the complete RenderState that will be applied to all nodes at this
## level and below.  (The actual state that will be applied to lower nodes is
## based on the composition of RenderStates from above this node as well).
## This completely replaces whatever has been set on this node via repeated
## calls to set_attrib().

proc getState*(this: PandaNode, current_thread: Thread): RenderState {.importcpp: "deconstify(#->get_state(#))", header: deconstifyCode.} ## \
## Returns the complete RenderState that will be applied to all nodes at this
## level and below, as set on this node.  This returns only the RenderState
## set on this particular node, and has nothing to do with state that might be
## inherited from above.

proc getState*(this: PandaNode): RenderState {.importcpp: "deconstify(#->get_state())", header: deconstifyCode.} ## \
## Returns the complete RenderState that will be applied to all nodes at this
## level and below, as set on this node.  This returns only the RenderState
## set on this particular node, and has nothing to do with state that might be
## inherited from above.

proc clearState*(this: PandaNode, current_thread: Thread) {.importcpp: "#->clear_state(#)".} ## \
## Resets this node to leave the render state alone.  Nodes at this level and
## below will once again inherit their render state unchanged from the nodes
## above this level.

proc clearState*(this: PandaNode) {.importcpp: "#->clear_state()".} ## \
## Resets this node to leave the render state alone.  Nodes at this level and
## below will once again inherit their render state unchanged from the nodes
## above this level.

proc setEffects*(this: PandaNode, effects: RenderEffects, current_thread: Thread) {.importcpp: "#->set_effects(#, #)".} ## \
## Sets the complete RenderEffects that will be applied this node.  This
## completely replaces whatever has been set on this node via repeated calls
## to set_attrib().

proc setEffects*(this: PandaNode, effects: RenderEffects) {.importcpp: "#->set_effects(#)".} ## \
## Sets the complete RenderEffects that will be applied this node.  This
## completely replaces whatever has been set on this node via repeated calls
## to set_attrib().

proc getEffects*(this: PandaNode, current_thread: Thread): RenderEffects {.importcpp: "deconstify(#->get_effects(#))", header: deconstifyCode.} ## \
## Returns the complete RenderEffects that will be applied to this node.

proc getEffects*(this: PandaNode): RenderEffects {.importcpp: "deconstify(#->get_effects())", header: deconstifyCode.} ## \
## Returns the complete RenderEffects that will be applied to this node.

proc clearEffects*(this: PandaNode, current_thread: Thread) {.importcpp: "#->clear_effects(#)".} ## \
## Resets this node to have no render effects.

proc clearEffects*(this: PandaNode) {.importcpp: "#->clear_effects()".} ## \
## Resets this node to have no render effects.

proc setTransform*(this: PandaNode, transform: TransformState, current_thread: Thread) {.importcpp: "#->set_transform(#, #)".} ## \
## Sets the transform that will be applied to this node and below.  This
## defines a new coordinate space at this point in the scene graph and below.

proc setTransform*(this: PandaNode, transform: TransformState) {.importcpp: "#->set_transform(#)".} ## \
## Sets the transform that will be applied to this node and below.  This
## defines a new coordinate space at this point in the scene graph and below.

proc getTransform*(this: PandaNode, current_thread: Thread): TransformState {.importcpp: "deconstify(#->get_transform(#))", header: deconstifyCode.} ## \
## Returns the transform that has been set on this particular node.  This is
## not the net transform from the root, but simply the transform on this
## particular node.

proc getTransform*(this: PandaNode): TransformState {.importcpp: "deconstify(#->get_transform())", header: deconstifyCode.} ## \
## Returns the transform that has been set on this particular node.  This is
## not the net transform from the root, but simply the transform on this
## particular node.

proc clearTransform*(this: PandaNode, current_thread: Thread) {.importcpp: "#->clear_transform(#)".} ## \
## Resets the transform on this node to the identity transform.

proc clearTransform*(this: PandaNode) {.importcpp: "#->clear_transform()".} ## \
## Resets the transform on this node to the identity transform.

proc setPrevTransform*(this: PandaNode, transform: TransformState, current_thread: Thread) {.importcpp: "#->set_prev_transform(#, #)".} ## \
## Sets the transform that represents this node's "previous" position, one
## frame ago, for the purposes of detecting motion for accurate collision
## calculations.

proc setPrevTransform*(this: PandaNode, transform: TransformState) {.importcpp: "#->set_prev_transform(#)".} ## \
## Sets the transform that represents this node's "previous" position, one
## frame ago, for the purposes of detecting motion for accurate collision
## calculations.

proc getPrevTransform*(this: PandaNode, current_thread: Thread): TransformState {.importcpp: "deconstify(#->get_prev_transform(#))", header: deconstifyCode.} ## \
## Returns the transform that has been set as this node's "previous" position.
## See set_prev_transform().

proc getPrevTransform*(this: PandaNode): TransformState {.importcpp: "deconstify(#->get_prev_transform())", header: deconstifyCode.} ## \
## Returns the transform that has been set as this node's "previous" position.
## See set_prev_transform().

proc resetPrevTransform*(this: PandaNode, current_thread: Thread) {.importcpp: "#->reset_prev_transform(#)".} ## \
## Resets the transform that represents this node's "previous" position to the
## same as the current transform.  This is not the same thing as clearing it
## to identity.

proc resetPrevTransform*(this: PandaNode) {.importcpp: "#->reset_prev_transform()".} ## \
## Resets the transform that represents this node's "previous" position to the
## same as the current transform.  This is not the same thing as clearing it
## to identity.

proc hasDirtyPrevTransform*(this: PandaNode): bool {.importcpp: "#->has_dirty_prev_transform()".} ## \
## Returns true if this node has the _dirty_prev_transform flag set, which
## indicates its _prev_transform is different from its _transform value (in
## pipeline stage 0).  In this case, the node will be visited by
## reset_prev_transform().

proc resetAllPrevTransform*(_: typedesc[PandaNode], current_thread: Thread) {.importcpp: "#PandaNode::reset_all_prev_transform(#)", header: "pandaNode.h".} ## \
## Visits all nodes in the world with the _dirty_prev_transform flag--that is,
## all nodes whose _prev_transform is different from the _transform in
## pipeline stage 0--and resets the _prev_transform to be the same as
## _transform.

proc resetAllPrevTransform*(_: typedesc[PandaNode]) {.importcpp: "PandaNode::reset_all_prev_transform()", header: "pandaNode.h".} ## \
## Visits all nodes in the world with the _dirty_prev_transform flag--that is,
## all nodes whose _prev_transform is different from the _transform in
## pipeline stage 0--and resets the _prev_transform to be the same as
## _transform.

proc setTag*(this: PandaNode, key: string, value: string, current_thread: Thread) {.importcpp: "#->set_tag(nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Associates a user-defined value with a user-defined key which is stored on
## the node.  This value has no meaning to Panda; but it is stored
## indefinitely on the node until it is requested again.
##
## Each unique key stores a different string value.  There is no effective
## limit on the number of different keys that may be stored or on the length
## of any one key's value.

proc setTag*(this: PandaNode, key: string, value: string) {.importcpp: "#->set_tag(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Associates a user-defined value with a user-defined key which is stored on
## the node.  This value has no meaning to Panda; but it is stored
## indefinitely on the node until it is requested again.
##
## Each unique key stores a different string value.  There is no effective
## limit on the number of different keys that may be stored or on the length
## of any one key's value.

proc getTag*(this: PandaNode, key: string, current_thread: Thread): string {.importcpp: "nimStringFromStdString(#->get_tag(nimStringToStdString(#), #))", header: stringConversionCode.} ## \
## Retrieves the user-defined value that was previously set on this node for
## the particular key, if any.  If no value has been previously set, returns
## the empty string.

proc getTag*(this: PandaNode, key: string): string {.importcpp: "nimStringFromStdString(#->get_tag(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Retrieves the user-defined value that was previously set on this node for
## the particular key, if any.  If no value has been previously set, returns
## the empty string.

proc hasTag*(this: PandaNode, key: string, current_thread: Thread): bool {.importcpp: "#->has_tag(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Returns true if a value has been defined on this node for the particular
## key (even if that value is the empty string), or false if no value has been
## set.

proc hasTag*(this: PandaNode, key: string): bool {.importcpp: "#->has_tag(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if a value has been defined on this node for the particular
## key (even if that value is the empty string), or false if no value has been
## set.

proc clearTag*(this: PandaNode, key: string, current_thread: Thread) {.importcpp: "#->clear_tag(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Removes the value defined for this key on this particular node.  After a
## call to clear_tag(), has_tag() will return false for the indicated key.

proc clearTag*(this: PandaNode, key: string) {.importcpp: "#->clear_tag(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes the value defined for this key on this particular node.  After a
## call to clear_tag(), has_tag() will return false for the indicated key.

proc getNumTags*(this: PandaNode): clonglong {.importcpp: "#->get_num_tags()".} ## \
## Returns the number of tags applied to this node.

proc getTagKey*(this: PandaNode, i: clonglong): string {.importcpp: "nimStringFromStdString(#->get_tag_key(#))", header: stringConversionCode.} ## \
## Returns the key of the nth tag applied to this node.

proc hasTags*(this: PandaNode): bool {.importcpp: "#->has_tags()".} ## \
## Returns true if the node has any tags (or any Python tags) at all, false if
## it has none.

proc copyTags*(this: PandaNode, other: PandaNode) {.importcpp: "#->copy_tags(#)".} ## \
## Copies all of the tags stored on the other node onto this node.  If a
## particular tag exists on both nodes, the contents of this node's value is
## replaced by that of the other.

proc listTags*(this: PandaNode, `out`: ostream, separator: string) {.importcpp: "#->list_tags(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Writes a list of all the tag keys assigned to the node to the indicated
## stream.  Writes one instance of the separator following each key (but does
## not write a terminal separator).  The value associated with each key is not
## written.
##
## This is mainly for the benefit of the realtime user, to see the list of all
## of the associated tag keys.

proc listTags*(this: PandaNode, `out`: ostream) {.importcpp: "#->list_tags(#)".} ## \
## Writes a list of all the tag keys assigned to the node to the indicated
## stream.  Writes one instance of the separator following each key (but does
## not write a terminal separator).  The value associated with each key is not
## written.
##
## This is mainly for the benefit of the realtime user, to see the list of all
## of the associated tag keys.

proc compareTags*(this: PandaNode, other: PandaNode): int {.importcpp: "#->compare_tags(#)".} ## \
## Returns a number less than 0, 0, or greater than 0, to indicate the
## similarity of tags between this node and the other one.  If this returns 0,
## the tags are identical.  If it returns other than 0, then the tags are
## different; and the nodes may be sorted into a consistent (but arbitrary)
## ordering based on this number.

proc copyAllProperties*(this: PandaNode, other: PandaNode) {.importcpp: "#->copy_all_properties(#)".} ## \
## Copies the TransformState, RenderState, RenderEffects, tags, Python tags,
## and the show/hide state from the other node onto this one.  Typically this
## is used to prepare a node to replace another node in the scene graph (also
## see replace_node()).

proc replaceNode*(this: PandaNode, other: PandaNode) {.importcpp: "#->replace_node(#)".} ## \
## Inserts this node into the scene graph in place of the other one, and
## removes the other node.  All scene graph attributes (TransformState,
## RenderState, etc.) are copied to this node.
##
## All children are moved to this node, and removed from the old node.  The
## new node is left in the same place in the old node's parent's list of
## children.
##
## Even NodePaths that reference the old node are updated in-place to
## reference the new node instead.
##
## This method is intended to be used to replace a node of a given type in the
## scene graph with a node of a different type.

proc setUnexpectedChange*(this: PandaNode, flags: int) {.importcpp: "#->set_unexpected_change(#)".} ## \
## Sets one or more of the PandaNode::UnexpectedChange bits on, indicating
## that the corresponding property should not change again on this node.  Once
## one of these bits has been set, if the property changes, an assertion
## failure will be raised, which is designed to assist the developer in
## identifying the troublesome code that modified the property unexpectedly.
##
## The input parameter is the union of bits that are to be set.  To clear
## these bits later, use clear_unexpected_change().
##
## Since this is a developer debugging tool only, this function does nothing
## in a production (NDEBUG) build.

proc getUnexpectedChange*(this: PandaNode, flags: int): int {.importcpp: "#->get_unexpected_change(#)".} ## \
## Returns nonzero if any of the bits in the input parameter are set on this
## node, or zero if none of them are set.  More specifically, this returns the
## particular set of bits (masked by the input parameter) that have been set
## on this node.  See set_unexpected_change().
##
## Since this is a developer debugging tool only, this function always returns
## zero in a production (NDEBUG) build.

proc clearUnexpectedChange*(this: PandaNode, flags: int) {.importcpp: "#->clear_unexpected_change(#)".} ## \
## Sets one or more of the PandaNode::UnexpectedChange bits off, indicating
## that the corresponding property may once again change on this node.  See
## set_unexpected_change().
##
## The input parameter is the union of bits that are to be cleared.
##
## Since this is a developer debugging tool only, this function does nothing
## in a production (NDEBUG) build.

proc getOverallBit*(_: typedesc[PandaNode]): DrawMask {.importcpp: "PandaNode::get_overall_bit()", header: "pandaNode.h".} ## \
## Returns the special bit that, when specifically cleared in the node's
## DrawMask, indicates that the node is hidden to all cameras, regardless of
## the remaining DrawMask bits.

proc getAllCameraMask*(_: typedesc[PandaNode]): DrawMask {.importcpp: "PandaNode::get_all_camera_mask()", header: "pandaNode.h".} ## \
## Returns a DrawMask that is appropriate for rendering to all cameras.

proc isOverallHidden*(this: PandaNode): bool {.importcpp: "#->is_overall_hidden()".} ## \
## Returns true if the node has been hidden to all cameras by clearing its
## overall bit.

proc setOverallHidden*(this: PandaNode, overall_hidden: bool) {.importcpp: "#->set_overall_hidden(#)".} ## \
## Sets or clears the hidden flag.  When the hidden flag is true, the node and
## all of its children are invisible to all cameras, regardless of the setting
## of any draw masks.  Setting the hidden flag to false restores the previous
## visibility as established by the draw masks.
##
## This actually works by twiddling the reserved _overall_bit in the node's
## draw mask, which has special meaning.

proc adjustDrawMask*(this: PandaNode, show_mask: DrawMask, hide_mask: DrawMask, clear_mask: DrawMask) {.importcpp: "#->adjust_draw_mask(#, #, #)".} ## \
## Adjusts the hide/show bits of this particular node.
##
## These three parameters can be used to adjust the _draw_control_mask and
## _draw_show_mask independently, which work together to provide per-camera
## visibility for the node and its descendents.
##
## _draw_control_mask indicates the bits in _draw_show_mask that are
## significant.  Each different bit corresponds to a different camera (and
## these bits are assigned via Camera::set_camera_mask()).
##
## Where _draw_control_mask has a 1 bit, a 1 bit in _draw_show_mask indicates
## the node is visible to that camera, and a 0 bit indicates the node is
## hidden to that camera.  Where _draw_control_mask is 0, the node is hidden
## only if a parent node is hidden.
##
## The meaning of the three parameters is as follows:
##
## Wherever show_mask is 1, _draw_show_mask and _draw_control_mask will be
## set 1.  Thus, show_mask indicates the set of cameras to which the node
## should be shown.
##
## Wherever hide_mask is 1, _draw_show_mask will be set 0 and
## _draw_control_mask will be set 1.  Thus, hide_mask indicates the set of
## cameras from which the node should be hidden.
##
## Wherever clear_mask is 1, _draw_control_mask will be set 0.  Thus,
## clear_mask indicates the set of cameras from which the hidden state should
## be inherited from a parent.

proc getDrawControlMask*(this: PandaNode): DrawMask {.importcpp: "#->get_draw_control_mask()".} ## \
## Returns the set of bits in draw_show_mask that are considered meaningful.
## See adjust_draw_mask().

proc getDrawShowMask*(this: PandaNode): DrawMask {.importcpp: "#->get_draw_show_mask()".} ## \
## Returns the hide/show bits of this particular node.  See
## adjust_draw_mask().

proc getNetDrawControlMask*(this: PandaNode): DrawMask {.importcpp: "#->get_net_draw_control_mask()".} ## \
## Returns the set of bits in get_net_draw_show_mask() that have been
## explicitly set via adjust_draw_mask(), rather than implicitly inherited.
##
## A 1 bit in any position of this mask indicates that (a) this node has
## renderable children, and (b) some child of this node has made an explicit
## hide() or show_through() call for the corresponding bit.

proc getNetDrawShowMask*(this: PandaNode): DrawMask {.importcpp: "#->get_net_draw_show_mask()".} ## \
## Returns the union of all draw_show_mask values--of renderable nodes only--
## at this level and below.  If any bit in this mask is 0, there is no reason
## to traverse below this node for a camera with the corresponding
## camera_mask.
##
## The bits in this mask that do not correspond to a 1 bit in the
## net_draw_control_mask are meaningless (and will be set to 1).  For bits
## that \*do\* correspond to a 1 bit in the net_draw_control_mask, a 1 bit
## indicates that at least one child should be visible, while a 0 bit
## indicates that all children are hidden.

proc setIntoCollideMask*(this: PandaNode, mask: CollideMask) {.importcpp: "#->set_into_collide_mask(#)".} ## \
## Sets the "into" CollideMask.
##
## This specifies the set of bits that must be shared with a CollisionNode's
## "from" CollideMask in order for the CollisionNode to detect a collision
## with this particular node.
##
## The actual CollideMask that will be set is masked by the return value from
## get_legal_collide_mask(). Thus, the into_collide_mask cannot be set to
## anything other than nonzero except for those types of nodes that can be
## collided into, such as CollisionNodes and GeomNodes.

proc getIntoCollideMask*(this: PandaNode): CollideMask {.importcpp: "#->get_into_collide_mask()".} ## \
## Returns the "into" collide mask for this node.

proc getLegalCollideMask*(this: PandaNode): CollideMask {.importcpp: "#->get_legal_collide_mask()".} ## \
## Returns the subset of CollideMask bits that may be set for this particular
## type of PandaNode.  For most nodes, this is 0; it doesn't make sense to set
## a CollideMask for most kinds of nodes.
##
## For nodes that can be collided with, such as GeomNode and CollisionNode,
## this returns all bits on.

proc getNetCollideMask*(this: PandaNode, current_thread: Thread): CollideMask {.importcpp: "#->get_net_collide_mask(#)".} ## \
## Returns the union of all into_collide_mask() values set at CollisionNodes
## at this level and below.

proc getNetCollideMask*(this: PandaNode): CollideMask {.importcpp: "#->get_net_collide_mask()".} ## \
## Returns the union of all into_collide_mask() values set at CollisionNodes
## at this level and below.

proc getOffClipPlanes*(this: PandaNode, current_thread: Thread): RenderAttrib {.importcpp: "deconstify(#->get_off_clip_planes(#))", header: deconstifyCode.} ## \
## Returns a ClipPlaneAttrib which represents the union of all of the clip
## planes that have been turned \*off\* at this level and below.

proc getOffClipPlanes*(this: PandaNode): RenderAttrib {.importcpp: "deconstify(#->get_off_clip_planes())", header: deconstifyCode.} ## \
## Returns a ClipPlaneAttrib which represents the union of all of the clip
## planes that have been turned \*off\* at this level and below.

proc prepareScene*(this: PandaNode, gsg: GraphicsStateGuardianBase, node_state: RenderState) {.importcpp: "#->prepare_scene(#, #)".} ## \
## Walks through the scene graph beginning at this node, and does whatever
## initialization is required to render the scene properly with the indicated
## GSG.  It is not strictly necessary to call this, since the GSG will
## initialize itself when the scene is rendered, but this may take some of the
## overhead away from that process.
##
## In particular, this will ensure that textures and vertex buffers within the
## scene are loaded into graphics memory.

proc isSceneRoot*(this: PandaNode): bool {.importcpp: "#->is_scene_root()".} ## \
## Returns true if this particular node is known to be the render root of some
## active DisplayRegion associated with the global GraphicsEngine, false
## otherwise.

proc isUnderSceneRoot*(this: PandaNode): bool {.importcpp: "#->is_under_scene_root()".} ## \
## Returns true if this particular node is in a live scene graph: that is, it
## is a child or descendent of a node that is itself a scene root.  If this is
## true, this node may potentially be traversed by the render traverser.
## Stashed nodes don't count for this purpose, but hidden nodes do.

proc output*(this: PandaNode, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: PandaNode, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc ls*(this: PandaNode, `out`: ostream, indent_level: int) {.importcpp: "#->ls(#, #)".} ## \
## Lists all the nodes at and below the current path hierarchically.

proc setBounds*(this: PandaNode, volume: BoundingVolume) {.importcpp: "#->set_bounds(#)".} ## \
## Resets the bounding volume so that it is the indicated volume.  When it is
## explicitly set, the bounding volume will no longer be automatically
## computed according to the contents of the node itself, for nodes like
## GeomNodes and TextNodes that contain substance (but the bounding volume
## will still be automatically expanded to include its children).
##
## Call clear_bounds() if you would like to return the bounding volume to its
## default behavior later.

proc setBound*(this: PandaNode, volume: BoundingVolume) {.importcpp: "#->set_bound(#)".} ## \
## Deprecated.  Use set_bounds() instead.

proc clearBounds*(this: PandaNode) {.importcpp: "#->clear_bounds()".} ## \
## Reverses the effect of a previous call to set_bounds(), and allows the
## node's bounding volume to be automatically computed once more based on the
## contents of the node.

proc getBounds*(this: PandaNode, current_thread: Thread): BoundingVolume {.importcpp: "deconstify(#->get_bounds(#))", header: deconstifyCode.} ## \
## Returns the external bounding volume of this node: a bounding volume that
## contains the user bounding volume, the internal bounding volume, and all of
## the children's bounding volumes.

proc getBounds*(this: PandaNode): BoundingVolume {.importcpp: "deconstify(#->get_bounds())", header: deconstifyCode.} ## \
## Returns the external bounding volume of this node: a bounding volume that
## contains the user bounding volume, the internal bounding volume, and all of
## the children's bounding volumes.

proc getBounds*(this: PandaNode, seq: UpdateSeq, current_thread: Thread): BoundingVolume {.importcpp: "deconstify(#->get_bounds(#, #))", header: deconstifyCode.} ## \
## This flavor of get_bounds() return the external bounding volume, and also
## fills in seq with the bounding volume's current sequence number.  When this
## sequence number changes, it indicates that the bounding volume might have
## changed, e.g.  because some nested child's bounding volume has changed.
##
## Although this might occasionally increment without changing the bounding
## volume, the bounding volume will never change without incrementing this
## counter, so as long as this counter remains unchanged you can be confident
## the bounding volume is also unchanged.

proc getBounds*(this: PandaNode, seq: UpdateSeq): BoundingVolume {.importcpp: "deconstify(#->get_bounds(#))", header: deconstifyCode.} ## \
## This flavor of get_bounds() return the external bounding volume, and also
## fills in seq with the bounding volume's current sequence number.  When this
## sequence number changes, it indicates that the bounding volume might have
## changed, e.g.  because some nested child's bounding volume has changed.
##
## Although this might occasionally increment without changing the bounding
## volume, the bounding volume will never change without incrementing this
## counter, so as long as this counter remains unchanged you can be confident
## the bounding volume is also unchanged.

proc getNestedVertices*(this: PandaNode, current_thread: Thread): int {.importcpp: "#->get_nested_vertices(#)".} ## \
## Returns the total number of vertices that will be rendered by this node and
## all of its descendents.
##
## This is not necessarily an accurate count of vertices that will actually be
## rendered, since this will include all vertices of all LOD's, and it will
## also include hidden nodes.  It may also omit or only approximate certain
## kinds of dynamic geometry.  However, it will not include stashed nodes.

proc getNestedVertices*(this: PandaNode): int {.importcpp: "#->get_nested_vertices()".} ## \
## Returns the total number of vertices that will be rendered by this node and
## all of its descendents.
##
## This is not necessarily an accurate count of vertices that will actually be
## rendered, since this will include all vertices of all LOD's, and it will
## also include hidden nodes.  It may also omit or only approximate certain
## kinds of dynamic geometry.  However, it will not include stashed nodes.

proc getInternalBounds*(this: PandaNode, current_thread: Thread): BoundingVolume {.importcpp: "deconstify(#->get_internal_bounds(#))", header: deconstifyCode.} ## \
## Returns the node's internal bounding volume.  This is the bounding volume
## around the node alone, without including children.  If the user has called
## set_bounds(), it will be the specified bounding volume.

proc getInternalBounds*(this: PandaNode): BoundingVolume {.importcpp: "deconstify(#->get_internal_bounds())", header: deconstifyCode.} ## \
## Returns the node's internal bounding volume.  This is the bounding volume
## around the node alone, without including children.  If the user has called
## set_bounds(), it will be the specified bounding volume.

proc getInternalVertices*(this: PandaNode, current_thread: Thread): int {.importcpp: "#->get_internal_vertices(#)".} ## \
## Returns the total number of vertices that will be rendered by this
## particular node alone, not accounting for its children.
##
## This may not include all vertices for certain dynamic effects.

proc getInternalVertices*(this: PandaNode): int {.importcpp: "#->get_internal_vertices()".} ## \
## Returns the total number of vertices that will be rendered by this
## particular node alone, not accounting for its children.
##
## This may not include all vertices for certain dynamic effects.

proc markBoundsStale*(this: PandaNode, current_thread: Thread) {.importcpp: "#->mark_bounds_stale(#)".} ## \
## Indicates that the bounding volume, or something that influences the
## bounding volume (or any of the other things stored in CData, like
## net_collide_mask), may have changed for this node, and that it must be
## recomputed.
##
## With no parameters, this means to iterate through all stages including and
## upstream of the current pipeline stage.
##
## This method is intended for internal use; usually it is not necessary for a
## user to call this directly.  It will be called automatically by derived
## classes when appropriate.

proc markBoundsStale*(this: PandaNode) {.importcpp: "#->mark_bounds_stale()".} ## \
## Indicates that the bounding volume, or something that influences the
## bounding volume (or any of the other things stored in CData, like
## net_collide_mask), may have changed for this node, and that it must be
## recomputed.
##
## With no parameters, this means to iterate through all stages including and
## upstream of the current pipeline stage.
##
## This method is intended for internal use; usually it is not necessary for a
## user to call this directly.  It will be called automatically by derived
## classes when appropriate.

proc markInternalBoundsStale*(this: PandaNode, current_thread: Thread) {.importcpp: "#->mark_internal_bounds_stale(#)".} ## \
## Should be called by a derived class to mark the internal bounding volume
## stale, so that compute_internal_bounds() will be called when the bounding
## volume is next requested.
##
## With no parameters, this means to iterate through all stages including and
## upstream of the current pipeline stage.
##
## It is normally not necessary to call this method directly; each node should
## be responsible for calling it when its internals have changed.

proc markInternalBoundsStale*(this: PandaNode) {.importcpp: "#->mark_internal_bounds_stale()".} ## \
## Should be called by a derived class to mark the internal bounding volume
## stale, so that compute_internal_bounds() will be called when the bounding
## volume is next requested.
##
## With no parameters, this means to iterate through all stages including and
## upstream of the current pipeline stage.
##
## It is normally not necessary to call this method directly; each node should
## be responsible for calling it when its internals have changed.

proc isBoundsStale*(this: PandaNode): bool {.importcpp: "#->is_bounds_stale()".} ## \
## Returns true if the bounding volume of this node is stale and will be
## implicitly recomputed at the next call to get_bounds(), or false if it is
## fresh and need not be recomputed.

proc setFinal*(this: PandaNode, flag: bool) {.importcpp: "#->set_final(#)".} ## \
## Sets the "final" flag on this PandaNode.  If this is true, than no bounding
## volume need be tested below it; a positive intersection with this node's
## bounding volume is deemed to be a positive intersection with all geometry
## inside.
##
## This is useful to quickly force a larger bounding volume around a node when
## the GeomNodes themselves are inaccurate for some reason, without forcing a
## recompute of every nested bounding volume.  It's also helpful when the
## bounding volume is tricked by some special properties, like billboards,
## that may move geometry out of its bounding volume otherwise.

proc isFinal*(this: PandaNode, current_thread: Thread): bool {.importcpp: "#->is_final(#)".} ## \
## Returns the current state of the "final" flag.  Initially, this flag is off
## (false), but it may be changed by an explicit call to set_final().  See
## set_final().

proc isFinal*(this: PandaNode): bool {.importcpp: "#->is_final()".} ## \
## Returns the current state of the "final" flag.  Initially, this flag is off
## (false), but it may be changed by an explicit call to set_final().  See
## set_final().

proc isGeomNode*(this: PandaNode): bool {.importcpp: "#->is_geom_node()".} ## \
## A simple downcast check.  Returns true if this kind of node happens to
## inherit from GeomNode, false otherwise.
##
## This is provided as a a faster alternative to calling
## is_of_type(GeomNode::get_class_type()), since this test is so important to
## rendering.

proc isLodNode*(this: PandaNode): bool {.importcpp: "#->is_lod_node()".} ## \
## A simple downcast check.  Returns true if this kind of node happens to
## inherit from LODNode, false otherwise.
##
## This is provided as a a faster alternative to calling
## is_of_type(LODNode::get_class_type()).

proc isCollisionNode*(this: PandaNode): bool {.importcpp: "#->is_collision_node()".} ## \
## A simple downcast check.  Returns true if this kind of node happens to
## inherit from CollisionNode, false otherwise.
##
## This is provided as a a faster alternative to calling
## is_of_type(CollisionNode::get_class_type()).

proc asLight*(this: PandaNode): Light {.importcpp: "#->as_light()".} ## \
## Cross-casts the node to a Light pointer, if it is one of the four kinds of
## Light nodes, or returns NULL if it is not.

proc isAmbientLight*(this: PandaNode): bool {.importcpp: "#->is_ambient_light()".} ## \
## Returns true if this is an AmbientLight, false if it is not a light, or it
## is some other kind of light.

proc getFancyBits*(this: PandaNode, current_thread: Thread): int {.importcpp: "#->get_fancy_bits(#)".} ## \
## Returns the union of all of the enum FancyBits values corresponding to the
## various "fancy" attributes that are set on the node.  If this returns 0,
## the node has nothing interesting about it.  This is intended to speed
## traversal by quickly skipping past nodes that don't particularly affect the
## render state.

proc getFancyBits*(this: PandaNode): int {.importcpp: "#->get_fancy_bits()".} ## \
## Returns the union of all of the enum FancyBits values corresponding to the
## various "fancy" attributes that are set on the node.  If this returns 0,
## the node has nothing interesting about it.  This is intended to speed
## traversal by quickly skipping past nodes that don't particularly affect the
## render state.

converter getClassType*(_: typedesc[PandaNode]): TypeHandle {.importcpp: "PandaNode::get_class_type()", header: "pandaNode.h".}

proc makeDefault*(_: typedesc[TransparencyAttrib]): RenderAttrib {.importcpp: "deconstify(TransparencyAttrib::make_default())", header: "transparencyAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc getClassSlot*(_: typedesc[TransparencyAttrib]): int {.importcpp: "TransparencyAttrib::get_class_slot()", header: "transparencyAttrib.h".}

converter getClassType*(_: typedesc[TransparencyAttrib]): TypeHandle {.importcpp: "TransparencyAttrib::get_class_type()", header: "transparencyAttrib.h".}

proc makeOff*(_: typedesc[LogicOpAttrib]): RenderAttrib {.importcpp: "deconstify(LogicOpAttrib::make_off())", header: "logicOpAttrib.h".} ## \
## Constructs a new LogicOpAttrib object that disables special-effect
## blending, allowing normal transparency to be used instead.

proc makeDefault*(_: typedesc[LogicOpAttrib]): RenderAttrib {.importcpp: "deconstify(LogicOpAttrib::make_default())", header: "logicOpAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc getClassSlot*(_: typedesc[LogicOpAttrib]): int {.importcpp: "LogicOpAttrib::get_class_slot()", header: "logicOpAttrib.h".}

converter getClassType*(_: typedesc[LogicOpAttrib]): TypeHandle {.importcpp: "LogicOpAttrib::get_class_type()", header: "logicOpAttrib.h".}

proc getBlank*(_: typedesc[ShaderInput]): ShaderInput {.importcpp: "ShaderInput::get_blank()", header: "shaderInput.h".} ## \
## Returns a static ShaderInput object with name NULL, priority zero, type
## INVALID, and all value-fields cleared.

proc initShaderInput*(name: InternalName, tex: Texture, sampler: SamplerState, priority: int): ShaderInput {.importcpp: "ShaderInput(#, #, #, #)".}

proc initShaderInput*(name: InternalName, tex: Texture, sampler: SamplerState): ShaderInput {.importcpp: "ShaderInput(#, #, #)".}

proc initShaderInput*(name: InternalName, tex: Texture, read: bool, write: bool, z: int, n: int, priority: int): ShaderInput {.importcpp: "ShaderInput(#, #, #, #, #, #, #)".}

proc initShaderInput*(name: InternalName, tex: Texture, read: bool, write: bool, z: int, n: int): ShaderInput {.importcpp: "ShaderInput(#, #, #, #, #, #)".}

proc initShaderInput*(name: InternalName, tex: Texture, read: bool, write: bool, z: int): ShaderInput {.importcpp: "ShaderInput(#, #, #, #, #)".}

proc initShaderInput*(name: InternalName, tex: Texture, read: bool, write: bool): ShaderInput {.importcpp: "ShaderInput(#, #, #, #)".}

proc initShaderInput*(name: InternalName, priority: int): ShaderInput {.importcpp: "ShaderInput(#, #)".}

proc initShaderInput*(name: InternalName): ShaderInput {.importcpp: "ShaderInput(#)".}

proc initShaderInput*(param0: ShaderInput): ShaderInput {.importcpp: "ShaderInput(#)".}

proc `typecast bool`*(this: ShaderInput): bool {.importcpp: "#.operator typecast bool()".}

proc `==`*(this: ShaderInput, other: ShaderInput): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: ShaderInput, other: ShaderInput): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: ShaderInput, other: ShaderInput): bool {.importcpp: "#.operator <(#)".}

proc addHash*(this: ShaderInput, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".}

proc getName*(this: ShaderInput): InternalName {.importcpp: "#.get_name()".}

proc getValueType*(this: ShaderInput): int {.importcpp: "#.get_value_type()".}

proc getPriority*(this: ShaderInput): int {.importcpp: "#.get_priority()".}

proc getVector*(this: ShaderInput): LVecBase4 {.importcpp: "#.get_vector()".}

proc getNodepath*(this: ShaderInput): NodePath {.importcpp: "#.get_nodepath()".} ## \
## Warning: no error checking is done.  This \*will\* crash if get_value_type()
## is not M_nodepath.

proc getTexture*(this: ShaderInput): Texture {.importcpp: "#.get_texture()".}

proc getSampler*(this: ShaderInput): SamplerState {.importcpp: "#.get_sampler()".} ## \
## Warning: no error checking is done.

proc initInternalNameCollection*(): InternalNameCollection {.importcpp: "InternalNameCollection()".}

proc initInternalNameCollection*(copy: InternalNameCollection): InternalNameCollection {.importcpp: "InternalNameCollection(#)".}

proc addName*(this: InternalNameCollection, name: InternalName) {.importcpp: "#.add_name(#)".} ## \
## Adds a new InternalName to the collection.

proc removeName*(this: InternalNameCollection, name: InternalName): bool {.importcpp: "#.remove_name(#)".} ## \
## Removes the indicated InternalName from the collection.  Returns true if
## the name was removed, false if it was not a member of the collection.

proc addNamesFrom*(this: InternalNameCollection, other: InternalNameCollection) {.importcpp: "#.add_names_from(#)".} ## \
## Adds all the InternalNames indicated in the other collection to this name.
## The other names are simply appended to the end of the names in this list;
## duplicates are not automatically removed.

proc removeNamesFrom*(this: InternalNameCollection, other: InternalNameCollection) {.importcpp: "#.remove_names_from(#)".} ## \
## Removes from this collection all of the InternalNames listed in the other
## collection.

proc removeDuplicateNames*(this: InternalNameCollection) {.importcpp: "#.remove_duplicate_names()".} ## \
## Removes any duplicate entries of the same InternalNames on this collection.
## If a InternalName appears multiple times, the first appearance is retained;
## subsequent appearances are removed.

proc hasName*(this: InternalNameCollection, name: InternalName): bool {.importcpp: "#.has_name(#)".} ## \
## Returns true if the indicated InternalName appears in this collection,
## false otherwise.

proc clear*(this: InternalNameCollection) {.importcpp: "#.clear()".} ## \
## Removes all InternalNames from the collection.

proc getNumNames*(this: InternalNameCollection): int {.importcpp: "#.get_num_names()".} ## \
## Returns the number of InternalNames in the collection.

proc getName*(this: InternalNameCollection, index: int): InternalName {.importcpp: "#.get_name(#)".} ## \
## Returns the nth InternalName in the collection.

proc `[]`*(this: InternalNameCollection, index: int): InternalName {.importcpp: "#.operator [](#)".} ## \
## Returns the nth InternalName in the collection.  This is the same as
## get_name(), but it may be a more convenient way to access it.

proc size*(this: InternalNameCollection): int {.importcpp: "#.size()".} ## \
## Returns the number of names in the collection.  This is the same thing as
## get_num_names().

proc `+=`*(this: var InternalNameCollection, other: InternalNameCollection): InternalNameCollection {.importcpp: "#.operator +=(#)".}

proc `+`*(this: InternalNameCollection, other: InternalNameCollection): InternalNameCollection {.importcpp: "#.operator +(#)".}

proc output*(this: InternalNameCollection, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Writes a brief one-line description of the InternalNameCollection to the
## indicated output stream.

proc write*(this: InternalNameCollection, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Writes a complete multi-line description of the InternalNameCollection to
## the indicated output stream.

proc write*(this: InternalNameCollection, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes a complete multi-line description of the InternalNameCollection to
## the indicated output stream.

proc initMaterialCollection*(): MaterialCollection {.importcpp: "MaterialCollection()".}

proc initMaterialCollection*(copy: MaterialCollection): MaterialCollection {.importcpp: "MaterialCollection(#)".}

proc addMaterial*(this: MaterialCollection, node_material: Material) {.importcpp: "#.add_material(#)".} ## \
## Adds a new Material to the collection.

proc removeMaterial*(this: MaterialCollection, node_material: Material): bool {.importcpp: "#.remove_material(#)".} ## \
## Removes the indicated Material from the collection.  Returns true if the
## material was removed, false if it was not a member of the collection.

proc addMaterialsFrom*(this: MaterialCollection, other: MaterialCollection) {.importcpp: "#.add_materials_from(#)".} ## \
## Adds all the Materials indicated in the other collection to this material.
## The other materials are simply appended to the end of the materials in this
## list; duplicates are not automatically removed.

proc removeMaterialsFrom*(this: MaterialCollection, other: MaterialCollection) {.importcpp: "#.remove_materials_from(#)".} ## \
## Removes from this collection all of the Materials listed in the other
## collection.

proc removeDuplicateMaterials*(this: MaterialCollection) {.importcpp: "#.remove_duplicate_materials()".} ## \
## Removes any duplicate entries of the same Materials on this collection.  If
## a Material appears multiple times, the first appearance is retained;
## subsequent appearances are removed.

proc hasMaterial*(this: MaterialCollection, material: Material): bool {.importcpp: "#.has_material(#)".} ## \
## Returns true if the indicated Material appears in this collection, false
## otherwise.

proc clear*(this: MaterialCollection) {.importcpp: "#.clear()".} ## \
## Removes all Materials from the collection.

proc findMaterial*(this: MaterialCollection, name: string): Material {.importcpp: "#.find_material(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the material in the collection with the indicated name, if any, or
## NULL if no material has that name.

proc getNumMaterials*(this: MaterialCollection): int {.importcpp: "#.get_num_materials()".} ## \
## Returns the number of Materials in the collection.

proc getMaterial*(this: MaterialCollection, index: int): Material {.importcpp: "#.get_material(#)".} ## \
## Returns the nth Material in the collection.

proc `[]`*(this: MaterialCollection, index: int): Material {.importcpp: "#.operator [](#)".} ## \
## Returns the nth Material in the collection.  This is the same as
## get_material(), but it may be a more convenient way to access it.

proc size*(this: MaterialCollection): int {.importcpp: "#.size()".} ## \
## Returns the number of materials in the collection.  This is the same thing
## as get_num_materials().

proc `+=`*(this: var MaterialCollection, other: MaterialCollection): MaterialCollection {.importcpp: "#.operator +=(#)".}

proc `+`*(this: MaterialCollection, other: MaterialCollection): MaterialCollection {.importcpp: "#.operator +(#)".}

proc output*(this: MaterialCollection, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Writes a brief one-line description of the MaterialCollection to the
## indicated output stream.

proc write*(this: MaterialCollection, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Writes a complete multi-line description of the MaterialCollection to the
## indicated output stream.

proc write*(this: MaterialCollection, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes a complete multi-line description of the MaterialCollection to the
## indicated output stream.

proc initTextureStageCollection*(): TextureStageCollection {.importcpp: "TextureStageCollection()".}

proc initTextureStageCollection*(copy: TextureStageCollection): TextureStageCollection {.importcpp: "TextureStageCollection(#)".}

proc addTextureStage*(this: TextureStageCollection, node_texture_stage: TextureStage) {.importcpp: "#.add_texture_stage(#)".} ## \
## Adds a new TextureStage to the collection.

proc removeTextureStage*(this: TextureStageCollection, node_texture_stage: TextureStage): bool {.importcpp: "#.remove_texture_stage(#)".} ## \
## Removes the indicated TextureStage from the collection.  Returns true if
## the texture_stage was removed, false if it was not a member of the
## collection.

proc addTextureStagesFrom*(this: TextureStageCollection, other: TextureStageCollection) {.importcpp: "#.add_texture_stages_from(#)".} ## \
## Adds all the TextureStages indicated in the other collection to this
## texture_stage.  The other texture_stages are simply appended to the end of
## the texture_stages in this list; duplicates are not automatically removed.

proc removeTextureStagesFrom*(this: TextureStageCollection, other: TextureStageCollection) {.importcpp: "#.remove_texture_stages_from(#)".} ## \
## Removes from this collection all of the TextureStages listed in the other
## collection.

proc removeDuplicateTextureStages*(this: TextureStageCollection) {.importcpp: "#.remove_duplicate_texture_stages()".} ## \
## Removes any duplicate entries of the same TextureStages on this collection.
## If a TextureStage appears multiple times, the first appearance is retained;
## subsequent appearances are removed.

proc hasTextureStage*(this: TextureStageCollection, texture_stage: TextureStage): bool {.importcpp: "#.has_texture_stage(#)".} ## \
## Returns true if the indicated TextureStage appears in this collection,
## false otherwise.

proc clear*(this: TextureStageCollection) {.importcpp: "#.clear()".} ## \
## Removes all TextureStages from the collection.

proc findTextureStage*(this: TextureStageCollection, name: string): TextureStage {.importcpp: "#.find_texture_stage(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the texture_stage in the collection with the indicated name, if
## any, or NULL if no texture_stage has that name.

proc getNumTextureStages*(this: TextureStageCollection): int {.importcpp: "#.get_num_texture_stages()".} ## \
## Returns the number of TextureStages in the collection.

proc getTextureStage*(this: TextureStageCollection, index: int): TextureStage {.importcpp: "#.get_texture_stage(#)".} ## \
## Returns the nth TextureStage in the collection.

proc `[]`*(this: TextureStageCollection, index: int): TextureStage {.importcpp: "#.operator [](#)".} ## \
## Returns the nth TextureStage in the collection.  This is the same as
## get_texture_stage(), but it may be a more convenient way to access it.

proc size*(this: TextureStageCollection): int {.importcpp: "#.size()".} ## \
## Returns the number of texture stages in the collection.  This is the same
## thing as get_num_texture_stages().

proc `+=`*(this: var TextureStageCollection, other: TextureStageCollection): TextureStageCollection {.importcpp: "#.operator +=(#)".}

proc `+`*(this: TextureStageCollection, other: TextureStageCollection): TextureStageCollection {.importcpp: "#.operator +(#)".}

proc sort*(this: TextureStageCollection) {.importcpp: "#.sort()".} ## \
## Sorts the TextureStages in this collection into order by
## TextureStage::sort(), from lowest to highest.

proc output*(this: TextureStageCollection, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Writes a brief one-line description of the TextureStageCollection to the
## indicated output stream.

proc write*(this: TextureStageCollection, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Writes a complete multi-line description of the TextureStageCollection to
## the indicated output stream.

proc write*(this: TextureStageCollection, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes a complete multi-line description of the TextureStageCollection to
## the indicated output stream.

proc initNodePath*(): NodePath {.importcpp: "NodePath()".} ## \
## This constructs an empty NodePath with no nodes.

proc initNodePath*(copy: NodePath): NodePath {.importcpp: "NodePath(#)".}

proc initNodePath*(parent: NodePath, child_node: PandaNode, current_thread: Thread): NodePath {.importcpp: "NodePath(#, #, #)".} ## \
## Constructs a NodePath with the indicated parent NodePath and child node;
## the child node must be a stashed or unstashed child of the parent.

proc initNodePath*(parent: NodePath, child_node: PandaNode): NodePath {.importcpp: "NodePath(#, #)".} ## \
## Constructs a NodePath with the indicated parent NodePath and child node;
## the child node must be a stashed or unstashed child of the parent.

proc initNodePath*(node: PandaNode, current_thread: Thread): NodePath {.importcpp: "NodePath(#, #)".} ## \
## This constructs a NodePath for the indicated node.  If the node does not
## have any parents, this creates a singleton NodePath; otherwise, it
## automatically finds the path from the node to the root.  If the node has
## multiple paths to the root, one path is chosen arbitrarily and a warning
## message is printed (but see also NodePath::any_path(), below).

proc initNodePath*(node: PandaNode): NodePath {.importcpp: "NodePath(#)".} ## \
## This constructs a NodePath for the indicated node.  If the node does not
## have any parents, this creates a singleton NodePath; otherwise, it
## automatically finds the path from the node to the root.  If the node has
## multiple paths to the root, one path is chosen arbitrarily and a warning
## message is printed (but see also NodePath::any_path(), below).

proc initNodePath*(top_node_name: string, current_thread: Thread): NodePath {.importcpp: "NodePath(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## This constructs a new NodePath with a single node.  An ordinary, unattached
## PandaNode is created with the indicated name.

proc initNodePath*(top_node_name: string): NodePath {.importcpp: "NodePath(nimStringToStdString(#))", header: stringConversionCode.} ## \
## This constructs a new NodePath with a single node.  An ordinary, unattached
## PandaNode is created with the indicated name.

proc anyPath*(_: typedesc[NodePath], node: PandaNode, current_thread: Thread): NodePath {.importcpp: "#NodePath::any_path(#, #)", header: "nodePath.h".} ## \
## Returns a new NodePath that represents any arbitrary path from the root to
## the indicated node.  This is the same thing that would be returned by
## NodePath(node), except that no warning is issued if the path is ambiguous.

proc anyPath*(_: typedesc[NodePath], node: PandaNode): NodePath {.importcpp: "#NodePath::any_path(#)", header: "nodePath.h".} ## \
## Returns a new NodePath that represents any arbitrary path from the root to
## the indicated node.  This is the same thing that would be returned by
## NodePath(node), except that no warning is issued if the path is ambiguous.

proc clear*(this: NodePath) {.importcpp: "#.clear()".} ## \
## Sets this NodePath to the empty NodePath.  It will no longer point to any
## node.

proc notFound*(_: typedesc[NodePath]): NodePath {.importcpp: "NodePath::not_found()", header: "nodePath.h".} ## \
## Creates a NodePath with the ET_not_found error type set.

proc removed*(_: typedesc[NodePath]): NodePath {.importcpp: "NodePath::removed()", header: "nodePath.h".} ## \
## Creates a NodePath with the ET_removed error type set.

proc fail*(_: typedesc[NodePath]): NodePath {.importcpp: "NodePath::fail()", header: "nodePath.h".} ## \
## Creates a NodePath with the ET_fail error type set.

proc setMaxSearchDepth*(_: typedesc[NodePath], max_search_depth: int) {.importcpp: "#NodePath::set_max_search_depth(#)", header: "nodePath.h".} ## \
## Certain operations, such as find() or find_all_matches(), require a
## traversal of the scene graph to search for the target node or nodes.  This
## traversal does not attempt to detect cycles, so an arbitrary cap is set on
## the depth of the traversal as a poor man's cycle detection, in the event
## that a cycle has inadvertently been introduced into the scene graph.
##
## There may be other reasons you'd want to truncate a search before the
## bottom of the scene graph has been reached.  In any event, this function
## sets the limit on the number of levels that a traversal will continue, and
## hence the maximum length of a path that may be returned by a traversal.
##
## This is a static method, and so changing this parameter affects all of the
## NodePaths in the universe.

proc getMaxSearchDepth*(_: typedesc[NodePath]): int {.importcpp: "NodePath::get_max_search_depth()", header: "nodePath.h".} ## \
## Returns the current setting of the search depth limit.  See
## set_max_search_depth.

proc isEmpty*(this: NodePath): bool {.importcpp: "#.is_empty()".} ## \
## Returns true if the NodePath contains no nodes.

proc `typecast bool`*(this: NodePath): bool {.importcpp: "#.operator typecast bool()".}

proc isSingleton*(this: NodePath, current_thread: Thread): bool {.importcpp: "#.is_singleton(#)".} ## \
## Returns true if the NodePath contains exactly one node.

proc isSingleton*(this: NodePath): bool {.importcpp: "#.is_singleton()".} ## \
## Returns true if the NodePath contains exactly one node.

proc getNumNodes*(this: NodePath, current_thread: Thread): int {.importcpp: "#.get_num_nodes(#)".} ## \
## Returns the number of nodes in the path.

proc getNumNodes*(this: NodePath): int {.importcpp: "#.get_num_nodes()".} ## \
## Returns the number of nodes in the path.

proc getNode*(this: NodePath, index: int, current_thread: Thread): PandaNode {.importcpp: "#.get_node(#, #)".} ## \
## Returns the nth node of the path, where 0 is the referenced (bottom) node
## and get_num_nodes() - 1 is the top node.  This requires iterating through
## the path.
##
## Also see node(), which is a convenience function to return the same thing
## as get_node(0) (since the bottom node is the most important node in the
## NodePath, and is the one most frequently referenced).
##
## Note that this function returns the same thing as
## get_ancestor(index).node().

proc getNode*(this: NodePath, index: int): PandaNode {.importcpp: "#.get_node(#)".} ## \
## Returns the nth node of the path, where 0 is the referenced (bottom) node
## and get_num_nodes() - 1 is the top node.  This requires iterating through
## the path.
##
## Also see node(), which is a convenience function to return the same thing
## as get_node(0) (since the bottom node is the most important node in the
## NodePath, and is the one most frequently referenced).
##
## Note that this function returns the same thing as
## get_ancestor(index).node().

proc getAncestor*(this: NodePath, index: int, current_thread: Thread): NodePath {.importcpp: "#.get_ancestor(#, #)".} ## \
## Returns the nth ancestor of the path, where 0 is the NodePath itself and
## get_num_nodes() - 1 is get_top(). This requires iterating through the path.
##
## Also see get_node(), which returns the same thing as a PandaNode pointer,
## not a NodePath.

proc getAncestor*(this: NodePath, index: int): NodePath {.importcpp: "#.get_ancestor(#)".} ## \
## Returns the nth ancestor of the path, where 0 is the NodePath itself and
## get_num_nodes() - 1 is get_top(). This requires iterating through the path.
##
## Also see get_node(), which returns the same thing as a PandaNode pointer,
## not a NodePath.

proc getTopNode*(this: NodePath, current_thread: Thread): PandaNode {.importcpp: "#.get_top_node(#)".} ## \
## Returns the top node of the path, or NULL if the path is empty.  This
## requires iterating through the path.

proc getTopNode*(this: NodePath): PandaNode {.importcpp: "#.get_top_node()".} ## \
## Returns the top node of the path, or NULL if the path is empty.  This
## requires iterating through the path.

proc getTop*(this: NodePath, current_thread: Thread): NodePath {.importcpp: "#.get_top(#)".} ## \
## Returns a singleton NodePath that represents the top of the path, or empty
## NodePath if this path is empty.

proc getTop*(this: NodePath): NodePath {.importcpp: "#.get_top()".} ## \
## Returns a singleton NodePath that represents the top of the path, or empty
## NodePath if this path is empty.

proc node*(this: NodePath): PandaNode {.importcpp: "#.node()".} ## \
## Returns the referenced node of the path.

proc getKey*(this: NodePath): int {.importcpp: "#.get_key()".} ## \
## Returns an integer that is guaranteed to be the same for all NodePaths that
## represent the same node instance, and different for all NodePaths that
## represent a different node instance.
##
## The same key will be returned for a particular instance as long as at least
## one NodePath exists that represents that instance; if all NodePaths for a
## particular instance destruct and a new one is later created, it may have a
## different index.  However, a given key will never be reused for a different
## instance (unless the app has been running long enough that we overflow the
## integer key value).

proc addHash*(this: NodePath, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the NodePath into the running hash.  This is intended to be used by
## lower-level code that computes a hash for each NodePath.  It modifies the
## hash value passed in by a unique adjustment for each NodePath, and returns
## the modified hash.
##
## This is similar to the unique integer returned by get_key(), but it is not
## guaranteed to remain unique beyond the lifetime of this particular
## NodePath.  Once this NodePath destructs, a different NodePath may be
## created which shares the same hash value.

proc isSameGraph*(this: NodePath, other: NodePath, current_thread: Thread): bool {.importcpp: "#.is_same_graph(#, #)".} ## \
## Returns true if the node represented by this NodePath is parented within
## the same graph as that of the other NodePath.  This is essentially the same
## thing as asking whether get_top() of both NodePaths is the same (e.g., both
## "render").

proc isSameGraph*(this: NodePath, other: NodePath): bool {.importcpp: "#.is_same_graph(#)".} ## \
## Returns true if the node represented by this NodePath is parented within
## the same graph as that of the other NodePath.  This is essentially the same
## thing as asking whether get_top() of both NodePaths is the same (e.g., both
## "render").

proc isAncestorOf*(this: NodePath, other: NodePath, current_thread: Thread): bool {.importcpp: "#.is_ancestor_of(#, #)".} ## \
## Returns true if the node represented by this NodePath is a parent or other
## ancestor of the other NodePath, or false if it is not.

proc isAncestorOf*(this: NodePath, other: NodePath): bool {.importcpp: "#.is_ancestor_of(#)".} ## \
## Returns true if the node represented by this NodePath is a parent or other
## ancestor of the other NodePath, or false if it is not.

proc getCommonAncestor*(this: NodePath, other: NodePath, current_thread: Thread): NodePath {.importcpp: "#.get_common_ancestor(#, #)".} ## \
## Returns the lowest NodePath that both of these two NodePaths have in
## common: the first ancestor that both of them share.  If the two NodePaths
## are unrelated, returns NodePath::not_found().

proc getCommonAncestor*(this: NodePath, other: NodePath): NodePath {.importcpp: "#.get_common_ancestor(#)".} ## \
## Returns the lowest NodePath that both of these two NodePaths have in
## common: the first ancestor that both of them share.  If the two NodePaths
## are unrelated, returns NodePath::not_found().

proc getChildren*(this: NodePath, current_thread: Thread): NodePathCollection {.importcpp: "#.get_children(#)".} ## \
## Returns the set of all child nodes of the referenced node.

proc getChildren*(this: NodePath): NodePathCollection {.importcpp: "#.get_children()".} ## \
## Returns the set of all child nodes of the referenced node.

proc getNumChildren*(this: NodePath, current_thread: Thread): int {.importcpp: "#.get_num_children(#)".} ## \
## Returns the number of children of the referenced node.

proc getNumChildren*(this: NodePath): int {.importcpp: "#.get_num_children()".} ## \
## Returns the number of children of the referenced node.

proc getChild*(this: NodePath, n: int, current_thread: Thread): NodePath {.importcpp: "#.get_child(#, #)".} ## \
## Returns a NodePath representing the nth child of the referenced node.

proc getChild*(this: NodePath, n: int): NodePath {.importcpp: "#.get_child(#)".} ## \
## Returns a NodePath representing the nth child of the referenced node.

proc getStashedChildren*(this: NodePath, current_thread: Thread): NodePathCollection {.importcpp: "#.get_stashed_children(#)".} ## \
## Returns the set of all child nodes of the referenced node that have been
## stashed.  These children are not normally visible on the node, and do not
## appear in the list returned by get_children().

proc getStashedChildren*(this: NodePath): NodePathCollection {.importcpp: "#.get_stashed_children()".} ## \
## Returns the set of all child nodes of the referenced node that have been
## stashed.  These children are not normally visible on the node, and do not
## appear in the list returned by get_children().

proc initNodePathCollection*(): NodePathCollection {.importcpp: "NodePathCollection()".}

proc initNodePathCollection*(param0: NodePathCollection): NodePathCollection {.importcpp: "NodePathCollection(#)".}

proc addPath*(this: NodePathCollection, node_path: NodePath) {.importcpp: "#.add_path(#)".} ## \
## Adds a new NodePath to the collection.

proc removePath*(this: NodePathCollection, node_path: NodePath): bool {.importcpp: "#.remove_path(#)".} ## \
## Removes the indicated NodePath from the collection.  Returns true if the
## path was removed, false if it was not a member of the collection.

proc addPathsFrom*(this: NodePathCollection, other: NodePathCollection) {.importcpp: "#.add_paths_from(#)".} ## \
## Adds all the NodePaths indicated in the other collection to this path.  The
## other paths are simply appended to the end of the paths in this list;
## duplicates are not automatically removed.

proc removePathsFrom*(this: NodePathCollection, other: NodePathCollection) {.importcpp: "#.remove_paths_from(#)".} ## \
## Removes from this collection all of the NodePaths listed in the other
## collection.

proc removeDuplicatePaths*(this: NodePathCollection) {.importcpp: "#.remove_duplicate_paths()".} ## \
## Removes any duplicate entries of the same NodePaths on this collection.  If
## a NodePath appears multiple times, the first appearance is retained;
## subsequent appearances are removed.

proc hasPath*(this: NodePathCollection, path: NodePath): bool {.importcpp: "#.has_path(#)".} ## \
## Returns true if the indicated NodePath appears in this collection, false
## otherwise.

proc clear*(this: NodePathCollection) {.importcpp: "#.clear()".} ## \
## Removes all NodePaths from the collection.

proc reserve*(this: NodePathCollection, num: clonglong) {.importcpp: "#.reserve(#)".} ## \
## This is a hint to Panda to allocate enough memory to hold the given number
## of NodePaths, if you know ahead of time how many you will be adding.

proc isEmpty*(this: NodePathCollection): bool {.importcpp: "#.is_empty()".} ## \
## Returns true if there are no NodePaths in the collection, false otherwise.

proc getNumPaths*(this: NodePathCollection): int {.importcpp: "#.get_num_paths()".} ## \
## Returns the number of NodePaths in the collection.

proc getPath*(this: NodePathCollection, index: int): NodePath {.importcpp: "#.get_path(#)".} ## \
## Returns the nth NodePath in the collection.

proc `[]`*(this: NodePathCollection, index: clonglong): NodePath {.importcpp: "#.operator [](#)".}

proc size*(this: NodePathCollection): clonglong {.importcpp: "#.size()".} ## \
## Returns the number of paths in the collection.  This is the same thing as
## get_num_paths().

proc `+=`*(this: var NodePathCollection, other: NodePathCollection): NodePathCollection {.importcpp: "#.operator +=(#)".}

proc `+`*(this: NodePathCollection, other: NodePathCollection): NodePathCollection {.importcpp: "#.operator +(#)".}

proc append*(this: NodePathCollection, node_path: NodePath) {.importcpp: "#.append(#)".} ## \
## Adds a new NodePath to the collection.  This method duplicates the
## add_path() method; it is provided to satisfy Python's naming convention.

proc extend*(this: NodePathCollection, other: NodePathCollection) {.importcpp: "#.extend(#)".} ## \
## Appends the other list onto the end of this one.  This method duplicates
## the += operator; it is provided to satisfy Python's naming convention.

proc ls*(this: NodePathCollection) {.importcpp: "#.ls()".} ## \
## Lists all the nodes at and below each node in the collection
## hierarchically.

proc ls*(this: NodePathCollection, `out`: ostream, indent_level: int) {.importcpp: "#.ls(#, #)".} ## \
## Lists all the nodes at and below each node in the collection
## hierarchically.

proc ls*(this: NodePathCollection, `out`: ostream) {.importcpp: "#.ls(#)".} ## \
## Lists all the nodes at and below each node in the collection
## hierarchically.

proc findAllMatches*(this: NodePathCollection, path: string): NodePathCollection {.importcpp: "#.find_all_matches(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the complete set of all NodePaths that begin with any NodePath in
## this collection and can be extended by path.  The shortest paths will be
## listed first.

proc reparentTo*(this: NodePathCollection, other: NodePath) {.importcpp: "#.reparent_to(#)".} ## \
## Reparents all the NodePaths in the collection to the indicated node.

proc wrtReparentTo*(this: NodePathCollection, other: NodePath) {.importcpp: "#.wrt_reparent_to(#)".} ## \
## Reparents all the NodePaths in the collection to the indicated node,
## adjusting each transform so as not to move in world coordinates.

proc show*(this: NodePathCollection) {.importcpp: "#.show()".} ## \
## Shows all NodePaths in the collection.

proc hide*(this: NodePathCollection) {.importcpp: "#.hide()".} ## \
## Hides all NodePaths in the collection.

proc stash*(this: NodePathCollection) {.importcpp: "#.stash()".} ## \
## Stashes all NodePaths in the collection.

proc unstash*(this: NodePathCollection) {.importcpp: "#.unstash()".} ## \
## Unstashes all NodePaths in the collection.

proc detach*(this: NodePathCollection) {.importcpp: "#.detach()".} ## \
## Detaches all NodePaths in the collection.

proc getCollideMask*(this: NodePathCollection): CollideMask {.importcpp: "#.get_collide_mask()".} ## \
## Returns the union of all of the into_collide_masks for nodes at this level
## and below.  This is the same thing as node()->get_net_collide_mask().
##
## If you want to return what the into_collide_mask of this node itself is,
## without regard to its children, use node()->get_into_collide_mask().

proc setCollideMask*(this: NodePathCollection, new_mask: CollideMask, bits_to_change: CollideMask, node_type: TypeHandle) {.importcpp: "#.set_collide_mask(#, #, #)".} ## \
## Recursively applies the indicated CollideMask to the into_collide_masks for
## all nodes at this level and below.
##
## The default is to change all bits, but if bits_to_change is not all bits
## on, then only the bits that are set in bits_to_change are modified,
## allowing this call to change only a subset of the bits in the subgraph.

proc setCollideMask*(this: NodePathCollection, new_mask: CollideMask, bits_to_change: CollideMask) {.importcpp: "#.set_collide_mask(#, #)".} ## \
## Recursively applies the indicated CollideMask to the into_collide_masks for
## all nodes at this level and below.
##
## The default is to change all bits, but if bits_to_change is not all bits
## on, then only the bits that are set in bits_to_change are modified,
## allowing this call to change only a subset of the bits in the subgraph.

proc setCollideMask*(this: NodePathCollection, new_mask: CollideMask) {.importcpp: "#.set_collide_mask(#)".} ## \
## Recursively applies the indicated CollideMask to the into_collide_masks for
## all nodes at this level and below.
##
## The default is to change all bits, but if bits_to_change is not all bits
## on, then only the bits that are set in bits_to_change are modified,
## allowing this call to change only a subset of the bits in the subgraph.

proc calcTightBounds*(this: NodePathCollection, min_point: LPoint3, max_point: LPoint3): bool {.importcpp: "#.calc_tight_bounds(#, #)".} ## \
## Calculates the minimum and maximum vertices of all Geoms at these
## NodePath's bottom nodes and below This is a tight bounding box; it will
## generally be tighter than the bounding volume returned by get_bounds() (but
## it is more expensive to compute).
##
## The return value is true if any points are within the bounding volume, or
## false if none are.

proc setTexture*(this: NodePathCollection, tex: Texture, priority: int) {.importcpp: "#.set_texture(#, #)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the default texture stage.
##
## This is the deprecated single-texture variant of this method; it is now
## superceded by set_texture() that accepts a stage and texture.  However,
## this method may be used in the presence of multitexture if you just want to
## adjust the default stage.

proc setTexture*(this: NodePathCollection, tex: Texture) {.importcpp: "#.set_texture(#)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the default texture stage.
##
## This is the deprecated single-texture variant of this method; it is now
## superceded by set_texture() that accepts a stage and texture.  However,
## this method may be used in the presence of multitexture if you just want to
## adjust the default stage.

proc setTexture*(this: NodePathCollection, stage: TextureStage, tex: Texture, priority: int) {.importcpp: "#.set_texture(#, #, #)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the indicated multitexture stage.  If there are multiple texture stages
## specified (possibly on multiple different nodes at different levels), they
## will all be applied to geometry together, according to the stage
## specification set up in the TextureStage object.

proc setTexture*(this: NodePathCollection, stage: TextureStage, tex: Texture) {.importcpp: "#.set_texture(#, #)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the indicated multitexture stage.  If there are multiple texture stages
## specified (possibly on multiple different nodes at different levels), they
## will all be applied to geometry together, according to the stage
## specification set up in the TextureStage object.

proc setTextureOff*(this: NodePathCollection, stage: TextureStage, priority: int) {.importcpp: "#.set_texture_off(#, #)".} ## \
## Sets the geometry at this level and below to render using no texture, on
## the indicated stage.  This is different from not specifying a texture;
## rather, this specifically contradicts set_texture() at a higher node level
## (or, with a priority, overrides a set_texture() at a lower level).

proc setTextureOff*(this: NodePathCollection, stage: TextureStage) {.importcpp: "#.set_texture_off(#)".} ## \
## Sets the geometry at this level and below to render using no texture, on
## the indicated stage.  This is different from not specifying a texture;
## rather, this specifically contradicts set_texture() at a higher node level
## (or, with a priority, overrides a set_texture() at a lower level).

proc setTextureOff*(this: NodePathCollection, priority: int) {.importcpp: "#.set_texture_off(#)".} ## \
## Sets the geometry at this level and below to render using no texture, on
## any stage.  This is different from not specifying a texture; rather, this
## specifically contradicts set_texture() at a higher node level (or, with a
## priority, overrides a set_texture() at a lower level).

proc setTextureOff*(this: NodePathCollection) {.importcpp: "#.set_texture_off()".} ## \
## Sets the geometry at this level and below to render using no texture, on
## any stage.  This is different from not specifying a texture; rather, this
## specifically contradicts set_texture() at a higher node level (or, with a
## priority, overrides a set_texture() at a lower level).

proc setColor*(this: NodePathCollection, color: LColor, priority: int) {.importcpp: "#.set_color(#, #)".} ## \
## Colors all NodePaths in the collection

proc setColor*(this: NodePathCollection, color: LColor) {.importcpp: "#.set_color(#)".} ## \
## Colors all NodePaths in the collection

proc setColor*(this: NodePathCollection, r: float32, g: float32, b: float32, a: float32, priority: int) {.importcpp: "#.set_color(#, #, #, #, #)".} ## \
## Colors all NodePaths in the collection

proc setColor*(this: NodePathCollection, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_color(#, #, #, #)".} ## \
## Colors all NodePaths in the collection

proc setColor*(this: NodePathCollection, r: float32, g: float32, b: float32) {.importcpp: "#.set_color(#, #, #)".} ## \
## Colors all NodePaths in the collection

proc setColorScale*(this: NodePathCollection, scale: LVecBase4, priority: int) {.importcpp: "#.set_color_scale(#, #)".} ## \
## Applies color scales to all NodePaths in the collection.  The existing
## color scale is replaced.

proc setColorScale*(this: NodePathCollection, scale: LVecBase4) {.importcpp: "#.set_color_scale(#)".} ## \
## Applies color scales to all NodePaths in the collection.  The existing
## color scale is replaced.

proc setColorScale*(this: NodePathCollection, r: float32, g: float32, b: float32, a: float32, priority: int) {.importcpp: "#.set_color_scale(#, #, #, #, #)".} ## \
## Applies color scales to all NodePaths in the collection.  The existing
## color scale is replaced.

proc setColorScale*(this: NodePathCollection, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_color_scale(#, #, #, #)".} ## \
## Applies color scales to all NodePaths in the collection.  The existing
## color scale is replaced.

proc setColorScale*(this: NodePathCollection, r: float32, g: float32, b: float32) {.importcpp: "#.set_color_scale(#, #, #)".} ## \
## Applies color scales to all NodePaths in the collection.  The existing
## color scale is replaced.

proc composeColorScale*(this: NodePathCollection, scale: LVecBase4, priority: int) {.importcpp: "#.compose_color_scale(#, #)".} ## \
## Applies color scales to all NodePaths in the collection.  The existing
## color scale, if any, is multiplied by the specified color scale.

proc composeColorScale*(this: NodePathCollection, scale: LVecBase4) {.importcpp: "#.compose_color_scale(#)".} ## \
## Applies color scales to all NodePaths in the collection.  The existing
## color scale, if any, is multiplied by the specified color scale.

proc composeColorScale*(this: NodePathCollection, r: float32, g: float32, b: float32, a: float32, priority: int) {.importcpp: "#.compose_color_scale(#, #, #, #, #)".} ## \
## Applies color scales to all NodePaths in the collection.  The existing
## color scale, if any, is multiplied by the specified color scale.

proc composeColorScale*(this: NodePathCollection, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.compose_color_scale(#, #, #, #)".} ## \
## Applies color scales to all NodePaths in the collection.  The existing
## color scale, if any, is multiplied by the specified color scale.

proc composeColorScale*(this: NodePathCollection, r: float32, g: float32, b: float32) {.importcpp: "#.compose_color_scale(#, #, #)".} ## \
## Applies color scales to all NodePaths in the collection.  The existing
## color scale, if any, is multiplied by the specified color scale.

proc setAttrib*(this: NodePathCollection, attrib: RenderAttrib, priority: int) {.importcpp: "#.set_attrib(#, #)".} ## \
## Applies the indicated RenderAttrib to all NodePaths in the collection.  An
## effort is made to apply the attrib to many NodePaths as quickly as
## possible; redundant RenderState compositions are not duplicated.

proc setAttrib*(this: NodePathCollection, attrib: RenderAttrib) {.importcpp: "#.set_attrib(#)".} ## \
## Applies the indicated RenderAttrib to all NodePaths in the collection.  An
## effort is made to apply the attrib to many NodePaths as quickly as
## possible; redundant RenderState compositions are not duplicated.

proc output*(this: NodePathCollection, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Writes a brief one-line description of the NodePathCollection to the
## indicated output stream.

proc write*(this: NodePathCollection, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Writes a complete multi-line description of the NodePathCollection to the
## indicated output stream.

proc write*(this: NodePathCollection, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes a complete multi-line description of the NodePathCollection to the
## indicated output stream.

proc countNumDescendants*(this: NodePath): int {.importcpp: "#.count_num_descendants()".} ## \
## Returns the number of nodes at and below this level.

proc hasParent*(this: NodePath, current_thread: Thread): bool {.importcpp: "#.has_parent(#)".} ## \
## Returns true if the referenced node has a parent; i.e.  the NodePath chain
## contains at least two nodes.

proc hasParent*(this: NodePath): bool {.importcpp: "#.has_parent()".} ## \
## Returns true if the referenced node has a parent; i.e.  the NodePath chain
## contains at least two nodes.

proc getParent*(this: NodePath, current_thread: Thread): NodePath {.importcpp: "#.get_parent(#)".} ## \
## Returns the NodePath to the parent of the referenced node: that is, this
## NodePath, shortened by one node.  The parent of a singleton NodePath is
## defined to be the empty NodePath.

proc getParent*(this: NodePath): NodePath {.importcpp: "#.get_parent()".} ## \
## Returns the NodePath to the parent of the referenced node: that is, this
## NodePath, shortened by one node.  The parent of a singleton NodePath is
## defined to be the empty NodePath.

proc getSort*(this: NodePath, current_thread: Thread): int {.importcpp: "#.get_sort(#)".} ## \
## Returns the sort value of the referenced node within its parent; that is,
## the sort number passed on the last reparenting operation for this node.
## This will control the position of the node within its parent's list of
## children.

proc getSort*(this: NodePath): int {.importcpp: "#.get_sort()".} ## \
## Returns the sort value of the referenced node within its parent; that is,
## the sort number passed on the last reparenting operation for this node.
## This will control the position of the node within its parent's list of
## children.

proc find*(this: NodePath, path: string): NodePath {.importcpp: "#.find(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Searches for a node below the referenced node that matches the indicated
## string.  Returns the shortest match found, if any, or an empty NodePath if
## no match can be found.
##
## The referenced node itself is not considered in the search.

proc findPathTo*(this: NodePath, node: PandaNode): NodePath {.importcpp: "#.find_path_to(#)".} ## \
## Searches for the indicated node below this node and returns the shortest
## NodePath that connects them.

proc findAllMatches*(this: NodePath, path: string): NodePathCollection {.importcpp: "#.find_all_matches(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the complete set of all NodePaths that begin with this NodePath and
## can be extended by path.  The shortest paths will be listed first.
##
## The referenced node itself is not considered in the search.

proc findAllPathsTo*(this: NodePath, node: PandaNode): NodePathCollection {.importcpp: "#.find_all_paths_to(#)".} ## \
## Returns the set of all NodePaths that extend from this NodePath down to the
## indicated node.  The shortest paths will be listed first.

proc reparentTo*(this: NodePath, other: NodePath, sort: int, current_thread: Thread) {.importcpp: "#.reparent_to(#, #, #)".} ## \
## Removes the referenced node of the NodePath from its current parent and
## attaches it to the referenced node of the indicated NodePath.
##
## If the destination NodePath is empty, this is the same thing as
## detach_node().
##
## If the referenced node is already a child of the indicated NodePath (via
## some other instance), this operation fails and leaves the NodePath
## detached.

proc reparentTo*(this: NodePath, other: NodePath, sort: int) {.importcpp: "#.reparent_to(#, #)".} ## \
## Removes the referenced node of the NodePath from its current parent and
## attaches it to the referenced node of the indicated NodePath.
##
## If the destination NodePath is empty, this is the same thing as
## detach_node().
##
## If the referenced node is already a child of the indicated NodePath (via
## some other instance), this operation fails and leaves the NodePath
## detached.

proc reparentTo*(this: NodePath, other: NodePath) {.importcpp: "#.reparent_to(#)".} ## \
## Removes the referenced node of the NodePath from its current parent and
## attaches it to the referenced node of the indicated NodePath.
##
## If the destination NodePath is empty, this is the same thing as
## detach_node().
##
## If the referenced node is already a child of the indicated NodePath (via
## some other instance), this operation fails and leaves the NodePath
## detached.

proc stashTo*(this: NodePath, other: NodePath, sort: int, current_thread: Thread) {.importcpp: "#.stash_to(#, #, #)".} ## \
## Similar to reparent_to(), but the node is added to its new parent's stashed
## list, so that the result is equivalent to calling reparent_to() immediately
## followed by stash().

proc stashTo*(this: NodePath, other: NodePath, sort: int) {.importcpp: "#.stash_to(#, #)".} ## \
## Similar to reparent_to(), but the node is added to its new parent's stashed
## list, so that the result is equivalent to calling reparent_to() immediately
## followed by stash().

proc stashTo*(this: NodePath, other: NodePath) {.importcpp: "#.stash_to(#)".} ## \
## Similar to reparent_to(), but the node is added to its new parent's stashed
## list, so that the result is equivalent to calling reparent_to() immediately
## followed by stash().

proc wrtReparentTo*(this: NodePath, other: NodePath, sort: int, current_thread: Thread) {.importcpp: "#.wrt_reparent_to(#, #, #)".} ## \
## This functions identically to reparent_to(), except the transform on this
## node is also adjusted so that the node remains in the same place in world
## coordinates, even if it is reparented into a different coordinate system.

proc wrtReparentTo*(this: NodePath, other: NodePath, sort: int) {.importcpp: "#.wrt_reparent_to(#, #)".} ## \
## This functions identically to reparent_to(), except the transform on this
## node is also adjusted so that the node remains in the same place in world
## coordinates, even if it is reparented into a different coordinate system.

proc wrtReparentTo*(this: NodePath, other: NodePath) {.importcpp: "#.wrt_reparent_to(#)".} ## \
## This functions identically to reparent_to(), except the transform on this
## node is also adjusted so that the node remains in the same place in world
## coordinates, even if it is reparented into a different coordinate system.

proc instanceTo*(this: NodePath, other: NodePath, sort: int, current_thread: Thread): NodePath {.importcpp: "#.instance_to(#, #, #)".} ## \
## Adds the referenced node of the NodePath as a child of the referenced node
## of the indicated other NodePath.  Any other parent-child relations of the
## node are unchanged; in particular, the node is not removed from its
## existing parent, if any.
##
## If the node already had an existing parent, this method will create a new
## instance of the node within the scene graph.
##
## This does not change the NodePath itself, but does return a new NodePath
## that reflects the new instance node.
##
## If the destination NodePath is empty, this creates a new instance which is
## not yet parented to any node.  A new instance of this sort cannot easily be
## differentiated from other similar instances, but it is nevertheless a
## different instance and it will return a different get_id() value.
##
## If the referenced node is already a child of the indicated NodePath,
## returns that already-existing instance, unstashing it first if necessary.

proc instanceTo*(this: NodePath, other: NodePath, sort: int): NodePath {.importcpp: "#.instance_to(#, #)".} ## \
## Adds the referenced node of the NodePath as a child of the referenced node
## of the indicated other NodePath.  Any other parent-child relations of the
## node are unchanged; in particular, the node is not removed from its
## existing parent, if any.
##
## If the node already had an existing parent, this method will create a new
## instance of the node within the scene graph.
##
## This does not change the NodePath itself, but does return a new NodePath
## that reflects the new instance node.
##
## If the destination NodePath is empty, this creates a new instance which is
## not yet parented to any node.  A new instance of this sort cannot easily be
## differentiated from other similar instances, but it is nevertheless a
## different instance and it will return a different get_id() value.
##
## If the referenced node is already a child of the indicated NodePath,
## returns that already-existing instance, unstashing it first if necessary.

proc instanceTo*(this: NodePath, other: NodePath): NodePath {.importcpp: "#.instance_to(#)".} ## \
## Adds the referenced node of the NodePath as a child of the referenced node
## of the indicated other NodePath.  Any other parent-child relations of the
## node are unchanged; in particular, the node is not removed from its
## existing parent, if any.
##
## If the node already had an existing parent, this method will create a new
## instance of the node within the scene graph.
##
## This does not change the NodePath itself, but does return a new NodePath
## that reflects the new instance node.
##
## If the destination NodePath is empty, this creates a new instance which is
## not yet parented to any node.  A new instance of this sort cannot easily be
## differentiated from other similar instances, but it is nevertheless a
## different instance and it will return a different get_id() value.
##
## If the referenced node is already a child of the indicated NodePath,
## returns that already-existing instance, unstashing it first if necessary.

proc instanceUnderNode*(this: NodePath, other: NodePath, name: string, sort: int, current_thread: Thread): NodePath {.importcpp: "#.instance_under_node(#, nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Behaves like instance_to(), but implicitly creates a new node to instance
## the geometry under, and returns a NodePath to that new node.  This allows
## the programmer to set a unique state and/or transform on this instance.

proc instanceUnderNode*(this: NodePath, other: NodePath, name: string, sort: int): NodePath {.importcpp: "#.instance_under_node(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Behaves like instance_to(), but implicitly creates a new node to instance
## the geometry under, and returns a NodePath to that new node.  This allows
## the programmer to set a unique state and/or transform on this instance.

proc instanceUnderNode*(this: NodePath, other: NodePath, name: string): NodePath {.importcpp: "#.instance_under_node(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Behaves like instance_to(), but implicitly creates a new node to instance
## the geometry under, and returns a NodePath to that new node.  This allows
## the programmer to set a unique state and/or transform on this instance.

proc copyTo*(this: NodePath, other: NodePath, sort: int, current_thread: Thread): NodePath {.importcpp: "#.copy_to(#, #, #)".} ## \
## Functions like instance_to(), except a deep copy is made of the referenced
## node and all of its descendents, which is then parented to the indicated
## node.  A NodePath to the newly created copy is returned.

proc copyTo*(this: NodePath, other: NodePath, sort: int): NodePath {.importcpp: "#.copy_to(#, #)".} ## \
## Functions like instance_to(), except a deep copy is made of the referenced
## node and all of its descendents, which is then parented to the indicated
## node.  A NodePath to the newly created copy is returned.

proc copyTo*(this: NodePath, other: NodePath): NodePath {.importcpp: "#.copy_to(#)".} ## \
## Functions like instance_to(), except a deep copy is made of the referenced
## node and all of its descendents, which is then parented to the indicated
## node.  A NodePath to the newly created copy is returned.

proc attachNewNode*(this: NodePath, node: PandaNode, sort: int, current_thread: Thread): NodePath {.importcpp: "#.attach_new_node(#, #, #)".} ## \
## Attaches a new node, with or without existing parents, to the scene graph
## below the referenced node of this NodePath.  This is the preferred way to
## add nodes to the graph.
##
## If the node was already a child of the parent, this returns a NodePath to
## the existing child.
##
## This does \*not\* automatically extend the current NodePath to reflect the
## attachment; however, a NodePath that does reflect this extension is
## returned.

proc attachNewNode*(this: NodePath, node: PandaNode, sort: int): NodePath {.importcpp: "#.attach_new_node(#, #)".} ## \
## Attaches a new node, with or without existing parents, to the scene graph
## below the referenced node of this NodePath.  This is the preferred way to
## add nodes to the graph.
##
## If the node was already a child of the parent, this returns a NodePath to
## the existing child.
##
## This does \*not\* automatically extend the current NodePath to reflect the
## attachment; however, a NodePath that does reflect this extension is
## returned.

proc attachNewNode*(this: NodePath, node: PandaNode): NodePath {.importcpp: "#.attach_new_node(#)".} ## \
## Attaches a new node, with or without existing parents, to the scene graph
## below the referenced node of this NodePath.  This is the preferred way to
## add nodes to the graph.
##
## If the node was already a child of the parent, this returns a NodePath to
## the existing child.
##
## This does \*not\* automatically extend the current NodePath to reflect the
## attachment; however, a NodePath that does reflect this extension is
## returned.

proc attachNewNode*(this: NodePath, name: string, sort: int, current_thread: Thread): NodePath {.importcpp: "#.attach_new_node(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Creates an ordinary PandaNode and attaches it below the current NodePath,
## returning a new NodePath that references it.

proc attachNewNode*(this: NodePath, name: string, sort: int): NodePath {.importcpp: "#.attach_new_node(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Creates an ordinary PandaNode and attaches it below the current NodePath,
## returning a new NodePath that references it.

proc attachNewNode*(this: NodePath, name: string): NodePath {.importcpp: "#.attach_new_node(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates an ordinary PandaNode and attaches it below the current NodePath,
## returning a new NodePath that references it.

proc removeNode*(this: NodePath, current_thread: Thread) {.importcpp: "#.remove_node(#)".} ## \
## Disconnects the referenced node from the scene graph.  This will also
## delete the node if there are no other pointers to it.
##
## Normally, this should be called only when you are really done with the
## node.  If you want to remove a node from the scene graph but keep it around
## for later, you should probably use detach_node() instead.
##
## In practice, the only difference between remove_node() and detach_node() is
## that remove_node() also resets the NodePath to empty, which will cause the
## node to be deleted immediately if there are no other references.  On the
## other hand, detach_node() leaves the NodePath referencing the node, which
## will keep at least one reference to the node for as long as the NodePath
## exists.

proc removeNode*(this: NodePath) {.importcpp: "#.remove_node()".} ## \
## Disconnects the referenced node from the scene graph.  This will also
## delete the node if there are no other pointers to it.
##
## Normally, this should be called only when you are really done with the
## node.  If you want to remove a node from the scene graph but keep it around
## for later, you should probably use detach_node() instead.
##
## In practice, the only difference between remove_node() and detach_node() is
## that remove_node() also resets the NodePath to empty, which will cause the
## node to be deleted immediately if there are no other references.  On the
## other hand, detach_node() leaves the NodePath referencing the node, which
## will keep at least one reference to the node for as long as the NodePath
## exists.

proc detachNode*(this: NodePath, current_thread: Thread) {.importcpp: "#.detach_node(#)".} ## \
## Disconnects the referenced node from its parent, but does not immediately
## delete it.  The NodePath retains a pointer to the node, and becomes a
## singleton NodePath.
##
## This should be called to detach a node from the scene graph, with the
## option of reattaching it later to the same parent or to a different parent.
##
## In practice, the only difference between remove_node() and detach_node() is
## that remove_node() also resets the NodePath to empty, which will cause the
## node to be deleted immediately if there are no other references.  On the
## other hand, detach_node() leaves the NodePath referencing the node, which
## will keep at least one reference to the node for as long as the NodePath
## exists.

proc detachNode*(this: NodePath) {.importcpp: "#.detach_node()".} ## \
## Disconnects the referenced node from its parent, but does not immediately
## delete it.  The NodePath retains a pointer to the node, and becomes a
## singleton NodePath.
##
## This should be called to detach a node from the scene graph, with the
## option of reattaching it later to the same parent or to a different parent.
##
## In practice, the only difference between remove_node() and detach_node() is
## that remove_node() also resets the NodePath to empty, which will cause the
## node to be deleted immediately if there are no other references.  On the
## other hand, detach_node() leaves the NodePath referencing the node, which
## will keep at least one reference to the node for as long as the NodePath
## exists.

proc output*(this: NodePath, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Writes a sensible description of the NodePath to the indicated output
## stream.

proc ls*(this: NodePath) {.importcpp: "#.ls()".} ## \
## Lists the hierarchy at and below the referenced node.

proc ls*(this: NodePath, `out`: ostream, indent_level: int) {.importcpp: "#.ls(#, #)".} ## \
## Lists the hierarchy at and below the referenced node.

proc ls*(this: NodePath, `out`: ostream) {.importcpp: "#.ls(#)".} ## \
## Lists the hierarchy at and below the referenced node.

proc reverseLs*(this: NodePath) {.importcpp: "#.reverse_ls()".} ## \
## Lists the hierarchy at and above the referenced node.

proc reverseLs*(this: NodePath, `out`: ostream, indent_level: int): int {.importcpp: "#.reverse_ls(#, #)".} ## \
## Lists the hierarchy at and above the referenced node.

proc reverseLs*(this: NodePath, `out`: ostream): int {.importcpp: "#.reverse_ls(#)".} ## \
## Lists the hierarchy at and above the referenced node.

proc getState*(this: NodePath, other: NodePath, current_thread: Thread): RenderState {.importcpp: "#.get_state(#, #)".} ## \
## Returns the state changes that must be made to transition to the render
## state of this node from the render state of the other node.

proc getState*(this: NodePath, other: NodePath): RenderState {.importcpp: "#.get_state(#)".} ## \
## Returns the state changes that must be made to transition to the render
## state of this node from the render state of the other node.

proc getState*(this: NodePath, current_thread: Thread): RenderState {.importcpp: "#.get_state(#)".} ## \
## Returns the complete state object set on this node.

proc getState*(this: NodePath): RenderState {.importcpp: "#.get_state()".} ## \
## Returns the complete state object set on this node.

proc setState*(this: NodePath, other: NodePath, state: RenderState, current_thread: Thread) {.importcpp: "#.set_state(#, #, #)".} ## \
## Sets the state object on this node, relative to the other node.  This
## computes a new state object that will have the indicated value when seen
## from the other node.

proc setState*(this: NodePath, other: NodePath, state: RenderState) {.importcpp: "#.set_state(#, #)".} ## \
## Sets the state object on this node, relative to the other node.  This
## computes a new state object that will have the indicated value when seen
## from the other node.

proc setState*(this: NodePath, state: RenderState, current_thread: Thread) {.importcpp: "#.set_state(#, #)".} ## \
## Changes the complete state object on this node.

proc setState*(this: NodePath, state: RenderState) {.importcpp: "#.set_state(#)".} ## \
## Changes the complete state object on this node.

proc getNetState*(this: NodePath, current_thread: Thread): RenderState {.importcpp: "#.get_net_state(#)".} ## \
## Returns the net state on this node from the root.

proc getNetState*(this: NodePath): RenderState {.importcpp: "#.get_net_state()".} ## \
## Returns the net state on this node from the root.

proc setAttrib*(this: NodePath, attrib: RenderAttrib, priority: int) {.importcpp: "#.set_attrib(#, #)".} ## \
## Adds the indicated render attribute to the scene graph on this node.  This
## attribute will now apply to this node and everything below.  If there was
## already an attribute of the same type, it is replaced.

proc setAttrib*(this: NodePath, attrib: RenderAttrib) {.importcpp: "#.set_attrib(#)".} ## \
## Adds the indicated render attribute to the scene graph on this node.  This
## attribute will now apply to this node and everything below.  If there was
## already an attribute of the same type, it is replaced.

proc getAttrib*(this: NodePath, `type`: TypeHandle): RenderAttrib {.importcpp: "#.get_attrib(#)".} ## \
## Returns the render attribute of the indicated type, if it is defined on the
## node, or NULL if it is not.  This checks only what is set on this
## particular node level, and has nothing to do with what render attributes
## may be inherited from parent nodes.

proc hasAttrib*(this: NodePath, `type`: TypeHandle): bool {.importcpp: "#.has_attrib(#)".} ## \
## Returns true if there is a render attribute of the indicated type defined
## on this node, or false if there is not.

proc clearAttrib*(this: NodePath, `type`: TypeHandle) {.importcpp: "#.clear_attrib(#)".} ## \
## Removes the render attribute of the given type from this node.  This node,
## and the subgraph below, will now inherit the indicated render attribute
## from the nodes above this one.

proc setEffect*(this: NodePath, effect: RenderEffect) {.importcpp: "#.set_effect(#)".} ## \
## Adds the indicated render effect to the scene graph on this node.  If there
## was already an effect of the same type, it is replaced.

proc getEffect*(this: NodePath, `type`: TypeHandle): RenderEffect {.importcpp: "#.get_effect(#)".} ## \
## Returns the render effect of the indicated type, if it is defined on the
## node, or NULL if it is not.

proc hasEffect*(this: NodePath, `type`: TypeHandle): bool {.importcpp: "#.has_effect(#)".} ## \
## Returns true if there is a render effect of the indicated type defined on
## this node, or false if there is not.

proc clearEffect*(this: NodePath, `type`: TypeHandle) {.importcpp: "#.clear_effect(#)".} ## \
## Removes the render effect of the given type from this node.

proc setEffects*(this: NodePath, effects: RenderEffects) {.importcpp: "#.set_effects(#)".} ## \
## Sets the complete RenderEffects that will be applied this node.  This
## completely replaces whatever has been set on this node via repeated calls
## to set_attrib().

proc getEffects*(this: NodePath): RenderEffects {.importcpp: "#.get_effects()".} ## \
## Returns the complete RenderEffects that will be applied to this node.

proc clearEffects*(this: NodePath) {.importcpp: "#.clear_effects()".} ## \
## Resets this node to have no render effects.

proc getTransform*(this: NodePath, other: NodePath, current_thread: Thread): TransformState {.importcpp: "#.get_transform(#, #)".} ## \
## Returns the relative transform to this node from the other node; i.e.  the
## transformation of this node as seen from the other node.

proc getTransform*(this: NodePath, other: NodePath): TransformState {.importcpp: "#.get_transform(#)".} ## \
## Returns the relative transform to this node from the other node; i.e.  the
## transformation of this node as seen from the other node.

proc getTransform*(this: NodePath, current_thread: Thread): TransformState {.importcpp: "#.get_transform(#)".} ## \
## Returns the complete transform object set on this node.

proc getTransform*(this: NodePath): TransformState {.importcpp: "#.get_transform()".} ## \
## Returns the complete transform object set on this node.

proc clearTransform*(this: NodePath, other: NodePath, current_thread: Thread) {.importcpp: "#.clear_transform(#, #)".} ## \
## Sets the transform object on this node to identity, relative to the other
## node.  This effectively places this node at the same position as the other
## node.

proc clearTransform*(this: NodePath, other: NodePath) {.importcpp: "#.clear_transform(#)".} ## \
## Sets the transform object on this node to identity, relative to the other
## node.  This effectively places this node at the same position as the other
## node.

proc clearTransform*(this: NodePath, current_thread: Thread) {.importcpp: "#.clear_transform(#)".} ## \
## Sets the transform object on this node to identity.

proc clearTransform*(this: NodePath) {.importcpp: "#.clear_transform()".} ## \
## Sets the transform object on this node to identity.

proc setTransform*(this: NodePath, other: NodePath, transform: TransformState, current_thread: Thread) {.importcpp: "#.set_transform(#, #, #)".} ## \
## Sets the transform object on this node, relative to the other node.  This
## computes a new transform object that will have the indicated value when
## seen from the other node.

proc setTransform*(this: NodePath, other: NodePath, transform: TransformState) {.importcpp: "#.set_transform(#, #)".} ## \
## Sets the transform object on this node, relative to the other node.  This
## computes a new transform object that will have the indicated value when
## seen from the other node.

proc setTransform*(this: NodePath, transform: TransformState, current_thread: Thread) {.importcpp: "#.set_transform(#, #)".} ## \
## Changes the complete transform object on this node.

proc setTransform*(this: NodePath, transform: TransformState) {.importcpp: "#.set_transform(#)".} ## \
## Changes the complete transform object on this node.

proc getNetTransform*(this: NodePath, current_thread: Thread): TransformState {.importcpp: "#.get_net_transform(#)".} ## \
## Returns the net transform on this node from the root.

proc getNetTransform*(this: NodePath): TransformState {.importcpp: "#.get_net_transform()".} ## \
## Returns the net transform on this node from the root.

proc getPrevTransform*(this: NodePath, other: NodePath, current_thread: Thread): TransformState {.importcpp: "#.get_prev_transform(#, #)".} ## \
## Returns the relative "previous" transform to this node from the other node;
## i.e.  the position of this node in the previous frame, as seen by the other
## node in the previous frame.

proc getPrevTransform*(this: NodePath, other: NodePath): TransformState {.importcpp: "#.get_prev_transform(#)".} ## \
## Returns the relative "previous" transform to this node from the other node;
## i.e.  the position of this node in the previous frame, as seen by the other
## node in the previous frame.

proc getPrevTransform*(this: NodePath, current_thread: Thread): TransformState {.importcpp: "#.get_prev_transform(#)".} ## \
## Returns the transform that has been set as this node's "previous" position.
## See set_prev_transform().

proc getPrevTransform*(this: NodePath): TransformState {.importcpp: "#.get_prev_transform()".} ## \
## Returns the transform that has been set as this node's "previous" position.
## See set_prev_transform().

proc setPrevTransform*(this: NodePath, other: NodePath, transform: TransformState, current_thread: Thread) {.importcpp: "#.set_prev_transform(#, #, #)".} ## \
## Sets the "previous" transform object on this node, relative to the other
## node.  This computes a new transform object that will have the indicated
## value when seen from the other node.

proc setPrevTransform*(this: NodePath, other: NodePath, transform: TransformState) {.importcpp: "#.set_prev_transform(#, #)".} ## \
## Sets the "previous" transform object on this node, relative to the other
## node.  This computes a new transform object that will have the indicated
## value when seen from the other node.

proc setPrevTransform*(this: NodePath, transform: TransformState, current_thread: Thread) {.importcpp: "#.set_prev_transform(#, #)".} ## \
## Sets the transform that represents this node's "previous" position, one
## frame ago, for the purposes of detecting motion for accurate collision
## calculations.

proc setPrevTransform*(this: NodePath, transform: TransformState) {.importcpp: "#.set_prev_transform(#)".} ## \
## Sets the transform that represents this node's "previous" position, one
## frame ago, for the purposes of detecting motion for accurate collision
## calculations.

proc getNetPrevTransform*(this: NodePath, current_thread: Thread): TransformState {.importcpp: "#.get_net_prev_transform(#)".} ## \
## Returns the net "previous" transform on this node from the root.  See
## set_prev_transform().

proc getNetPrevTransform*(this: NodePath): TransformState {.importcpp: "#.get_net_prev_transform()".} ## \
## Returns the net "previous" transform on this node from the root.  See
## set_prev_transform().

proc setPos*(this: NodePath, pos: LVecBase3) {.importcpp: "#.set_pos(#)".} ## \
## Sets the translation component of the transform, leaving rotation and scale
## untouched.  This also resets the node's "previous" position, so that the
## collision system will see the node as having suddenly appeared in the new
## position, without passing any points in between.  See Also:
## NodePath::set_fluid_pos

proc setPos*(this: NodePath, other: NodePath, pos: LVecBase3) {.importcpp: "#.set_pos(#, #)".} ## \
## Sets the translation component of the transform, relative to the other
## node.

proc setPos*(this: NodePath, other: NodePath, x: float32, y: float32, z: float32) {.importcpp: "#.set_pos(#, #, #, #)".} ## \
## Sets the translation component of the transform, relative to the other
## node.

proc setPos*(this: NodePath, x: float32, y: float32, z: float32) {.importcpp: "#.set_pos(#, #, #)".} ## \
## Sets the translation component of the transform, leaving rotation and scale
## untouched.  This also resets the node's "previous" position, so that the
## collision system will see the node as having suddenly appeared in the new
## position, without passing any points in between.

proc setX*(this: NodePath, other: NodePath, x: float32) {.importcpp: "#.set_x(#, #)".}

proc setX*(this: NodePath, x: float32) {.importcpp: "#.set_x(#)".} ## \
## Sets the X component of the position transform, leaving other components
## untouched.
## @see set_pos()

proc setY*(this: NodePath, other: NodePath, y: float32) {.importcpp: "#.set_y(#, #)".}

proc setY*(this: NodePath, y: float32) {.importcpp: "#.set_y(#)".} ## \
## Sets the Y component of the position transform, leaving other components
## untouched.
## @see set_pos()

proc setZ*(this: NodePath, other: NodePath, z: float32) {.importcpp: "#.set_z(#, #)".}

proc setZ*(this: NodePath, z: float32) {.importcpp: "#.set_z(#)".} ## \
## Sets the Z component of the position transform, leaving other components
## untouched.
## @see set_pos()

proc setFluidPos*(this: NodePath, pos: LVecBase3) {.importcpp: "#.set_fluid_pos(#)".} ## \
## Sets the translation component, without changing the "previous" position,
## so that the collision system will see the node as moving fluidly from its
## previous position to its new position.  See Also: NodePath::set_pos

proc setFluidPos*(this: NodePath, other: NodePath, pos: LVecBase3) {.importcpp: "#.set_fluid_pos(#, #)".} ## \
## Sets the translation component of the transform, relative to the other
## node.

proc setFluidPos*(this: NodePath, other: NodePath, x: float32, y: float32, z: float32) {.importcpp: "#.set_fluid_pos(#, #, #, #)".} ## \
## Sets the translation component, without changing the "previous" position,
## so that the collision system will see the node as moving fluidly from its
## previous position to its new position.

proc setFluidPos*(this: NodePath, x: float32, y: float32, z: float32) {.importcpp: "#.set_fluid_pos(#, #, #)".} ## \
## Sets the translation component, without changing the "previous" position,
## so that the collision system will see the node as moving fluidly from its
## previous position to its new position.

proc setFluidX*(this: NodePath, other: NodePath, x: float32) {.importcpp: "#.set_fluid_x(#, #)".}

proc setFluidX*(this: NodePath, x: float32) {.importcpp: "#.set_fluid_x(#)".}

proc setFluidY*(this: NodePath, other: NodePath, y: float32) {.importcpp: "#.set_fluid_y(#, #)".}

proc setFluidY*(this: NodePath, y: float32) {.importcpp: "#.set_fluid_y(#)".}

proc setFluidZ*(this: NodePath, other: NodePath, z: float32) {.importcpp: "#.set_fluid_z(#, #)".}

proc setFluidZ*(this: NodePath, z: float32) {.importcpp: "#.set_fluid_z(#)".}

proc getPos*(this: NodePath): LPoint3 {.importcpp: "#.get_pos()".} ## \
## Retrieves the translation component of the transform.

proc getPos*(this: NodePath, other: NodePath): LPoint3 {.importcpp: "#.get_pos(#)".} ## \
## Returns the relative position of the referenced node as seen from the other
## node.

proc getX*(this: NodePath): float32 {.importcpp: "#.get_x()".}

proc getX*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_x(#)".}

proc getY*(this: NodePath): float32 {.importcpp: "#.get_y()".}

proc getY*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_y(#)".}

proc getZ*(this: NodePath): float32 {.importcpp: "#.get_z()".}

proc getZ*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_z(#)".}

proc getPosDelta*(this: NodePath): LVector3 {.importcpp: "#.get_pos_delta()".} ## \
## Returns the delta vector from this node's position in the previous frame
## (according to set_prev_transform(), typically set via the use of
## set_fluid_pos()) and its position in the current frame.  This is the vector
## used to determine collisions.  Generally, if the node was last repositioned
## via set_pos(), the delta will be zero; if it was adjusted via
## set_fluid_pos(), the delta will represent the change from the previous
## frame's position.

proc getPosDelta*(this: NodePath, other: NodePath): LVector3 {.importcpp: "#.get_pos_delta(#)".} ## \
## Returns the delta vector from this node's position in the previous frame
## (according to set_prev_transform(), typically set via the use of
## set_fluid_pos()) and its position in the current frame, as seen in the
## indicated node's coordinate space.  This is the vector used to determine
## collisions.  Generally, if the node was last repositioned via set_pos(),
## the delta will be zero; if it was adjusted via set_fluid_pos(), the delta
## will represent the change from the previous frame's position.

proc setHpr*(this: NodePath, hpr: LVecBase3) {.importcpp: "#.set_hpr(#)".} ## \
## Sets the rotation component of the transform, leaving translation and scale
## untouched.

proc setHpr*(this: NodePath, other: NodePath, hpr: LVecBase3) {.importcpp: "#.set_hpr(#, #)".} ## \
## Sets the rotation component of the transform, relative to the other node.

proc setHpr*(this: NodePath, other: NodePath, h: float32, p: float32, r: float32) {.importcpp: "#.set_hpr(#, #, #, #)".} ## \
## Sets the rotation component of the transform, relative to the other node.

proc setHpr*(this: NodePath, h: float32, p: float32, r: float32) {.importcpp: "#.set_hpr(#, #, #)".} ## \
## Sets the rotation component of the transform, leaving translation and scale
## untouched.

proc setH*(this: NodePath, other: NodePath, h: float32) {.importcpp: "#.set_h(#, #)".}

proc setH*(this: NodePath, h: float32) {.importcpp: "#.set_h(#)".}

proc setP*(this: NodePath, other: NodePath, p: float32) {.importcpp: "#.set_p(#, #)".}

proc setP*(this: NodePath, p: float32) {.importcpp: "#.set_p(#)".}

proc setR*(this: NodePath, other: NodePath, r: float32) {.importcpp: "#.set_r(#, #)".}

proc setR*(this: NodePath, r: float32) {.importcpp: "#.set_r(#)".}

proc getHpr*(this: NodePath): LVecBase3 {.importcpp: "#.get_hpr()".} ## \
## Retrieves the rotation component of the transform.

proc getHpr*(this: NodePath, other: NodePath): LVecBase3 {.importcpp: "#.get_hpr(#)".} ## \
## Returns the relative orientation of the bottom node as seen from the other
## node.

proc getH*(this: NodePath): float32 {.importcpp: "#.get_h()".}

proc getH*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_h(#)".}

proc getP*(this: NodePath): float32 {.importcpp: "#.get_p()".}

proc getP*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_p(#)".}

proc getR*(this: NodePath): float32 {.importcpp: "#.get_r()".}

proc getR*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_r(#)".}

proc setQuat*(this: NodePath, quat: LQuaternion) {.importcpp: "#.set_quat(#)".} ## \
## Sets the rotation component of the transform, leaving translation and scale
## untouched.

proc setQuat*(this: NodePath, other: NodePath, quat: LQuaternion) {.importcpp: "#.set_quat(#, #)".} ## \
## Sets the rotation component of the transform, relative to the other node.

proc getQuat*(this: NodePath): LQuaternion {.importcpp: "#.get_quat()".} ## \
## Retrieves the rotation component of the transform.

proc getQuat*(this: NodePath, other: NodePath): LQuaternion {.importcpp: "#.get_quat(#)".} ## \
## Returns the relative orientation of the bottom node as seen from the other
## node.

proc setScale*(this: NodePath, scale: LVecBase3) {.importcpp: "#.set_scale(#)".} ## \
## Sets the scale component of the transform, leaving translation and rotation
## untouched.

proc setScale*(this: NodePath, other: NodePath, scale: LVecBase3) {.importcpp: "#.set_scale(#, #)".} ## \
## Sets the scale component of the transform, relative to the other node.

proc setScale*(this: NodePath, other: NodePath, scale: float32) {.importcpp: "#.set_scale(#, #)".} ## \
## Sets the scale component of the transform, relative to the other node.

proc setScale*(this: NodePath, other: NodePath, sx: float32, sy: float32, sz: float32) {.importcpp: "#.set_scale(#, #, #, #)".} ## \
## Sets the scale component of the transform, relative to the other node.

proc setScale*(this: NodePath, scale: float32) {.importcpp: "#.set_scale(#)".} ## \
## Sets the scale component of the transform, leaving translation and rotation
## untouched.

proc setScale*(this: NodePath, sx: float32, sy: float32, sz: float32) {.importcpp: "#.set_scale(#, #, #)".}

proc setSx*(this: NodePath, other: NodePath, sx: float32) {.importcpp: "#.set_sx(#, #)".}

proc setSx*(this: NodePath, sx: float32) {.importcpp: "#.set_sx(#)".} ## \
## Sets the x-scale component of the transform, leaving other components
## untouched.
## @see set_scale()

proc setSy*(this: NodePath, other: NodePath, sy: float32) {.importcpp: "#.set_sy(#, #)".}

proc setSy*(this: NodePath, sy: float32) {.importcpp: "#.set_sy(#)".} ## \
## Sets the y-scale component of the transform, leaving other components
## untouched.
## @see set_scale()

proc setSz*(this: NodePath, other: NodePath, sz: float32) {.importcpp: "#.set_sz(#, #)".}

proc setSz*(this: NodePath, sz: float32) {.importcpp: "#.set_sz(#)".} ## \
## Sets the z-scale component of the transform, leaving other components
## untouched.
## @see set_scale()

proc getScale*(this: NodePath): LVecBase3 {.importcpp: "#.get_scale()".} ## \
## Retrieves the scale component of the transform.

proc getScale*(this: NodePath, other: NodePath): LVecBase3 {.importcpp: "#.get_scale(#)".} ## \
## Returns the relative scale of the bottom node as seen from the other node.

proc getSx*(this: NodePath): float32 {.importcpp: "#.get_sx()".}

proc getSx*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_sx(#)".} ## \
## Returns the relative scale of the referenced node as seen from the other
## node.

proc getSy*(this: NodePath): float32 {.importcpp: "#.get_sy()".}

proc getSy*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_sy(#)".}

proc getSz*(this: NodePath): float32 {.importcpp: "#.get_sz()".}

proc getSz*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_sz(#)".}

proc setShear*(this: NodePath, shear: LVecBase3) {.importcpp: "#.set_shear(#)".} ## \
## Sets the shear component of the transform, leaving translation and rotation
## untouched.

proc setShear*(this: NodePath, other: NodePath, shear: LVecBase3) {.importcpp: "#.set_shear(#, #)".} ## \
## Sets the shear component of the transform, relative to the other node.

proc setShear*(this: NodePath, other: NodePath, shxy: float32, shxz: float32, shyz: float32) {.importcpp: "#.set_shear(#, #, #, #)".} ## \
## Sets the shear component of the transform, relative to the other node.

proc setShear*(this: NodePath, shxy: float32, shxz: float32, shyz: float32) {.importcpp: "#.set_shear(#, #, #)".} ## \
## Sets the shear component of the transform, leaving translation, rotation,
## and scale untouched.

proc setShxy*(this: NodePath, other: NodePath, shxy: float32) {.importcpp: "#.set_shxy(#, #)".}

proc setShxy*(this: NodePath, shxy: float32) {.importcpp: "#.set_shxy(#)".}

proc setShxz*(this: NodePath, other: NodePath, shxz: float32) {.importcpp: "#.set_shxz(#, #)".}

proc setShxz*(this: NodePath, shxz: float32) {.importcpp: "#.set_shxz(#)".}

proc setShyz*(this: NodePath, other: NodePath, shyz: float32) {.importcpp: "#.set_shyz(#, #)".}

proc setShyz*(this: NodePath, shyz: float32) {.importcpp: "#.set_shyz(#)".}

proc getShear*(this: NodePath): LVecBase3 {.importcpp: "#.get_shear()".} ## \
## Retrieves the shear component of the transform.

proc getShear*(this: NodePath, other: NodePath): LVecBase3 {.importcpp: "#.get_shear(#)".} ## \
## Returns the relative shear of the bottom node as seen from the other node.

proc getShxy*(this: NodePath): float32 {.importcpp: "#.get_shxy()".}

proc getShxy*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_shxy(#)".} ## \
## Returns the relative shear of the referenced node as seen from the other
## node.

proc getShxz*(this: NodePath): float32 {.importcpp: "#.get_shxz()".}

proc getShxz*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_shxz(#)".}

proc getShyz*(this: NodePath): float32 {.importcpp: "#.get_shyz()".}

proc getShyz*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_shyz(#)".}

proc setPosHpr*(this: NodePath, pos: LVecBase3, hpr: LVecBase3) {.importcpp: "#.set_pos_hpr(#, #)".} ## \
## Sets the translation and rotation component of the transform, leaving scale
## untouched.

proc setPosHpr*(this: NodePath, other: NodePath, pos: LVecBase3, hpr: LVecBase3) {.importcpp: "#.set_pos_hpr(#, #, #)".} ## \
## Sets the translation and rotation component of the transform, relative to
## the other node.

proc setPosHpr*(this: NodePath, other: NodePath, x: float32, y: float32, z: float32, h: float32, p: float32, r: float32) {.importcpp: "#.set_pos_hpr(#, #, #, #, #, #, #)".} ## \
## Sets the translation and rotation component of the transform, relative to
## the other node.

proc setPosHpr*(this: NodePath, x: float32, y: float32, z: float32, h: float32, p: float32, r: float32) {.importcpp: "#.set_pos_hpr(#, #, #, #, #, #)".} ## \
## Sets the translation and rotation component of the transform, leaving scale
## untouched.

proc setPosQuat*(this: NodePath, pos: LVecBase3, quat: LQuaternion) {.importcpp: "#.set_pos_quat(#, #)".} ## \
## Sets the translation and rotation component of the transform, leaving scale
## untouched.

proc setPosQuat*(this: NodePath, other: NodePath, pos: LVecBase3, quat: LQuaternion) {.importcpp: "#.set_pos_quat(#, #, #)".} ## \
## Sets the translation and rotation component of the transform, relative to
## the other node.

proc setHprScale*(this: NodePath, hpr: LVecBase3, scale: LVecBase3) {.importcpp: "#.set_hpr_scale(#, #)".} ## \
## Sets the rotation and scale components of the transform, leaving
## translation untouched.

proc setHprScale*(this: NodePath, other: NodePath, hpr: LVecBase3, scale: LVecBase3) {.importcpp: "#.set_hpr_scale(#, #, #)".} ## \
## Sets the rotation and scale components of the transform, leaving
## translation untouched.  This, or set_pos_hpr_scale, is the preferred way to
## update a transform when both hpr and scale are to be changed.

proc setHprScale*(this: NodePath, other: NodePath, h: float32, p: float32, r: float32, sx: float32, sy: float32, sz: float32) {.importcpp: "#.set_hpr_scale(#, #, #, #, #, #, #)".} ## \
## Sets the rotation and scale components of the transform, leaving
## translation untouched.  This, or set_pos_hpr_scale, is the preferred way to
## update a transform when both hpr and scale are to be changed.

proc setHprScale*(this: NodePath, h: float32, p: float32, r: float32, sx: float32, sy: float32, sz: float32) {.importcpp: "#.set_hpr_scale(#, #, #, #, #, #)".} ## \
## Sets the rotation and scale components of the transform, leaving
## translation untouched.

proc setQuatScale*(this: NodePath, quat: LQuaternion, scale: LVecBase3) {.importcpp: "#.set_quat_scale(#, #)".} ## \
## Sets the rotation and scale components of the transform, leaving
## translation untouched.

proc setQuatScale*(this: NodePath, other: NodePath, quat: LQuaternion, scale: LVecBase3) {.importcpp: "#.set_quat_scale(#, #, #)".} ## \
## Sets the rotation and scale components of the transform, leaving
## translation untouched.  This, or set_pos_quat_scale, is the preferred way
## to update a transform when both quat and scale are to be changed.

proc setPosHprScale*(this: NodePath, pos: LVecBase3, hpr: LVecBase3, scale: LVecBase3) {.importcpp: "#.set_pos_hpr_scale(#, #, #)".} ## \
## Replaces the translation, rotation, and scale components, implicitly
## setting shear to 0.

proc setPosHprScale*(this: NodePath, other: NodePath, pos: LVecBase3, hpr: LVecBase3, scale: LVecBase3) {.importcpp: "#.set_pos_hpr_scale(#, #, #, #)".} ## \
## Completely replaces the transform with new translation, rotation, and scale
## components, relative to the other node, implicitly setting shear to 0.

proc setPosHprScale*(this: NodePath, other: NodePath, x: float32, y: float32, z: float32, h: float32, p: float32, r: float32, sx: float32, sy: float32, sz: float32) {.importcpp: "#.set_pos_hpr_scale(#, #, #, #, #, #, #, #, #, #)".} ## \
## Completely replaces the transform with new translation, rotation, and scale
## components, relative to the other node.

proc setPosHprScale*(this: NodePath, x: float32, y: float32, z: float32, h: float32, p: float32, r: float32, sx: float32, sy: float32, sz: float32) {.importcpp: "#.set_pos_hpr_scale(#, #, #, #, #, #, #, #, #)".} ## \
## Completely replaces the transform with new translation, rotation, and scale
## components.

proc setPosQuatScale*(this: NodePath, pos: LVecBase3, quat: LQuaternion, scale: LVecBase3) {.importcpp: "#.set_pos_quat_scale(#, #, #)".} ## \
## Replaces the translation, rotation, and scale components, implicitly
## setting shear to 0.

proc setPosQuatScale*(this: NodePath, other: NodePath, pos: LVecBase3, quat: LQuaternion, scale: LVecBase3) {.importcpp: "#.set_pos_quat_scale(#, #, #, #)".} ## \
## Completely replaces the transform with new translation, rotation, and scale
## components, relative to the other node, implicitly setting shear to 0.

proc setPosHprScaleShear*(this: NodePath, pos: LVecBase3, hpr: LVecBase3, scale: LVecBase3, shear: LVecBase3) {.importcpp: "#.set_pos_hpr_scale_shear(#, #, #, #)".} ## \
## Completely replaces the transform with new translation, rotation, scale,
## and shear components.

proc setPosHprScaleShear*(this: NodePath, other: NodePath, pos: LVecBase3, hpr: LVecBase3, scale: LVecBase3, shear: LVecBase3) {.importcpp: "#.set_pos_hpr_scale_shear(#, #, #, #, #)".} ## \
## Completely replaces the transform with new translation, rotation, scale,
## and shear components, relative to the other node.

proc setPosQuatScaleShear*(this: NodePath, pos: LVecBase3, quat: LQuaternion, scale: LVecBase3, shear: LVecBase3) {.importcpp: "#.set_pos_quat_scale_shear(#, #, #, #)".} ## \
## Completely replaces the transform with new translation, rotation, scale,
## and shear components.

proc setPosQuatScaleShear*(this: NodePath, other: NodePath, pos: LVecBase3, quat: LQuaternion, scale: LVecBase3, shear: LVecBase3) {.importcpp: "#.set_pos_quat_scale_shear(#, #, #, #, #)".} ## \
## Completely replaces the transform with new translation, rotation, scale,
## and shear components, relative to the other node.

proc setMat*(this: NodePath, mat: LMatrix4) {.importcpp: "#.set_mat(#)".} ## \
## Directly sets an arbitrary 4x4 transform matrix.

proc setMat*(this: NodePath, other: NodePath, mat: LMatrix4) {.importcpp: "#.set_mat(#, #)".} ## \
## Converts the indicated matrix from the other's coordinate space to the
## local coordinate space, and applies it to the node.

proc clearMat*(this: NodePath) {.importcpp: "#.clear_mat()".} ## \
## Completely removes any transform from the referenced node.

proc hasMat*(this: NodePath): bool {.importcpp: "#.has_mat()".} ## \
## Returns true if a non-identity transform matrix has been applied to the
## referenced node, false otherwise.

proc getMat*(this: NodePath): LMatrix4 {.importcpp: "#.get_mat()".} ## \
## Returns the transform matrix that has been applied to the referenced node,
## or the identity matrix if no matrix has been applied.

proc getMat*(this: NodePath, other: NodePath): LMatrix4 {.importcpp: "#.get_mat(#)".} ## \
## Returns the matrix that describes the coordinate space of the bottom node,
## relative to the other path's bottom node's coordinate space.

proc lookAt*(this: NodePath, point: LPoint3, up: LVector3) {.importcpp: "#.look_at(#, #)".} ## \
## Sets the hpr on this NodePath so that it rotates to face the indicated
## point in space.

proc lookAt*(this: NodePath, point: LPoint3) {.importcpp: "#.look_at(#)".} ## \
## Sets the hpr on this NodePath so that it rotates to face the indicated
## point in space.

proc lookAt*(this: NodePath, other: NodePath, point: LPoint3, up: LVector3) {.importcpp: "#.look_at(#, #, #)".} ## \
## Sets the transform on this NodePath so that it rotates to face the
## indicated point in space, which is relative to the other NodePath.

proc lookAt*(this: NodePath, other: NodePath, point: LPoint3) {.importcpp: "#.look_at(#, #)".} ## \
## Sets the transform on this NodePath so that it rotates to face the
## indicated point in space, which is relative to the other NodePath.

proc lookAt*(this: NodePath, other: NodePath) {.importcpp: "#.look_at(#)".} ## \
## Sets the transform on this NodePath so that it rotates to face the
## indicated point in space, which is relative to the other NodePath.

proc lookAt*(this: NodePath, other: NodePath, x: float32, y: float32, z: float32) {.importcpp: "#.look_at(#, #, #, #)".} ## \
## Sets the hpr on this NodePath so that it rotates to face the indicated
## point in space, which is relative to the other NodePath.

proc lookAt*(this: NodePath, x: float32, y: float32, z: float32) {.importcpp: "#.look_at(#, #, #)".} ## \
## Sets the transform on this NodePath so that it rotates to face the
## indicated point in space.  This will overwrite any previously existing
## scale on the node, although it will preserve any translation.

proc headsUp*(this: NodePath, point: LPoint3, up: LVector3) {.importcpp: "#.heads_up(#, #)".} ## \
## Behaves like look_at(), but with a strong preference to keeping the up
## vector oriented in the indicated "up" direction.

proc headsUp*(this: NodePath, point: LPoint3) {.importcpp: "#.heads_up(#)".} ## \
## Behaves like look_at(), but with a strong preference to keeping the up
## vector oriented in the indicated "up" direction.

proc headsUp*(this: NodePath, other: NodePath, point: LPoint3, up: LVector3) {.importcpp: "#.heads_up(#, #, #)".} ## \
## Behaves like look_at(), but with a strong preference to keeping the up
## vector oriented in the indicated "up" direction.

proc headsUp*(this: NodePath, other: NodePath, point: LPoint3) {.importcpp: "#.heads_up(#, #)".} ## \
## Behaves like look_at(), but with a strong preference to keeping the up
## vector oriented in the indicated "up" direction.

proc headsUp*(this: NodePath, other: NodePath) {.importcpp: "#.heads_up(#)".} ## \
## Behaves like look_at(), but with a strong preference to keeping the up
## vector oriented in the indicated "up" direction.

proc headsUp*(this: NodePath, other: NodePath, x: float32, y: float32, z: float32) {.importcpp: "#.heads_up(#, #, #, #)".} ## \
## Behaves like look_at(), but with a strong preference to keeping the up
## vector oriented in the indicated "up" direction.

proc headsUp*(this: NodePath, x: float32, y: float32, z: float32) {.importcpp: "#.heads_up(#, #, #)".} ## \
## Behaves like look_at(), but with a strong preference to keeping the up
## vector oriented in the indicated "up" direction.

proc getRelativePoint*(this: NodePath, other: NodePath, point: LVecBase3): LPoint3 {.importcpp: "#.get_relative_point(#, #)".} ## \
## Given that the indicated point is in the coordinate system of the other
## node, returns the same point in this node's coordinate system.

proc getRelativeVector*(this: NodePath, other: NodePath, vec: LVecBase3): LVector3 {.importcpp: "#.get_relative_vector(#, #)".} ## \
## Given that the indicated vector is in the coordinate system of the other
## node, returns the same vector in this node's coordinate system.

proc getDistance*(this: NodePath, other: NodePath): float32 {.importcpp: "#.get_distance(#)".} ## \
## Returns the straight-line distance between this referenced node's
## coordinate frame's origin, and that of the other node's origin.

proc setColor*(this: NodePath, color: LColor, priority: int) {.importcpp: "#.set_color(#, #)".} ## \
## Applies a scene-graph color to the referenced node.  This color will apply
## to all geometry at this level and below (that does not specify a new color
## or a set_color_off()).

proc setColor*(this: NodePath, color: LColor) {.importcpp: "#.set_color(#)".} ## \
## Applies a scene-graph color to the referenced node.  This color will apply
## to all geometry at this level and below (that does not specify a new color
## or a set_color_off()).

proc setColor*(this: NodePath, r: float32, g: float32, b: float32, a: float32, priority: int) {.importcpp: "#.set_color(#, #, #, #, #)".} ## \
## Applies a scene-graph color to the referenced node.  This color will apply
## to all geometry at this level and below (that does not specify a new color
## or a set_color_off()).

proc setColor*(this: NodePath, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_color(#, #, #, #)".} ## \
## Applies a scene-graph color to the referenced node.  This color will apply
## to all geometry at this level and below (that does not specify a new color
## or a set_color_off()).

proc setColor*(this: NodePath, r: float32, g: float32, b: float32) {.importcpp: "#.set_color(#, #, #)".} ## \
## Applies a scene-graph color to the referenced node.  This color will apply
## to all geometry at this level and below (that does not specify a new color
## or a set_color_off()).

proc setColorOff*(this: NodePath, priority: int) {.importcpp: "#.set_color_off(#)".} ## \
## Sets the geometry at this level and below to render using the geometry
## color.  This is normally the default, but it may be useful to use this to
## contradict set_color() at a higher node level (or, with a priority, to
## override a set_color() at a lower level).

proc setColorOff*(this: NodePath) {.importcpp: "#.set_color_off()".} ## \
## Sets the geometry at this level and below to render using the geometry
## color.  This is normally the default, but it may be useful to use this to
## contradict set_color() at a higher node level (or, with a priority, to
## override a set_color() at a lower level).

proc clearColor*(this: NodePath) {.importcpp: "#.clear_color()".} ## \
## Completely removes any color adjustment from the node.  This allows the
## natural color of the geometry, or whatever color transitions might be
## otherwise affecting the geometry, to show instead.

proc hasColor*(this: NodePath): bool {.importcpp: "#.has_color()".} ## \
## Returns true if a color has been applied to the given node, false
## otherwise.

proc getColor*(this: NodePath): LColor {.importcpp: "#.get_color()".} ## \
## Returns the color that has been assigned to the node, or black if no color
## has been assigned.

proc hasColorScale*(this: NodePath): bool {.importcpp: "#.has_color_scale()".} ## \
## Returns true if a color scale has been applied to the referenced node,
## false otherwise.  It is still possible that color at this node might have
## been scaled by an ancestor node.

proc clearColorScale*(this: NodePath) {.importcpp: "#.clear_color_scale()".} ## \
## Completely removes any color scale from the referenced node.  This is
## preferable to simply setting the color scale to identity, as it also
## removes the overhead associated with having a color scale at all.

proc setColorScale*(this: NodePath, scale: LVecBase4, priority: int) {.importcpp: "#.set_color_scale(#, #)".} ## \
## Sets the color scale component of the transform, leaving translation and
## rotation untouched.

proc setColorScale*(this: NodePath, scale: LVecBase4) {.importcpp: "#.set_color_scale(#)".} ## \
## Sets the color scale component of the transform, leaving translation and
## rotation untouched.

proc setColorScale*(this: NodePath, sx: float32, sy: float32, sz: float32, sa: float32, priority: int) {.importcpp: "#.set_color_scale(#, #, #, #, #)".} ## \
## Sets the color scale component of the transform

proc setColorScale*(this: NodePath, sx: float32, sy: float32, sz: float32, sa: float32) {.importcpp: "#.set_color_scale(#, #, #, #)".} ## \
## Sets the color scale component of the transform

proc composeColorScale*(this: NodePath, scale: LVecBase4, priority: int) {.importcpp: "#.compose_color_scale(#, #)".} ## \
## multiplies the color scale component of the transform, with previous color
## scale leaving translation and rotation untouched.

proc composeColorScale*(this: NodePath, scale: LVecBase4) {.importcpp: "#.compose_color_scale(#)".} ## \
## multiplies the color scale component of the transform, with previous color
## scale leaving translation and rotation untouched.

proc composeColorScale*(this: NodePath, sx: float32, sy: float32, sz: float32, sa: float32, priority: int) {.importcpp: "#.compose_color_scale(#, #, #, #, #)".} ## \
## Sets the color scale component of the transform

proc composeColorScale*(this: NodePath, sx: float32, sy: float32, sz: float32, sa: float32) {.importcpp: "#.compose_color_scale(#, #, #, #)".} ## \
## Sets the color scale component of the transform

proc setColorScaleOff*(this: NodePath, priority: int) {.importcpp: "#.set_color_scale_off(#)".} ## \
## Disables any color scale attribute inherited from above.  This is not the
## same thing as clear_color_scale(), which undoes any previous
## set_color_scale() operation on this node; rather, this actively disables
## any set_color_scale() that might be inherited from a parent node.  This
## also disables set_alpha_scale() at the same time.
##
## It is legal to specify a new color scale on the same node with a subsequent
## call to set_color_scale() or set_alpha_scale(); this new scale will apply
## to lower geometry.

proc setColorScaleOff*(this: NodePath) {.importcpp: "#.set_color_scale_off()".} ## \
## Disables any color scale attribute inherited from above.  This is not the
## same thing as clear_color_scale(), which undoes any previous
## set_color_scale() operation on this node; rather, this actively disables
## any set_color_scale() that might be inherited from a parent node.  This
## also disables set_alpha_scale() at the same time.
##
## It is legal to specify a new color scale on the same node with a subsequent
## call to set_color_scale() or set_alpha_scale(); this new scale will apply
## to lower geometry.

proc setAlphaScale*(this: NodePath, scale: float32, priority: int) {.importcpp: "#.set_alpha_scale(#, #)".} ## \
## Sets the alpha scale component of the transform without (much) affecting
## the color scale.  Note that any priority specified will also apply to the
## color scale.

proc setAlphaScale*(this: NodePath, scale: float32) {.importcpp: "#.set_alpha_scale(#)".} ## \
## Sets the alpha scale component of the transform without (much) affecting
## the color scale.  Note that any priority specified will also apply to the
## color scale.

proc setAllColorScale*(this: NodePath, scale: float32, priority: int) {.importcpp: "#.set_all_color_scale(#, #)".} ## \
## Scales all the color components of the object by the same amount, darkening
## the object, without (much) affecting alpha.  Note that any priority
## specified will also apply to the alpha scale.

proc setAllColorScale*(this: NodePath, scale: float32) {.importcpp: "#.set_all_color_scale(#)".} ## \
## Scales all the color components of the object by the same amount, darkening
## the object, without (much) affecting alpha.  Note that any priority
## specified will also apply to the alpha scale.

proc setSr*(this: NodePath, sr: float32) {.importcpp: "#.set_sr(#)".} ## \
## Sets the red component of the color scale.
## @see set_color_scale()

proc setSg*(this: NodePath, sg: float32) {.importcpp: "#.set_sg(#)".} ## \
## Sets the green component of the color scale.
## @see set_color_scale()

proc setSb*(this: NodePath, sb: float32) {.importcpp: "#.set_sb(#)".} ## \
## Sets the blue component of the color scale.
## @see set_color_scale()

proc setSa*(this: NodePath, sa: float32) {.importcpp: "#.set_sa(#)".} ## \
## Sets the alpha component of the color scale.
## @see set_color_scale()

proc getColorScale*(this: NodePath): LVecBase4 {.importcpp: "#.get_color_scale()".} ## \
## Returns the complete color scale vector that has been applied to this node
## via a previous call to set_color_scale() and/or set_alpha_scale(), or all
## 1's (identity) if no scale has been applied to this particular node.

proc getSr*(this: NodePath): float32 {.importcpp: "#.get_sr()".} ## \
## Gets the red component of the color scale.
## @see get_color_scale()

proc getSg*(this: NodePath): float32 {.importcpp: "#.get_sg()".} ## \
## Gets the green component of the color scale.
## @see get_color_scale()

proc getSb*(this: NodePath): float32 {.importcpp: "#.get_sb()".} ## \
## Gets the blue component of the color scale.
## @see get_color_scale()

proc getSa*(this: NodePath): float32 {.importcpp: "#.get_sa()".} ## \
## Gets the alpha component of the color scale.
## @see get_color_scale()

proc setLight*(this: NodePath, light: NodePath, priority: int) {.importcpp: "#.set_light(#, #)".} ## \
## Adds the indicated Light or PolylightNode to the list of lights that
## illuminate geometry at this node and below.  The light itself should be
## parented into the scene graph elsewhere, to represent the light's position
## in space; but until set_light() is called it will illuminate no geometry.

proc setLight*(this: NodePath, light: NodePath) {.importcpp: "#.set_light(#)".} ## \
## Adds the indicated Light or PolylightNode to the list of lights that
## illuminate geometry at this node and below.  The light itself should be
## parented into the scene graph elsewhere, to represent the light's position
## in space; but until set_light() is called it will illuminate no geometry.

proc setLightOff*(this: NodePath, light: NodePath, priority: int) {.importcpp: "#.set_light_off(#, #)".} ## \
## Sets the geometry at this level and below to render without using the
## indicated Light.  This is different from not specifying the Light; rather,
## this specifically contradicts set_light() at a higher node level (or, with
## a priority, overrides a set_light() at a lower level).
##
## This interface does not support PolylightNodes, which cannot be turned off
## at a lower level.

proc setLightOff*(this: NodePath, light: NodePath) {.importcpp: "#.set_light_off(#)".} ## \
## Sets the geometry at this level and below to render without using the
## indicated Light.  This is different from not specifying the Light; rather,
## this specifically contradicts set_light() at a higher node level (or, with
## a priority, overrides a set_light() at a lower level).
##
## This interface does not support PolylightNodes, which cannot be turned off
## at a lower level.

proc setLightOff*(this: NodePath, priority: int) {.importcpp: "#.set_light_off(#)".} ## \
## Sets the geometry at this level and below to render using no lights at all.
## This is different from not specifying a light; rather, this specifically
## contradicts set_light() at a higher node level (or, with a priority,
## overrides a set_light() at a lower level).
##
## If no lights are in effect on a particular piece of geometry, that geometry
## is rendered with lighting disabled.

proc setLightOff*(this: NodePath) {.importcpp: "#.set_light_off()".} ## \
## Sets the geometry at this level and below to render using no lights at all.
## This is different from not specifying a light; rather, this specifically
## contradicts set_light() at a higher node level (or, with a priority,
## overrides a set_light() at a lower level).
##
## If no lights are in effect on a particular piece of geometry, that geometry
## is rendered with lighting disabled.

proc clearLight*(this: NodePath) {.importcpp: "#.clear_light()".} ## \
## Completely removes any lighting operations that may have been set via
## set_light() or set_light_off() from this particular node.

proc clearLight*(this: NodePath, light: NodePath) {.importcpp: "#.clear_light(#)".} ## \
## Removes any reference to the indicated Light or PolylightNode from the
## NodePath.

proc hasLight*(this: NodePath, light: NodePath): bool {.importcpp: "#.has_light(#)".} ## \
## Returns true if the indicated Light or PolylightNode has been specifically
## enabled on this particular node.  This means that someone called
## set_light() on this node with the indicated light.

proc hasLightOff*(this: NodePath): bool {.importcpp: "#.has_light_off()".} ## \
## Returns true if all Lights have been specifically disabled on this
## particular node.  This means that someone called set_light_off() on this
## node with no parameters.

proc hasLightOff*(this: NodePath, light: NodePath): bool {.importcpp: "#.has_light_off(#)".} ## \
## Returns true if the indicated Light has been specifically disabled on this
## particular node.  This means that someone called set_light_off() on this
## node with the indicated light.
##
## This interface does not support PolylightNodes, which cannot be turned off
## at a lower level.

proc setClipPlane*(this: NodePath, clip_plane: NodePath, priority: int) {.importcpp: "#.set_clip_plane(#, #)".} ## \
## Adds the indicated clipping plane to the list of planes that apply to
## geometry at this node and below.  The clipping plane itself, a PlaneNode,
## should be parented into the scene graph elsewhere, to represent the plane's
## position in space; but until set_clip_plane() is called it will clip no
## geometry.

proc setClipPlane*(this: NodePath, clip_plane: NodePath) {.importcpp: "#.set_clip_plane(#)".} ## \
## Adds the indicated clipping plane to the list of planes that apply to
## geometry at this node and below.  The clipping plane itself, a PlaneNode,
## should be parented into the scene graph elsewhere, to represent the plane's
## position in space; but until set_clip_plane() is called it will clip no
## geometry.

proc setClipPlaneOff*(this: NodePath, clip_plane: NodePath, priority: int) {.importcpp: "#.set_clip_plane_off(#, #)".} ## \
## Sets the geometry at this level and below to render without being clipped
## by the indicated PlaneNode.  This is different from not specifying the
## PlaneNode; rather, this specifically contradicts set_clip_plane() at a
## higher node level (or, with a priority, overrides a set_clip_plane() at a
## lower level).

proc setClipPlaneOff*(this: NodePath, clip_plane: NodePath) {.importcpp: "#.set_clip_plane_off(#)".} ## \
## Sets the geometry at this level and below to render without being clipped
## by the indicated PlaneNode.  This is different from not specifying the
## PlaneNode; rather, this specifically contradicts set_clip_plane() at a
## higher node level (or, with a priority, overrides a set_clip_plane() at a
## lower level).

proc setClipPlaneOff*(this: NodePath, priority: int) {.importcpp: "#.set_clip_plane_off(#)".} ## \
## Sets the geometry at this level and below to render using no clip_planes at
## all.  This is different from not specifying a clip_plane; rather, this
## specifically contradicts set_clip_plane() at a higher node level (or, with
## a priority, overrides a set_clip_plane() at a lower level).
##
## If no clip_planes are in effect on a particular piece of geometry, that
## geometry is rendered without being clipped (other than by the viewing
## frustum).

proc setClipPlaneOff*(this: NodePath) {.importcpp: "#.set_clip_plane_off()".} ## \
## Sets the geometry at this level and below to render using no clip_planes at
## all.  This is different from not specifying a clip_plane; rather, this
## specifically contradicts set_clip_plane() at a higher node level (or, with
## a priority, overrides a set_clip_plane() at a lower level).
##
## If no clip_planes are in effect on a particular piece of geometry, that
## geometry is rendered without being clipped (other than by the viewing
## frustum).

proc clearClipPlane*(this: NodePath) {.importcpp: "#.clear_clip_plane()".} ## \
## Completely removes any clip planes that may have been set via
## set_clip_plane() or set_clip_plane_off() from this particular node.

proc clearClipPlane*(this: NodePath, clip_plane: NodePath) {.importcpp: "#.clear_clip_plane(#)".} ## \
## Removes any reference to the indicated clipping plane from the NodePath.

proc hasClipPlane*(this: NodePath, clip_plane: NodePath): bool {.importcpp: "#.has_clip_plane(#)".} ## \
## Returns true if the indicated clipping plane has been specifically applied
## to this particular node.  This means that someone called set_clip_plane()
## on this node with the indicated clip_plane.

proc hasClipPlaneOff*(this: NodePath): bool {.importcpp: "#.has_clip_plane_off()".} ## \
## Returns true if all clipping planes have been specifically disabled on this
## particular node.  This means that someone called set_clip_plane_off() on
## this node with no parameters.

proc hasClipPlaneOff*(this: NodePath, clip_plane: NodePath): bool {.importcpp: "#.has_clip_plane_off(#)".} ## \
## Returns true if the indicated clipping plane has been specifically disabled
## on this particular node.  This means that someone called
## set_clip_plane_off() on this node with the indicated clip_plane.

proc setScissor*(this: NodePath, a: LPoint3, b: LPoint3) {.importcpp: "#.set_scissor(#, #)".} ## \
## Sets up a scissor region on the nodes rendered at this level and below.
## The two points are understood to be relative to this node.  When these
## points are projected into screen space, they define the diagonally-opposite
## points that determine the scissor region.

proc setScissor*(this: NodePath, a: LPoint3, b: LPoint3, c: LPoint3, d: LPoint3) {.importcpp: "#.set_scissor(#, #, #, #)".} ## \
## Sets up a scissor region on the nodes rendered at this level and below.
## The four points are understood to be relative to this node.  When these
## points are projected into screen space, they define the bounding volume of
## the scissor region (the scissor region is the smallest onscreen rectangle
## that encloses all four points).

proc setScissor*(this: NodePath, other: NodePath, a: LPoint3, b: LPoint3) {.importcpp: "#.set_scissor(#, #, #)".} ## \
## Sets up a scissor region on the nodes rendered at this level and below.
## The two points are understood to be relative to the indicated other node.
## When these points are projected into screen space, they define the
## diagonally-opposite points that determine the scissor region.

proc setScissor*(this: NodePath, other: NodePath, a: LPoint3, b: LPoint3, c: LPoint3, d: LPoint3) {.importcpp: "#.set_scissor(#, #, #, #, #)".} ## \
## Sets up a scissor region on the nodes rendered at this level and below.
## The four points are understood to be relative to the indicated other node.
## When these points are projected into screen space, they define the bounding
## volume of the scissor region (the scissor region is the smallest onscreen
## rectangle that encloses all four points).

proc setScissor*(this: NodePath, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#.set_scissor(#, #, #, #)".} ## \
## Sets up a scissor region on the nodes rendered at this level and below.
## The four coordinates are understood to define a rectangle in screen space.
## These numbers are relative to the current DisplayRegion, where (0,0) is the
## lower-left corner of the DisplayRegion, and (1,1) is the upper-right
## corner.

proc clearScissor*(this: NodePath) {.importcpp: "#.clear_scissor()".} ## \
## Removes the scissor region that was defined at this node level by a
## previous call to set_scissor().

proc hasScissor*(this: NodePath): bool {.importcpp: "#.has_scissor()".} ## \
## Returns true if a scissor region was defined at this node by a previous
## call to set_scissor().  This does not check for scissor regions inherited
## from a parent class.  It also does not check for the presence of a low-
## level ScissorAttrib, which is different from the ScissorEffect added by
## set_scissor.

proc setOccluder*(this: NodePath, occluder: NodePath) {.importcpp: "#.set_occluder(#)".} ## \
## Adds the indicated occluder to the list of occluders that apply to geometry
## at this node and below.  The occluder itself, an OccluderNode, should be
## parented into the scene graph elsewhere, to represent the occluder's
## position in space; but until set_occluder() is called it will clip no
## geometry.

proc clearOccluder*(this: NodePath) {.importcpp: "#.clear_occluder()".} ## \
## Completely removes any occluders that may have been set via set_occluder()
## from this particular node.

proc clearOccluder*(this: NodePath, occluder: NodePath) {.importcpp: "#.clear_occluder(#)".} ## \
## Removes any reference to the indicated occluder from the NodePath.

proc hasOccluder*(this: NodePath, occluder: NodePath): bool {.importcpp: "#.has_occluder(#)".} ## \
## Returns true if the indicated occluder has been specifically applied to
## this particular node.  This means that someone called set_occluder() on
## this node with the indicated occluder.

proc setBin*(this: NodePath, bin_name: string, draw_order: int, priority: int) {.importcpp: "#.set_bin(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Assigns the geometry at this level and below to the named rendering bin.
## It is the user's responsibility to ensure that such a bin already exists,
## either via the cull-bin Configrc variable, or by explicitly creating a
## GeomBin of the appropriate type at runtime.
##
## There are two default bins created when Panda is started: "default" and
## "fixed".  Normally, all geometry is assigned to "default" unless specified
## otherwise.  This bin renders opaque geometry in state-sorted order,
## followed by transparent geometry sorted back-to-front.  If any geometry is
## assigned to "fixed", this will be rendered following all the geometry in
## "default", in the order specified by draw_order for each piece of geometry
## so assigned.
##
## The draw_order parameter is meaningful only for GeomBinFixed type bins,
## e.g.  "fixed".  Other kinds of bins ignore it.

proc setBin*(this: NodePath, bin_name: string, draw_order: int) {.importcpp: "#.set_bin(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Assigns the geometry at this level and below to the named rendering bin.
## It is the user's responsibility to ensure that such a bin already exists,
## either via the cull-bin Configrc variable, or by explicitly creating a
## GeomBin of the appropriate type at runtime.
##
## There are two default bins created when Panda is started: "default" and
## "fixed".  Normally, all geometry is assigned to "default" unless specified
## otherwise.  This bin renders opaque geometry in state-sorted order,
## followed by transparent geometry sorted back-to-front.  If any geometry is
## assigned to "fixed", this will be rendered following all the geometry in
## "default", in the order specified by draw_order for each piece of geometry
## so assigned.
##
## The draw_order parameter is meaningful only for GeomBinFixed type bins,
## e.g.  "fixed".  Other kinds of bins ignore it.

proc clearBin*(this: NodePath) {.importcpp: "#.clear_bin()".} ## \
## Completely removes any bin adjustment that may have been set via set_bin()
## from this particular node.

proc hasBin*(this: NodePath): bool {.importcpp: "#.has_bin()".} ## \
## Returns true if the node has been assigned to the a particular rendering
## bin via set_bin(), false otherwise.

proc getBinName*(this: NodePath): string {.importcpp: "nimStringFromStdString(#.get_bin_name())", header: stringConversionCode.} ## \
## Returns the name of the bin that this particular node was assigned to via
## set_bin(), or the empty string if no bin was assigned.  See set_bin() and
## has_bin().

proc getBinDrawOrder*(this: NodePath): int {.importcpp: "#.get_bin_draw_order()".} ## \
## Returns the drawing order associated with the bin that this particular node
## was assigned to via set_bin(), or 0 if no bin was assigned.  See set_bin()
## and has_bin().

proc setTexture*(this: NodePath, tex: Texture, sampler: SamplerState, priority: int) {.importcpp: "#.set_texture(#, #, #)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the default texture stage.
##
## The given sampler state will override the sampling settings on the texture
## itself.  Note that this method makes a copy of the sampler settings that
## you give; further changes to this object will not be reflected.
##
## This is the convenience single-texture variant of this method; it is now
## superceded by set_texture() that accepts a stage and texture.  You may use
## this method if you just want to adjust the default stage.

proc setTexture*(this: NodePath, tex: Texture, sampler: SamplerState) {.importcpp: "#.set_texture(#, #)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the default texture stage.
##
## The given sampler state will override the sampling settings on the texture
## itself.  Note that this method makes a copy of the sampler settings that
## you give; further changes to this object will not be reflected.
##
## This is the convenience single-texture variant of this method; it is now
## superceded by set_texture() that accepts a stage and texture.  You may use
## this method if you just want to adjust the default stage.

proc setTexture*(this: NodePath, tex: Texture, priority: int) {.importcpp: "#.set_texture(#, #)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the default texture stage.
##
## This is the convenience single-texture variant of this method; it is now
## superceded by set_texture() that accepts a stage and texture.  You may use
## this method if you just want to adjust the default stage.

proc setTexture*(this: NodePath, tex: Texture) {.importcpp: "#.set_texture(#)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the default texture stage.
##
## This is the convenience single-texture variant of this method; it is now
## superceded by set_texture() that accepts a stage and texture.  You may use
## this method if you just want to adjust the default stage.

proc setTexture*(this: NodePath, stage: TextureStage, tex: Texture, sampler: SamplerState, priority: int) {.importcpp: "#.set_texture(#, #, #, #)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the indicated multitexture stage.  If there are multiple texture stages
## specified (possibly on multiple different nodes at different levels), they
## will all be applied to geometry together, according to the stage
## specification set up in the TextureStage object.
##
## The given sampler state will override the sampling settings on the texture
## itself.  Note that this method makes a copy of the sampler settings that
## you give; further changes to this object will not be reflected.

proc setTexture*(this: NodePath, stage: TextureStage, tex: Texture, sampler: SamplerState) {.importcpp: "#.set_texture(#, #, #)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the indicated multitexture stage.  If there are multiple texture stages
## specified (possibly on multiple different nodes at different levels), they
## will all be applied to geometry together, according to the stage
## specification set up in the TextureStage object.
##
## The given sampler state will override the sampling settings on the texture
## itself.  Note that this method makes a copy of the sampler settings that
## you give; further changes to this object will not be reflected.

proc setTexture*(this: NodePath, stage: TextureStage, tex: Texture, priority: int) {.importcpp: "#.set_texture(#, #, #)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the indicated multitexture stage.  If there are multiple texture stages
## specified (possibly on multiple different nodes at different levels), they
## will all be applied to geometry together, according to the stage
## specification set up in the TextureStage object.

proc setTexture*(this: NodePath, stage: TextureStage, tex: Texture) {.importcpp: "#.set_texture(#, #)".} ## \
## Adds the indicated texture to the list of textures that will be rendered on
## the indicated multitexture stage.  If there are multiple texture stages
## specified (possibly on multiple different nodes at different levels), they
## will all be applied to geometry together, according to the stage
## specification set up in the TextureStage object.

proc setTextureOff*(this: NodePath, stage: TextureStage, priority: int) {.importcpp: "#.set_texture_off(#, #)".} ## \
## Sets the geometry at this level and below to render using no texture, on
## the indicated stage.  This is different from not specifying a texture;
## rather, this specifically contradicts set_texture() at a higher node level
## (or, with a priority, overrides a set_texture() at a lower level).

proc setTextureOff*(this: NodePath, stage: TextureStage) {.importcpp: "#.set_texture_off(#)".} ## \
## Sets the geometry at this level and below to render using no texture, on
## the indicated stage.  This is different from not specifying a texture;
## rather, this specifically contradicts set_texture() at a higher node level
## (or, with a priority, overrides a set_texture() at a lower level).

proc setTextureOff*(this: NodePath, priority: int) {.importcpp: "#.set_texture_off(#)".} ## \
## Sets the geometry at this level and below to render using no texture, on
## any stage.  This is different from not specifying a texture; rather, this
## specifically contradicts set_texture() at a higher node level (or, with a
## priority, overrides a set_texture() at a lower level).

proc setTextureOff*(this: NodePath) {.importcpp: "#.set_texture_off()".} ## \
## Sets the geometry at this level and below to render using no texture, on
## any stage.  This is different from not specifying a texture; rather, this
## specifically contradicts set_texture() at a higher node level (or, with a
## priority, overrides a set_texture() at a lower level).

proc clearTexture*(this: NodePath) {.importcpp: "#.clear_texture()".} ## \
## Completely removes any texture adjustment that may have been set via
## set_texture() or set_texture_off() from this particular node.  This allows
## whatever textures might be otherwise affecting the geometry to show
## instead.

proc clearTexture*(this: NodePath, stage: TextureStage) {.importcpp: "#.clear_texture(#)".} ## \
## Removes any reference to the indicated texture stage from the NodePath.

proc hasTexture*(this: NodePath): bool {.importcpp: "#.has_texture()".} ## \
## Returns true if a texture has been applied to this particular node via
## set_texture(), false otherwise.  This is not the same thing as asking
## whether the geometry at this node will be rendered with texturing, as there
## may be a texture in effect from a higher or lower level.

proc hasTexture*(this: NodePath, stage: TextureStage): bool {.importcpp: "#.has_texture(#)".} ## \
## Returns true if texturing has been specifically enabled on this particular
## node for the indicated stage.  This means that someone called set_texture()
## on this node with the indicated stage name, or the stage_name is the
## default stage_name, and someone called set_texture() on this node.

proc hasTextureOff*(this: NodePath): bool {.importcpp: "#.has_texture_off()".} ## \
## Returns true if texturing has been specifically disabled on this particular
## node via set_texture_off(), false otherwise.  This is not the same thing as
## asking whether the geometry at this node will be rendered untextured, as
## there may be a texture in effect from a higher or lower level.

proc hasTextureOff*(this: NodePath, stage: TextureStage): bool {.importcpp: "#.has_texture_off(#)".} ## \
## Returns true if texturing has been specifically disabled on this particular
## node for the indicated stage.  This means that someone called
## set_texture_off() on this node with the indicated stage name, or that
## someone called set_texture_off() on this node to remove all stages.

proc getTexture*(this: NodePath): Texture {.importcpp: "#.get_texture()".} ## \
## Returns the base-level texture that has been set on this particular node,
## or NULL if no texture has been set.  This is not necessarily the texture
## that will be applied to the geometry at or below this level, as another
## texture at a higher or lower level may override.
##
## See also find_texture().

proc getTexture*(this: NodePath, stage: TextureStage): Texture {.importcpp: "#.get_texture(#)".} ## \
## Returns the texture that has been set on the indicated stage for this
## particular node, or NULL if no texture has been set for this stage.

proc replaceTexture*(this: NodePath, tex: Texture, new_tex: Texture) {.importcpp: "#.replace_texture(#, #)".} ## \
## Recursively searches the scene graph for references to the given texture,
## and replaces them with the new texture.
##
## @since 1.10.4

proc getTextureSampler*(this: NodePath): SamplerState {.importcpp: "#.get_texture_sampler()".} ## \
## Returns the sampler state that has been given for the base-level texture
## that has been set on this particular node.  If no sampler state was given,
## this returns the texture's default sampler settings.
##
## It is an error to call this if there is no base-level texture applied to
## this particular node.

proc getTextureSampler*(this: NodePath, stage: TextureStage): SamplerState {.importcpp: "#.get_texture_sampler(#)".} ## \
## Returns the sampler state that has been given for the indicated texture
## stage that has been set on this particular node.  If no sampler state was
## given, this returns the texture's default sampler settings.
##
## It is an error to call this if there is no texture set for this stage on
## this particular node.

proc setShader*(this: NodePath, sha: Shader, priority: int) {.importcpp: "#.set_shader(#, #)".}

proc setShader*(this: NodePath, sha: Shader) {.importcpp: "#.set_shader(#)".}

proc setShaderOff*(this: NodePath, priority: int) {.importcpp: "#.set_shader_off(#)".}

proc setShaderOff*(this: NodePath) {.importcpp: "#.set_shader_off()".}

proc setShaderAuto*(this: NodePath, shader_switch: BitMask32, priority: int) {.importcpp: "#.set_shader_auto(#, #)".} ## \
## overloaded for auto shader customization

proc setShaderAuto*(this: NodePath, shader_switch: BitMask32) {.importcpp: "#.set_shader_auto(#)".} ## \
## overloaded for auto shader customization

proc setShaderAuto*(this: NodePath, priority: int) {.importcpp: "#.set_shader_auto(#)".}

proc setShaderAuto*(this: NodePath) {.importcpp: "#.set_shader_auto()".}

proc clearShader*(this: NodePath) {.importcpp: "#.clear_shader()".}

proc setShaderInput*(this: NodePath, id: InternalName, n1: float32, n2: float32, n3: float32, n4: float32, priority: int) {.importcpp: "#.set_shader_input(#, #, #, #, #, #)".}

proc setShaderInput*(this: NodePath, id: InternalName, n1: float32, n2: float32, n3: float32, n4: float32) {.importcpp: "#.set_shader_input(#, #, #, #, #)".}

proc setShaderInput*(this: NodePath, id: InternalName, n1: float32, n2: float32, n3: float32) {.importcpp: "#.set_shader_input(#, #, #, #)".}

proc setShaderInput*(this: NodePath, id: InternalName, n1: float32, n2: float32) {.importcpp: "#.set_shader_input(#, #, #)".}

proc setShaderInput*(this: NodePath, id: InternalName, tex: Texture, sampler: SamplerState, priority: int) {.importcpp: "#.set_shader_input(#, #, #, #)".}

proc setShaderInput*(this: NodePath, id: InternalName, tex: Texture, sampler: SamplerState) {.importcpp: "#.set_shader_input(#, #, #)".}

proc setShaderInput*(this: NodePath, id: InternalName, tex: Texture, read: bool, write: bool, z: int, n: int, priority: int) {.importcpp: "#.set_shader_input(#, #, #, #, #, #, #)".}

proc setShaderInput*(this: NodePath, id: InternalName, tex: Texture, read: bool, write: bool, z: int, n: int) {.importcpp: "#.set_shader_input(#, #, #, #, #, #)".}

proc setShaderInput*(this: NodePath, id: InternalName, tex: Texture, read: bool, write: bool, z: int) {.importcpp: "#.set_shader_input(#, #, #, #, #)".}

proc setShaderInput*(this: NodePath, id: InternalName, tex: Texture, read: bool, write: bool) {.importcpp: "#.set_shader_input(#, #, #, #)".}

proc setShaderInput*(this: NodePath, id: InternalName, n1: int, n2: int, n3: int, n4: int, priority: int) {.importcpp: "#.set_shader_input(#, #, #, #, #, #)".}

proc setShaderInput*(this: NodePath, id: InternalName, n1: int, n2: int, n3: int, n4: int) {.importcpp: "#.set_shader_input(#, #, #, #, #)".}

proc setShaderInput*(this: NodePath, id: InternalName, n1: int, n2: int, n3: int) {.importcpp: "#.set_shader_input(#, #, #, #)".}

proc setShaderInput*(this: NodePath, id: InternalName, n1: int, n2: int) {.importcpp: "#.set_shader_input(#, #, #)".}

proc setShaderInput*(this: NodePath, input: ShaderInput) {.importcpp: "#.set_shader_input(#)".}

proc clearShaderInput*(this: NodePath, id: InternalName) {.importcpp: "#.clear_shader_input(#)".}

proc setInstanceCount*(this: NodePath, instance_count: int) {.importcpp: "#.set_instance_count(#)".} ## \
## Sets the geometry instance count, or 0 if geometry instancing should be
## disabled.  Do not confuse with instanceTo which only applies to animation
## instancing.

proc getShader*(this: NodePath): Shader {.importcpp: "#.get_shader()".}

proc getShaderInput*(this: NodePath, id: InternalName): ShaderInput {.importcpp: "#.get_shader_input(#)".}

proc getInstanceCount*(this: NodePath): int {.importcpp: "#.get_instance_count()".} ## \
## Returns the geometry instance count, or 0 if disabled.  See
## set_instance_count.

proc setTexTransform*(this: NodePath, other: NodePath, stage: TextureStage, transform: TransformState) {.importcpp: "#.set_tex_transform(#, #, #)".} ## \
## Sets the texture matrix on the current node to the indicated transform for
## the given stage.

proc setTexTransform*(this: NodePath, stage: TextureStage, transform: TransformState) {.importcpp: "#.set_tex_transform(#, #)".} ## \
## Sets the texture matrix on the current node to the indicated transform for
## the given stage.

proc clearTexTransform*(this: NodePath) {.importcpp: "#.clear_tex_transform()".} ## \
## Removes all texture matrices from the current node.

proc clearTexTransform*(this: NodePath, stage: TextureStage) {.importcpp: "#.clear_tex_transform(#)".} ## \
## Removes the texture matrix on the current node for the given stage.

proc hasTexTransform*(this: NodePath, stage: TextureStage): bool {.importcpp: "#.has_tex_transform(#)".} ## \
## Returns true if there is an explicit texture matrix on the current node for
## the given stage.

proc getTexTransform*(this: NodePath, other: NodePath, stage: TextureStage): TransformState {.importcpp: "#.get_tex_transform(#, #)".} ## \
## Returns the texture matrix on the current node for the given stage,
## relative to the other node.

proc getTexTransform*(this: NodePath, stage: TextureStage): TransformState {.importcpp: "#.get_tex_transform(#)".} ## \
## Returns the texture matrix on the current node for the given stage, or
## identity transform if there is no explicit transform set for the given
## stage.

proc setTexOffset*(this: NodePath, other: NodePath, stage: TextureStage, uv: LVecBase2) {.importcpp: "#.set_tex_offset(#, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated offset to
## UV's for the given stage.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc setTexOffset*(this: NodePath, other: NodePath, stage: TextureStage, u: float32, v: float32) {.importcpp: "#.set_tex_offset(#, #, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated offset to
## UV's for the given stage.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc setTexOffset*(this: NodePath, stage: TextureStage, uv: LVecBase2) {.importcpp: "#.set_tex_offset(#, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated offset to
## UV's for the given stage.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc setTexOffset*(this: NodePath, stage: TextureStage, u: float32, v: float32) {.importcpp: "#.set_tex_offset(#, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated offset to
## UV's for the given stage.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc setTexRotate*(this: NodePath, other: NodePath, stage: TextureStage, r: float32) {.importcpp: "#.set_tex_rotate(#, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated rotation,
## clockwise in degrees, to UV's for the given stage.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc setTexRotate*(this: NodePath, stage: TextureStage, r: float32) {.importcpp: "#.set_tex_rotate(#, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated rotation,
## clockwise in degrees, to UV's for the given stage.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc setTexScale*(this: NodePath, other: NodePath, stage: TextureStage, scale: LVecBase2) {.importcpp: "#.set_tex_scale(#, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated scale to
## UV's for the given stage.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc setTexScale*(this: NodePath, other: NodePath, stage: TextureStage, scale: LVecBase3) {.importcpp: "#.set_tex_scale(#, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated scale to
## UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc setTexScale*(this: NodePath, other: NodePath, stage: TextureStage, scale: float32) {.importcpp: "#.set_tex_scale(#, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated scale to
## UV's for the given stage.
##
## This call is appropriate for 2-d or 3-d texture coordinates.

proc setTexScale*(this: NodePath, other: NodePath, stage: TextureStage, su: float32, sv: float32) {.importcpp: "#.set_tex_scale(#, #, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated scale to
## UV's for the given stage.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc setTexScale*(this: NodePath, other: NodePath, stage: TextureStage, su: float32, sv: float32, sw: float32) {.importcpp: "#.set_tex_scale(#, #, #, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated scale to
## UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc setTexScale*(this: NodePath, stage: TextureStage, scale: LVecBase2) {.importcpp: "#.set_tex_scale(#, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated scale to
## UV's for the given stage.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc setTexScale*(this: NodePath, stage: TextureStage, scale: LVecBase3) {.importcpp: "#.set_tex_scale(#, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated scale to
## UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc setTexScale*(this: NodePath, stage: TextureStage, scale: float32) {.importcpp: "#.set_tex_scale(#, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated scale to
## UVW's for the given stage.
##
## This call is appropriate for 2-d or 3-d texture coordinates.

proc setTexScale*(this: NodePath, stage: TextureStage, su: float32, sv: float32) {.importcpp: "#.set_tex_scale(#, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated scale to
## UV's for the given stage.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc setTexScale*(this: NodePath, stage: TextureStage, su: float32, sv: float32, sw: float32) {.importcpp: "#.set_tex_scale(#, #, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated scale to
## UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc getTexOffset*(this: NodePath, other: NodePath, stage: TextureStage): LVecBase2 {.importcpp: "#.get_tex_offset(#, #)".} ## \
## Returns the offset set for the UV's for the given stage on the current
## node.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc getTexOffset*(this: NodePath, stage: TextureStage): LVecBase2 {.importcpp: "#.get_tex_offset(#)".} ## \
## Returns the offset set for the UV's for the given stage on the current
## node.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc getTexRotate*(this: NodePath, other: NodePath, stage: TextureStage): float32 {.importcpp: "#.get_tex_rotate(#, #)".} ## \
## Returns the rotation set for the UV's for the given stage on the current
## node.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc getTexRotate*(this: NodePath, stage: TextureStage): float32 {.importcpp: "#.get_tex_rotate(#)".} ## \
## Returns the rotation set for the UV's for the given stage on the current
## node.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc getTexScale*(this: NodePath, other: NodePath, stage: TextureStage): LVecBase2 {.importcpp: "#.get_tex_scale(#, #)".} ## \
## Returns the scale set for the UV's for the given stage on the current node.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc getTexScale*(this: NodePath, stage: TextureStage): LVecBase2 {.importcpp: "#.get_tex_scale(#)".} ## \
## Returns the scale set for the UV's for the given stage on the current node.
##
## This call is appropriate for ordinary 2-d texture coordinates.

proc setTexPos*(this: NodePath, other: NodePath, stage: TextureStage, uvw: LVecBase3) {.importcpp: "#.set_tex_pos(#, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated offset to
## UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc setTexPos*(this: NodePath, other: NodePath, stage: TextureStage, u: float32, v: float32, w: float32) {.importcpp: "#.set_tex_pos(#, #, #, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated offset to
## UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc setTexPos*(this: NodePath, stage: TextureStage, uvw: LVecBase3) {.importcpp: "#.set_tex_pos(#, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated offset to
## UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc setTexPos*(this: NodePath, stage: TextureStage, u: float32, v: float32, w: float32) {.importcpp: "#.set_tex_pos(#, #, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated offset to
## UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc setTexHpr*(this: NodePath, other: NodePath, stage: TextureStage, hpr: LVecBase3) {.importcpp: "#.set_tex_hpr(#, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated rotation,
## as a 3-D HPR, to UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc setTexHpr*(this: NodePath, other: NodePath, stage: TextureStage, h: float32, p: float32, r: float32) {.importcpp: "#.set_tex_hpr(#, #, #, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated rotation,
## as a 3-D HPR, to UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc setTexHpr*(this: NodePath, stage: TextureStage, hpr: LVecBase3) {.importcpp: "#.set_tex_hpr(#, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated rotation,
## as a 3-D HPR, to UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc setTexHpr*(this: NodePath, stage: TextureStage, h: float32, p: float32, r: float32) {.importcpp: "#.set_tex_hpr(#, #, #, #)".} ## \
## Sets a texture matrix on the current node to apply the indicated rotation,
## as a 3-D HPR, to UVW's for the given stage.
##
## This call is appropriate for 3-d texture coordinates.

proc getTexPos*(this: NodePath, other: NodePath, stage: TextureStage): LVecBase3 {.importcpp: "#.get_tex_pos(#, #)".} ## \
## Returns the offset set for the UVW's for the given stage on the current
## node.
##
## This call is appropriate for 3-d texture coordinates.

proc getTexPos*(this: NodePath, stage: TextureStage): LVecBase3 {.importcpp: "#.get_tex_pos(#)".} ## \
## Returns the offset set for the UVW's for the given stage on the current
## node.
##
## This call is appropriate for 3-d texture coordinates.

proc getTexHpr*(this: NodePath, other: NodePath, stage: TextureStage): LVecBase3 {.importcpp: "#.get_tex_hpr(#, #)".} ## \
## Returns the 3-D HPR set for the UVW's for the given stage on the current
## node.
##
## This call is appropriate for 3-d texture coordinates.

proc getTexHpr*(this: NodePath, stage: TextureStage): LVecBase3 {.importcpp: "#.get_tex_hpr(#)".} ## \
## Returns the 3-D HPR set for the UVW's for the given stage on the current
## node.
##
## This call is appropriate for 3-d texture coordinates.

proc getTexScale3d*(this: NodePath, other: NodePath, stage: TextureStage): LVecBase3 {.importcpp: "#.get_tex_scale_3d(#, #)".} ## \
## Returns the scale set for the UVW's for the given stage on the current
## node.
##
## This call is appropriate for 3-d texture coordinates.

proc getTexScale3d*(this: NodePath, stage: TextureStage): LVecBase3 {.importcpp: "#.get_tex_scale_3d(#)".} ## \
## Returns the scale set for the UVW's for the given stage on the current
## node.
##
## This call is appropriate for 3-d texture coordinates.

proc clearTexGen*(this: NodePath) {.importcpp: "#.clear_tex_gen()".} ## \
## Removes the texture coordinate generation mode from all texture stages on
## this node.

proc clearTexGen*(this: NodePath, stage: TextureStage) {.importcpp: "#.clear_tex_gen(#)".} ## \
## Disables automatic texture coordinate generation for the indicated texture
## stage.

proc hasTexGen*(this: NodePath, stage: TextureStage): bool {.importcpp: "#.has_tex_gen(#)".} ## \
## Returns true if there is a mode for automatic texture coordinate generation
## on the current node for the given stage.

proc setTexProjector*(this: NodePath, stage: TextureStage, `from`: NodePath, to: NodePath, lens_index: int) {.importcpp: "#.set_tex_projector(#, #, #, #)".} ## \
## Establishes a TexProjectorEffect on this node, which can be used to
## establish projective texturing (but see also the
## NodePath::project_texture() convenience function), or it can be used to
## bind this node's texture transform to particular node's position in space,
## allowing a LerpInterval (for instance) to adjust this node's texture
## coordinates.
##
## If to is a LensNode, then the fourth parameter, lens_index, can be provided
## to select a particular lens to apply.  Otherwise lens_index is not used.

proc setTexProjector*(this: NodePath, stage: TextureStage, `from`: NodePath, to: NodePath) {.importcpp: "#.set_tex_projector(#, #, #)".} ## \
## Establishes a TexProjectorEffect on this node, which can be used to
## establish projective texturing (but see also the
## NodePath::project_texture() convenience function), or it can be used to
## bind this node's texture transform to particular node's position in space,
## allowing a LerpInterval (for instance) to adjust this node's texture
## coordinates.
##
## If to is a LensNode, then the fourth parameter, lens_index, can be provided
## to select a particular lens to apply.  Otherwise lens_index is not used.

proc clearTexProjector*(this: NodePath) {.importcpp: "#.clear_tex_projector()".} ## \
## Removes the TexProjectorEffect for all stages from this node.

proc clearTexProjector*(this: NodePath, stage: TextureStage) {.importcpp: "#.clear_tex_projector(#)".} ## \
## Removes the TexProjectorEffect for the indicated stage from this node.

proc hasTexProjector*(this: NodePath, stage: TextureStage): bool {.importcpp: "#.has_tex_projector(#)".} ## \
## Returns true if this node has a TexProjectorEffect for the indicated stage,
## false otherwise.

proc getTexProjectorFrom*(this: NodePath, stage: TextureStage): NodePath {.importcpp: "#.get_tex_projector_from(#)".} ## \
## Returns the "from" node associated with the TexProjectorEffect on the
## indicated stage.  The relative transform between the "from" and the "to"
## nodes is automatically applied to the texture transform each frame.

proc getTexProjectorTo*(this: NodePath, stage: TextureStage): NodePath {.importcpp: "#.get_tex_projector_to(#)".} ## \
## Returns the "to" node associated with the TexProjectorEffect on the
## indicated stage.  The relative transform between the "from" and the "to"
## nodes is automatically applied to the texture transform each frame.

proc projectTexture*(this: NodePath, stage: TextureStage, tex: Texture, projector: NodePath) {.importcpp: "#.project_texture(#, #, #)".} ## \
## A convenience function to enable projective texturing at this node level
## and below, using the indicated NodePath (which should contain a LensNode)
## as the projector.

proc clearProjectTexture*(this: NodePath, stage: TextureStage) {.importcpp: "#.clear_project_texture(#)".} ## \
## Undoes the effect of project_texture().

proc hasTexcoord*(this: NodePath, texcoord_name: string): bool {.importcpp: "#.has_texcoord(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if there are at least some vertices at this node and below
## that use the named texture coordinate set, false otherwise.  Pass the empty
## string for the default texture coordinate set.

proc hasVertexColumn*(this: NodePath, name: InternalName): bool {.importcpp: "#.has_vertex_column(#)".} ## \
## Returns true if there are at least some vertices at this node and below
## that contain a reference to the indicated vertex data column name, false
## otherwise.
##
## This is particularly useful for testing whether a particular model has a
## given texture coordinate set (but see has_texcoord()).

proc findAllVertexColumns*(this: NodePath): InternalNameCollection {.importcpp: "#.find_all_vertex_columns()".} ## \
## Returns a list of all vertex array columns stored on some geometry found at
## this node level and below.

proc findAllVertexColumns*(this: NodePath, name: string): InternalNameCollection {.importcpp: "#.find_all_vertex_columns(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a list of all vertex array columns stored on some geometry found at
## this node level and below that match the indicated name (which may contain
## wildcard characters).

proc findAllTexcoords*(this: NodePath): InternalNameCollection {.importcpp: "#.find_all_texcoords()".} ## \
## Returns a list of all texture coordinate sets used by any geometry at this
## node level and below.

proc findAllTexcoords*(this: NodePath, name: string): InternalNameCollection {.importcpp: "#.find_all_texcoords(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a list of all texture coordinate sets used by any geometry at this
## node level and below that match the indicated name (which may contain
## wildcard characters).

proc findTexture*(this: NodePath, stage: TextureStage): Texture {.importcpp: "#.find_texture(#)".} ## \
## Returns the first texture found applied to geometry at this node or below
## that is assigned to the indicated texture stage.  Returns the texture if it
## is found, or NULL if it is not.

proc findTexture*(this: NodePath, name: string): Texture {.importcpp: "#.find_texture(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the first texture found applied to geometry at this node or below
## that matches the indicated name (which may contain wildcards).  Returns the
## texture if it is found, or NULL if it is not.

proc findAllTextures*(this: NodePath): TextureCollection {.importcpp: "#.find_all_textures()".} ## \
## Returns a list of a textures applied to geometry at this node and below.

proc findAllTextures*(this: NodePath, stage: TextureStage): TextureCollection {.importcpp: "#.find_all_textures(#)".} ## \
## Returns a list of a textures on geometry at this node and below that are
## assigned to the indicated texture stage.

proc findAllTextures*(this: NodePath, name: string): TextureCollection {.importcpp: "#.find_all_textures(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a list of a textures applied to geometry at this node and below
## that match the indicated name (which may contain wildcard characters).

proc findTextureStage*(this: NodePath, name: string): TextureStage {.importcpp: "#.find_texture_stage(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the first TextureStage found applied to geometry at this node or
## below that matches the indicated name (which may contain wildcards).
## Returns the TextureStage if it is found, or NULL if it is not.

proc findAllTextureStages*(this: NodePath): TextureStageCollection {.importcpp: "#.find_all_texture_stages()".} ## \
## Returns a list of a TextureStages applied to geometry at this node and
## below.

proc findAllTextureStages*(this: NodePath, name: string): TextureStageCollection {.importcpp: "#.find_all_texture_stages(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a list of a TextureStages applied to geometry at this node and
## below that match the indicated name (which may contain wildcard
## characters).

proc unifyTextureStages*(this: NodePath, stage: TextureStage) {.importcpp: "#.unify_texture_stages(#)".} ## \
## Searches through all TextureStages at this node and below.  Any
## TextureStages that share the same name as the indicated TextureStage object
## are replaced with this object, thus ensuring that all geometry at this node
## and below with a particular TextureStage name is using the same
## TextureStage object.

proc findMaterial*(this: NodePath, name: string): Material {.importcpp: "#.find_material(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the first material found applied to geometry at this node or below
## that matches the indicated name (which may contain wildcards).  Returns the
## material if it is found, or NULL if it is not.

proc findAllMaterials*(this: NodePath): MaterialCollection {.importcpp: "#.find_all_materials()".} ## \
## Returns a list of a materials applied to geometry at this node and below.

proc findAllMaterials*(this: NodePath, name: string): MaterialCollection {.importcpp: "#.find_all_materials(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a list of a materials applied to geometry at this node and below
## that match the indicated name (which may contain wildcard characters).

proc setMaterial*(this: NodePath, tex: Material, priority: int) {.importcpp: "#.set_material(#, #)".} ## \
## Sets the geometry at this level and below to render using the indicated
## material.
##
## Previously, this operation made a copy of the material structure, but
## nowadays it assigns the pointer directly.

proc setMaterial*(this: NodePath, tex: Material) {.importcpp: "#.set_material(#)".} ## \
## Sets the geometry at this level and below to render using the indicated
## material.
##
## Previously, this operation made a copy of the material structure, but
## nowadays it assigns the pointer directly.

proc setMaterialOff*(this: NodePath, priority: int) {.importcpp: "#.set_material_off(#)".} ## \
## Sets the geometry at this level and below to render using no material.
## This is normally the default, but it may be useful to use this to
## contradict set_material() at a higher node level (or, with a priority, to
## override a set_material() at a lower level).

proc setMaterialOff*(this: NodePath) {.importcpp: "#.set_material_off()".} ## \
## Sets the geometry at this level and below to render using no material.
## This is normally the default, but it may be useful to use this to
## contradict set_material() at a higher node level (or, with a priority, to
## override a set_material() at a lower level).

proc clearMaterial*(this: NodePath) {.importcpp: "#.clear_material()".} ## \
## Completely removes any material adjustment that may have been set via
## set_material() from this particular node.

proc hasMaterial*(this: NodePath): bool {.importcpp: "#.has_material()".} ## \
## Returns true if a material has been applied to this particular node via
## set_material(), false otherwise.

proc getMaterial*(this: NodePath): Material {.importcpp: "#.get_material()".} ## \
## Returns the material that has been set on this particular node, or NULL if
## no material has been set.  This is not necessarily the material that will
## be applied to the geometry at or below this level, as another material at a
## higher or lower level may override.
##
## See also find_material().

proc replaceMaterial*(this: NodePath, mat: Material, new_mat: Material) {.importcpp: "#.replace_material(#, #)".} ## \
## Recursively searches the scene graph for references to the given material,
## and replaces them with the new material.
##
## @since 1.10.0

proc setFog*(this: NodePath, fog: Fog, priority: int) {.importcpp: "#.set_fog(#, #)".} ## \
## Sets the geometry at this level and below to render using the indicated
## fog.

proc setFog*(this: NodePath, fog: Fog) {.importcpp: "#.set_fog(#)".} ## \
## Sets the geometry at this level and below to render using the indicated
## fog.

proc setFogOff*(this: NodePath, priority: int) {.importcpp: "#.set_fog_off(#)".} ## \
## Sets the geometry at this level and below to render using no fog.  This is
## normally the default, but it may be useful to use this to contradict
## set_fog() at a higher node level (or, with a priority, to override a
## set_fog() at a lower level).

proc setFogOff*(this: NodePath) {.importcpp: "#.set_fog_off()".} ## \
## Sets the geometry at this level and below to render using no fog.  This is
## normally the default, but it may be useful to use this to contradict
## set_fog() at a higher node level (or, with a priority, to override a
## set_fog() at a lower level).

proc clearFog*(this: NodePath) {.importcpp: "#.clear_fog()".} ## \
## Completely removes any fog adjustment that may have been set via set_fog()
## or set_fog_off() from this particular node.  This allows whatever fogs
## might be otherwise affecting the geometry to show instead.

proc hasFog*(this: NodePath): bool {.importcpp: "#.has_fog()".} ## \
## Returns true if a fog has been applied to this particular node via
## set_fog(), false otherwise.  This is not the same thing as asking whether
## the geometry at this node will be rendered with fog, as there may be a fog
## in effect from a higher or lower level.

proc hasFogOff*(this: NodePath): bool {.importcpp: "#.has_fog_off()".} ## \
## Returns true if a fog has been specifically disabled on this particular
## node via set_fog_off(), false otherwise.  This is not the same thing as
## asking whether the geometry at this node will be rendered unfogged, as
## there may be a fog in effect from a higher or lower level.

proc getFog*(this: NodePath): Fog {.importcpp: "#.get_fog()".} ## \
## Returns the fog that has been set on this particular node, or NULL if no
## fog has been set.  This is not necessarily the fog that will be applied to
## the geometry at or below this level, as another fog at a higher or lower
## level may override.

proc setRenderModeWireframe*(this: NodePath, priority: int) {.importcpp: "#.set_render_mode_wireframe(#)".} ## \
## Sets up the geometry at this level and below (unless overridden) to render
## in wireframe mode.

proc setRenderModeWireframe*(this: NodePath) {.importcpp: "#.set_render_mode_wireframe()".} ## \
## Sets up the geometry at this level and below (unless overridden) to render
## in wireframe mode.

proc setRenderModeFilled*(this: NodePath, priority: int) {.importcpp: "#.set_render_mode_filled(#)".} ## \
## Sets up the geometry at this level and below (unless overridden) to render
## in filled (i.e.  not wireframe) mode.

proc setRenderModeFilled*(this: NodePath) {.importcpp: "#.set_render_mode_filled()".} ## \
## Sets up the geometry at this level and below (unless overridden) to render
## in filled (i.e.  not wireframe) mode.

proc setRenderModeFilledWireframe*(this: NodePath, wireframe_color: LColor, priority: int) {.importcpp: "#.set_render_mode_filled_wireframe(#, #)".} ## \
## Sets up the geometry at this level and below (unless overridden) to render
## in filled, but overlay the wireframe on top with a fixed color.  This is
## useful for debug visualizations.

proc setRenderModeFilledWireframe*(this: NodePath, wireframe_color: LColor) {.importcpp: "#.set_render_mode_filled_wireframe(#)".} ## \
## Sets up the geometry at this level and below (unless overridden) to render
## in filled, but overlay the wireframe on top with a fixed color.  This is
## useful for debug visualizations.

proc setRenderModeThickness*(this: NodePath, thickness: float32, priority: int) {.importcpp: "#.set_render_mode_thickness(#, #)".} ## \
## Sets up the point geometry at this level and below to render as thick
## points (that is, billboarded quads).  The thickness is in pixels, unless
## set_render_mode_perspective is also true, in which case it is in 3-D units.
##
## If you want the quads to be individually textured, you should also set a
## TexGenAttrib::M_point_sprite on the node.

proc setRenderModeThickness*(this: NodePath, thickness: float32) {.importcpp: "#.set_render_mode_thickness(#)".} ## \
## Sets up the point geometry at this level and below to render as thick
## points (that is, billboarded quads).  The thickness is in pixels, unless
## set_render_mode_perspective is also true, in which case it is in 3-D units.
##
## If you want the quads to be individually textured, you should also set a
## TexGenAttrib::M_point_sprite on the node.

proc setRenderModePerspective*(this: NodePath, perspective: bool, priority: int) {.importcpp: "#.set_render_mode_perspective(#, #)".} ## \
## Sets up the point geometry at this level and below to render as perspective
## sprites (that is, billboarded quads).  The thickness, as specified with
## set_render_mode_thickness(), is the width of each point in 3-D units,
## unless it is overridden on a per-vertex basis.  This does not affect
## geometry other than points.
##
## If you want the quads to be individually textured, you should also set a
## TexGenAttrib::M_point_sprite on the node.

proc setRenderModePerspective*(this: NodePath, perspective: bool) {.importcpp: "#.set_render_mode_perspective(#)".} ## \
## Sets up the point geometry at this level and below to render as perspective
## sprites (that is, billboarded quads).  The thickness, as specified with
## set_render_mode_thickness(), is the width of each point in 3-D units,
## unless it is overridden on a per-vertex basis.  This does not affect
## geometry other than points.
##
## If you want the quads to be individually textured, you should also set a
## TexGenAttrib::M_point_sprite on the node.

proc clearRenderMode*(this: NodePath) {.importcpp: "#.clear_render_mode()".} ## \
## Completely removes any render mode adjustment that may have been set on
## this node via set_render_mode_wireframe() or set_render_mode_filled().

proc hasRenderMode*(this: NodePath): bool {.importcpp: "#.has_render_mode()".} ## \
## Returns true if a render mode has been explicitly set on this particular
## node via set_render_mode() (or set_render_mode_wireframe() or
## set_render_mode_filled()), false otherwise.

proc getRenderModeThickness*(this: NodePath): float32 {.importcpp: "#.get_render_mode_thickness()".} ## \
## Returns the render mode thickness that has been specifically set on this
## node via set_render_mode(), or 1.0 if nothing has been set.

proc getRenderModePerspective*(this: NodePath): bool {.importcpp: "#.get_render_mode_perspective()".} ## \
## Returns the flag that has been set on this node via
## set_render_mode_perspective(), or false if no flag has been set.

proc setTwoSided*(this: NodePath, two_sided: bool, priority: int) {.importcpp: "#.set_two_sided(#, #)".} ## \
## Specifically sets or disables two-sided rendering mode on this particular
## node.  If no other nodes override, this will cause backfacing polygons to
## be drawn (in two-sided mode, true) or culled (in one-sided mode, false).

proc setTwoSided*(this: NodePath, two_sided: bool) {.importcpp: "#.set_two_sided(#)".} ## \
## Specifically sets or disables two-sided rendering mode on this particular
## node.  If no other nodes override, this will cause backfacing polygons to
## be drawn (in two-sided mode, true) or culled (in one-sided mode, false).

proc clearTwoSided*(this: NodePath) {.importcpp: "#.clear_two_sided()".} ## \
## Completely removes any two-sided adjustment that may have been set on this
## node via set_two_sided(). The geometry at this level and below will
## subsequently be rendered either two-sided or one-sided, according to
## whatever other nodes may have had set_two_sided() on it, or according to
## the initial state otherwise.

proc hasTwoSided*(this: NodePath): bool {.importcpp: "#.has_two_sided()".} ## \
## Returns true if a two-sided adjustment has been explicitly set on this
## particular node via set_two_sided().  If this returns true, then
## get_two_sided() may be called to determine which has been set.

proc getTwoSided*(this: NodePath): bool {.importcpp: "#.get_two_sided()".} ## \
## Returns true if two-sided rendering has been specifically set on this node
## via set_two_sided(), or false if one-sided rendering has been specifically
## set, or if nothing has been specifically set.  See also has_two_sided().
## This does not necessarily imply that the geometry will or will not be
## rendered two-sided, as there may be other nodes that override.

proc setDepthTest*(this: NodePath, depth_test: bool, priority: int) {.importcpp: "#.set_depth_test(#, #)".} ## \
## Specifically sets or disables the testing of the depth buffer on this
## particular node.  This is normally on in the 3-d scene graph and off in the
## 2-d scene graph; it should be on for rendering most 3-d objects properly.

proc setDepthTest*(this: NodePath, depth_test: bool) {.importcpp: "#.set_depth_test(#)".} ## \
## Specifically sets or disables the testing of the depth buffer on this
## particular node.  This is normally on in the 3-d scene graph and off in the
## 2-d scene graph; it should be on for rendering most 3-d objects properly.

proc clearDepthTest*(this: NodePath) {.importcpp: "#.clear_depth_test()".} ## \
## Completely removes any depth-test adjustment that may have been set on this
## node via set_depth_test().

proc hasDepthTest*(this: NodePath): bool {.importcpp: "#.has_depth_test()".} ## \
## Returns true if a depth-test adjustment has been explicitly set on this
## particular node via set_depth_test().  If this returns true, then
## get_depth_test() may be called to determine which has been set.

proc getDepthTest*(this: NodePath): bool {.importcpp: "#.get_depth_test()".} ## \
## Returns true if depth-test rendering has been specifically set on this node
## via set_depth_test(), or false if depth-test rendering has been
## specifically disabled.  If nothing has been specifically set, returns true.
## See also has_depth_test().

proc setDepthWrite*(this: NodePath, depth_write: bool, priority: int) {.importcpp: "#.set_depth_write(#, #)".} ## \
## Specifically sets or disables the writing to the depth buffer on this
## particular node.  This is normally on in the 3-d scene graph and off in the
## 2-d scene graph; it should be on for rendering most 3-d objects properly.

proc setDepthWrite*(this: NodePath, depth_write: bool) {.importcpp: "#.set_depth_write(#)".} ## \
## Specifically sets or disables the writing to the depth buffer on this
## particular node.  This is normally on in the 3-d scene graph and off in the
## 2-d scene graph; it should be on for rendering most 3-d objects properly.

proc clearDepthWrite*(this: NodePath) {.importcpp: "#.clear_depth_write()".} ## \
## Completely removes any depth-write adjustment that may have been set on
## this node via set_depth_write().

proc hasDepthWrite*(this: NodePath): bool {.importcpp: "#.has_depth_write()".} ## \
## Returns true if a depth-write adjustment has been explicitly set on this
## particular node via set_depth_write().  If this returns true, then
## get_depth_write() may be called to determine which has been set.

proc getDepthWrite*(this: NodePath): bool {.importcpp: "#.get_depth_write()".} ## \
## Returns true if depth-write rendering has been specifically set on this
## node via set_depth_write(), or false if depth-write rendering has been
## specifically disabled.  If nothing has been specifically set, returns true.
## See also has_depth_write().

proc setDepthOffset*(this: NodePath, bias: int, priority: int) {.importcpp: "#.set_depth_offset(#, #)".} ## \
## This instructs the graphics driver to apply an offset or bias to the
## generated depth values for rendered polygons, before they are written to
## the depth buffer.  This can be used to shift polygons forward slightly, to
## resolve depth conflicts, or self-shadowing artifacts on thin objects.  The
## bias is always an integer number, and each integer increment represents the
## smallest possible increment in Z that is sufficient to completely resolve
## two coplanar polygons.  Positive numbers are closer towards the camera.

proc setDepthOffset*(this: NodePath, bias: int) {.importcpp: "#.set_depth_offset(#)".} ## \
## This instructs the graphics driver to apply an offset or bias to the
## generated depth values for rendered polygons, before they are written to
## the depth buffer.  This can be used to shift polygons forward slightly, to
## resolve depth conflicts, or self-shadowing artifacts on thin objects.  The
## bias is always an integer number, and each integer increment represents the
## smallest possible increment in Z that is sufficient to completely resolve
## two coplanar polygons.  Positive numbers are closer towards the camera.

proc clearDepthOffset*(this: NodePath) {.importcpp: "#.clear_depth_offset()".} ## \
## Completely removes any depth-offset adjustment that may have been set on
## this node via set_depth_offset().

proc hasDepthOffset*(this: NodePath): bool {.importcpp: "#.has_depth_offset()".} ## \
## Returns true if a depth-offset adjustment has been explicitly set on this
## particular node via set_depth_offset().  If this returns true, then
## get_depth_offset() may be called to determine which has been set.

proc getDepthOffset*(this: NodePath): int {.importcpp: "#.get_depth_offset()".} ## \
## Returns the depth offset value if it has been specified using
## set_depth_offset, or 0 if not.

proc doBillboardAxis*(this: NodePath, camera: NodePath, offset: float32) {.importcpp: "#.do_billboard_axis(#, #)".} ## \
## Performs a billboard-type rotate to the indicated camera node, one time
## only, and leaves the object rotated.  This is similar in principle to
## heads_up().

proc doBillboardPointEye*(this: NodePath, camera: NodePath, offset: float32) {.importcpp: "#.do_billboard_point_eye(#, #)".} ## \
## Performs a billboard-type rotate to the indicated camera node, one time
## only, and leaves the object rotated.  This is similar in principle to
## look_at(), although the point_eye billboard effect cannot be achieved using
## the ordinary look_at() call.

proc doBillboardPointWorld*(this: NodePath, camera: NodePath, offset: float32) {.importcpp: "#.do_billboard_point_world(#, #)".} ## \
## Performs a billboard-type rotate to the indicated camera node, one time
## only, and leaves the object rotated.  This is similar in principle to
## look_at().

proc setBillboardAxis*(this: NodePath, camera: NodePath, offset: float32) {.importcpp: "#.set_billboard_axis(#, #)".} ## \
## Puts a billboard transition on the node such that it will rotate in two
## dimensions around the up axis, towards a specified "camera" instead of to
## the viewing camera.

proc setBillboardAxis*(this: NodePath, offset: float32) {.importcpp: "#.set_billboard_axis(#)".} ## \
## Puts a billboard transition on the node such that it will rotate in two
## dimensions around the up axis.

proc setBillboardAxis*(this: NodePath) {.importcpp: "#.set_billboard_axis()".} ## \
## Puts a billboard transition on the node such that it will rotate in two
## dimensions around the up axis.

proc setBillboardPointEye*(this: NodePath, camera: NodePath, offset: float32, fixed_depth: bool) {.importcpp: "#.set_billboard_point_eye(#, #, #)".} ## \
## Puts a billboard transition on the node such that it will rotate in three
## dimensions about the origin, keeping its up vector oriented to the top of
## the camera, towards a specified "camera" instead of to the viewing camera.

proc setBillboardPointEye*(this: NodePath, camera: NodePath, offset: float32) {.importcpp: "#.set_billboard_point_eye(#, #)".} ## \
## Puts a billboard transition on the node such that it will rotate in three
## dimensions about the origin, keeping its up vector oriented to the top of
## the camera, towards a specified "camera" instead of to the viewing camera.

proc setBillboardPointEye*(this: NodePath, offset: float32, fixed_depth: bool) {.importcpp: "#.set_billboard_point_eye(#, #)".} ## \
## Puts a billboard transition on the node such that it will rotate in three
## dimensions about the origin, keeping its up vector oriented to the top of
## the camera.

proc setBillboardPointEye*(this: NodePath, offset: float32) {.importcpp: "#.set_billboard_point_eye(#)".} ## \
## Puts a billboard transition on the node such that it will rotate in three
## dimensions about the origin, keeping its up vector oriented to the top of
## the camera.

proc setBillboardPointEye*(this: NodePath) {.importcpp: "#.set_billboard_point_eye()".} ## \
## Puts a billboard transition on the node such that it will rotate in three
## dimensions about the origin, keeping its up vector oriented to the top of
## the camera.

proc setBillboardPointWorld*(this: NodePath, camera: NodePath, offset: float32) {.importcpp: "#.set_billboard_point_world(#, #)".} ## \
## Puts a billboard transition on the node such that it will rotate in three
## dimensions about the origin, keeping its up vector oriented to the sky,
## towards a specified "camera" instead of to the viewing camera.

proc setBillboardPointWorld*(this: NodePath, offset: float32) {.importcpp: "#.set_billboard_point_world(#)".} ## \
## Puts a billboard transition on the node such that it will rotate in three
## dimensions about the origin, keeping its up vector oriented to the sky.

proc setBillboardPointWorld*(this: NodePath) {.importcpp: "#.set_billboard_point_world()".} ## \
## Puts a billboard transition on the node such that it will rotate in three
## dimensions about the origin, keeping its up vector oriented to the sky.

proc clearBillboard*(this: NodePath) {.importcpp: "#.clear_billboard()".} ## \
## Removes any billboard effect from the node.

proc hasBillboard*(this: NodePath): bool {.importcpp: "#.has_billboard()".} ## \
## Returns true if there is any billboard effect on the node.

proc setCompass*(this: NodePath, reference: NodePath) {.importcpp: "#.set_compass(#)".} ## \
## Puts a compass effect on the node, so that it will retain a fixed rotation
## relative to the reference node (or render if the reference node is empty)
## regardless of the transforms above it.

proc setCompass*(this: NodePath) {.importcpp: "#.set_compass()".} ## \
## Puts a compass effect on the node, so that it will retain a fixed rotation
## relative to the reference node (or render if the reference node is empty)
## regardless of the transforms above it.

proc clearCompass*(this: NodePath) {.importcpp: "#.clear_compass()".} ## \
## Removes any compass effect from the node.

proc hasCompass*(this: NodePath): bool {.importcpp: "#.has_compass()".} ## \
## Returns true if there is any compass effect on the node.

proc clearTransparency*(this: NodePath) {.importcpp: "#.clear_transparency()".} ## \
## Completely removes any transparency adjustment that may have been set on
## this node via set_transparency(). The geometry at this level and below will
## subsequently be rendered either transparent or not, to whatever other nodes
## may have had set_transparency() on them.

proc hasTransparency*(this: NodePath): bool {.importcpp: "#.has_transparency()".} ## \
## Returns true if a transparent-rendering adjustment has been explicitly set
## on this particular node via set_transparency().  If this returns true, then
## get_transparency() may be called to determine whether transparency has been
## explicitly enabled or explicitly disabled for this node.

proc clearLogicOp*(this: NodePath) {.importcpp: "#.clear_logic_op()".} ## \
## Completely removes any logical operation that may have been set on this
## node via set_logic_op(). The geometry at this level and below will
## subsequently be rendered using standard color blending.
##
## @since 1.10.0

proc hasLogicOp*(this: NodePath): bool {.importcpp: "#.has_logic_op()".} ## \
## Returns true if a logical operation has been explicitly set on this
## particular node via set_logic_op().  If this returns true, then
## get_logic_op() may be called to determine whether a logical operation has
## been explicitly disabled for this node or set to particular operation.
##
## @since 1.10.0

proc setAntialias*(this: NodePath, mode: int, priority: int) {.importcpp: "#.set_antialias(#, #)".} ## \
## Specifies the antialiasing type that should be applied at this node and
## below.  See AntialiasAttrib.

proc setAntialias*(this: NodePath, mode: int) {.importcpp: "#.set_antialias(#)".} ## \
## Specifies the antialiasing type that should be applied at this node and
## below.  See AntialiasAttrib.

proc clearAntialias*(this: NodePath) {.importcpp: "#.clear_antialias()".} ## \
## Completely removes any antialias setting that may have been set on this
## node via set_antialias().

proc hasAntialias*(this: NodePath): bool {.importcpp: "#.has_antialias()".} ## \
## Returns true if an antialias setting has been explicitly mode on this
## particular node via set_antialias().  If this returns true, then
## get_antialias() may be called to determine what the setting was.

proc getAntialias*(this: NodePath): int {.importcpp: "#.get_antialias()".} ## \
## Returns the antialias setting that has been specifically set on this node
## via set_antialias(), or M_none if no setting has been made.

proc hasAudioVolume*(this: NodePath): bool {.importcpp: "#.has_audio_volume()".} ## \
## Returns true if an audio volume has been applied to the referenced node,
## false otherwise.  It is still possible that volume at this node might have
## been scaled by an ancestor node.

proc clearAudioVolume*(this: NodePath) {.importcpp: "#.clear_audio_volume()".} ## \
## Completely removes any audio volume from the referenced node.  This is
## preferable to simply setting the audio volume to identity, as it also
## removes the overhead associated with having an audio volume at all.

proc setAudioVolume*(this: NodePath, volume: float32, priority: int) {.importcpp: "#.set_audio_volume(#, #)".} ## \
## Sets the audio volume component of the transform

proc setAudioVolume*(this: NodePath, volume: float32) {.importcpp: "#.set_audio_volume(#)".} ## \
## Sets the audio volume component of the transform

proc setAudioVolumeOff*(this: NodePath, priority: int) {.importcpp: "#.set_audio_volume_off(#)".} ## \
## Disables any audio volume attribute inherited from above.  This is not the
## same thing as clear_audio_volume(), which undoes any previous
## set_audio_volume() operation on this node; rather, this actively disables
## any set_audio_volume() that might be inherited from a parent node.
##
## It is legal to specify a new volume on the same node with a subsequent call
## to set_audio_volume(); this new scale will apply to lower nodes.

proc setAudioVolumeOff*(this: NodePath) {.importcpp: "#.set_audio_volume_off()".} ## \
## Disables any audio volume attribute inherited from above.  This is not the
## same thing as clear_audio_volume(), which undoes any previous
## set_audio_volume() operation on this node; rather, this actively disables
## any set_audio_volume() that might be inherited from a parent node.
##
## It is legal to specify a new volume on the same node with a subsequent call
## to set_audio_volume(); this new scale will apply to lower nodes.

proc getAudioVolume*(this: NodePath): float32 {.importcpp: "#.get_audio_volume()".} ## \
## Returns the complete audio volume that has been applied to this node via a
## previous call to set_audio_volume(), or 1. (identity) if no volume has been
## applied to this particular node.

proc getNetAudioVolume*(this: NodePath): float32 {.importcpp: "#.get_net_audio_volume()".} ## \
## Returns the complete audio volume for this node taking highers nodes in the
## graph into account.

proc adjustAllPriorities*(this: NodePath, adjustment: int) {.importcpp: "#.adjust_all_priorities(#)".} ## \
## Adds the indicated adjustment amount (which may be negative) to the
## priority for all transitions on the referenced node, and for all nodes in
## the subgraph below.  This can be used to force these nodes not to be
## overridden by a high-level state change above.  If the priority would drop
## below zero, it is set to zero.

proc show*(this: NodePath) {.importcpp: "#.show()".} ## \
## Undoes the effect of a previous hide() on this node: makes the referenced
## node (and the entire subgraph below this node) visible to all cameras.
##
## This will not reveal the node if a parent node has been hidden.

proc show*(this: NodePath, camera_mask: DrawMask) {.importcpp: "#.show(#)".} ## \
## Makes the referenced node visible just to the cameras whose camera_mask
## shares the indicated bits.
##
## This undoes the effect of a previous hide() call.  It will not reveal the
## node if a parent node has been hidden.  However, see show_through().

proc showThrough*(this: NodePath) {.importcpp: "#.show_through()".} ## \
## Makes the referenced node visible just to the cameras whose camera_mask
## shares the indicated bits.
##
## Unlike show(), this will reveal the node even if a parent node has been
## hidden, thus "showing through" a parent's hide().

proc showThrough*(this: NodePath, camera_mask: DrawMask) {.importcpp: "#.show_through(#)".} ## \
## Makes the referenced node visible just to the cameras whose camera_mask
## shares the indicated bits.
##
## Unlike show(), this will reveal the node even if a parent node has been
## hidden via the one-parameter hide() method, thus "showing through" a
## parent's hide().  (However, it will not show through a parent's hide() call
## if the no-parameter form of hide() was used.)

proc hide*(this: NodePath) {.importcpp: "#.hide()".} ## \
## Makes the referenced node (and the entire subgraph below this node)
## invisible to all cameras.  It remains part of the scene graph, its bounding
## volume still contributes to its parent's bounding volume, and it will still
## be involved in collision tests.
##
## To undo this, call show().

proc hide*(this: NodePath, camera_mask: DrawMask) {.importcpp: "#.hide(#)".} ## \
## Makes the referenced node invisible just to the cameras whose camera_mask
## shares the indicated bits.
##
## This will also hide any nodes below this node in the scene graph, including
## those nodes for which show() has been called, but it will not hide
## descendent nodes for which show_through() has been called.

proc isHidden*(this: NodePath, camera_mask: DrawMask): bool {.importcpp: "#.is_hidden(#)".} ## \
## Returns true if the referenced node is hidden from the indicated camera(s)
## either directly, or because some ancestor is hidden.

proc isHidden*(this: NodePath): bool {.importcpp: "#.is_hidden()".} ## \
## Returns true if the referenced node is hidden from the indicated camera(s)
## either directly, or because some ancestor is hidden.

proc getHiddenAncestor*(this: NodePath, camera_mask: DrawMask, current_thread: Thread): NodePath {.importcpp: "#.get_hidden_ancestor(#, #)".} ## \
## Returns the NodePath at or above the referenced node that is hidden to the
## indicated camera(s), or an empty NodePath if no ancestor of the referenced
## node is hidden (and the node should be visible).

proc getHiddenAncestor*(this: NodePath, camera_mask: DrawMask): NodePath {.importcpp: "#.get_hidden_ancestor(#)".} ## \
## Returns the NodePath at or above the referenced node that is hidden to the
## indicated camera(s), or an empty NodePath if no ancestor of the referenced
## node is hidden (and the node should be visible).

proc getHiddenAncestor*(this: NodePath): NodePath {.importcpp: "#.get_hidden_ancestor()".} ## \
## Returns the NodePath at or above the referenced node that is hidden to the
## indicated camera(s), or an empty NodePath if no ancestor of the referenced
## node is hidden (and the node should be visible).

proc stash*(this: NodePath, sort: int, current_thread: Thread) {.importcpp: "#.stash(#, #)".} ## \
## Removes the referenced node (and the entire subgraph below this node) from
## the scene graph in any normal sense.  The node will no longer be visible
## and is not tested for collisions; furthermore, no normal scene graph
## traversal will visit the node.  The node's bounding volume no longer
## contributes to its parent's bounding volume.
##
## A stashed node cannot be located by a normal find() operation (although a
## special find string can still retrieve it).

proc stash*(this: NodePath, sort: int) {.importcpp: "#.stash(#)".} ## \
## Removes the referenced node (and the entire subgraph below this node) from
## the scene graph in any normal sense.  The node will no longer be visible
## and is not tested for collisions; furthermore, no normal scene graph
## traversal will visit the node.  The node's bounding volume no longer
## contributes to its parent's bounding volume.
##
## A stashed node cannot be located by a normal find() operation (although a
## special find string can still retrieve it).

proc stash*(this: NodePath) {.importcpp: "#.stash()".} ## \
## Removes the referenced node (and the entire subgraph below this node) from
## the scene graph in any normal sense.  The node will no longer be visible
## and is not tested for collisions; furthermore, no normal scene graph
## traversal will visit the node.  The node's bounding volume no longer
## contributes to its parent's bounding volume.
##
## A stashed node cannot be located by a normal find() operation (although a
## special find string can still retrieve it).

proc unstash*(this: NodePath, sort: int, current_thread: Thread) {.importcpp: "#.unstash(#, #)".} ## \
## Undoes the effect of a previous stash() on this node: makes the referenced
## node (and the entire subgraph below this node) once again part of the scene
## graph.

proc unstash*(this: NodePath, sort: int) {.importcpp: "#.unstash(#)".} ## \
## Undoes the effect of a previous stash() on this node: makes the referenced
## node (and the entire subgraph below this node) once again part of the scene
## graph.

proc unstash*(this: NodePath) {.importcpp: "#.unstash()".} ## \
## Undoes the effect of a previous stash() on this node: makes the referenced
## node (and the entire subgraph below this node) once again part of the scene
## graph.

proc unstashAll*(this: NodePath, current_thread: Thread) {.importcpp: "#.unstash_all(#)".} ## \
## Unstashes this node and all stashed child nodes.

proc unstashAll*(this: NodePath) {.importcpp: "#.unstash_all()".} ## \
## Unstashes this node and all stashed child nodes.

proc isStashed*(this: NodePath): bool {.importcpp: "#.is_stashed()".} ## \
## Returns true if the referenced node is stashed either directly, or because
## some ancestor is stashed.

proc getStashedAncestor*(this: NodePath, current_thread: Thread): NodePath {.importcpp: "#.get_stashed_ancestor(#)".} ## \
## Returns the NodePath at or above the referenced node that is stashed, or an
## empty NodePath if no ancestor of the referenced node is stashed (and the
## node should be visible).

proc getStashedAncestor*(this: NodePath): NodePath {.importcpp: "#.get_stashed_ancestor()".} ## \
## Returns the NodePath at or above the referenced node that is stashed, or an
## empty NodePath if no ancestor of the referenced node is stashed (and the
## node should be visible).

proc getCollideMask*(this: NodePath): CollideMask {.importcpp: "#.get_collide_mask()".} ## \
## Returns the union of all of the into_collide_masks for nodes at this level
## and below.  This is the same thing as node()->get_net_collide_mask().
##
## If you want to return what the into_collide_mask of this node itself is,
## without regard to its children, use node()->get_into_collide_mask().

proc setCollideMask*(this: NodePath, new_mask: CollideMask, bits_to_change: CollideMask, node_type: TypeHandle) {.importcpp: "#.set_collide_mask(#, #, #)".} ## \
## Recursively applies the indicated CollideMask to the into_collide_masks for
## all nodes at this level and below.  If node_type is not TypeHandle::none(),
## then only nodes matching (or inheriting from) the indicated PandaNode
## subclass are modified.
##
## The default is to change all bits, but if bits_to_change is not all bits
## on, then only the bits that are set in bits_to_change are modified,
## allowing this call to change only a subset of the bits in the subgraph.

proc setCollideMask*(this: NodePath, new_mask: CollideMask, bits_to_change: CollideMask) {.importcpp: "#.set_collide_mask(#, #)".} ## \
## Recursively applies the indicated CollideMask to the into_collide_masks for
## all nodes at this level and below.  If node_type is not TypeHandle::none(),
## then only nodes matching (or inheriting from) the indicated PandaNode
## subclass are modified.
##
## The default is to change all bits, but if bits_to_change is not all bits
## on, then only the bits that are set in bits_to_change are modified,
## allowing this call to change only a subset of the bits in the subgraph.

proc setCollideMask*(this: NodePath, new_mask: CollideMask) {.importcpp: "#.set_collide_mask(#)".} ## \
## Recursively applies the indicated CollideMask to the into_collide_masks for
## all nodes at this level and below.  If node_type is not TypeHandle::none(),
## then only nodes matching (or inheriting from) the indicated PandaNode
## subclass are modified.
##
## The default is to change all bits, but if bits_to_change is not all bits
## on, then only the bits that are set in bits_to_change are modified,
## allowing this call to change only a subset of the bits in the subgraph.

proc `==`*(this: NodePath, other: NodePath): bool {.importcpp: "#.operator ==(#)".} ## \
## Comparison methods

proc `==`*(this: NodePath, other: WeakNodePath): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: NodePath, other: NodePath): bool {.importcpp: "#.operator !=(#)".}

proc `!=`*(this: NodePath, other: WeakNodePath): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: NodePath, other: NodePath): bool {.importcpp: "#.operator <(#)".}

proc `<`*(this: NodePath, other: WeakNodePath): bool {.importcpp: "#.operator <(#)".}

proc compareTo*(this: NodePath, other: NodePath): int {.importcpp: "#.compare_to(#)".} ## \
## Returns a number less than zero if this NodePath sorts before the other
## one, greater than zero if it sorts after, or zero if they are equivalent.
##
## Two NodePaths are considered equivalent if they consist of exactly the same
## list of nodes in the same order.  Otherwise, they are different; different
## NodePaths will be ranked in a consistent but undefined ordering; the
## ordering is useful only for placing the NodePaths in a sorted container
## like an STL set.

proc compareTo*(this: NodePath, other: WeakNodePath): int {.importcpp: "#.compare_to(#)".} ## \
## Returns a number less than zero if this NodePath sorts before the other
## one, greater than zero if it sorts after, or zero if they are equivalent.
##
## Two NodePaths are considered equivalent if they consist of exactly the same
## list of nodes in the same order.  Otherwise, they are different; different
## NodePaths will be ranked in a consistent but undefined ordering; the
## ordering is useful only for placing the NodePaths in a sorted container
## like an STL set.

proc verifyComplete*(this: NodePath, current_thread: Thread): bool {.importcpp: "#.verify_complete(#)".} ## \
## Returns true if all of the nodes described in the NodePath are connected,
## or false otherwise.

proc verifyComplete*(this: NodePath): bool {.importcpp: "#.verify_complete()".} ## \
## Returns true if all of the nodes described in the NodePath are connected,
## or false otherwise.

proc premungeScene*(this: NodePath, gsg: GraphicsStateGuardianBase) {.importcpp: "#.premunge_scene(#)".} ## \
## Walks through the scene graph beginning at the bottom node, and internally
## adjusts any GeomVertexFormats for optimal rendering on the indicated GSG.
## If this step is not done prior to rendering, the formats will be optimized
## at render time instead, for a small cost.
##
## It is not normally necessary to do this on a model loaded directly from
## disk, since the loader will do this by default.

proc premungeScene*(this: NodePath) {.importcpp: "#.premunge_scene()".} ## \
## Walks through the scene graph beginning at the bottom node, and internally
## adjusts any GeomVertexFormats for optimal rendering on the indicated GSG.
## If this step is not done prior to rendering, the formats will be optimized
## at render time instead, for a small cost.
##
## It is not normally necessary to do this on a model loaded directly from
## disk, since the loader will do this by default.

proc prepareScene*(this: NodePath, gsg: GraphicsStateGuardianBase) {.importcpp: "#.prepare_scene(#)".} ## \
## Walks through the scene graph beginning at the bottom node, and does
## whatever initialization is required to render the scene properly with the
## indicated GSG.  It is not strictly necessary to call this, since the GSG
## will initialize itself when the scene is rendered, but this may take some
## of the overhead away from that process.
##
## In particular, this will ensure that textures and vertex buffers within the
## scene are loaded into graphics memory.

proc showBounds*(this: NodePath) {.importcpp: "#.show_bounds()".} ## \
## Causes the bounding volume of the bottom node and all of its descendants
## (that is, the bounding volume associated with the the bottom arc) to be
## rendered, if possible.  The rendering method is less than optimal; this is
## intended primarily for debugging.

proc showTightBounds*(this: NodePath) {.importcpp: "#.show_tight_bounds()".} ## \
## Similar to show_bounds(), this draws a bounding box representing the
## "tight" bounds of this node and all of its descendants.  The bounding box
## is recomputed every frame by reexamining all of the vertices; this is far
## from efficient, but this is intended for debugging.

proc hideBounds*(this: NodePath) {.importcpp: "#.hide_bounds()".} ## \
## Stops the rendering of the bounding volume begun with show_bounds().

proc getBounds*(this: NodePath, current_thread: Thread): BoundingVolume {.importcpp: "#.get_bounds(#)".} ## \
## Returns a newly-allocated bounding volume containing the bottom node and
## all of its descendants.  This is the bounding volume on the bottom arc,
## converted to the local coordinate space of the node.

proc getBounds*(this: NodePath): BoundingVolume {.importcpp: "#.get_bounds()".} ## \
## Returns a newly-allocated bounding volume containing the bottom node and
## all of its descendants.  This is the bounding volume on the bottom arc,
## converted to the local coordinate space of the node.

proc forceRecomputeBounds*(this: NodePath) {.importcpp: "#.force_recompute_bounds()".} ## \
## Forces the recomputing of all the bounding volumes at every node in the
## subgraph beginning at this node and below.
##
## This should not normally need to be called, since the bounding volumes are
## supposed to be recomputed automatically when necessary.  It may be useful
## when debugging, to verify that the bounding volumes have not become
## inadvertently stale; it may also be useful to force animated characters to
## update their bounding volumes (which does not presently happen
## automatically).

proc writeBounds*(this: NodePath, `out`: ostream) {.importcpp: "#.write_bounds(#)".} ## \
## Writes a description of the bounding volume containing the bottom node and
## all of its descendants to the indicated output stream.

proc calcTightBounds*(this: NodePath, min_point: LPoint3, max_point: LPoint3, other: NodePath, current_thread: Thread): bool {.importcpp: "#.calc_tight_bounds(#, #, #, #)".} ## \
## Calculates the minimum and maximum vertices of all Geoms at this NodePath's
## bottom node and below.  This is a tight bounding box; it will generally be
## tighter than the bounding volume returned by get_bounds() (but it is more
## expensive to compute).
##
## The bounding box is computed relative to the parent node's coordinate
## system by default.  You can optionally specify a different NodePath to
## compute the bounds relative to.  Note that the box is always axis-aligned
## against the given NodePath's coordinate system, so you might get a
## differently sized box depending on which node you pass.
##
## The return value is true if any points are within the bounding volume, or
## false if none are.

proc calcTightBounds*(this: NodePath, min_point: LPoint3, max_point: LPoint3, other: NodePath): bool {.importcpp: "#.calc_tight_bounds(#, #, #)".} ## \
## Calculates the minimum and maximum vertices of all Geoms at this NodePath's
## bottom node and below.  This is a tight bounding box; it will generally be
## tighter than the bounding volume returned by get_bounds() (but it is more
## expensive to compute).
##
## The bounding box is computed relative to the parent node's coordinate
## system by default.  You can optionally specify a different NodePath to
## compute the bounds relative to.  Note that the box is always axis-aligned
## against the given NodePath's coordinate system, so you might get a
## differently sized box depending on which node you pass.
##
## The return value is true if any points are within the bounding volume, or
## false if none are.

proc calcTightBounds*(this: NodePath, min_point: LPoint3, max_point: LPoint3): bool {.importcpp: "#.calc_tight_bounds(#, #)".} ## \
## Calculates the minimum and maximum vertices of all Geoms at this NodePath's
## bottom node and below.  This is a tight bounding box; it will generally be
## tighter than the bounding volume returned by get_bounds() (but it is more
## expensive to compute).
##
## The bounding box is computed relative to the parent node's coordinate
## system by default.  You can optionally specify a different NodePath to
## compute the bounds relative to.  Note that the box is always axis-aligned
## against the given NodePath's coordinate system, so you might get a
## differently sized box depending on which node you pass.
##
## The return value is true if any points are within the bounding volume, or
## false if none are.

proc flattenLight*(this: NodePath): int {.importcpp: "#.flatten_light()".} ## \
## Lightly flattens out the hierarchy below this node by applying transforms,
## colors, and texture matrices from the nodes onto the vertices, but does not
## remove any nodes.
##
## This can result in improved rendering performance because there will be
## fewer transforms in the resulting scene graph, but the number of nodes will
## remain the same.
##
## In particular, any NodePaths that reference nodes within this hierarchy
## will not be damaged.  However, since this operation will remove transforms
## from the scene graph, it may be dangerous to apply to nodes where you
## expect to dynamically modify the transform, or where you expect the
## geometry to remain in a particular local coordinate system.
##
## The return value is always 0, since flatten_light does not remove any
## nodes.

proc flattenMedium*(this: NodePath): int {.importcpp: "#.flatten_medium()".} ## \
## A more thorough flattening than flatten_light(), this first applies all the
## transforms, colors, and texture matrices from the nodes onto the vertices,
## and then removes unneeded grouping nodes--nodes that have exactly one
## child, for instance, but have no special properties in themselves.
##
## This results in improved performance over flatten_light() because the
## number of nodes in the scene graph is reduced.
##
## The return value is the number of nodes removed.

proc flattenStrong*(this: NodePath): int {.importcpp: "#.flatten_strong()".} ## \
## The strongest possible flattening.  This first applies all of the
## transforms to the vertices, as in flatten_medium(), but then it will
## combine sibling nodes together when possible, in addition to removing
## unnecessary parent-child nodes.  This can result in substantially fewer
## nodes, but any nicely-grouped hierachical bounding volumes may be lost.
##
## It is generally a good idea to apply this kind of flattening only to nodes
## that will be culled largely as a single unit, like a car.  Applying this to
## an entire scene may result in overall poorer performance because of less-
## effective culling.

proc applyTextureColors*(this: NodePath) {.importcpp: "#.apply_texture_colors()".} ## \
## Removes textures from Geoms at this node and below by applying the texture
## colors to the vertices.  This is primarily useful to simplify a low-LOD
## model.  The texture colors are replaced by flat colors that approximate the
## original textures.
##
## Only the bottommost texture on each Geom is used (if there is more than
## one), and it is applied as if it were M_modulate, and WM_repeat, regardless
## of its actual settings.  If the texture has a simple_ram_image, this may be
## used if the main image isn't resident.
##
## After this call, there will be no texturing specified at this level and
## below.  Of course, there might still be texturing inherited from above.

proc clearModelNodes*(this: NodePath): int {.importcpp: "#.clear_model_nodes()".} ## \
## Recursively walks through the scene graph at this level and below, looking
## for ModelNodes, and calls model_node->set_preserve_transform(PT_drop_node)
## on each one.  This allows a subsequent call to flatten_strong() to
## eliminate all of the ModelNodes.
##
## Returns the number of ModelNodes found.

proc setTag*(this: NodePath, key: string, value: string) {.importcpp: "#.set_tag(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Associates a user-defined value with a user-defined key which is stored on
## the node.  This value has no meaning to Panda; but it is stored
## indefinitely on the node until it is requested again.
##
## Each unique key stores a different string value.  There is no effective
## limit on the number of different keys that may be stored or on the length
## of any one key's value.

proc getTag*(this: NodePath, key: string): string {.importcpp: "nimStringFromStdString(#.get_tag(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Retrieves the user-defined value that was previously set on this node for
## the particular key, if any.  If no value has been previously set, returns
## the empty string.  See also get_net_tag().

proc hasTag*(this: NodePath, key: string): bool {.importcpp: "#.has_tag(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if a value has been defined on this node for the particular
## key (even if that value is the empty string), or false if no value has been
## set.  See also has_net_tag().

proc clearTag*(this: NodePath, key: string) {.importcpp: "#.clear_tag(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes the value defined for this key on this particular node.  After a
## call to clear_tag(), has_tag() will return false for the indicated key.

proc getNetTag*(this: NodePath, key: string): string {.importcpp: "nimStringFromStdString(#.get_net_tag(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Returns the tag value that has been defined on this node, or the nearest
## ancestor node, for the indicated key.  If no value has been defined for the
## indicated key on any ancestor node, returns the empty string.  See also
## get_tag().

proc hasNetTag*(this: NodePath, key: string): bool {.importcpp: "#.has_net_tag(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if the indicated tag value has been defined on this node or on
## any ancestor node, or false otherwise.  See also has_tag().

proc findNetTag*(this: NodePath, key: string): NodePath {.importcpp: "#.find_net_tag(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the lowest ancestor of this node that contains a tag definition
## with the indicated key, if any, or an empty NodePath if no ancestor of this
## node contains this tag definition.  See set_tag().

proc listTags*(this: NodePath) {.importcpp: "#.list_tags()".} ## \
## Lists the tags to the nout stream, one per line.  See
## PandaNode::list_tags() for a variant that allows you to specify the output
## stream.

proc setName*(this: NodePath, name: string) {.importcpp: "#.set_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name of the referenced node.

proc getName*(this: NodePath): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the referenced node.

proc writeBamFile*(this: NodePath, filename: Filename): bool {.importcpp: "#.write_bam_file(#)".} ## \
## Writes the contents of this node and below out to a bam file with the
## indicated filename.  This file may then be read in again, as is, at some
## later point.  Returns true if successful, false on some kind of error.

proc writeBamStream*(this: NodePath, `out`: ostream): bool {.importcpp: "#.write_bam_stream(#)".} ## \
## Writes the contents of this node and below out to the indicated stream.

converter getClassType*(_: typedesc[NodePath]): TypeHandle {.importcpp: "NodePath::get_class_type()", header: "nodePath.h".}

proc addNode*(this: AttribNodeRegistry, attrib_node: NodePath) {.importcpp: "#.add_node(#)".} ## \
## Adds the indicated NodePath to the registry.  The name and type of the node
## are noted at the time of this call; if the name changes later, it will not
## update the registry index.
##
## The NodePath must reference some kind of an attribute node, such as a
## LightNode or a PlaneNode.  When bam files that reference an attribute node
## of the same type and the same name are loaded, they will quietly be
## redirected to reference this NodePath.
##
## If there is already a node matching the indicated name and type, it will be
## replaced.

proc removeNode*(this: AttribNodeRegistry, attrib_node: NodePath): bool {.importcpp: "#.remove_node(#)".} ## \
## Removes the indicated NodePath from the registry.  The name of the node
## must not have changed since the matching call to add_node(), or it will not
## be successfully removed.
##
## Returns true if the NodePath is found and removed, false if it is not found
## (for instance, because the name has changed).

proc removeNode*(this: AttribNodeRegistry, n: int) {.importcpp: "#.remove_node(#)".} ## \
## Removes the nth node from the registry.

proc lookupNode*(this: AttribNodeRegistry, orig_node: NodePath): NodePath {.importcpp: "#.lookup_node(#)".} ## \
## Looks up the indicated NodePath in the registry.  If there is a node
## already in the registry with the matching name and type, returns that
## NodePath instead; otherwise, returns the original NodePath.

proc getNumNodes*(this: AttribNodeRegistry): int {.importcpp: "#.get_num_nodes()".} ## \
## Returns the total number of nodes in the registry.

proc getNode*(this: AttribNodeRegistry, n: int): NodePath {.importcpp: "#.get_node(#)".} ## \
## Returns the nth NodePath recorded in the registry.

proc getNodeType*(this: AttribNodeRegistry, n: int): TypeHandle {.importcpp: "#.get_node_type(#)".} ## \
## Returns the type of the nth node, as recorded in the registry.

proc getNodeName*(this: AttribNodeRegistry, n: int): string {.importcpp: "nimStringFromStdString(#.get_node_name(#))", header: stringConversionCode.} ## \
## Returns the name of the nth node, as recorded in the registry.  This will
## be the node name as it was at the time the node was recorded; if the node
## has changed names since then, this will still return the original name.

proc findNode*(this: AttribNodeRegistry, attrib_node: NodePath): int {.importcpp: "#.find_node(#)".} ## \
## Returns the index number of the indicated NodePath in the registry
## (assuming its name hasn't changed since it was recorded in the registry),
## or -1 if the NodePath cannot be found (for instance, because its name has
## changed).

proc findNode*(this: AttribNodeRegistry, `type`: TypeHandle, name: string): int {.importcpp: "#.find_node(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the index number of the node with the indicated type and name in
## the registry, or -1 if there is no such node in the registry.

proc clear*(this: AttribNodeRegistry) {.importcpp: "#.clear()".} ## \
## Removes all nodes from the registry.

proc output*(this: AttribNodeRegistry, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: AttribNodeRegistry, `out`: ostream) {.importcpp: "#.write(#)".}

proc getGlobalPtr*(_: typedesc[AttribNodeRegistry]): AttribNodeRegistry {.importcpp: "AttribNodeRegistry::get_global_ptr()", header: "attribNodeRegistry.h".}

proc makeIdentity*(_: typedesc[AudioVolumeAttrib]): RenderAttrib {.importcpp: "deconstify(AudioVolumeAttrib::make_identity())", header: "audioVolumeAttrib.h".} ## \
## Constructs an identity audio volume attrib.

proc make*(_: typedesc[AudioVolumeAttrib], volume: float32): RenderAttrib {.importcpp: "deconstify(#AudioVolumeAttrib::make(#))", header: "audioVolumeAttrib.h".} ## \
## Constructs a new AudioVolumeAttrib object that indicates audio volume
## should be scaled by the indicated factor.

proc makeOff*(_: typedesc[AudioVolumeAttrib]): RenderAttrib {.importcpp: "deconstify(AudioVolumeAttrib::make_off())", header: "audioVolumeAttrib.h".} ## \
## Constructs a new AudioVolumeAttrib object that ignores any
## AudioVolumeAttrib inherited from above.  You may also specify an additional
## volume scale to apply to geometry below (using set_volume()).

proc makeDefault*(_: typedesc[AudioVolumeAttrib]): RenderAttrib {.importcpp: "deconstify(AudioVolumeAttrib::make_default())", header: "audioVolumeAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc isOff*(this: AudioVolumeAttrib): bool {.importcpp: "#->is_off()".} ## \
## Returns true if the AudioVolumeAttrib will ignore any color scales
## inherited from above, false otherwise.  This is not the same thing as
## !has_scale(); a AudioVolumeAttrib may have the "off" flag set and also have
## another scale specified.

proc hasVolume*(this: AudioVolumeAttrib): bool {.importcpp: "#->has_volume()".} ## \
## Returns true if the AudioVolumeAttrib has a non-identity volume, false
## otherwise (in which case it might be an off attrib or an identity attrib).

proc getVolume*(this: AudioVolumeAttrib): float32 {.importcpp: "#->get_volume()".} ## \
## Returns the volume to be applied to sounds.

proc setVolume*(this: AudioVolumeAttrib, volume: float32): RenderAttrib {.importcpp: "deconstify(#->set_volume(#))", header: deconstifyCode.} ## \
## Returns a new AudioVolumeAttrib, just like this one, but with the volume
## changed to the indicated value.

proc getClassSlot*(_: typedesc[AudioVolumeAttrib]): int {.importcpp: "AudioVolumeAttrib::get_class_slot()", header: "audioVolumeAttrib.h".}

converter getClassType*(_: typedesc[AudioVolumeAttrib]): TypeHandle {.importcpp: "AudioVolumeAttrib::get_class_type()", header: "audioVolumeAttrib.h".}

proc make*(_: typedesc[AuxBitplaneAttrib]): RenderAttrib {.importcpp: "deconstify(AuxBitplaneAttrib::make())", header: "auxBitplaneAttrib.h".} ## \
## Constructs a default AuxBitplaneAttrib object.

proc make*(_: typedesc[AuxBitplaneAttrib], outputs: int): RenderAttrib {.importcpp: "deconstify(#AuxBitplaneAttrib::make(#))", header: "auxBitplaneAttrib.h".} ## \
## Constructs a specified AuxBitplaneAttrib object.

proc makeDefault*(_: typedesc[AuxBitplaneAttrib]): RenderAttrib {.importcpp: "deconstify(AuxBitplaneAttrib::make_default())", header: "auxBitplaneAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc getOutputs*(this: AuxBitplaneAttrib): int {.importcpp: "#->get_outputs()".} ## \
## Returns the AuxBitplaneAttrib output bits.

proc getClassSlot*(_: typedesc[AuxBitplaneAttrib]): int {.importcpp: "AuxBitplaneAttrib::get_class_slot()", header: "auxBitplaneAttrib.h".}

converter getClassType*(_: typedesc[AuxBitplaneAttrib]): TypeHandle {.importcpp: "AuxBitplaneAttrib::get_class_type()", header: "auxBitplaneAttrib.h".}

proc setDuration*(this: AuxSceneData, duration: float64) {.importcpp: "#->set_duration(#)".} ## \
## Specifies the minimum length in time, in seconds, to keep this AuxSceneData
## object around in the scene graph after the last time it was rendered.

proc getDuration*(this: AuxSceneData): float64 {.importcpp: "#->get_duration()".} ## \
## Returns the minimum length in time, in seconds, to keep this AuxSceneData
## object around in the scene graph after the last time it was rendered.

proc setLastRenderTime*(this: AuxSceneData, render_time: float64) {.importcpp: "#->set_last_render_time(#)".} ## \
## Should be called with the current frame_time each time the AuxSceneData is
## used during traversal.

proc getLastRenderTime*(this: AuxSceneData): float64 {.importcpp: "#->get_last_render_time()".} ## \
## Returns the last time this object was used during traversal (according to
## set_last_render_time()).

proc getExpirationTime*(this: AuxSceneData): float64 {.importcpp: "#->get_expiration_time()".} ## \
## Returns the frame_time at which this AuxSceneData object is currently
## scheduled to be removed from the scene graph.

proc output*(this: AuxSceneData, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: AuxSceneData, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: AuxSceneData, `out`: ostream) {.importcpp: "#->write(#)".}

converter getClassType*(_: typedesc[AuxSceneData]): TypeHandle {.importcpp: "AuxSceneData::get_class_type()", header: "auxSceneData.h".}

proc newAuxSceneData*(param0: AuxSceneData): AuxSceneData {.importcpp: "new AuxSceneData(#)".}

proc initBamFile*(): BamFile {.importcpp: "BamFile()".}

proc openRead*(this: BamFile, bam_filename: Filename, report_errors: bool): bool {.importcpp: "#.open_read(#, #)".} ## \
## Attempts to open the indicated filename for reading.  Returns true if
## successful, false on error.

proc openRead*(this: BamFile, bam_filename: Filename): bool {.importcpp: "#.open_read(#)".} ## \
## Attempts to open the indicated filename for reading.  Returns true if
## successful, false on error.

proc openRead*(this: BamFile, `in`: istream, bam_filename: string, report_errors: bool): bool {.importcpp: "#.open_read(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Attempts to open the indicated stream for reading.  The filename is just
## for information purposes only.  Returns true if successful, false on error.

proc openRead*(this: BamFile, `in`: istream, bam_filename: string): bool {.importcpp: "#.open_read(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Attempts to open the indicated stream for reading.  The filename is just
## for information purposes only.  Returns true if successful, false on error.

proc openRead*(this: BamFile, `in`: istream): bool {.importcpp: "#.open_read(#)".} ## \
## Attempts to open the indicated stream for reading.  The filename is just
## for information purposes only.  Returns true if successful, false on error.

proc readObject*(this: BamFile): TypedWritable {.importcpp: "#.read_object()".} ## \
## Reads and returns the next object from the Bam file, or NULL if the end of
## the file has been reached, or if there is an error condition.  Use is_eof()
## to differentiate these two cases.
##
## The pointers returned by this method will not be valid for use until
## resolve() is subsequently called.

proc isEof*(this: BamFile): bool {.importcpp: "#.is_eof()".} ## \
## Returns true if the reader has reached end-of-file, false otherwise.  This
## call is only valid after a call to read_object().

proc resolve*(this: BamFile): bool {.importcpp: "#.resolve()".} ## \
## This must be called after one or more objects have been read via calls to
## read_object() in order to resolve all internal pointer references in the
## objects read and make all the pointers valid.  It returns true if all
## objects are successfully resolved, or false if some have not been (in which
## case you must call resolve() again later).

proc readNode*(this: BamFile, report_errors: bool): PandaNode {.importcpp: "#.read_node(#)".} ## \
## Although the bam file format is general enough to store a list of objects
## of arbitrary type, bam files on disk usually contain just one object, a
## PandaNode that is the root of a scene graph.  (Bam files that store other
## kinds of things are usually given the extension "boo", for "binary other
## objects", to differentiate them from the normal scene graph type file.)
##
## This is a convenience method for when you believe you are reading a scene
## graph bam file.  It reads the one PandaNode and returns it.  It also calls
## resolve() to fully resolve the object, since we expect this will be the
## only object in the file.
##
## If the bam file contains something other than a PandaNode, an error is
## printed and NULL is returned.

proc readNode*(this: BamFile): PandaNode {.importcpp: "#.read_node()".} ## \
## Although the bam file format is general enough to store a list of objects
## of arbitrary type, bam files on disk usually contain just one object, a
## PandaNode that is the root of a scene graph.  (Bam files that store other
## kinds of things are usually given the extension "boo", for "binary other
## objects", to differentiate them from the normal scene graph type file.)
##
## This is a convenience method for when you believe you are reading a scene
## graph bam file.  It reads the one PandaNode and returns it.  It also calls
## resolve() to fully resolve the object, since we expect this will be the
## only object in the file.
##
## If the bam file contains something other than a PandaNode, an error is
## printed and NULL is returned.

proc openWrite*(this: BamFile, bam_filename: Filename, report_errors: bool): bool {.importcpp: "#.open_write(#, #)".} ## \
## Attempts to open the indicated file for writing.  If another file by the
## same name already exists, it will be silently removed.  Returns true if
## successful, false otherwise.

proc openWrite*(this: BamFile, bam_filename: Filename): bool {.importcpp: "#.open_write(#)".} ## \
## Attempts to open the indicated file for writing.  If another file by the
## same name already exists, it will be silently removed.  Returns true if
## successful, false otherwise.

proc openWrite*(this: BamFile, `out`: ostream, bam_filename: string, report_errors: bool): bool {.importcpp: "#.open_write(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Attempts to open the indicated stream for writing.  The filename is just
## for information purposes only.  Returns true if successful, false on error.

proc openWrite*(this: BamFile, `out`: ostream, bam_filename: string): bool {.importcpp: "#.open_write(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Attempts to open the indicated stream for writing.  The filename is just
## for information purposes only.  Returns true if successful, false on error.

proc openWrite*(this: BamFile, `out`: ostream): bool {.importcpp: "#.open_write(#)".} ## \
## Attempts to open the indicated stream for writing.  The filename is just
## for information purposes only.  Returns true if successful, false on error.

proc writeObject*(this: BamFile, `object`: TypedWritable): bool {.importcpp: "#.write_object(#)".} ## \
## Writes the indicated object to the Bam file.  Returns true if successful,
## false on error.

proc close*(this: BamFile) {.importcpp: "#.close()".} ## \
## Closes the input or output stream.

proc isValidRead*(this: BamFile): bool {.importcpp: "#.is_valid_read()".} ## \
## Returns true if the Bam file is open and ready for reading with no errors
## so far detected, or false otherwise.

proc isValidWrite*(this: BamFile): bool {.importcpp: "#.is_valid_write()".} ## \
## Returns true if the Bam file is open and ready for writing with no errors
## so far detected, or false otherwise.

proc getFileMajorVer*(this: BamFile): int {.importcpp: "#.get_file_major_ver()".} ## \
## Returns the major version number of the file currently being read, or the
## system current major version number if no file is currently open for
## reading.

proc getFileMinorVer*(this: BamFile): int {.importcpp: "#.get_file_minor_ver()".} ## \
## Returns the minor version number of the file currently being read, or the
## system current minor version number if no file is currently open for
## reading.

proc getFileStdfloatDouble*(this: BamFile): bool {.importcpp: "#.get_file_stdfloat_double()".} ## \
## Returns true if the file stores all "standard" floats as 64-bit doubles, or
## false if they are 32-bit floats.

proc getCurrentMajorVer*(this: BamFile): int {.importcpp: "#.get_current_major_ver()".} ## \
## Returns the system current major version number.  This is the version
## number that will be assigned to any generated Bam files.

proc getCurrentMinorVer*(this: BamFile): int {.importcpp: "#.get_current_minor_ver()".} ## \
## Returns the system current minor version number.  This is the version
## number that will be assigned to any generated Bam files.

proc getReader*(this: BamFile): BamReader {.importcpp: "#.get_reader()".} ## \
## Returns the BamReader in charge of performing the read operations.  This
## will return NULL unless open_read() was called.

proc getWriter*(this: BamFile): BamWriter {.importcpp: "#.get_writer()".} ## \
## Returns the BamWriter in charge of performing the write operations.  This
## will return NULL unless open_write() was called.

proc make*(_: typedesc[BillboardEffect], up_vector: LVector3, eye_relative: bool, axial_rotate: bool, offset: float32, look_at: NodePath, look_at_point: LPoint3, fixed_depth: bool): RenderEffect {.importcpp: "deconstify(#BillboardEffect::make(#, #, #, #, #, #, #))", header: "billboardEffect.h".} ## \
## Constructs a new BillboardEffect object with the indicated properties.

proc make*(_: typedesc[BillboardEffect], up_vector: LVector3, eye_relative: bool, axial_rotate: bool, offset: float32, look_at: NodePath, look_at_point: LPoint3): RenderEffect {.importcpp: "deconstify(#BillboardEffect::make(#, #, #, #, #, #))", header: "billboardEffect.h".} ## \
## Constructs a new BillboardEffect object with the indicated properties.

proc makeAxis*(_: typedesc[BillboardEffect]): RenderEffect {.importcpp: "deconstify(BillboardEffect::make_axis())", header: "billboardEffect.h".} ## \
## A convenience function to make a typical axis-rotating billboard.

proc makePointEye*(_: typedesc[BillboardEffect]): RenderEffect {.importcpp: "deconstify(BillboardEffect::make_point_eye())", header: "billboardEffect.h".} ## \
## A convenience function to make a typical eye-relative point-rotating
## billboard.

proc makePointWorld*(_: typedesc[BillboardEffect]): RenderEffect {.importcpp: "deconstify(BillboardEffect::make_point_world())", header: "billboardEffect.h".} ## \
## A convenience function to make a typical world-relative point-rotating
## billboard.

proc isOff*(this: BillboardEffect): bool {.importcpp: "#->is_off()".} ## \
## Returns true if the BillboardEffect is an 'off' BillboardEffect, indicating
## that it does not enable billboarding.  This kind of BillboardEffect isn't
## particularly useful and isn't normally created or stored in the graph; it
## might be implicitly discovered as the result of a
## NodePath::get_rel_state().

proc getUpVector*(this: BillboardEffect): LVector3 {.importcpp: "#->get_up_vector()".} ## \
## Returns the up vector in effect for this billboard.

proc getEyeRelative*(this: BillboardEffect): bool {.importcpp: "#->get_eye_relative()".} ## \
## Returns true if this billboard interprets the up vector relative to the
## camera, or false if it is relative to the world.

proc getAxialRotate*(this: BillboardEffect): bool {.importcpp: "#->get_axial_rotate()".} ## \
## Returns true if this billboard rotates only around the axis of the up
## vector, or false if it rotates freely in three dimensions.

proc getFixedDepth*(this: BillboardEffect): bool {.importcpp: "#->get_fixed_depth()".} ## \
## Returns true if this billboard always appears at a fixed distance from the
## camera.

proc getOffset*(this: BillboardEffect): float32 {.importcpp: "#->get_offset()".} ## \
## Returns the distance toward the camera (or the look_at_point) the billboard
## is moved towards, after rotating.  This can be used to ensure the billboard
## is not obscured by nearby geometry.

proc getLookAt*(this: BillboardEffect): NodePath {.importcpp: "#->get_look_at()".} ## \
## Returns the node this billboard will rotate to look towards.  If this is
## empty, it means the billboard will rotate towards the current camera node,
## wherever that might be.

proc getLookAtPoint*(this: BillboardEffect): LPoint3 {.importcpp: "#->get_look_at_point()".} ## \
## Returns the point, relative to the look_at node, towards which the
## billboard will rotate.  Normally this is (0, 0, 0).

converter getClassType*(_: typedesc[BillboardEffect]): TypeHandle {.importcpp: "BillboardEffect::get_class_type()", header: "billboardEffect.h".}

proc newLensNode*(name: string, lens: Lens): LensNode {.importcpp: "new LensNode(nimStringToStdString(#), #)", header: stringConversionCode.}

proc newLensNode*(name: string): LensNode {.importcpp: "new LensNode(nimStringToStdString(#))", header: stringConversionCode.}

proc copyLens*(this: LensNode, lens: Lens) {.importcpp: "#->copy_lens(#)".} ## \
## Sets up the LensNode using a copy of the indicated Lens.  If the original
## Lens is changed or destroyed, this LensNode is not affected.

proc copyLens*(this: LensNode, index: int, lens: Lens) {.importcpp: "#->copy_lens(#, #)".} ## \
## Copies the indicated lens into the specified slot.

proc setLens*(this: LensNode, lens: Lens) {.importcpp: "#->set_lens(#)".} ## \
## Sets up the LensNode using this particular Lens pointer.  If the lens is
## subsequently modified, the LensNode properties immediately reflect the
## change.

proc setLens*(this: LensNode, index: int, lens: Lens) {.importcpp: "#->set_lens(#, #)".} ## \
## Sets the indicated lens.  Although a LensNode normally holds only one lens,
## it may optionally include multiple lenses, each with a different index
## number.  The different lenses may be referenced by index number on the
## DisplayRegion.  Adding a new lens automatically makes it active.

proc getLens*(this: LensNode, index: int): Lens {.importcpp: "#->get_lens(#)".} ## \
## Returns a pointer to the particular Lens associated with this LensNode, or
## NULL if there is not yet a Lens associated.  If an index number is
## specified, returns the nth lens.

proc getLens*(this: LensNode): Lens {.importcpp: "#->get_lens()".} ## \
## Returns a pointer to the particular Lens associated with this LensNode, or
## NULL if there is not yet a Lens associated.  If an index number is
## specified, returns the nth lens.

proc setLensActive*(this: LensNode, index: int, active: bool): bool {.importcpp: "#->set_lens_active(#, #)".} ## \
## Sets the active flag for the nth lens.  When a lens is inactive, it is not
## used for rendering, and any DisplayRegions associated with it are
## implicitly inactive as well.  Returns true if the flag is changed, false if
## it already had this value.

proc getLensActive*(this: LensNode, index: int): bool {.importcpp: "#->get_lens_active(#)".} ## \
## Returns the active flag for the nth lens.

proc activateLens*(this: LensNode, index: int): bool {.importcpp: "#->activate_lens(#)".} ## \
## An alternate way to call set_lens_active(index, true).

proc deactivateLens*(this: LensNode, index: int): bool {.importcpp: "#->deactivate_lens(#)".} ## \
## An alternate way to call set_lens_active(index, false).

proc isInView*(this: LensNode, pos: LPoint3): bool {.importcpp: "#->is_in_view(#)".} ## \
## Returns true if the given point is within the bounds of the lens of the
## LensNode (i.e.  if the camera can see the point).

proc isInView*(this: LensNode, index: int, pos: LPoint3): bool {.importcpp: "#->is_in_view(#, #)".} ## \
## Returns true if the given point is within the bounds of the lens of the
## LensNode (i.e.  if the camera can see the point).

proc showFrustum*(this: LensNode) {.importcpp: "#->show_frustum()".} ## \
## Enables the drawing of the lens's frustum to aid in visualization.  This
## actually creates a GeomNode which is parented to the LensNode.

proc hideFrustum*(this: LensNode) {.importcpp: "#->hide_frustum()".} ## \
## Disables the drawing of the lens's frustum to aid in visualization.

converter getClassType*(_: typedesc[LensNode]): TypeHandle {.importcpp: "LensNode::get_class_type()", header: "lensNode.h".}

converter initWeakNodePath*(node_path: NodePath): WeakNodePath {.importcpp: "WeakNodePath(#)".}

proc initWeakNodePath*(copy: WeakNodePath): WeakNodePath {.importcpp: "WeakNodePath(#)".}

proc clear*(this: WeakNodePath) {.importcpp: "#.clear()".} ## \
## Sets this NodePath to the empty NodePath.  It will no longer point to any
## node.

proc `typecast bool`*(this: WeakNodePath): bool {.importcpp: "#.operator typecast bool()".}

proc isEmpty*(this: WeakNodePath): bool {.importcpp: "#.is_empty()".} ## \
## Returns true if the NodePath contains no nodes, or if it has been deleted.

proc wasDeleted*(this: WeakNodePath): bool {.importcpp: "#.was_deleted()".} ## \
## Returns true if the NodePath we were referencing has been quietly deleted
## outside of the WeakNodePath.

proc getNodePath*(this: WeakNodePath): NodePath {.importcpp: "#.get_node_path()".} ## \
## Returns the NodePath held within this object, or an empty NodePath with the
## error flag set if the object was deleted.

proc node*(this: WeakNodePath): PandaNode {.importcpp: "#.node()".} ## \
## Returns the PandaNode held within this object, or nullptr if the object was
## deleted.

proc `==`*(this: WeakNodePath, other: NodePath): bool {.importcpp: "#.operator ==(#)".}

proc `==`*(this: WeakNodePath, other: WeakNodePath): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: WeakNodePath, other: NodePath): bool {.importcpp: "#.operator !=(#)".}

proc `!=`*(this: WeakNodePath, other: WeakNodePath): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: WeakNodePath, other: NodePath): bool {.importcpp: "#.operator <(#)".}

proc `<`*(this: WeakNodePath, other: WeakNodePath): bool {.importcpp: "#.operator <(#)".}

proc compareTo*(this: WeakNodePath, other: NodePath): int {.importcpp: "#.compare_to(#)".} ## \
## Returns a number less than zero if this NodePath sorts before the other
## one, greater than zero if it sorts after, or zero if they are equivalent.
##
## Two NodePaths are considered equivalent if they consist of exactly the same
## list of nodes in the same order.  Otherwise, they are different; different
## NodePaths will be ranked in a consistent but undefined ordering; the
## ordering is useful only for placing the NodePaths in a sorted container
## like an STL set.

proc compareTo*(this: WeakNodePath, other: WeakNodePath): int {.importcpp: "#.compare_to(#)".} ## \
## Returns a number less than zero if this WeakNodePath sorts before the other
## one, greater than zero if it sorts after, or zero if they are equivalent.
##
## Two WeakNodePaths are considered equivalent if they consist of exactly the
## same list of nodes in the same order.  Otherwise, they are different;
## different WeakNodePaths will be ranked in a consistent but undefined
## ordering; the ordering is useful only for placing the WeakNodePaths in a
## sorted container like an STL set.

proc getKey*(this: WeakNodePath): int {.importcpp: "#.get_key()".} ## \
## Returns the same values as NodePath::get_key().

proc output*(this: WeakNodePath, `out`: ostream) {.importcpp: "#.output(#)".}

proc newCamera*(copy: Camera): Camera {.importcpp: "new Camera(#)".}

proc newCamera*(name: string, lens: Lens): Camera {.importcpp: "new Camera(nimStringToStdString(#), #)", header: stringConversionCode.}

proc newCamera*(name: string): Camera {.importcpp: "new Camera(nimStringToStdString(#))", header: stringConversionCode.}

proc setActive*(this: Camera, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets the active flag on the camera.  When the camera is not active, nothing
## will be rendered.

proc isActive*(this: Camera): bool {.importcpp: "#->is_active()".} ## \
## Returns the current setting of the active flag on the camera.

proc setScene*(this: Camera, scene: NodePath) {.importcpp: "#->set_scene(#)".} ## \
## Sets the scene that will be rendered by the camera.  This is normally the
## root node of a scene graph, typically a node called 'render', although it
## could represent the root of any subgraph.
##
## Note that the use of this method is now deprecated.  In the absence of an
## explicit scene set on the camera, the camera will render whatever scene it
## is parented into.  This is the preferred way to specify the scene, since it
## is the more intuitive mechanism.

proc getScene*(this: Camera): NodePath {.importcpp: "#->get_scene()".} ## \
## Returns the scene that will be rendered by the camera.  See set_scene().

proc getNumDisplayRegions*(this: Camera): clonglong {.importcpp: "#->get_num_display_regions()".} ## \
## Returns the number of display regions associated with the camera.

proc getDisplayRegion*(this: Camera, n: clonglong): DisplayRegion {.importcpp: "#->get_display_region(#)".} ## \
## Returns the nth display region associated with the camera.

proc setCameraMask*(this: Camera, mask: DrawMask) {.importcpp: "#->set_camera_mask(#)".} ## \
## Changes the set of bits that represent the subset of the scene graph the
## camera will render.
##
## During the cull traversal, a node is not visited if none of its draw mask
## bits intersect with the camera's camera mask bits.  These masks can be used
## to selectively hide and show different parts of the scene graph from
## different cameras that are otherwise viewing the same scene.

proc getCameraMask*(this: Camera): DrawMask {.importcpp: "#->get_camera_mask()".} ## \
## Returns the set of bits that represent the subset of the scene graph the
## camera will render.  See set_camera_mask().

proc setCullCenter*(this: Camera, cull_center: NodePath) {.importcpp: "#->set_cull_center(#)".} ## \
## Specifies the point from which the culling operations are performed.
## Normally, this is the same as the camera, and that is the default if this
## is not specified; but it may sometimes be useful to perform the culling
## from some other viewpoint, particularly when you are debugging the culling
## itself.

proc getCullCenter*(this: Camera): NodePath {.importcpp: "#->get_cull_center()".} ## \
## Returns the point from which the culling operations will be performed, if
## it was set by set_cull_center(), or the empty NodePath otherwise.

proc setCullBounds*(this: Camera, cull_bounds: BoundingVolume) {.importcpp: "#->set_cull_bounds(#)".} ## \
## Specifies the bounding volume that should be used to perform culling from
## this camera.  Normally, this is the bounding volume returned from the
## active lens' make_bounds() call, but you may override this to specify a
## custom volume if you require.  The specified bounding volume will be
## understood to be in the coordinate space of the get_cull_center() node.

proc getCullBounds*(this: Camera): BoundingVolume {.importcpp: "#->get_cull_bounds()".} ## \
## Returns the custom cull volume that was set by set_cull_bounds(), if any,
## or NULL if no custom cull volume was set.

proc setLodCenter*(this: Camera, lod_center: NodePath) {.importcpp: "#->set_lod_center(#)".} ## \
## Specifies the point from which the LOD distances are measured.  Normally,
## this is the same as the camera, and that is the default if this is not
## specified; but it may sometimes be useful to perform the distance test from
## some other viewpoint.  This may be used, for instance, to reduce LOD
## popping when the camera rotates in a small circle about an avatar.

proc getLodCenter*(this: Camera): NodePath {.importcpp: "#->get_lod_center()".} ## \
## Returns the point from which the LOD distances will be measured, if it was
## set by set_lod_center(), or the empty NodePath otherwise.

proc setInitialState*(this: Camera, state: RenderState) {.importcpp: "#->set_initial_state(#)".} ## \
## Sets the initial state which is applied to all nodes in the scene, as if it
## were set at the top of the scene graph.

proc getInitialState*(this: Camera): RenderState {.importcpp: "deconstify(#->get_initial_state())", header: deconstifyCode.} ## \
## Returns the initial state as set by a previous call to set_initial_state().

proc setTagStateKey*(this: Camera, tag_state_key: string) {.importcpp: "#->set_tag_state_key(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the tag key which, when encountered as a tag on nodes in the scene
## graph, causes this Camera to apply an arbitrary state transition based on
## the value of the tag (as specified to set_tag_state()).

proc getTagStateKey*(this: Camera): string {.importcpp: "nimStringFromStdString(#->get_tag_state_key())", header: stringConversionCode.} ## \
## Returns the tag key as set by a previous call to set_tag_state_key().

proc setLodScale*(this: Camera, value: float32) {.importcpp: "#->set_lod_scale(#)".} ## \
## Sets the multiplier for LOD distances.  This value is multiplied with the
## LOD scale set on LodNodes.

proc getLodScale*(this: Camera): float32 {.importcpp: "#->get_lod_scale()".} ## \
## Returns the multiplier for LOD distances.

proc setTagState*(this: Camera, tag_state: string, state: RenderState) {.importcpp: "#->set_tag_state(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Associates a particular state transition with the indicated tag value.
## When a node is encountered during traversal with the tag key specified by
## set_tag_state_key(), if the value of that tag matches tag_state, then the
## indicated state is applied to this node--but only when it is rendered by
## this camera.
##
## This can be used to apply special effects to nodes when they are rendered
## by certain cameras.  It is particularly useful for multipass rendering, in
## which specialty cameras might be needed to render the scene with a
## particular set of effects.

proc clearTagState*(this: Camera, tag_state: string) {.importcpp: "#->clear_tag_state(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes the association established by a previous call to set_tag_state().

proc clearTagStates*(this: Camera) {.importcpp: "#->clear_tag_states()".} ## \
## Removes all associations established by previous calls to set_tag_state().

proc hasTagState*(this: Camera, tag_state: string): bool {.importcpp: "#->has_tag_state(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if set_tag_state() has previously been called with the
## indicated tag state, false otherwise.

proc getTagState*(this: Camera, tag_state: string): RenderState {.importcpp: "deconstify(#->get_tag_state(nimStringToStdString(#)))", header: deconstifyCode.} ## \
## Returns the state associated with the indicated tag state by a previous
## call to set_tag_state(), or the empty state if nothing has been associated.

proc setAuxSceneData*(this: Camera, node_path: NodePath, data: AuxSceneData) {.importcpp: "#->set_aux_scene_data(#, #)".} ## \
## Associates the indicated AuxSceneData object with the given NodePath,
## possibly replacing a previous data defined for the same NodePath, if any.

proc clearAuxSceneData*(this: Camera, node_path: NodePath): bool {.importcpp: "#->clear_aux_scene_data(#)".} ## \
## Removes the AuxSceneData associated with the indicated NodePath.  Returns
## true if it is removed successfully, false if it was already gone.

proc getAuxSceneData*(this: Camera, node_path: NodePath): AuxSceneData {.importcpp: "#->get_aux_scene_data(#)".} ## \
## Returns the AuxSceneData associated with the indicated NodePath, or NULL if
## nothing is associated.

proc listAuxSceneData*(this: Camera, `out`: ostream) {.importcpp: "#->list_aux_scene_data(#)".} ## \
## Outputs all of the NodePaths and AuxSceneDatas in use.

proc cleanupAuxSceneData*(this: Camera, current_thread: Thread): int {.importcpp: "#->cleanup_aux_scene_data(#)".} ## \
## Walks through the list of currently-assigned AuxSceneData objects and
## releases any that are past their expiration times.  Returns the number of
## elements released.

proc cleanupAuxSceneData*(this: Camera): int {.importcpp: "#->cleanup_aux_scene_data()".} ## \
## Walks through the list of currently-assigned AuxSceneData objects and
## releases any that are past their expiration times.  Returns the number of
## elements released.

converter getClassType*(_: typedesc[Camera]): TypeHandle {.importcpp: "Camera::get_class_type()", header: "camera.h".}

proc newPlaneNode*(name: string, plane: LPlane): PlaneNode {.importcpp: "new PlaneNode(nimStringToStdString(#), #)", header: stringConversionCode.}

proc newPlaneNode*(name: string): PlaneNode {.importcpp: "new PlaneNode(nimStringToStdString(#))", header: stringConversionCode.}

proc setPlane*(this: PlaneNode, plane: LPlane) {.importcpp: "#->set_plane(#)".} ## \
## Sets the particular plane represented by the PlaneNode.

proc getPlane*(this: PlaneNode): LPlane {.importcpp: "#->get_plane()".} ## \
## Returns the plane represented by the PlaneNode.

proc setVizScale*(this: PlaneNode, viz_scale: float32) {.importcpp: "#->set_viz_scale(#)".} ## \
## Specifies the size of the visual representation of the plane that is drawn
## if the PlaneNode is shown.

proc getVizScale*(this: PlaneNode): float32 {.importcpp: "#->get_viz_scale()".} ## \
## Returns the size of the visual representation of the plane that is drawn if
## the PlaneNode is shown.

proc setPriority*(this: PlaneNode, priority: int) {.importcpp: "#->set_priority(#)".} ## \
## Changes the relative importance of this PlaneNode (when it is used as a
## clip plane) relative to the other clip planes that are applied
## simultaneously.
##
## The priority number is used to decide which of the requested clip planes
## are to be activated when more clip planes are requested than the hardware
## will support.  The highest-priority n planes are selected for rendering.
##
## This is similar to TextureStage::set_priority().

proc getPriority*(this: PlaneNode): int {.importcpp: "#->get_priority()".} ## \
## Returns the priority associated with this clip plane.  See set_priority().

proc setClipEffect*(this: PlaneNode, clip_effect: int) {.importcpp: "#->set_clip_effect(#)".} ## \
## Specifies the sort of things this plane will actually clip (when it is used
## as a clip plane).  This is a bitmask union of ClipEffect values.  If it
## includes CE_visible, then it will clip visible geometry; if it includes
## CE_collision, then it will clip collision polygons.  If it includes neither
## bit, it will still affect culling, but objects will either be wholly behind
## the clipping plane, or wholly present.

proc getClipEffect*(this: PlaneNode): int {.importcpp: "#->get_clip_effect()".} ## \
## Returns the clip_effect bits for this clip plane.  See set_clip_effect().

converter getClassType*(_: typedesc[PlaneNode]): TypeHandle {.importcpp: "PlaneNode::get_class_type()", header: "planeNode.h".}

proc make*(_: typedesc[ClipPlaneAttrib]): RenderAttrib {.importcpp: "deconstify(ClipPlaneAttrib::make())", header: "clipPlaneAttrib.h".} ## \
## The following is the new, more general interface to the ClipPlaneAttrib.

proc makeDefault*(_: typedesc[ClipPlaneAttrib]): RenderAttrib {.importcpp: "deconstify(ClipPlaneAttrib::make_default())", header: "clipPlaneAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc getNumPlanes*(this: ClipPlaneAttrib): int {.importcpp: "#->get_num_planes()".} ## \
## Returns the number of planes listed in the attribute.
##
## @deprecated ClipPlaneAttribs nowadays have a separate list of on_planes and
## off_planes, so this method no longer makes sense.  Query the lists
## independently.

proc getPlane*(this: ClipPlaneAttrib, n: int): PlaneNode {.importcpp: "#->get_plane(#)".} ## \
## Returns the nth plane listed in the attribute.
##
## @deprecated ClipPlaneAttribs nowadays have a separate list of on_planes and
## off_planes, so this method no longer makes sense.  Query the lists
## independently.

proc hasPlane*(this: ClipPlaneAttrib, plane: PlaneNode): bool {.importcpp: "#->has_plane(#)".} ## \
## Returns true if the indicated plane is listed in the attrib, false
## otherwise.
##
## @deprecated ClipPlaneAttribs nowadays have a separate list of on_planes and
## off_planes, so this method no longer makes sense.  Query the lists
## independently.

proc addPlane*(this: ClipPlaneAttrib, plane: PlaneNode): RenderAttrib {.importcpp: "deconstify(#->add_plane(#))", header: deconstifyCode.} ## \
## Returns a new ClipPlaneAttrib, just like this one, but with the indicated
## plane added to the list of planes.
##
## @deprecated Use add_on_plane() or add_off_plane() instead.

proc removePlane*(this: ClipPlaneAttrib, plane: PlaneNode): RenderAttrib {.importcpp: "deconstify(#->remove_plane(#))", header: deconstifyCode.} ## \
## Returns a new ClipPlaneAttrib, just like this one, but with the indicated
## plane removed from the list of planes.
##
## @deprecated Use remove_on_plane() or remove_off_plane() instead.

proc makeAllOff*(_: typedesc[ClipPlaneAttrib]): RenderAttrib {.importcpp: "deconstify(ClipPlaneAttrib::make_all_off())", header: "clipPlaneAttrib.h".} ## \
## Constructs a new ClipPlaneAttrib object that disables all planes (and hence
## disables clipping).

proc getNumOnPlanes*(this: ClipPlaneAttrib): int {.importcpp: "#->get_num_on_planes()".} ## \
## Returns the number of planes that are enabled by the attribute.

proc getOnPlane*(this: ClipPlaneAttrib, n: int): NodePath {.importcpp: "#->get_on_plane(#)".} ## \
## Returns the nth plane enabled by the attribute, sorted in render order.

proc hasOnPlane*(this: ClipPlaneAttrib, plane: NodePath): bool {.importcpp: "#->has_on_plane(#)".} ## \
## Returns true if the indicated plane is enabled by the attrib, false
## otherwise.

proc getNumOffPlanes*(this: ClipPlaneAttrib): int {.importcpp: "#->get_num_off_planes()".} ## \
## Returns the number of planes that are disabled by the attribute.

proc getOffPlane*(this: ClipPlaneAttrib, n: int): NodePath {.importcpp: "#->get_off_plane(#)".} ## \
## Returns the nth plane disabled by the attribute, sorted in arbitrary
## (pointer) order.

proc hasOffPlane*(this: ClipPlaneAttrib, plane: NodePath): bool {.importcpp: "#->has_off_plane(#)".} ## \
## Returns true if the indicated plane is disabled by the attrib, false
## otherwise.

proc hasAllOff*(this: ClipPlaneAttrib): bool {.importcpp: "#->has_all_off()".} ## \
## Returns true if this attrib disables all planes (although it may also
## enable some).

proc isIdentity*(this: ClipPlaneAttrib): bool {.importcpp: "#->is_identity()".} ## \
## Returns true if this is an identity attrib: it does not change the set of
## planes in use.

proc addOnPlane*(this: ClipPlaneAttrib, plane: NodePath): RenderAttrib {.importcpp: "deconstify(#->add_on_plane(#))", header: deconstifyCode.} ## \
## Returns a new ClipPlaneAttrib, just like this one, but with the indicated
## plane added to the list of planes enabled by this attrib.

proc removeOnPlane*(this: ClipPlaneAttrib, plane: NodePath): RenderAttrib {.importcpp: "deconstify(#->remove_on_plane(#))", header: deconstifyCode.} ## \
## Returns a new ClipPlaneAttrib, just like this one, but with the indicated
## plane removed from the list of planes enabled by this attrib.

proc addOffPlane*(this: ClipPlaneAttrib, plane: NodePath): RenderAttrib {.importcpp: "deconstify(#->add_off_plane(#))", header: deconstifyCode.} ## \
## Returns a new ClipPlaneAttrib, just like this one, but with the indicated
## plane added to the list of planes disabled by this attrib.

proc removeOffPlane*(this: ClipPlaneAttrib, plane: NodePath): RenderAttrib {.importcpp: "deconstify(#->remove_off_plane(#))", header: deconstifyCode.} ## \
## Returns a new ClipPlaneAttrib, just like this one, but with the indicated
## plane removed from the list of planes disabled by this attrib.

proc filterToMax*(this: ClipPlaneAttrib, max_clip_planes: int): ClipPlaneAttrib {.importcpp: "deconstify(#->filter_to_max(#))", header: deconstifyCode.} ## \
## Returns a new ClipPlaneAttrib, very much like this one, but with the number
## of on_planes reduced to be no more than max_clip_planes.  The number of
## off_planes in the new ClipPlaneAttrib is undefined.

proc getClassSlot*(_: typedesc[ClipPlaneAttrib]): int {.importcpp: "ClipPlaneAttrib::get_class_slot()", header: "clipPlaneAttrib.h".}

converter getClassType*(_: typedesc[ClipPlaneAttrib]): TypeHandle {.importcpp: "ClipPlaneAttrib::get_class_type()", header: "clipPlaneAttrib.h".}

proc makeVertex*(_: typedesc[ColorAttrib]): RenderAttrib {.importcpp: "deconstify(ColorAttrib::make_vertex())", header: "colorAttrib.h".} ## \
## Constructs a new ColorAttrib object that indicates geometry should be
## rendered according to its own vertex color.

proc makeFlat*(_: typedesc[ColorAttrib], color: LColor): RenderAttrib {.importcpp: "deconstify(#ColorAttrib::make_flat(#))", header: "colorAttrib.h".} ## \
## Constructs a new ColorAttrib object that indicates geometry should be
## rendered in the indicated color.

proc makeOff*(_: typedesc[ColorAttrib]): RenderAttrib {.importcpp: "deconstify(ColorAttrib::make_off())", header: "colorAttrib.h".} ## \
## Constructs a new ColorAttrib object that indicates geometry should be
## rendered in white.

proc makeDefault*(_: typedesc[ColorAttrib]): RenderAttrib {.importcpp: "deconstify(ColorAttrib::make_default())", header: "colorAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc getColor*(this: ColorAttrib): LColor {.importcpp: "#->get_color()".} ## \
## If the type is T_flat or T_off, this returns the color that will be applied
## to geometry.  If the type is T_vertex, this is meaningless.

proc getClassSlot*(_: typedesc[ColorAttrib]): int {.importcpp: "ColorAttrib::get_class_slot()", header: "colorAttrib.h".}

converter getClassType*(_: typedesc[ColorAttrib]): TypeHandle {.importcpp: "ColorAttrib::get_class_type()", header: "colorAttrib.h".}

proc makeOff*(_: typedesc[ColorBlendAttrib]): RenderAttrib {.importcpp: "deconstify(ColorBlendAttrib::make_off())", header: "colorBlendAttrib.h".} ## \
## Constructs a new ColorBlendAttrib object that disables special-effect
## blending, allowing normal transparency to be used instead.

proc makeDefault*(_: typedesc[ColorBlendAttrib]): RenderAttrib {.importcpp: "deconstify(ColorBlendAttrib::make_default())", header: "colorBlendAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc getColor*(this: ColorBlendAttrib): LColor {.importcpp: "#->get_color()".} ## \
## Returns the constant color associated with the attrib.

proc involvesConstantColor*(this: ColorBlendAttrib): bool {.importcpp: "#->involves_constant_color()".} ## \
## Returns true if the this attrib uses the constant color, false otherwise.

proc involvesColorScale*(this: ColorBlendAttrib): bool {.importcpp: "#->involves_color_scale()".} ## \
## Returns true if the this attrib uses the color scale attrib, false
## otherwise.

proc getClassSlot*(_: typedesc[ColorBlendAttrib]): int {.importcpp: "ColorBlendAttrib::get_class_slot()", header: "colorBlendAttrib.h".}

converter getClassType*(_: typedesc[ColorBlendAttrib]): TypeHandle {.importcpp: "ColorBlendAttrib::get_class_type()", header: "colorBlendAttrib.h".}

proc makeIdentity*(_: typedesc[ColorScaleAttrib]): RenderAttrib {.importcpp: "deconstify(ColorScaleAttrib::make_identity())", header: "colorScaleAttrib.h".} ## \
## Constructs an identity scale attrib.

proc make*(_: typedesc[ColorScaleAttrib], scale: LVecBase4): RenderAttrib {.importcpp: "deconstify(#ColorScaleAttrib::make(#))", header: "colorScaleAttrib.h".} ## \
## Constructs a new ColorScaleAttrib object that indicates geometry should be
## scaled by the indicated factor.

proc makeOff*(_: typedesc[ColorScaleAttrib]): RenderAttrib {.importcpp: "deconstify(ColorScaleAttrib::make_off())", header: "colorScaleAttrib.h".} ## \
## Constructs a new ColorScaleAttrib object that ignores any ColorScaleAttrib
## inherited from above.  You may also specify an additional color scale to
## apply to geometry below (using set_scale()).

proc makeDefault*(_: typedesc[ColorScaleAttrib]): RenderAttrib {.importcpp: "deconstify(ColorScaleAttrib::make_default())", header: "colorScaleAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc isOff*(this: ColorScaleAttrib): bool {.importcpp: "#->is_off()".} ## \
## Returns true if the ColorScaleAttrib will ignore any color scales inherited
## from above, false otherwise.  This is not the same thing as !has_scale(); a
## ColorScaleAttrib may have the "off" flag set and also have another scale
## specified.

proc isIdentity*(this: ColorScaleAttrib): bool {.importcpp: "#->is_identity()".} ## \
## Returns true if the ColorScaleAttrib is an identity attrib, false if it is
## either an off attrib or it has a scale.

proc hasScale*(this: ColorScaleAttrib): bool {.importcpp: "#->has_scale()".} ## \
## Returns true if the ColorScaleAttrib has a non-identity scale, false
## otherwise (in which case it might be an off attrib or an identity attrib).

proc hasRgbScale*(this: ColorScaleAttrib): bool {.importcpp: "#->has_rgb_scale()".} ## \
## Returns true if the ColorScaleAttrib has a non-identity scale in the RGB
## components (ignoring alpha), or false otherwise.

proc hasAlphaScale*(this: ColorScaleAttrib): bool {.importcpp: "#->has_alpha_scale()".} ## \
## Returns true if the ColorScaleAttrib has a non-identity scale in the alpha
## component (ignoring RGB), or false otherwise.

proc getScale*(this: ColorScaleAttrib): LVecBase4 {.importcpp: "#->get_scale()".} ## \
## Returns the scale to be applied to colors.

proc setScale*(this: ColorScaleAttrib, scale: LVecBase4): RenderAttrib {.importcpp: "deconstify(#->set_scale(#))", header: deconstifyCode.} ## \
## Returns a new ColorScaleAttrib, just like this one, but with the scale
## changed to the indicated value.

proc getClassSlot*(_: typedesc[ColorScaleAttrib]): int {.importcpp: "ColorScaleAttrib::get_class_slot()", header: "colorScaleAttrib.h".}

converter getClassType*(_: typedesc[ColorScaleAttrib]): TypeHandle {.importcpp: "ColorScaleAttrib::get_class_type()", header: "colorScaleAttrib.h".}

proc make*(_: typedesc[ColorWriteAttrib], channels: int): RenderAttrib {.importcpp: "deconstify(#ColorWriteAttrib::make(#))", header: "colorWriteAttrib.h".} ## \
## Constructs a new ColorWriteAttrib object.

proc makeDefault*(_: typedesc[ColorWriteAttrib]): RenderAttrib {.importcpp: "deconstify(ColorWriteAttrib::make_default())", header: "colorWriteAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc getChannels*(this: ColorWriteAttrib): int {.importcpp: "#->get_channels()".} ## \
## Returns the mask of color channels that are enabled by this attrib.

proc getClassSlot*(_: typedesc[ColorWriteAttrib]): int {.importcpp: "ColorWriteAttrib::get_class_slot()", header: "colorWriteAttrib.h".}

converter getClassType*(_: typedesc[ColorWriteAttrib]): TypeHandle {.importcpp: "ColorWriteAttrib::get_class_type()", header: "colorWriteAttrib.h".}

proc make*(_: typedesc[CompassEffect], reference: NodePath, properties: int): RenderEffect {.importcpp: "deconstify(#CompassEffect::make(#, #))", header: "compassEffect.h".} ## \
## Constructs a new CompassEffect object.  If the reference is an empty
## NodePath, it means the CompassEffect is relative to the root of the scene
## graph; otherwise, it's relative to the indicated node.  The properties
## bitmask specifies the set of properties that the compass node inherits from
## the reference instead of from its parent.

proc make*(_: typedesc[CompassEffect], reference: NodePath): RenderEffect {.importcpp: "deconstify(#CompassEffect::make(#))", header: "compassEffect.h".} ## \
## Constructs a new CompassEffect object.  If the reference is an empty
## NodePath, it means the CompassEffect is relative to the root of the scene
## graph; otherwise, it's relative to the indicated node.  The properties
## bitmask specifies the set of properties that the compass node inherits from
## the reference instead of from its parent.

proc getReference*(this: CompassEffect): NodePath {.importcpp: "#->get_reference()".} ## \
## Returns the reference node from which the CompassEffect inherits its
## transform.  If this is empty, it means the root of the scene graph.

proc getProperties*(this: CompassEffect): int {.importcpp: "#->get_properties()".} ## \
## Returns the bitmask of properties that this CompassEffect object inherits
## from its reference node (or from the root).

converter getClassType*(_: typedesc[CompassEffect]): TypeHandle {.importcpp: "CompassEffect::get_class_type()", header: "compassEffect.h".}

proc initCullBinEnums*(): CullBinEnums {.importcpp: "CullBinEnums()".}

proc initCullBinEnums*(param0: CullBinEnums): CullBinEnums {.importcpp: "CullBinEnums(#)".}

proc newGeomNode*(name: string): GeomNode {.importcpp: "new GeomNode(nimStringToStdString(#))", header: stringConversionCode.}

proc setPreserved*(this: GeomNode, value: bool) {.importcpp: "#->set_preserved(#)".} ## \
## Sets the "preserved" flag.  When this is true, the GeomNode will be left
## untouched by any flatten operations.

proc getPreserved*(this: GeomNode): bool {.importcpp: "#->get_preserved()".} ## \
## Returns the "preserved" flag.  When this is true, the GeomNode will be left
## untouched by any flatten operations.

proc getNumGeoms*(this: GeomNode): int {.importcpp: "#->get_num_geoms()".} ## \
## Returns the number of geoms in the node.

proc getGeom*(this: GeomNode, n: int): Geom {.importcpp: "deconstify(#->get_geom(#))", header: deconstifyCode.} ## \
## Returns the nth geom of the node.  This object should not be modified,
## since the same object might be shared between multiple different GeomNodes,
## but see modify_geom().

proc modifyGeom*(this: GeomNode, n: int): Geom {.importcpp: "#->modify_geom(#)".} ## \
## Returns the nth geom of the node, suitable for modifying it.  If the nth
## Geom has multiple reference counts to it, reassigns it to an identical copy
## first, and returns the new copy--this provides a "copy on write" that
## ensures that the Geom that is returned is unique to this GeomNode and is
## not shared with any other GeomNodes.
##
## Note that if this method is called in a downstream stage (for instance,
## during cull or draw), then it will propagate the new list of Geoms upstream
## all the way to pipeline stage 0, which may step on changes that were made
## independently in pipeline stage 0. Use with caution.

proc getGeomState*(this: GeomNode, n: int): RenderState {.importcpp: "deconstify(#->get_geom_state(#))", header: deconstifyCode.} ## \
## Returns the RenderState associated with the nth geom of the node.  This is
## just the RenderState directly associated with the Geom; the actual state in
## which the Geom is rendered will also be affected by RenderStates that
## appear on the scene graph in nodes above this GeomNode.

proc setGeomState*(this: GeomNode, n: int, state: RenderState) {.importcpp: "#->set_geom_state(#, #)".} ## \
## Changes the RenderState associated with the nth geom of the node.  This is
## just the RenderState directly associated with the Geom; the actual state in
## which the Geom is rendered will also be affected by RenderStates that
## appear on the scene graph in nodes above this GeomNode.
##
## Note that if this method is called in a downstream stage (for instance,
## during cull or draw), then it will propagate the new list of Geoms upstream
## all the way to pipeline stage 0, which may step on changes that were made
## independently in pipeline stage 0. Use with caution.

proc addGeom*(this: GeomNode, geom: Geom, state: RenderState) {.importcpp: "#->add_geom(#, #)".} ## \
## Adds a new Geom to the node.  The geom is given the indicated state (which
## may be RenderState::make_empty(), to completely inherit its state from the
## scene graph).

proc addGeom*(this: GeomNode, geom: Geom) {.importcpp: "#->add_geom(#)".} ## \
## Adds a new Geom to the node.  The geom is given the indicated state (which
## may be RenderState::make_empty(), to completely inherit its state from the
## scene graph).

proc addGeomsFrom*(this: GeomNode, other: GeomNode) {.importcpp: "#->add_geoms_from(#)".} ## \
## Copies the Geoms (and their associated RenderStates) from the indicated
## GeomNode into this one.

proc setGeom*(this: GeomNode, n: int, geom: Geom) {.importcpp: "#->set_geom(#, #)".} ## \
## Replaces the nth Geom of the node with a new pointer.  There must already
## be a Geom in this slot.
##
## Note that if this method is called in a downstream stage (for instance,
## during cull or draw), then it will propagate the new list of Geoms upstream
## all the way to pipeline stage 0, which may step on changes that were made
## independently in pipeline stage 0. Use with caution.

proc removeGeom*(this: GeomNode, n: int) {.importcpp: "#->remove_geom(#)".} ## \
## Removes the nth geom from the node.

proc removeAllGeoms*(this: GeomNode) {.importcpp: "#->remove_all_geoms()".} ## \
## Removes all the geoms from the node at once.

proc checkValid*(this: GeomNode): bool {.importcpp: "#->check_valid()".} ## \
## Verifies that the each Geom within the GeomNode reference vertices that
## actually exist within its GeomVertexData.  Returns true if the GeomNode
## appears to be valid, false otherwise.

proc decompose*(this: GeomNode) {.importcpp: "#->decompose()".} ## \
## Calls decompose() on each Geom with the GeomNode.  This decomposes higher-
## order primitive types, like triangle strips, into lower-order types like
## indexed triangles.  Normally there is no reason to do this, but it can be
## useful as an early preprocessing step, to allow a later call to unify() to
## proceed more quickly.
##
## See also SceneGraphReducer::decompose(), which is the normal way this is
## called.

proc unify*(this: GeomNode, max_indices: int, preserve_order: bool) {.importcpp: "#->unify(#, #)".} ## \
## Attempts to unify all of the Geoms contained within this node into a single
## Geom, or at least as few Geoms as possible.  In turn, the individual
## GeomPrimitives contained within each resulting Geom are also unified.  The
## goal is to reduce the number of GeomPrimitives within the node as far as
## possible.  This may result in composite primitives, such as triangle strips
## and triangle fans, being decomposed into triangles.  See also
## Geom::unify().
##
## max_indices represents the maximum number of indices that will be put in
## any one GeomPrimitive.  If preserve_order is true, then the primitives will
## not be reordered during the operation, even if this results in a suboptimal
## result.
##
## In order for this to be successful, the primitives must reference the same
## GeomVertexData, have the same fundamental primitive type, and have
## compatible shade models.

proc writeGeoms*(this: GeomNode, `out`: ostream, indent_level: int) {.importcpp: "#->write_geoms(#, #)".} ## \
## Writes a short description of all the Geoms in the node.

proc writeVerbose*(this: GeomNode, `out`: ostream, indent_level: int) {.importcpp: "#->write_verbose(#, #)".} ## \
## Writes a detailed description of all the Geoms in the node.

proc getDefaultCollideMask*(_: typedesc[GeomNode]): CollideMask {.importcpp: "GeomNode::get_default_collide_mask()", header: "geomNode.h".} ## \
## Returns the default into_collide_mask assigned to new GeomNodes.

converter getClassType*(_: typedesc[GeomNode]): TypeHandle {.importcpp: "GeomNode::get_class_type()", header: "geomNode.h".}

proc make*(_: typedesc[CullBinAttrib], bin_name: string, draw_order: int): RenderAttrib {.importcpp: "deconstify(#CullBinAttrib::make(nimStringToStdString(#), #))", header: "cullBinAttrib.h".} ## \
## Constructs a new CullBinAttrib assigning geometry into the named bin.  If
## the bin name is the empty string, the default bin is used.
##
## The draw_order specifies further ordering information which is relevant
## only to certain kinds of bins (in particular CullBinFixed type bins).

proc makeDefault*(_: typedesc[CullBinAttrib]): RenderAttrib {.importcpp: "deconstify(CullBinAttrib::make_default())", header: "cullBinAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc getBinName*(this: CullBinAttrib): string {.importcpp: "nimStringFromStdString(#->get_bin_name())", header: stringConversionCode.} ## \
## Returns the name of the bin this attribute specifies.  If this is the empty
## string, it refers to the default bin.

proc getDrawOrder*(this: CullBinAttrib): int {.importcpp: "#->get_draw_order()".} ## \
## Returns the draw order this attribute specifies.  Some bins (in particular,
## CullBinFixed bins) use this to further specify the order in which objects
## should be rendered.

proc getClassSlot*(_: typedesc[CullBinAttrib]): int {.importcpp: "CullBinAttrib::get_class_slot()", header: "cullBinAttrib.h".}

converter getClassType*(_: typedesc[CullBinAttrib]): TypeHandle {.importcpp: "CullBinAttrib::get_class_type()", header: "cullBinAttrib.h".}

proc removeBin*(this: CullBinManager, bin_index: int) {.importcpp: "#.remove_bin(#)".} ## \
## Permanently removes the indicated bin.  This operation is not protected
## from the pipeline and will disturb whatever is currently rendering in draw.
## You should not call this during the normal course of rendering a frame; it
## is intended only as an aid to development, to allow the developer to
## interactively fiddle with the set of bins.

proc getNumBins*(this: CullBinManager): int {.importcpp: "#.get_num_bins()".} ## \
## Returns the number of bins in the world.

proc getBin*(this: CullBinManager, n: int): int {.importcpp: "#.get_bin(#)".} ## \
## Returns the bin_index of the nth bin in the set, where n is a number
## between 0 and get_num_bins(). This returns the list of bin_index numbers,
## in sorted order (that is, in the order in which the bins should be
## rendered).

proc findBin*(this: CullBinManager, name: string): int {.importcpp: "#.find_bin(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the bin_index associated with the bin of the given name, or -1 if
## no bin has that name.

proc getBinName*(this: CullBinManager, bin_index: int): string {.importcpp: "nimStringFromStdString(#.get_bin_name(#))", header: stringConversionCode.} ## \
## Returns the name of the bin with the indicated bin_index (where bin_index
## was retrieved by get_bin() or find_bin()).  The bin's name may not be
## changed during the life of the bin.

proc getBinSort*(this: CullBinManager, bin_index: int): int {.importcpp: "#.get_bin_sort(#)".} ## \
## Returns the sort order of the bin with the indicated bin_index (where
## bin_index was retrieved by get_bin() or find_bin()).
##
## The bins are rendered in increasing order by their sort order; this number
## may be changed from time to time to reorder the bins.

proc getBinSort*(this: CullBinManager, name: string): int {.importcpp: "#.get_bin_sort(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the sort order of the bin with the indicated name.
##
## The bins are rendered in increasing order by their sort order; this number
## may be changed from time to time to reorder the bins.

proc setBinSort*(this: CullBinManager, bin_index: int, sort: int) {.importcpp: "#.set_bin_sort(#, #)".} ## \
## Changes the sort order of the bin with the indicated bin_index (where
## bin_index was retrieved by get_bin() or find_bin()).
##
## The bins are rendered in increasing order by their sort order; this number
## may be changed from time to time to reorder the bins.

proc setBinSort*(this: CullBinManager, name: string, sort: int) {.importcpp: "#.set_bin_sort(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Changes the sort order of the bin with the indicated name.
##
## The bins are rendered in increasing order by their sort order; this number
## may be changed from time to time to reorder the bins.

proc getBinActive*(this: CullBinManager, bin_index: int): bool {.importcpp: "#.get_bin_active(#)".} ## \
## Returns the active flag of the bin with the indicated bin_index (where
## bin_index was retrieved by get_bin() or find_bin()).
##
## When a bin is marked inactive, all geometry assigned to it is not rendered.

proc getBinActive*(this: CullBinManager, name: string): bool {.importcpp: "#.get_bin_active(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the active flag of the bin with the indicated name.
##
## When a bin is marked inactive, all geometry assigned to it is not rendered.

proc setBinActive*(this: CullBinManager, bin_index: int, active: bool) {.importcpp: "#.set_bin_active(#, #)".} ## \
## Changes the active flag of the bin with the indicated bin_index (where
## bin_index was retrieved by get_bin() or find_bin()).
##
## When a bin is marked inactive, all geometry assigned to it is not rendered.

proc setBinActive*(this: CullBinManager, name: string, active: bool) {.importcpp: "#.set_bin_active(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Changes the active flag of the bin with the indicated name.
##
## When a bin is marked inactive, all geometry assigned to it is not rendered.

proc getBinFlashActive*(this: CullBinManager, bin_index: int): bool {.importcpp: "#.get_bin_flash_active(#)".} ## \
## Returns true if the bin with the given bin_index is configured to flash at
## a predetermined color (where bin_index was retrieved by get_bin() or
## find_bin()).
##
## This method is not available in release builds.

proc getBinFlashColor*(this: CullBinManager, bin_index: int): LColor {.importcpp: "#.get_bin_flash_color(#)".} ## \
## Returns the color that this bin has been configured to flash to, if
## configured.
##
## This method is not available in release builds.

proc setBinFlashActive*(this: CullBinManager, bin_index: int, active: bool) {.importcpp: "#.set_bin_flash_active(#, #)".} ## \
## When set to true, the given bin_index is configured to flash at a
## predetermined color (where bin_index was retrieved by get_bin() or
## find_bin()).
##
## This method is not available in release builds.

proc setBinFlashColor*(this: CullBinManager, bin_index: int, color: LColor) {.importcpp: "#.set_bin_flash_color(#, #)".} ## \
## Changes the flash color for the given bin index.
##
## This method is not available in release builds.

proc write*(this: CullBinManager, `out`: ostream) {.importcpp: "#.write(#)".}

proc getGlobalPtr*(_: typedesc[CullBinManager]): CullBinManager {.importcpp: "CullBinManager::get_global_ptr()", header: "cullBinManager.h".} ## \
## Returns the pointer to the global CullBinManager object.

proc make*(_: typedesc[CullFaceAttrib]): RenderAttrib {.importcpp: "deconstify(CullFaceAttrib::make())", header: "cullFaceAttrib.h".} ## \
## Constructs a new CullFaceAttrib object that specifies how to cull geometry.
## By Panda convention, vertices are ordered counterclockwise when seen from
## the front, so the M_cull_clockwise will cull backfacing polygons.
##
## M_cull_unchanged is an identity attrib; if this is applied to vertices
## without any other intervening attrib, it is the same as applying the
## default attrib.

proc makeReverse*(_: typedesc[CullFaceAttrib]): RenderAttrib {.importcpp: "deconstify(CullFaceAttrib::make_reverse())", header: "cullFaceAttrib.h".} ## \
## Constructs a new CullFaceAttrib object that reverses the effects of any
## other CullFaceAttrib objects in the scene graph.  M_cull_clockwise will be
## treated as M_cull_counter_clockwise, and vice-versa.  M_cull_none is
## unchanged.

proc makeDefault*(_: typedesc[CullFaceAttrib]): RenderAttrib {.importcpp: "deconstify(CullFaceAttrib::make_default())", header: "cullFaceAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc getReverse*(this: CullFaceAttrib): bool {.importcpp: "#->get_reverse()".} ## \
## Returns the 'reverse' flag.  If this is true, the actual cull direction
## (clockwise vs.  counterclockwise) is the reverse of what is specified here.
## This allows support for make_reverse(), which defines a CullFaceAttrib that
## reverses whatever the sense of culling would have been.

proc getClassSlot*(_: typedesc[CullFaceAttrib]): int {.importcpp: "CullFaceAttrib::get_class_slot()", header: "cullFaceAttrib.h".}

converter getClassType*(_: typedesc[CullFaceAttrib]): TypeHandle {.importcpp: "CullFaceAttrib::get_class_type()", header: "cullFaceAttrib.h".}

proc node*(this: CullTraverserData): PandaNode {.importcpp: "#.node()".} ## \
## Returns the node traversed to so far.

proc getModelviewTransform*(this: CullTraverserData, trav: CullTraverser): TransformState {.importcpp: "#.get_modelview_transform(#)".} ## \
## Returns the modelview transform: the relative transform from the camera to
## the model.

proc getInternalTransform*(this: CullTraverserData, trav: CullTraverser): TransformState {.importcpp: "#.get_internal_transform(#)".} ## \
## Returns the internal transform: the modelview transform in the GSG's
## internal coordinate system.

proc getNetTransform*(this: CullTraverserData, trav: CullTraverser): TransformState {.importcpp: "#.get_net_transform(#)".} ## \
## Returns the net transform: the relative transform from root of the scene
## graph to the current node.

proc isInView*(this: CullTraverserData, camera_mask: DrawMask): bool {.importcpp: "#.is_in_view(#)".} ## \
## Returns true if the current node is within the view frustum, false
## otherwise.  If the node's bounding volume falls completely within the view
## frustum, this will also reset the view frustum pointer, saving some work
## for future nodes.

proc isThisNodeHidden*(this: CullTraverserData, camera_mask: DrawMask): bool {.importcpp: "#.is_this_node_hidden(#)".} ## \
## Returns true if this particular node is hidden, even though we might be
## traversing past this node to find a child node that has had show_through()
## called for it.  If this returns true, the node should not be rendered.

proc applyTransformAndState*(this: CullTraverserData, trav: CullTraverser) {.importcpp: "#.apply_transform_and_state(#)".} ## \
## Applies the transform and state from the current node onto the current
## data.  This also evaluates billboards, etc.

proc applyTransform*(this: CullTraverserData, node_transform: TransformState) {.importcpp: "#.apply_transform(#)".} ## \
## Applies the indicated transform changes onto the current data.

proc initCullTraverserData*(param0: CullTraverserData): CullTraverserData {.importcpp: "CullTraverserData(#)".}

proc setDisplayRegion*(this: SceneSetup, display_region: DisplayRegion) {.importcpp: "#->set_display_region(#)".} ## \
## Specifies the display region for the scene.

proc getDisplayRegion*(this: SceneSetup): DisplayRegion {.importcpp: "#->get_display_region()".} ## \
## Returns the display region for the scene.

proc setViewportSize*(this: SceneSetup, width: int, height: int) {.importcpp: "#->set_viewport_size(#, #)".} ## \
## Specifies the size of the viewport (display region), in pixels.

proc getViewportWidth*(this: SceneSetup): int {.importcpp: "#->get_viewport_width()".} ## \
## Returns the width of the viewport (display region) in pixels.

proc getViewportHeight*(this: SceneSetup): int {.importcpp: "#->get_viewport_height()".} ## \
## Returns the height of the viewport (display region) in pixels.

proc setSceneRoot*(this: SceneSetup, scene_root: NodePath) {.importcpp: "#->set_scene_root(#)".} ## \
## Specifies the root node of the scene.

proc getSceneRoot*(this: SceneSetup): NodePath {.importcpp: "#->get_scene_root()".} ## \
## Returns the root node of the scene.

proc setCameraPath*(this: SceneSetup, camera_path: NodePath) {.importcpp: "#->set_camera_path(#)".} ## \
## Specifies the NodePath to the camera.

proc getCameraPath*(this: SceneSetup): NodePath {.importcpp: "#->get_camera_path()".} ## \
## Returns the NodePath to the camera.

proc setCameraNode*(this: SceneSetup, camera_node: Camera) {.importcpp: "#->set_camera_node(#)".} ## \
## Specifies the camera used to render the scene.

proc getCameraNode*(this: SceneSetup): Camera {.importcpp: "#->get_camera_node()".} ## \
## Returns the camera used to render the scene.

proc setLens*(this: SceneSetup, lens: Lens) {.importcpp: "#->set_lens(#)".} ## \
## Indicates the particular Lens used for rendering.

proc getLens*(this: SceneSetup): Lens {.importcpp: "deconstify(#->get_lens())", header: deconstifyCode.} ## \
## Returns the particular Lens used for rendering.

proc setInverted*(this: SceneSetup, inverted: bool) {.importcpp: "#->set_inverted(#)".} ## \
## Changes the current setting of the inverted flag.  When this is true, the
## scene is rendered into the window upside-down and backwards, that is,
## inverted as if viewed through a mirror placed on the floor.

proc getInverted*(this: SceneSetup): bool {.importcpp: "#->get_inverted()".} ## \
## Returns the current setting of the inverted flag.  When this is true, the
## scene is rendered into the window upside-down, flipped like a mirror along
## the X axis.

proc getCullCenter*(this: SceneSetup): NodePath {.importcpp: "#->get_cull_center()".} ## \
## Returns the point from which the culling operations will be performed.
## This is normally the camera, but if camera->set_cull_center() has been
## specified, it will be that special node instead.

proc getCullBounds*(this: SceneSetup): BoundingVolume {.importcpp: "#->get_cull_bounds()".} ## \
## Returns the bounding volume that should be used to perform view-frustum
## culling (in the space of get_cull_center()).  This is normally the current
## lens' bounding volume, but it may be overridden with
## Camera::set_cull_bounds().

proc setInitialState*(this: SceneSetup, initial_state: RenderState) {.importcpp: "#->set_initial_state(#)".} ## \
## Sets the initial state which is applied to all nodes in the scene, as if it
## were set at the top of the scene graph.

proc getInitialState*(this: SceneSetup): RenderState {.importcpp: "deconstify(#->get_initial_state())", header: deconstifyCode.} ## \
## Returns the initial state as set by a previous call to set_initial_state().

proc setCameraTransform*(this: SceneSetup, camera_transform: TransformState) {.importcpp: "#->set_camera_transform(#)".} ## \
## Specifies the position of the camera relative to the starting node.

proc getCameraTransform*(this: SceneSetup): TransformState {.importcpp: "deconstify(#->get_camera_transform())", header: deconstifyCode.} ## \
## Returns the position of the camera relative to the starting node.

proc setWorldTransform*(this: SceneSetup, world_transform: TransformState) {.importcpp: "#->set_world_transform(#)".} ## \
## Specifies the position of the starting node relative to the camera.  This
## is the inverse of the camera transform.

proc getWorldTransform*(this: SceneSetup): TransformState {.importcpp: "deconstify(#->get_world_transform())", header: deconstifyCode.} ## \
## Returns the position of the starting node relative to the camera.  This is
## the inverse of the camera transform.

proc setCsTransform*(this: SceneSetup, cs_transform: TransformState) {.importcpp: "#->set_cs_transform(#)".} ## \
## Specifies the transform from the camera's coordinate system to the GSG's
## internal coordinate system.

proc getCsTransform*(this: SceneSetup): TransformState {.importcpp: "deconstify(#->get_cs_transform())", header: deconstifyCode.} ## \
## Returns the transform from the camera's coordinate system to the GSG's
## internal coordinate system.

proc setCsWorldTransform*(this: SceneSetup, cs_world_transform: TransformState) {.importcpp: "#->set_cs_world_transform(#)".} ## \
## Specifies the position from the starting node relative to the camera, in
## the GSG's internal coordinate system.

proc getCsWorldTransform*(this: SceneSetup): TransformState {.importcpp: "deconstify(#->get_cs_world_transform())", header: deconstifyCode.} ## \
## Returns the position from the starting node relative to the camera, in the
## GSG's internal coordinate system.

converter getClassType*(_: typedesc[SceneSetup]): TypeHandle {.importcpp: "SceneSetup::get_class_type()", header: "sceneSetup.h".}

proc newSceneSetup*(param0: SceneSetup): SceneSetup {.importcpp: "new SceneSetup(#)".}

proc newFog*(name: string): Fog {.importcpp: "new Fog(nimStringToStdString(#))", header: stringConversionCode.}

proc getColor*(this: Fog): LColor {.importcpp: "#->get_color()".} ## \
## Returns the color of the fog.

proc setColor*(this: Fog, color: LColor) {.importcpp: "#->set_color(#)".} ## \
## Sets the color of the fog.  The alpha component is not used.

proc setColor*(this: Fog, r: float32, g: float32, b: float32) {.importcpp: "#->set_color(#, #, #)".} ## \
## Sets the color of the fog.

proc setLinearRange*(this: Fog, onset: float32, opaque: float32) {.importcpp: "#->set_linear_range(#, #)".} ## \
## Specifies the effects of the fog in linear distance units.  This is only
## used if the mode is M_linear.
##
## This specifies a fog that begins at distance onset units from the origin,
## and becomes totally opaque at distance opaque units from the origin, along
## the forward axis (usually Y).
##
## This function also implicitly sets the mode the M_linear, if it is not
## already set.

proc getLinearOnsetPoint*(this: Fog): LPoint3 {.importcpp: "#->get_linear_onset_point()".} ## \
## Returns the point in space at which the fog begins.  This is only used if
## the mode is M_linear.

proc setLinearOnsetPoint*(this: Fog, linear_onset_point: LPoint3) {.importcpp: "#->set_linear_onset_point(#)".} ## \
## Specifies the point in space at which the fog begins.  This is only used if
## the mode is M_linear.

proc setLinearOnsetPoint*(this: Fog, x: float32, y: float32, z: float32) {.importcpp: "#->set_linear_onset_point(#, #, #)".} ## \
## Specifies the point in space at which the fog begins.  This is only used if
## the mode is M_linear.

proc getLinearOpaquePoint*(this: Fog): LPoint3 {.importcpp: "#->get_linear_opaque_point()".} ## \
## Returns the point in space at which the fog completely obscures geometry.
## This is only used if the mode is M_linear.

proc setLinearOpaquePoint*(this: Fog, linear_opaque_point: LPoint3) {.importcpp: "#->set_linear_opaque_point(#)".} ## \
## Specifies the point in space at which the fog completely obscures geometry.
## This is only used if the mode is M_linear.

proc setLinearOpaquePoint*(this: Fog, x: float32, y: float32, z: float32) {.importcpp: "#->set_linear_opaque_point(#, #, #)".} ## \
## Specifies the point in space at which the fog completely obscures geometry.
## This is only used if the mode is M_linear.

proc setLinearFallback*(this: Fog, angle: float32, onset: float32, opaque: float32) {.importcpp: "#->set_linear_fallback(#, #, #)".} ## \
## Fog effects are traditionally defined in camera-relative space, but the
## Panda Fog node has a special mode in which it can define a linear fog
## effect in an arbitrary coordinate space.
##
## This is done by specifying 3-d onset and opaque points, and parenting the
## Fog object somewhere within the scene graph.  In this mode, the fog will be
## rendered as if it extended along the vector from the onset point to the
## opaque point, in 3-d space.
##
## However, the underlying fog effect supported by hardware is generally only
## one-dimensional, and must be rendered based on linear distance from the
## camera plane.  Thus, this in-the-world effect is most effective when the
## fog vector from onset point to opaque point is most nearly parallel to the
## camera's eye vector.
##
## As the angle between the fog vector and the eye vector increases, the
## accuracy of the effect diminishes, up to a complete breakdown of the effect
## at a 90 degree angle.
##
## This function exists to define the workaround to this problem.  The linear
## fallback parameters given here specify how the fog should be rendered when
## the parameters are exceeded in this way.
##
## The angle parameter is the minimum angle, in degrees, of the fog vector to
## the eye vector, at which the fallback effect should be employed.  The onset
## and opaque parameters specify the camera-relative onset and opaque
## distances to pass to the rendering hardware when employing the fallback
## effect.  This supercedes the 3-d onset point and opaque points.

proc getExpDensity*(this: Fog): float32 {.importcpp: "#->get_exp_density()".} ## \
## Returns the density of the fog for exponential calculations.  This is only
## used if the mode is not M_linear.

proc setExpDensity*(this: Fog, exp_density: float32) {.importcpp: "#->set_exp_density(#)".} ## \
## Sets the density of the fog for exponential calculations.  This is only
## used if the mode is not M_linear.
##
## If the mode is currently set to M_linear, this function implicitly sets it
## to M_exponential.

converter getClassType*(_: typedesc[Fog]): TypeHandle {.importcpp: "Fog::get_class_type()", header: "fog.h".}

proc make*(_: typedesc[FogAttrib], fog: Fog): RenderAttrib {.importcpp: "deconstify(#FogAttrib::make(#))", header: "fogAttrib.h".} ## \
## Constructs a new FogAttrib object suitable for rendering the indicated fog
## onto geometry.

proc makeOff*(_: typedesc[FogAttrib]): RenderAttrib {.importcpp: "deconstify(FogAttrib::make_off())", header: "fogAttrib.h".} ## \
## Constructs a new FogAttrib object suitable for rendering unfogd geometry.

proc makeDefault*(_: typedesc[FogAttrib]): RenderAttrib {.importcpp: "deconstify(FogAttrib::make_default())", header: "fogAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc isOff*(this: FogAttrib): bool {.importcpp: "#->is_off()".} ## \
## Returns true if the FogAttrib is an 'off' FogAttrib, indicating that it
## should disable fog.

proc getFog*(this: FogAttrib): Fog {.importcpp: "#->get_fog()".} ## \
## If the FogAttrib is not an 'off' FogAttrib, returns the fog that is
## associated.  Otherwise, return NULL.

proc getClassSlot*(_: typedesc[FogAttrib]): int {.importcpp: "FogAttrib::get_class_slot()", header: "fogAttrib.h".}

converter getClassType*(_: typedesc[FogAttrib]): TypeHandle {.importcpp: "FogAttrib::get_class_type()", header: "fogAttrib.h".}

proc newCullTraverser*(): CullTraverser {.importcpp: "new CullTraverser()".}

proc newCullTraverser*(copy: CullTraverser): CullTraverser {.importcpp: "new CullTraverser(#)".}

proc getGsg*(this: CullTraverser): GraphicsStateGuardianBase {.importcpp: "#->get_gsg()".} ## \
## Returns the GraphicsStateGuardian in effect.

proc getCurrentThread*(this: CullTraverser): Thread {.importcpp: "#->get_current_thread()".} ## \
## Returns the currently-executing thread object, as passed to the
## CullTraverser constructor.

proc setScene*(this: CullTraverser, scene_setup: SceneSetup, gsg: GraphicsStateGuardianBase, dr_incomplete_render: bool) {.importcpp: "#->set_scene(#, #, #)".} ## \
## Sets the SceneSetup object that indicates the initial camera position, etc.
## This must be called before traversal begins.

proc getScene*(this: CullTraverser): SceneSetup {.importcpp: "#->get_scene()".} ## \
## Returns the SceneSetup object.

proc hasTagStateKey*(this: CullTraverser): bool {.importcpp: "#->has_tag_state_key()".} ## \
## Returns true if a nonempty tag state key has been specified for the scene's
## camera, false otherwise.

proc getTagStateKey*(this: CullTraverser): string {.importcpp: "nimStringFromStdString(#->get_tag_state_key())", header: stringConversionCode.} ## \
## Returns the tag state key that has been specified for the scene's camera,
## if any.

proc setCameraMask*(this: CullTraverser, camera_mask: DrawMask) {.importcpp: "#->set_camera_mask(#)".} ## \
## Changes the visibility mask for the camera viewing the scene.  This is
## normally set automatically at the time setup_scene() is called; you should
## change this only if you want to render some set of objects different from
## what the camera normally would draw.

proc getCameraMask*(this: CullTraverser): DrawMask {.importcpp: "#->get_camera_mask()".} ## \
## Returns the visibility mask from the camera viewing the scene.

proc getCameraTransform*(this: CullTraverser): TransformState {.importcpp: "deconstify(#->get_camera_transform())", header: deconstifyCode.} ## \
## Returns the position of the camera relative to the starting node.

proc getWorldTransform*(this: CullTraverser): TransformState {.importcpp: "deconstify(#->get_world_transform())", header: deconstifyCode.} ## \
## Returns the position of the starting node relative to the camera.  This is
## the inverse of the camera transform.
##
## Note that this value is always the position of the starting node, not the
## current node, even if it is sampled during a traversal.  To get the
## transform of the current node use
## CullTraverserData::get_modelview_transform().

proc getInitialState*(this: CullTraverser): RenderState {.importcpp: "deconstify(#->get_initial_state())", header: deconstifyCode.} ## \
## Returns the initial RenderState at the top of the scene graph we are
## traversing, or the empty state if the initial state was never set.

proc getDepthOffsetDecals*(this: CullTraverser): bool {.importcpp: "#->get_depth_offset_decals()".} ## \
## Returns true, as depth offsets are the only way that we implement decals
## nowadays.

proc setViewFrustum*(this: CullTraverser, view_frustum: GeometricBoundingVolume) {.importcpp: "#->set_view_frustum(#)".} ## \
## Specifies the bounding volume that corresponds to the view frustum.  Any
## primitives that fall entirely outside of this volume are not drawn.

proc getViewFrustum*(this: CullTraverser): GeometricBoundingVolume {.importcpp: "#->get_view_frustum()".} ## \
## Returns the bounding volume that corresponds to the view frustum, or NULL
## if the view frustum is not in use or has not been set.
##
## Note that the view frustum returned here is always in the coordinate space
## of the starting node, not the current node, even if it is sampled during a
## traversal.  To get the view frustum in the current node's coordinate space,
## check in the current CullTraverserData.

proc getEffectiveIncompleteRender*(this: CullTraverser): bool {.importcpp: "#->get_effective_incomplete_render()".} ## \
## Returns true if the cull traversal is effectively in incomplete_render
## state, considering both the GSG's incomplete_render and the current
## DisplayRegion's incomplete_render flags.  This returns the flag during the
## cull traversal; see GSG::get_effective_incomplete_render() for this same
## flag during the draw traversal.

proc traverse*(this: CullTraverser, data: CullTraverserData) {.importcpp: "#->traverse(#)".} ## \
## Traverses from the next node with the given data, which has been
## constructed with the node but has not yet been converted into the node's
## space.

proc traverse*(this: CullTraverser, root: NodePath) {.importcpp: "#->traverse(#)".} ## \
## Begins the traversal from the indicated node.

proc traverseBelow*(this: CullTraverser, data: CullTraverserData) {.importcpp: "#->traverse_below(#)".} ## \
## Traverses all the children of the indicated node, with the given data,
## which has been converted into the node's space.

proc endTraverse*(this: CullTraverser) {.importcpp: "#->end_traverse()".} ## \
## Should be called when the traverser has finished traversing its scene, this
## gives it a chance to do any necessary finalization.

proc flushLevel*(_: typedesc[CullTraverser]) {.importcpp: "CullTraverser::flush_level()", header: "cullTraverser.h".} ## \
## Flushes the PStatCollectors used during traversal.

proc drawBoundingVolume*(this: CullTraverser, vol: BoundingVolume, internal_transform: TransformState) {.importcpp: "#->draw_bounding_volume(#, #)".} ## \
## Draws an appropriate visualization of the indicated bounding volume.

converter getClassType*(_: typedesc[CullTraverser]): TypeHandle {.importcpp: "CullTraverser::get_class_type()", header: "cullTraverser.h".}

proc getGsg*(this: GeomDrawCallbackData): GraphicsStateGuardianBase {.importcpp: "#.get_gsg()".} ## \
## Returns a pointer to the current GSG.

proc getForce*(this: GeomDrawCallbackData): bool {.importcpp: "#.get_force()".} ## \
## Returns true if any required data should be forced into memory if necessary
## to render the object, or false if the object should be omitted if some of
## the data is not available (at least until the data becomes available
## later).

proc setLostState*(this: GeomDrawCallbackData, lost_state: bool) {.importcpp: "#.set_lost_state(#)".} ## \
## Sets the lost_state flag.  If this is true, the callback does not have to
## be quite so careful to clean up after itself; Panda will assume that the
## graphics state is in an unknown state after the callback has finished, and
## will issue all the necessary calls to restore it.  If this is false, Panda
## will assume the callback will leave the graphics state exactly as it came
## in, and won't bother to try to restore it.  The default is true.

proc getLostState*(this: GeomDrawCallbackData): bool {.importcpp: "#.get_lost_state()".} ## \
## Returns the lost_state flag.  See set_lost_state().

converter getClassType*(_: typedesc[GeomDrawCallbackData]): TypeHandle {.importcpp: "GeomDrawCallbackData::get_class_type()", header: "geomDrawCallbackData.h".}

proc makeDefault*(_: typedesc[RescaleNormalAttrib]): RenderAttrib {.importcpp: "deconstify(RescaleNormalAttrib::make_default())", header: "rescaleNormalAttrib.h".} ## \
## Constructs a RescaleNormalAttrib object that's suitable for putting at the
## top of a scene graph.  This will contain whatever attrib was suggested by
## the user's rescale-normals Config variable.

proc getClassSlot*(_: typedesc[RescaleNormalAttrib]): int {.importcpp: "RescaleNormalAttrib::get_class_slot()", header: "rescaleNormalAttrib.h".}

converter getClassType*(_: typedesc[RescaleNormalAttrib]): TypeHandle {.importcpp: "RescaleNormalAttrib::get_class_type()", header: "rescaleNormalAttrib.h".}

proc makeNext*(this: CullResult): CullResult {.importcpp: "#->make_next()".} ## \
## Returns a newly-allocated CullResult object that contains a copy of just
## the subset of the data from this CullResult object that is worth keeping
## around for next frame.

proc finishCull*(this: CullResult, scene_setup: SceneSetup, current_thread: Thread) {.importcpp: "#->finish_cull(#, #)".} ## \
## Called after all the geoms have been added, this indicates that the cull
## process is finished for this frame and gives the bins a chance to do any
## post-processing (like sorting) before moving on to draw.

proc draw*(this: CullResult, current_thread: Thread) {.importcpp: "#->draw(#)".} ## \
## Asks all the bins to draw themselves in the correct order.

proc makeResultGraph*(this: CullResult): PandaNode {.importcpp: "#->make_result_graph()".} ## \
## Returns a special scene graph constructed to represent the results of the
## cull.  This will be a hierarchy of nodes, one node for each bin, each of
## which will in term be a parent of a number of GeomNodes, representing the
## geometry drawn in each bin.
##
## This is useful mainly for high-level debugging and abstraction tools; it
## should not be mistaken for the low-level cull result itself.  For the low-
## level cull result, use draw() to efficiently draw the culled scene.

converter getClassType*(_: typedesc[CullResult]): TypeHandle {.importcpp: "CullResult::get_class_type()", header: "cullResult.h".}

proc newCullResult*(param0: CullResult): CullResult {.importcpp: "new CullResult(#)".}

proc make*(_: typedesc[DecalEffect]): RenderEffect {.importcpp: "deconstify(DecalEffect::make())", header: "decalEffect.h".} ## \
## Constructs a new DecalEffect object.

converter getClassType*(_: typedesc[DecalEffect]): TypeHandle {.importcpp: "DecalEffect::get_class_type()", header: "decalEffect.h".}

proc make*(_: typedesc[DepthOffsetAttrib], offset: int): RenderAttrib {.importcpp: "deconstify(#DepthOffsetAttrib::make(#))", header: "depthOffsetAttrib.h".} ## \
## Constructs a new DepthOffsetAttrib object that indicates the relative
## amount of bias to write to the depth buffer for subsequent geometry.

proc make*(_: typedesc[DepthOffsetAttrib]): RenderAttrib {.importcpp: "deconstify(DepthOffsetAttrib::make())", header: "depthOffsetAttrib.h".} ## \
## Constructs a new DepthOffsetAttrib object that indicates the relative
## amount of bias to write to the depth buffer for subsequent geometry.

proc make*(_: typedesc[DepthOffsetAttrib], offset: int, min_value: float32, max_value: float32): RenderAttrib {.importcpp: "deconstify(#DepthOffsetAttrib::make(#, #, #))", header: "depthOffsetAttrib.h".} ## \
## Constructs a new DepthOffsetAttrib object that indicates the bias, and also
## specifies a minimum and maximum (or, more precisely, nearest and farthest)
## values to write to the depth buffer, in the range 0 .. 1.  This range is 0,
## 1 by default; setting it to some other range can be used to create
## additional depth buffer effects.

proc makeDefault*(_: typedesc[DepthOffsetAttrib]): RenderAttrib {.importcpp: "deconstify(DepthOffsetAttrib::make_default())", header: "depthOffsetAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc getOffset*(this: DepthOffsetAttrib): int {.importcpp: "#->get_offset()".} ## \
## Returns the depth offset represented by this attrib.

proc getMinValue*(this: DepthOffsetAttrib): float32 {.importcpp: "#->get_min_value()".} ## \
## Returns the value for the minimum (closest) depth value to be stored in the
## buffer, in the range 0 .. 1.

proc getMaxValue*(this: DepthOffsetAttrib): float32 {.importcpp: "#->get_max_value()".} ## \
## Returns the value for the maximum (farthest) depth value to be stored in
## the buffer, in the range 0 .. 1.

proc getClassSlot*(_: typedesc[DepthOffsetAttrib]): int {.importcpp: "DepthOffsetAttrib::get_class_slot()", header: "depthOffsetAttrib.h".}

converter getClassType*(_: typedesc[DepthOffsetAttrib]): TypeHandle {.importcpp: "DepthOffsetAttrib::get_class_type()", header: "depthOffsetAttrib.h".}

proc makeDefault*(_: typedesc[DepthTestAttrib]): RenderAttrib {.importcpp: "deconstify(DepthTestAttrib::make_default())", header: "depthTestAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc getClassSlot*(_: typedesc[DepthTestAttrib]): int {.importcpp: "DepthTestAttrib::get_class_slot()", header: "depthTestAttrib.h".}

converter getClassType*(_: typedesc[DepthTestAttrib]): TypeHandle {.importcpp: "DepthTestAttrib::get_class_type()", header: "depthTestAttrib.h".}

proc makeDefault*(_: typedesc[DepthWriteAttrib]): RenderAttrib {.importcpp: "deconstify(DepthWriteAttrib::make_default())", header: "depthWriteAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc getClassSlot*(_: typedesc[DepthWriteAttrib]): int {.importcpp: "DepthWriteAttrib::get_class_slot()", header: "depthWriteAttrib.h".}

converter getClassType*(_: typedesc[DepthWriteAttrib]): TypeHandle {.importcpp: "DepthWriteAttrib::get_class_type()", header: "depthWriteAttrib.h".}

proc asNode*(this: Light): PandaNode {.importcpp: "#->as_node()".}

proc isAmbientLight*(this: Light): bool {.importcpp: "#->is_ambient_light()".} ## \
## Returns true if this is an AmbientLight, false if it is some other kind of
## light.

proc getColor*(this: Light): LColor {.importcpp: "#->get_color()".} ## \
## Returns the basic color of the light.

proc setColor*(this: Light, color: LColor) {.importcpp: "#->set_color(#)".} ## \
## Sets the basic color of the light.

proc hasColorTemperature*(this: Light): bool {.importcpp: "#->has_color_temperature()".} ## \
## Returns true if the color was specified as a temperature in kelvins, and
## get_color_temperature is defined.
##
## @since 1.10.0

proc getColorTemperature*(this: Light): float32 {.importcpp: "#->get_color_temperature()".} ## \
## Returns the basic color temperature of the light, assuming
## has_color_temperature() returns true.
##
## @since 1.10.0

proc setColorTemperature*(this: Light, temperature: float32) {.importcpp: "#->set_color_temperature(#)".} ## \
## Sets the color temperature of the light in kelvins.  This will recalculate
## the light's color.
##
## The default value is 6500 K, corresponding to a perfectly white light
## assuming a D65 white point.
##
## @since 1.10.0

proc getExponent*(this: Light): float32 {.importcpp: "#->get_exponent()".} ## \
## For spotlights, returns the exponent that controls the amount of light
## falloff from the center of the spotlight.  For other kinds of lights,
## returns 0.

proc getSpecularColor*(this: Light): LColor {.importcpp: "#->get_specular_color()".} ## \
## Returns the color of specular highlights generated by the light.  This
## value is meaningless for ambient lights.

proc getAttenuation*(this: Light): LVecBase3 {.importcpp: "#->get_attenuation()".} ## \
## Returns the terms of the attenuation equation for the light.  These are, in
## order, the constant, linear, and quadratic terms based on the distance from
## the point to the vertex.

proc setPriority*(this: Light, priority: int) {.importcpp: "#->set_priority(#)".} ## \
## Changes the relative importance of this light relative to the other lights
## that are applied simultaneously.
##
## The priority number is used to decide which of the requested lights are to
## be selected for rendering when more lights are requested than the hardware
## will support.  The highest-priority n lights are selected for rendering.
##
## This is similar to TextureStage::set_priority().

proc getPriority*(this: Light): int {.importcpp: "#->get_priority()".} ## \
## Returns the priority associated with this light.  See set_priority().

proc getClassPriority*(this: Light): int {.importcpp: "#->get_class_priority()".}

converter getClassType*(_: typedesc[Light]): TypeHandle {.importcpp: "Light::get_class_type()", header: "light.h".}

proc make*(_: typedesc[LightAttrib]): RenderAttrib {.importcpp: "deconstify(LightAttrib::make())", header: "lightAttrib.h".} ## \
## The following is the new, more general interface to the LightAttrib.

proc makeDefault*(_: typedesc[LightAttrib]): RenderAttrib {.importcpp: "deconstify(LightAttrib::make_default())", header: "lightAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc getNumLights*(this: LightAttrib): int {.importcpp: "#->get_num_lights()".} ## \
## Returns the number of lights listed in the attribute.
##
## @deprecated LightAttribs nowadays have a separate list of on_lights and
## off_lights, so this method no longer makes sense.  Query the lists
## independently.

proc getLight*(this: LightAttrib, n: int): Light {.importcpp: "#->get_light(#)".} ## \
## Returns the nth light listed in the attribute.
##
## @deprecated LightAttribs nowadays have a separate list of on_lights and
## off_lights, so this method no longer makes sense.  Query the lists
## independently.

proc hasLight*(this: LightAttrib, light: Light): bool {.importcpp: "#->has_light(#)".} ## \
## Returns true if the indicated light is listed in the attrib, false
## otherwise.
##
## @deprecated LightAttribs nowadays have a separate list of on_lights and
## off_lights, so this method no longer makes sense.  Query the lists
## independently.

proc addLight*(this: LightAttrib, light: Light): RenderAttrib {.importcpp: "deconstify(#->add_light(#))", header: deconstifyCode.} ## \
## Returns a new LightAttrib, just like this one, but with the indicated light
## added to the list of lights.
##
## @deprecated Use add_on_light() or add_off_light() instead.

proc removeLight*(this: LightAttrib, light: Light): RenderAttrib {.importcpp: "deconstify(#->remove_light(#))", header: deconstifyCode.} ## \
## Returns a new LightAttrib, just like this one, but with the indicated light
## removed from the list of lights.
##
## @deprecated Use remove_on_light() or remove_off_light() instead.

proc makeAllOff*(_: typedesc[LightAttrib]): RenderAttrib {.importcpp: "deconstify(LightAttrib::make_all_off())", header: "lightAttrib.h".} ## \
## Constructs a new LightAttrib object that turns off all lights (and hence
## disables lighting).

proc getNumOnLights*(this: LightAttrib): clonglong {.importcpp: "#->get_num_on_lights()".} ## \
## Returns the number of lights that are turned on by the attribute.

proc getNumNonAmbientLights*(this: LightAttrib): clonglong {.importcpp: "#->get_num_non_ambient_lights()".} ## \
## Returns the number of non-ambient lights that are turned on by this
## attribute.

proc getOnLight*(this: LightAttrib, n: clonglong): NodePath {.importcpp: "#->get_on_light(#)".} ## \
## Returns the nth light turned on by the attribute, sorted in render order.

proc hasOnLight*(this: LightAttrib, light: NodePath): bool {.importcpp: "#->has_on_light(#)".} ## \
## Returns true if the indicated light is turned on by the attrib, false
## otherwise.

proc hasAnyOnLight*(this: LightAttrib): bool {.importcpp: "#->has_any_on_light()".} ## \
## Returns true if any light is turned on by the attrib, false otherwise.

proc getNumOffLights*(this: LightAttrib): clonglong {.importcpp: "#->get_num_off_lights()".} ## \
## Returns the number of lights that are turned off by the attribute.

proc getOffLight*(this: LightAttrib, n: clonglong): NodePath {.importcpp: "#->get_off_light(#)".} ## \
## Returns the nth light turned off by the attribute, sorted in arbitrary
## (pointer) order.

proc hasOffLight*(this: LightAttrib, light: NodePath): bool {.importcpp: "#->has_off_light(#)".} ## \
## Returns true if the indicated light is turned off by the attrib, false
## otherwise.

proc hasAllOff*(this: LightAttrib): bool {.importcpp: "#->has_all_off()".} ## \
## Returns true if this attrib turns off all lights (although it may also turn
## some on).

proc isIdentity*(this: LightAttrib): bool {.importcpp: "#->is_identity()".} ## \
## Returns true if this is an identity attrib: it does not change the set of
## lights in use.

proc addOnLight*(this: LightAttrib, light: NodePath): RenderAttrib {.importcpp: "deconstify(#->add_on_light(#))", header: deconstifyCode.} ## \
## Returns a new LightAttrib, just like this one, but with the indicated light
## added to the list of lights turned on by this attrib.

proc removeOnLight*(this: LightAttrib, light: NodePath): RenderAttrib {.importcpp: "deconstify(#->remove_on_light(#))", header: deconstifyCode.} ## \
## Returns a new LightAttrib, just like this one, but with the indicated light
## removed from the list of lights turned on by this attrib.

proc replaceOnLight*(this: LightAttrib, source: NodePath, dest: NodePath): RenderAttrib {.importcpp: "deconstify(#->replace_on_light(#, #))", header: deconstifyCode.} ## \
## Returns a new LightAttrib, just like this one, but with the indicated light
## replaced with the given other light.

proc addOffLight*(this: LightAttrib, light: NodePath): RenderAttrib {.importcpp: "deconstify(#->add_off_light(#))", header: deconstifyCode.} ## \
## Returns a new LightAttrib, just like this one, but with the indicated light
## added to the list of lights turned off by this attrib.

proc removeOffLight*(this: LightAttrib, light: NodePath): RenderAttrib {.importcpp: "deconstify(#->remove_off_light(#))", header: deconstifyCode.} ## \
## Returns a new LightAttrib, just like this one, but with the indicated light
## removed from the list of lights turned off by this attrib.

proc replaceOffLight*(this: LightAttrib, source: NodePath, dest: NodePath): RenderAttrib {.importcpp: "deconstify(#->replace_off_light(#, #))", header: deconstifyCode.} ## \
## Returns a new LightAttrib, just like this one, but with the indicated light
## replaced with the given other light.

proc getMostImportantLight*(this: LightAttrib): NodePath {.importcpp: "#->get_most_important_light()".} ## \
## Returns the most important light (that is, the light with the highest
## priority) in the LightAttrib, excluding any ambient lights.  Returns an
## empty NodePath if no non-ambient lights are found.

proc getAmbientContribution*(this: LightAttrib): LColor {.importcpp: "#->get_ambient_contribution()".} ## \
## Returns the total contribution of all the ambient lights.

proc getClassSlot*(_: typedesc[LightAttrib]): int {.importcpp: "LightAttrib::get_class_slot()", header: "lightAttrib.h".}

converter getClassType*(_: typedesc[LightAttrib]): TypeHandle {.importcpp: "LightAttrib::get_class_type()", header: "lightAttrib.h".}

proc makeDefault*(_: typedesc[LightRampAttrib]): RenderAttrib {.importcpp: "deconstify(LightRampAttrib::make_default())", header: "lightRampAttrib.h".} ## \
## Constructs a new LightRampAttrib object.  This is the standard OpenGL
## lighting ramp, which clamps the final light total to the 0-1 range.

proc makeIdentity*(_: typedesc[LightRampAttrib]): RenderAttrib {.importcpp: "deconstify(LightRampAttrib::make_identity())", header: "lightRampAttrib.h".} ## \
## Constructs a new LightRampAttrib object.  This differs from the usual
## OpenGL lighting model in that it does not clamp the final lighting total to
## (0,1).

proc makeSingleThreshold*(_: typedesc[LightRampAttrib], thresh0: float32, lev0: float32): RenderAttrib {.importcpp: "deconstify(#LightRampAttrib::make_single_threshold(#, #))", header: "lightRampAttrib.h".} ## \
## Constructs a new LightRampAttrib object.  This causes the luminance of the
## diffuse lighting contribution to be quantized using a single threshold:
##
## @code
## if (original_luminance > threshold0) {
## luminance = level0;
## } else {
## luminance = 0.0;
## }
## @endcode

proc makeDoubleThreshold*(_: typedesc[LightRampAttrib], thresh0: float32, lev0: float32, thresh1: float32, lev1: float32): RenderAttrib {.importcpp: "deconstify(#LightRampAttrib::make_double_threshold(#, #, #, #))", header: "lightRampAttrib.h".} ## \
## Constructs a new LightRampAttrib object.  This causes the luminance of the
## diffuse lighting contribution to be quantized using two thresholds:
##
## @code
## if (original_luminance > threshold1) {
## luminance = level1;
## } else if (original_luminance > threshold0) {
## luminance = level0;
## } else {
## luminance = 0.0;
## }
## @endcode

proc makeHdr0*(_: typedesc[LightRampAttrib]): RenderAttrib {.importcpp: "deconstify(LightRampAttrib::make_hdr0())", header: "lightRampAttrib.h".} ## \
## Constructs a new LightRampAttrib object.  This causes an HDR tone mapping
## operation to be applied.
##
## Normally, brightness values greater than 1 cannot be distinguished from
## each other, causing very brightly lit objects to wash out white and all
## detail to be erased.  HDR tone mapping remaps brightness values in the
## range 0-infinity into the range (0,1), making it possible to distinguish
## detail in scenes whose brightness exceeds 1.
##
## However, the monitor has finite contrast.  Normally, all of that contrast
## is used to represent brightnesses in the range 0-1.  The HDR0 tone mapping
## operator 'steals' one quarter of that contrast to represent brightnesses in
## the range 1-infinity.
##
## @code
## FINAL_RGB = (RGB^3 + RGB^2 + RGB) / (RGB^3 + RGB^2 + RGB + 1)
## @endcode

proc makeHdr1*(_: typedesc[LightRampAttrib]): RenderAttrib {.importcpp: "deconstify(LightRampAttrib::make_hdr1())", header: "lightRampAttrib.h".} ## \
## Constructs a new LightRampAttrib object.  This causes an HDR tone mapping
## operation to be applied.
##
## Normally, brightness values greater than 1 cannot be distinguished from
## each other, causing very brightly lit objects to wash out white and all
## detail to be erased.  HDR tone mapping remaps brightness values in the
## range 0-infinity into the range (0,1), making it possible to distinguish
## detail in scenes whose brightness exceeds 1.
##
## However, the monitor has finite contrast.  Normally, all of that contrast
## is used to represent brightnesses in the range 0-1.  The HDR1 tone mapping
## operator 'steals' one third of that contrast to represent brightnesses in
## the range 1-infinity.
##
## @code
## FINAL_RGB = (RGB^2 + RGB) / (RGB^2 + RGB + 1)
## @endcode

proc makeHdr2*(_: typedesc[LightRampAttrib]): RenderAttrib {.importcpp: "deconstify(LightRampAttrib::make_hdr2())", header: "lightRampAttrib.h".} ## \
## Constructs a new LightRampAttrib object.  This causes an HDR tone mapping
## operation to be applied.
##
## Normally, brightness values greater than 1 cannot be distinguished from
## each other, causing very brightly lit objects to wash out white and all
## detail to be erased.  HDR tone mapping remaps brightness values in the
## range 0-infinity into the range (0,1), making it possible to distinguish
## detail in scenes whose brightness exceeds 1.
##
## However, the monitor has finite contrast.  Normally, all of that contrast
## is used to represent brightnesses in the range 0-1.  The HDR2 tone mapping
## operator 'steals' one half of that contrast to represent brightnesses in
## the range 1-infinity.
##
## @code
## FINAL_RGB = (RGB) / (RGB + 1)
## @endcode

proc getLevel*(this: LightRampAttrib, n: int): float32 {.importcpp: "#->get_level(#)".} ## \
## Returns the nth lighting level.

proc getThreshold*(this: LightRampAttrib, n: int): float32 {.importcpp: "#->get_threshold(#)".} ## \
## Returns the nth threshold level.

proc getClassSlot*(_: typedesc[LightRampAttrib]): int {.importcpp: "LightRampAttrib::get_class_slot()", header: "lightRampAttrib.h".}

converter getClassType*(_: typedesc[LightRampAttrib]): TypeHandle {.importcpp: "LightRampAttrib::get_class_type()", header: "lightRampAttrib.h".}

converter upcastToTypedReferenceCount*(this: Loader): TypedReferenceCount {.importcpp: "(PT(TypedReferenceCount)(#))".}

converter upcastToNamable*(this: Loader): Namable {.importcpp: "((Namable *)(Loader *)(#))".}

proc newLoader*(param0: Loader): Loader {.importcpp: "new Loader(#)".}

proc newLoader*(name: string): Loader {.importcpp: "new Loader(nimStringToStdString(#))", header: stringConversionCode.}

proc newLoader*(): Loader {.importcpp: "new Loader()".}

proc setTaskManager*(this: Loader, task_manager: AsyncTaskManager) {.importcpp: "#->set_task_manager(#)".} ## \
## Specifies the task manager that is used for asynchronous loads.  The
## default is the global task manager.

proc getTaskManager*(this: Loader): AsyncTaskManager {.importcpp: "#->get_task_manager()".} ## \
## Returns the task manager that is used for asynchronous loads.

proc setTaskChain*(this: Loader, task_chain: string) {.importcpp: "#->set_task_chain(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the task chain that is used for asynchronous loads.  The default
## is the initial name of the Loader object.

proc getTaskChain*(this: Loader): string {.importcpp: "nimStringFromStdString(#->get_task_chain())", header: stringConversionCode.} ## \
## Returns the task chain that is used for asynchronous loads.

proc stopThreads*(this: Loader) {.importcpp: "#->stop_threads()".} ## \
## Stop any threads used for asynchronous loads.

proc remove*(this: Loader, task: AsyncTask): bool {.importcpp: "#->remove(#)".} ## \
## Removes a pending asynchronous load request.  Returns true if successful,
## false otherwise.
## @deprecated use task.cancel() to cancel the request instead.

proc loadSync*(this: Loader, filename: Filename, options: LoaderOptions): PandaNode {.importcpp: "#->load_sync(#, #)".} ## \
## Loads the file immediately, waiting for it to complete.
##
## If search is true, the file is searched for along the model path;
## otherwise, only the exact filename is loaded.

proc loadSync*(this: Loader, filename: Filename): PandaNode {.importcpp: "#->load_sync(#)".} ## \
## Loads the file immediately, waiting for it to complete.
##
## If search is true, the file is searched for along the model path;
## otherwise, only the exact filename is loaded.

proc makeAsyncRequest*(this: Loader, filename: Filename, options: LoaderOptions): AsyncTask {.importcpp: "#->make_async_request(#, #)".} ## \
## Returns a new AsyncTask object suitable for adding to load_async() to start
## an asynchronous model load.

proc makeAsyncRequest*(this: Loader, filename: Filename): AsyncTask {.importcpp: "#->make_async_request(#)".} ## \
## Returns a new AsyncTask object suitable for adding to load_async() to start
## an asynchronous model load.

proc loadAsync*(this: Loader, request: AsyncTask) {.importcpp: "#->load_async(#)".} ## \
## Begins an asynchronous load request.  To use this call, first call
## make_async_request() to create a new ModelLoadRequest object with the
## filename you wish to load, and then add that object to the Loader with
## load_async.  This function will return immediately, and the model will be
## loaded in the background.
##
## To determine when the model has completely loaded, you may poll
## request->is_ready() from time to time, or set the done_event on the request
## object and listen for that event.  When the model is ready, you may
## retrieve it via request->get_model().

proc saveSync*(this: Loader, filename: Filename, options: LoaderOptions, node: PandaNode): bool {.importcpp: "#->save_sync(#, #, #)".} ## \
## Saves the file immediately, waiting for it to complete.

proc makeAsyncSaveRequest*(this: Loader, filename: Filename, options: LoaderOptions, node: PandaNode): AsyncTask {.importcpp: "#->make_async_save_request(#, #, #)".} ## \
## Returns a new AsyncTask object suitable for adding to save_async() to start
## an asynchronous model save.

proc saveAsync*(this: Loader, request: AsyncTask) {.importcpp: "#->save_async(#)".} ## \
## Begins an asynchronous save request.  To use this call, first call
## make_async_save_request() to create a new ModelSaveRequest object with the
## filename you wish to load, and then add that object to the Loader with
## save_async.  This function will return immediately, and the model will be
## loaded in the background.
##
## To determine when the model has completely loaded, you may poll
## request->is_ready() from time to time, or set the done_event on the request
## object and listen for that event.  When the request is ready, you may
## retrieve the success or failure via request->get_success().

proc loadBamStream*(this: Loader, `in`: istream): PandaNode {.importcpp: "#->load_bam_stream(#)".} ## \
## Attempts to read a bam file from the indicated stream and return the scene
## graph defined there.

proc output*(this: Loader, `out`: ostream) {.importcpp: "#->output(#)".}

proc getGlobalPtr*(_: typedesc[Loader]): Loader {.importcpp: "Loader::get_global_ptr()", header: "loader.h".} ## \
## Returns a pointer to the global Loader.  This is the Loader that most code
## should use for loading models.

converter getClassType*(_: typedesc[Loader]): TypeHandle {.importcpp: "Loader::get_class_type()", header: "loader.h".}

proc getName*(this: LoaderFileType): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.}

proc getExtension*(this: LoaderFileType): string {.importcpp: "nimStringFromStdString(#.get_extension())", header: stringConversionCode.}

proc getAdditionalExtensions*(this: LoaderFileType): string {.importcpp: "nimStringFromStdString(#.get_additional_extensions())", header: stringConversionCode.} ## \
## Returns a space-separated list of extension, in addition to the one
## returned by get_extension(), that are recognized by this loader.

proc supportsCompressed*(this: LoaderFileType): bool {.importcpp: "#.supports_compressed()".} ## \
## Returns true if this file type can transparently load compressed files
## (with a .pz or .gz extension), false otherwise.

proc getAllowDiskCache*(this: LoaderFileType, options: LoaderOptions): bool {.importcpp: "#.get_allow_disk_cache(#)".} ## \
## Returns true if the loader flags allow retrieving the model from the on-
## disk bam cache (if it is enabled), false otherwise.

proc getAllowRamCache*(this: LoaderFileType, options: LoaderOptions): bool {.importcpp: "#.get_allow_ram_cache(#)".} ## \
## Returns true if the loader flags allow retrieving the model from the in-
## memory ModelPool cache, false otherwise.

proc supportsLoad*(this: LoaderFileType): bool {.importcpp: "#.supports_load()".} ## \
## Returns true if the file type can be used to load files, and load_file() is
## supported.  Returns false if load_file() is unimplemented and will always
## fail.

proc supportsSave*(this: LoaderFileType): bool {.importcpp: "#.supports_save()".} ## \
## Returns true if the file type can be used to save files, and save_file() is
## supported.  Returns false if save_file() is unimplemented and will always
## fail.

converter getClassType*(_: typedesc[LoaderFileType]): TypeHandle {.importcpp: "LoaderFileType::get_class_type()", header: "loaderFileType.h".}

proc getNumTypes*(this: LoaderFileTypeRegistry): int {.importcpp: "#.get_num_types()".} ## \
## Returns the total number of types registered.

proc getType*(this: LoaderFileTypeRegistry, n: int): LoaderFileType {.importcpp: "#.get_type(#)".} ## \
## Returns the nth type registered.

proc getTypeFromExtension*(this: LoaderFileTypeRegistry, extension: string): LoaderFileType {.importcpp: "#.get_type_from_extension(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Determines the type of the file based on the indicated extension (without a
## leading dot).  Returns NULL if the extension matches no known file types.

proc write*(this: LoaderFileTypeRegistry, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Writes a list of supported file types to the indicated output stream, one
## per line.

proc write*(this: LoaderFileTypeRegistry, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes a list of supported file types to the indicated output stream, one
## per line.

proc getGlobalPtr*(_: typedesc[LoaderFileTypeRegistry]): LoaderFileTypeRegistry {.importcpp: "LoaderFileTypeRegistry::get_global_ptr()", header: "loaderFileTypeRegistry.h".} ## \
## Returns a pointer to the global LoaderFileTypeRegistry object.

proc initLoaderFileTypeRegistry*(param0: LoaderFileTypeRegistry): LoaderFileTypeRegistry {.importcpp: "LoaderFileTypeRegistry(#)".}

proc make*(_: typedesc[MaterialAttrib], material: Material): RenderAttrib {.importcpp: "deconstify(#MaterialAttrib::make(#))", header: "materialAttrib.h".} ## \
## Constructs a new MaterialAttrib object suitable for rendering the indicated
## material onto geometry.

proc makeOff*(_: typedesc[MaterialAttrib]): RenderAttrib {.importcpp: "deconstify(MaterialAttrib::make_off())", header: "materialAttrib.h".} ## \
## Constructs a new MaterialAttrib object suitable for rendering unmateriald
## geometry.

proc makeDefault*(_: typedesc[MaterialAttrib]): RenderAttrib {.importcpp: "deconstify(MaterialAttrib::make_default())", header: "materialAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc isOff*(this: MaterialAttrib): bool {.importcpp: "#->is_off()".} ## \
## Returns true if the MaterialAttrib is an 'off' MaterialAttrib, indicating
## that it should disable the use of materials.

proc getMaterial*(this: MaterialAttrib): Material {.importcpp: "#->get_material()".} ## \
## If the MaterialAttrib is not an 'off' MaterialAttrib, returns the material
## that is associated.  Otherwise, return NULL.

proc getClassSlot*(_: typedesc[MaterialAttrib]): int {.importcpp: "MaterialAttrib::get_class_slot()", header: "materialAttrib.h".}

converter getClassType*(_: typedesc[MaterialAttrib]): TypeHandle {.importcpp: "MaterialAttrib::get_class_type()", header: "materialAttrib.h".}

proc newModelFlattenRequest*(param0: ModelFlattenRequest): ModelFlattenRequest {.importcpp: "new ModelFlattenRequest(#)".}

proc newModelFlattenRequest*(orig: PandaNode): ModelFlattenRequest {.importcpp: "new ModelFlattenRequest(#)".} ## \
## Create a new ModelFlattenRequest, and add it to the loader via
## load_async(), to begin an asynchronous load.

proc getOrig*(this: ModelFlattenRequest): PandaNode {.importcpp: "#->get_orig()".} ## \
## Returns the original, unflattened node.

proc isReady*(this: ModelFlattenRequest): bool {.importcpp: "#->is_ready()".} ## \
## Returns true if this request has completed, false if it is still pending.
## When this returns true, you may retrieve the model loaded by calling
## result().
## Equivalent to `req.done() and not req.cancelled()`.
## @see done()

proc getModel*(this: ModelFlattenRequest): PandaNode {.importcpp: "#->get_model()".} ## \
## Returns the flattened copy of the model.  It is an error to call this
## unless done() returns true.
## @deprecated Use result() instead.

converter getClassType*(_: typedesc[ModelFlattenRequest]): TypeHandle {.importcpp: "ModelFlattenRequest::get_class_type()", header: "modelFlattenRequest.h".}

proc newModelLoadRequest*(param0: ModelLoadRequest): ModelLoadRequest {.importcpp: "new ModelLoadRequest(#)".}

proc newModelLoadRequest*(name: string, filename: Filename, options: LoaderOptions, loader: Loader): ModelLoadRequest {.importcpp: "new ModelLoadRequest(nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## Create a new ModelLoadRequest, and add it to the loader via load_async(),
## to begin an asynchronous load.

proc getFilename*(this: ModelLoadRequest): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the filename associated with this asynchronous ModelLoadRequest.

proc getOptions*(this: ModelLoadRequest): LoaderOptions {.importcpp: "#->get_options()".} ## \
## Returns the LoaderOptions associated with this asynchronous
## ModelLoadRequest.

proc getLoader*(this: ModelLoadRequest): Loader {.importcpp: "#->get_loader()".} ## \
## Returns the Loader object associated with this asynchronous
## ModelLoadRequest.

proc isReady*(this: ModelLoadRequest): bool {.importcpp: "#->is_ready()".} ## \
## Returns true if this request has completed, false if it is still pending or
## if it has been cancelled.  When this returns true, you may retrieve the
## model loaded by calling get_model().
## Equivalent to `req.done() and not req.cancelled()`.
## @see done()

proc getModel*(this: ModelLoadRequest): PandaNode {.importcpp: "#->get_model()".} ## \
## Returns the model that was loaded asynchronously, if any, or null if there
## was an error.  It is an error to call this unless done() returns true.
## @deprecated Use result() instead.

converter getClassType*(_: typedesc[ModelLoadRequest]): TypeHandle {.importcpp: "ModelLoadRequest::get_class_type()", header: "modelLoadRequest.h".}

proc newModelNode*(name: string): ModelNode {.importcpp: "new ModelNode(nimStringToStdString(#))", header: stringConversionCode.}

proc setPreserveAttributes*(this: ModelNode, attrib_mask: int) {.importcpp: "#->set_preserve_attributes(#)".} ## \
## Sets the preserve_attributes flag.  This restricts the ability of a flatten
## operation to affect the render attributes stored on this node.
##
## The value should be the union of bits from SceneGraphReducer::AttribTypes
## that represent the attributes that should \*not\* be changed.

proc getPreserveAttributes*(this: ModelNode): int {.importcpp: "#->get_preserve_attributes()".} ## \
## Returns the current setting of the preserve_attributes flag.  See
## set_preserve_attributes().

proc setTransformLimit*(this: ModelNode, limit: float32) {.importcpp: "#->set_transform_limit(#)".}

converter getClassType*(_: typedesc[ModelNode]): TypeHandle {.importcpp: "ModelNode::get_class_type()", header: "modelNode.h".}

proc newModelRoot*(fullpath: Filename, timestamp: time_t.Time): ModelRoot {.importcpp: "new ModelRoot(#, #)".}

proc newModelRoot*(name: string): ModelRoot {.importcpp: "new ModelRoot(nimStringToStdString(#))", header: stringConversionCode.}

proc getModelRefCount*(this: ModelRoot): int {.importcpp: "#->get_model_ref_count()".} ## \
## Returns the number of copies that exist of this particular ModelRoot node.
## Each time ModelRoot::copy_subgraph() or make_copy() is called (or some
## other copying mechanism, such as NodePath.copy_to(), is used), this count
## will increment by one in all copies; when one of the copies is destructed,
## this count will decrement.

proc getFullpath*(this: ModelRoot): Filename {.importcpp: "#->get_fullpath()".} ## \
## Returns the full pathname of the model represented by this node, as found
## on disk.  This is mainly useful for reference purposes, but is also used to
## index the ModelRoot into the ModelPool.

proc setFullpath*(this: ModelRoot, fullpath: Filename) {.importcpp: "#->set_fullpath(#)".} ## \
## Sets the full pathname of the model represented by this node, as found on
## disk.  This is mainly useful for reference purposes, but is also used to
## index the ModelRoot into the ModelPool.
##
## This is normally set automatically when a model is loaded, and should not
## be set directly by the user.  If you change this on a loaded model, then
## ModelPool::release_model() may fail.

proc getTimestamp*(this: ModelRoot): time_t.Time {.importcpp: "#->get_timestamp()".} ## \
## Returns the timestamp of the file on disk that was read for this model, at
## the time it was read, if it is known.  Returns 0 if the timestamp is not
## known or could not be provided.  This can be used as a quick (but fallible)
## check to verify whether the file might have changed since the model was
## read.

proc setTimestamp*(this: ModelRoot, timestamp: time_t.Time) {.importcpp: "#->set_timestamp(#)".} ## \
## Sets the timestamp of the file on disk that was read for this model.  This
## is normally set automatically when a model is loaded, and should not be set
## directly by the user.

converter getClassType*(_: typedesc[ModelRoot]): TypeHandle {.importcpp: "ModelRoot::get_class_type()", header: "modelRoot.h".}

proc hasModel*(_: typedesc[ModelPool], filename: Filename): bool {.importcpp: "#ModelPool::has_model(#)", header: "modelPool.h".} ## \
## Returns true if the model has ever been loaded, false otherwise.  Note that
## this does not guarantee that the model is still up-to-date.

proc verifyModel*(_: typedesc[ModelPool], filename: Filename): bool {.importcpp: "#ModelPool::verify_model(#)", header: "modelPool.h".} ## \
## Loads the given filename up as a model, if it has not already been loaded,
## and returns true to indicate success, or false to indicate failure.  If
## this returns true, it is probable that a subsequent call to load_model()
## with the same model name will return a valid PandaNode.
##
## However, even if this returns true, it is still possible for a subsequent
## call to load_model() to fail.  This can happen if cache-check-timestamps is
## true, and the on-disk file is subsequently modified to replace it with an
## invalid model.

proc getModel*(_: typedesc[ModelPool], filename: Filename, verify: bool): ModelRoot {.importcpp: "#ModelPool::get_model(#, #)", header: "modelPool.h".} ## \
## Returns the model that has already been previously loaded, or NULL
## otherwise.  If verify is true, it will check if the file is still up-to-
## date (and hasn't been modified in the meantime), and if not, will still
## return NULL.

proc loadModel*(_: typedesc[ModelPool], filename: Filename, options: LoaderOptions): ModelRoot {.importcpp: "#ModelPool::load_model(#, #)", header: "modelPool.h".} ## \
## Loads the given filename up as a model, if it has not already been loaded,
## and returns the new model.  If a model with the same filename was
## previously loaded, returns that one instead (unless cache-check-timestamps
## is true and the file has recently changed).  If the model file cannot be
## found, or cannot be loaded for some reason, returns NULL.

proc loadModel*(_: typedesc[ModelPool], filename: Filename): ModelRoot {.importcpp: "#ModelPool::load_model(#)", header: "modelPool.h".} ## \
## Loads the given filename up as a model, if it has not already been loaded,
## and returns the new model.  If a model with the same filename was
## previously loaded, returns that one instead (unless cache-check-timestamps
## is true and the file has recently changed).  If the model file cannot be
## found, or cannot be loaded for some reason, returns NULL.

proc addModel*(_: typedesc[ModelPool], filename: Filename, model: ModelRoot) {.importcpp: "#ModelPool::add_model(#, #)", header: "modelPool.h".} ## \
## Adds the indicated already-loaded model to the pool.  The model will
## replace any previously-loaded model in the pool that had the same filename.
##
## @deprecated Use the one-parameter add_model(model) instead.

proc addModel*(_: typedesc[ModelPool], model: ModelRoot) {.importcpp: "#ModelPool::add_model(#)", header: "modelPool.h".} ## \
## Adds the indicated already-loaded model to the pool.  The model will
## replace any previously-loaded model in the pool that had the same filename.

proc releaseModel*(_: typedesc[ModelPool], filename: Filename) {.importcpp: "#ModelPool::release_model(#)", header: "modelPool.h".} ## \
## Removes the indicated model from the pool, indicating it will never be
## loaded again; the model may then be freed.  If this function is never
## called, a reference count will be maintained on every model every loaded,
## and models will never be freed.
##
## @deprecated Use release_model(model) instead.

proc releaseModel*(_: typedesc[ModelPool], model: ModelRoot) {.importcpp: "#ModelPool::release_model(#)", header: "modelPool.h".} ## \
## Removes the indicated model from the pool, indicating it will never be
## loaded again; the model may then be freed.  If this function (and
## garbage_collect()) is never called, a reference count will be maintained on
## every model every loaded, and models will never be freed.
##
## The model's get_fullpath() value should not have been changed during its
## lifetime, or this function may fail to locate it in the pool.

proc releaseAllModels*(_: typedesc[ModelPool]) {.importcpp: "ModelPool::release_all_models()", header: "modelPool.h".} ## \
## Releases all models in the pool and restores the pool to the empty state.

proc garbageCollect*(_: typedesc[ModelPool]): int {.importcpp: "ModelPool::garbage_collect()", header: "modelPool.h".} ## \
## Releases only those models in the pool that have a reference count of
## exactly 1; i.e.  only those models that are not being used outside of the
## pool.  Returns the number of models released.

proc listContents*(_: typedesc[ModelPool]) {.importcpp: "ModelPool::list_contents()", header: "modelPool.h".} ## \
## Lists the contents of the model pool to cout.

proc listContents*(_: typedesc[ModelPool], `out`: ostream) {.importcpp: "#ModelPool::list_contents(#)", header: "modelPool.h".} ## \
## Lists the contents of the model pool to the indicated output stream.

proc write*(_: typedesc[ModelPool], `out`: ostream) {.importcpp: "#ModelPool::write(#)", header: "modelPool.h".} ## \
## Lists the contents of the model pool to the indicated output stream.  Helps
## with debugging.

proc newModelSaveRequest*(param0: ModelSaveRequest): ModelSaveRequest {.importcpp: "new ModelSaveRequest(#)".}

proc newModelSaveRequest*(name: string, filename: Filename, options: LoaderOptions, node: PandaNode, loader: Loader): ModelSaveRequest {.importcpp: "new ModelSaveRequest(nimStringToStdString(#), #, #, #, #)", header: stringConversionCode.} ## \
## Create a new ModelSaveRequest, and add it to the loader via save_async(),
## to begin an asynchronous save.

proc getFilename*(this: ModelSaveRequest): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the filename associated with this asynchronous ModelSaveRequest.

proc getOptions*(this: ModelSaveRequest): LoaderOptions {.importcpp: "#->get_options()".} ## \
## Returns the LoaderOptions associated with this asynchronous
## ModelSaveRequest.

proc getNode*(this: ModelSaveRequest): PandaNode {.importcpp: "#->get_node()".} ## \
## Returns the node that was passed to the constructor.

proc getLoader*(this: ModelSaveRequest): Loader {.importcpp: "#->get_loader()".} ## \
## Returns the Loader object associated with this asynchronous
## ModelSaveRequest.

proc isReady*(this: ModelSaveRequest): bool {.importcpp: "#->is_ready()".} ## \
## Returns true if this request has completed, false if it is still pending.
## When this returns true, you may retrieve the success flag with
## get_success().
## Equivalent to `req.done() and not req.cancelled()`.
## @see done()

proc getSuccess*(this: ModelSaveRequest): bool {.importcpp: "#->get_success()".} ## \
## Returns the true if the model was saved successfully, false otherwise.  It
## is an error to call this unless done() returns true.

converter getClassType*(_: typedesc[ModelSaveRequest]): TypeHandle {.importcpp: "ModelSaveRequest::get_class_type()", header: "modelSaveRequest.h".}

proc make*(_: typedesc[TextureAttrib]): RenderAttrib {.importcpp: "deconstify(TextureAttrib::make())", header: "textureAttrib.h".} ## \
## The following methods define the new multitexture mode for TextureAttrib.
## Each TextureAttrib can add or remove individual texture stages from the
## complete set of textures that are to be applied; this is similar to the
## mechanism of LightAttrib.

proc make*(_: typedesc[TextureAttrib], tex: Texture): RenderAttrib {.importcpp: "deconstify(#TextureAttrib::make(#))", header: "textureAttrib.h".} ## \
## Constructs a new TextureAttrib object suitable for rendering the indicated
## texture onto geometry, using the default TextureStage.

proc makeOff*(_: typedesc[TextureAttrib]): RenderAttrib {.importcpp: "deconstify(TextureAttrib::make_off())", header: "textureAttrib.h".} ## \
## Constructs a new TextureAttrib object suitable for rendering untextured
## geometry.

proc makeDefault*(_: typedesc[TextureAttrib]): RenderAttrib {.importcpp: "deconstify(TextureAttrib::make_default())", header: "textureAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc isOff*(this: TextureAttrib): bool {.importcpp: "#->is_off()".} ## \
## Returns true if the TextureAttrib is an 'off' TextureAttrib, indicating
## that it should disable texturing.
##
## If multitexture is in effect, a TextureAttrib may not be strictly "on" or
## "off"; therefore, to get a more precise answer to this question, you should
## consider using has_all_off() or get_num_off_stages() or has_off_stage()
## instead.

proc getTexture*(this: TextureAttrib): Texture {.importcpp: "#->get_texture()".} ## \
## If the TextureAttrib is not an 'off' TextureAttrib, returns the base-level
## texture that is associated.  Otherwise, return NULL.

proc makeAllOff*(_: typedesc[TextureAttrib]): RenderAttrib {.importcpp: "deconstify(TextureAttrib::make_all_off())", header: "textureAttrib.h".} ## \
## Constructs a new TextureAttrib object that turns off all stages (and hence
## disables texturing).

proc getNumOnStages*(this: TextureAttrib): int {.importcpp: "#->get_num_on_stages()".} ## \
## Returns the number of stages that are turned on by the attribute.

proc getOnStage*(this: TextureAttrib, n: int): TextureStage {.importcpp: "#->get_on_stage(#)".} ## \
## Returns the nth stage turned on by the attribute, sorted in render order.

proc getNumOnFfStages*(this: TextureAttrib): int {.importcpp: "#->get_num_on_ff_stages()".} ## \
## Returns the number of on-stages that are relevant to the classic fixed
## function pipeline.  This excludes texture stages such as normal maps.

proc getOnFfStage*(this: TextureAttrib, n: int): TextureStage {.importcpp: "#->get_on_ff_stage(#)".} ## \
## Returns the nth stage turned on by the attribute, sorted in render order,
## including only those relevant to the classic fixed function pipeline.  This
## excludes texture stages such as normal maps.

proc getFfTcIndex*(this: TextureAttrib, n: int): int {.importcpp: "#->get_ff_tc_index(#)".} ## \
## For each TextureStage listed in get_on_ff_stage(), this returns a unique
## index number for the texture coordinate name used by that TextureStage.  It
## is guaranteed to remain the same index number for each texcoord name (for a
## given set of TextureStages), even if the texture render order changes.

proc hasOnStage*(this: TextureAttrib, stage: TextureStage): bool {.importcpp: "#->has_on_stage(#)".} ## \
## Returns true if the indicated stage is turned on by the attrib, false
## otherwise.

proc getOnTexture*(this: TextureAttrib, stage: TextureStage): Texture {.importcpp: "#->get_on_texture(#)".} ## \
## Returns the texture associated with the indicated stage, or NULL if no
## texture is associated.

proc getOnSampler*(this: TextureAttrib, stage: TextureStage): SamplerState {.importcpp: "#->get_on_sampler(#)".} ## \
## Returns the sampler associated with the indicated stage, or the one
## associated with its texture if no custom stage has been specified.  It is
## an error to call this if the stage does not exist.

proc getOnStageOverride*(this: TextureAttrib, stage: TextureStage): int {.importcpp: "#->get_on_stage_override(#)".} ## \
## Returns the override value associated with the indicated stage.

proc findOnStage*(this: TextureAttrib, stage: TextureStage): int {.importcpp: "#->find_on_stage(#)".} ## \
## Returns the index number of the indicated TextureStage within the list of
## on_stages, or -1 if the indicated stage is not listed.

proc getNumOffStages*(this: TextureAttrib): int {.importcpp: "#->get_num_off_stages()".} ## \
## Returns the number of stages that are turned off by the attribute.

proc getOffStage*(this: TextureAttrib, n: int): TextureStage {.importcpp: "#->get_off_stage(#)".} ## \
## Returns the nth stage turned off by the attribute, sorted in arbitrary
## (pointer) order.

proc hasOffStage*(this: TextureAttrib, stage: TextureStage): bool {.importcpp: "#->has_off_stage(#)".} ## \
## Returns true if the indicated stage is turned off by the attrib, false
## otherwise.

proc hasAllOff*(this: TextureAttrib): bool {.importcpp: "#->has_all_off()".} ## \
## Returns true if this attrib turns off all stages (although it may also turn
## some on).

proc isIdentity*(this: TextureAttrib): bool {.importcpp: "#->is_identity()".} ## \
## Returns true if this is an identity attrib: it does not change the set of
## stages in use.

proc addOnStage*(this: TextureAttrib, stage: TextureStage, tex: Texture, sampler: SamplerState, override: int): RenderAttrib {.importcpp: "deconstify(#->add_on_stage(#, #, #, #))", header: deconstifyCode.} ## \
## Returns a new TextureAttrib, just like this one, but with the indicated
## stage added to the list of stages turned on by this attrib.

proc addOnStage*(this: TextureAttrib, stage: TextureStage, tex: Texture, sampler: SamplerState): RenderAttrib {.importcpp: "deconstify(#->add_on_stage(#, #, #))", header: deconstifyCode.} ## \
## Returns a new TextureAttrib, just like this one, but with the indicated
## stage added to the list of stages turned on by this attrib.

proc addOnStage*(this: TextureAttrib, stage: TextureStage, tex: Texture, override: int): RenderAttrib {.importcpp: "deconstify(#->add_on_stage(#, #, #))", header: deconstifyCode.} ## \
## Returns a new TextureAttrib, just like this one, but with the indicated
## stage added to the list of stages turned on by this attrib.

proc addOnStage*(this: TextureAttrib, stage: TextureStage, tex: Texture): RenderAttrib {.importcpp: "deconstify(#->add_on_stage(#, #))", header: deconstifyCode.} ## \
## Returns a new TextureAttrib, just like this one, but with the indicated
## stage added to the list of stages turned on by this attrib.

proc removeOnStage*(this: TextureAttrib, stage: TextureStage): RenderAttrib {.importcpp: "deconstify(#->remove_on_stage(#))", header: deconstifyCode.} ## \
## Returns a new TextureAttrib, just like this one, but with the indicated
## stage removed from the list of stages turned on by this attrib.

proc addOffStage*(this: TextureAttrib, stage: TextureStage, override: int): RenderAttrib {.importcpp: "deconstify(#->add_off_stage(#, #))", header: deconstifyCode.} ## \
## Returns a new TextureAttrib, just like this one, but with the indicated
## stage added to the list of stages turned off by this attrib.

proc addOffStage*(this: TextureAttrib, stage: TextureStage): RenderAttrib {.importcpp: "deconstify(#->add_off_stage(#))", header: deconstifyCode.} ## \
## Returns a new TextureAttrib, just like this one, but with the indicated
## stage added to the list of stages turned off by this attrib.

proc removeOffStage*(this: TextureAttrib, stage: TextureStage): RenderAttrib {.importcpp: "deconstify(#->remove_off_stage(#))", header: deconstifyCode.} ## \
## Returns a new TextureAttrib, just like this one, but with the indicated
## stage removed from the list of stages turned off by this attrib.

proc unifyTextureStages*(this: TextureAttrib, stage: TextureStage): RenderAttrib {.importcpp: "deconstify(#->unify_texture_stages(#))", header: deconstifyCode.} ## \
## Returns a new TextureAttrib, just like this one, but with any included
## TextureAttribs that happen to have the same name as the given object
## replaced with the object.

proc replaceTexture*(this: TextureAttrib, tex: Texture, new_tex: Texture): RenderAttrib {.importcpp: "deconstify(#->replace_texture(#, #))", header: deconstifyCode.} ## \
## Returns a new TextureAttrib, just like this one, but with all references to
## the given texture replaced with the new texture.
##
## @since 1.10.4

proc getClassSlot*(_: typedesc[TextureAttrib]): int {.importcpp: "TextureAttrib::get_class_slot()", header: "textureAttrib.h".}

converter getClassType*(_: typedesc[TextureAttrib]): TypeHandle {.importcpp: "TextureAttrib::get_class_type()", header: "textureAttrib.h".}

proc make*(_: typedesc[TexGenAttrib]): RenderAttrib {.importcpp: "deconstify(TexGenAttrib::make())", header: "texGenAttrib.h".} ## \
## Constructs a TexGenAttrib that generates no stages at all.

proc makeDefault*(_: typedesc[TexGenAttrib]): RenderAttrib {.importcpp: "deconstify(TexGenAttrib::make_default())", header: "texGenAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc removeStage*(this: TexGenAttrib, stage: TextureStage): RenderAttrib {.importcpp: "deconstify(#->remove_stage(#))", header: deconstifyCode.} ## \
## Returns a new TexGenAttrib just like this one, with the indicated stage
## removed.

proc isEmpty*(this: TexGenAttrib): bool {.importcpp: "#->is_empty()".} ## \
## Returns true if no stages are defined in the TexGenAttrib, false if at
## least one is.

proc hasStage*(this: TexGenAttrib, stage: TextureStage): bool {.importcpp: "#->has_stage(#)".} ## \
## Returns true if there is a mode associated with the indicated stage, or
## false otherwise (in which case get_transform(stage) will return M_off).

proc hasGenTexcoordStage*(this: TexGenAttrib, stage: TextureStage): bool {.importcpp: "#->has_gen_texcoord_stage(#)".} ## \
## Returns true if the indicated TextureStage will have texture coordinates
## generated for it automatically (and thus there is no need to upload the
## texture coordinates encoded in the vertices).

proc getConstantValue*(this: TexGenAttrib, stage: TextureStage): LTexCoord3 {.importcpp: "#->get_constant_value(#)".} ## \
## Returns the constant value associated with the named texture stage.  This
## is only meaningful if the mode is M_constant.

proc getGeomRendering*(this: TexGenAttrib, geom_rendering: int): int {.importcpp: "#->get_geom_rendering(#)".} ## \
## Returns the union of the Geom::GeomRendering bits that will be required
## once this TexGenAttrib is applied to a geom which includes the indicated
## geom_rendering bits.

proc getClassSlot*(_: typedesc[TexGenAttrib]): int {.importcpp: "TexGenAttrib::get_class_slot()", header: "texGenAttrib.h".}

converter getClassType*(_: typedesc[TexGenAttrib]): TypeHandle {.importcpp: "TexGenAttrib::get_class_type()", header: "texGenAttrib.h".}

proc newOccluderNode*(name: string): OccluderNode {.importcpp: "new OccluderNode(nimStringToStdString(#))", header: stringConversionCode.} ## \
## The default constructor creates a default occlusion polygon in the XZ plane
## (or XY plane in a y-up coordinate system).  Use the normal Panda set_pos(),
## set_hpr(), set_scale() to position it appropriately, or replace the
## vertices with set_vertices().

proc setDoubleSided*(this: OccluderNode, value: bool) {.importcpp: "#->set_double_sided(#)".} ## \
## If true, the back-face will also be used to occlude

proc isDoubleSided*(this: OccluderNode): bool {.importcpp: "#->is_double_sided()".} ## \
## Is this occluder double-sided

proc setMinCoverage*(this: OccluderNode, value: float32) {.importcpp: "#->set_min_coverage(#)".} ## \
## Minimum screen coverage needed before occluder used.  Range should be 0 to
## 1. For example, setting to 0.2 would mean that the occluder needs to cover
## 20% of the screen to be considered.

proc getMinCoverage*(this: OccluderNode): float32 {.importcpp: "#->get_min_coverage()".} ## \
## Returns the minimum screen coverage.

proc setVertices*(this: OccluderNode, v0: LPoint3, v1: LPoint3, v2: LPoint3, v3: LPoint3) {.importcpp: "#->set_vertices(#, #, #, #)".} ## \
## Replaces the four vertices of the occluder polygon.  The vertices should be
## defined in a counterclockwise orientation when looking at the face of the
## occluder.

proc getNumVertices*(this: OccluderNode): clonglong {.importcpp: "#->get_num_vertices()".} ## \
## Returns the number of vertices in the occluder polygon.  This should always
## return 4.

proc getVertex*(this: OccluderNode, n: clonglong): LPoint3 {.importcpp: "#->get_vertex(#)".} ## \
## Returns the nth vertex of the occluder polygon.

proc setVertex*(this: OccluderNode, n: clonglong, v: LPoint3) {.importcpp: "#->set_vertex(#, #)".} ## \
## Sets the nth vertex of the occluder polygon.

converter getClassType*(_: typedesc[OccluderNode]): TypeHandle {.importcpp: "OccluderNode::get_class_type()", header: "occluderNode.h".}

proc make*(_: typedesc[OccluderEffect]): RenderEffect {.importcpp: "deconstify(OccluderEffect::make())", header: "occluderEffect.h".} ## \
## Constructs a new OccluderEffect object that does nothing.

proc getNumOnOccluders*(this: OccluderEffect): int {.importcpp: "#->get_num_on_occluders()".} ## \
## Returns the number of occluders that are enabled by the effectute.

proc getOnOccluder*(this: OccluderEffect, n: int): NodePath {.importcpp: "#->get_on_occluder(#)".} ## \
## Returns the nth occluder enabled by the effectute, sorted in render order.

proc hasOnOccluder*(this: OccluderEffect, occluder: NodePath): bool {.importcpp: "#->has_on_occluder(#)".} ## \
## Returns true if the indicated occluder is enabled by the effect, false
## otherwise.

proc isIdentity*(this: OccluderEffect): bool {.importcpp: "#->is_identity()".} ## \
## Returns true if this is an identity effect: it does not change the set of
## occluders in use.

proc addOnOccluder*(this: OccluderEffect, occluder: NodePath): RenderEffect {.importcpp: "deconstify(#->add_on_occluder(#))", header: deconstifyCode.} ## \
## Returns a new OccluderEffect, just like this one, but with the indicated
## occluder added to the list of occluders enabled by this effect.

proc removeOnOccluder*(this: OccluderEffect, occluder: NodePath): RenderEffect {.importcpp: "deconstify(#->remove_on_occluder(#))", header: deconstifyCode.} ## \
## Returns a new OccluderEffect, just like this one, but with the indicated
## occluder removed from the list of occluders enabled by this effect.

converter getClassType*(_: typedesc[OccluderEffect]): TypeHandle {.importcpp: "OccluderEffect::get_class_type()", header: "occluderEffect.h".}

proc newPolylightNode*(param0: PolylightNode): PolylightNode {.importcpp: "new PolylightNode(#)".}

proc newPolylightNode*(name: string): PolylightNode {.importcpp: "new PolylightNode(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Use PolylightNode() to construct a new PolylightNode object.

proc enable*(this: PolylightNode) {.importcpp: "#->enable()".} ## \
## Enable this light

proc disable*(this: PolylightNode) {.importcpp: "#->disable()".} ## \
## Disable this light

proc setPos*(this: PolylightNode, position: LPoint3) {.importcpp: "#->set_pos(#)".} ## \
## Set this light's position

proc setPos*(this: PolylightNode, x: float32, y: float32, z: float32) {.importcpp: "#->set_pos(#, #, #)".} ## \
## Set this light's position

proc getPos*(this: PolylightNode): LPoint3 {.importcpp: "#->get_pos()".} ## \
## Returns position as a LPoint3

proc setColor*(this: PolylightNode, color: LColor) {.importcpp: "#->set_color(#)".} ## \
## Set the light's color...

proc setColor*(this: PolylightNode, r: float32, g: float32, b: float32) {.importcpp: "#->set_color(#, #, #)".} ## \
## Set the light's color... 3 floats between 0 and 1

proc getColor*(this: PolylightNode): LColor {.importcpp: "#->get_color()".} ## \
## Returns the light's color as LColor

proc getColorScenegraph*(this: PolylightNode): LColor {.importcpp: "#->get_color_scenegraph()".} ## \
## This differs from get_color in that when applying the light color we need
## to make sure that a color flattening external to the PolylightNode is not
## ignored.

proc setRadius*(this: PolylightNode, r: float32) {.importcpp: "#->set_radius(#)".} ## \
## Set radius of the spherical light volume

proc getRadius*(this: PolylightNode): float32 {.importcpp: "#->get_radius()".} ## \
## Get radius of the spherical light volume

proc setA0*(this: PolylightNode, a0: float32) {.importcpp: "#->set_a0(#)".} ## \
## Set the quadratic attenuation factor a0 fd = 1 / ( a0 + a1\*distance +
## a2\*distance\*distance)

proc setA1*(this: PolylightNode, a1: float32) {.importcpp: "#->set_a1(#)".} ## \
## Set the quadratic attenuation factor a1 fd = 1 / ( a0 + a1\*distance +
## a2\*distance\*distance)

proc setA2*(this: PolylightNode, a2: float32) {.importcpp: "#->set_a2(#)".} ## \
## Set the quadratic attenuation factor a2 fd = 1 / ( a0 + a1\*distance +
## a2\*distance\*distance)

proc getA0*(this: PolylightNode): float32 {.importcpp: "#->get_a0()".} ## \
## Get the quadratic attenuation factor a0 fd = 1 / ( a0 + a1\*distance +
## a2\*distance\*distance)

proc getA1*(this: PolylightNode): float32 {.importcpp: "#->get_a1()".} ## \
## Get the quadratic attenuation factor a1 fd = 1 / ( a0 + a1\*distance +
## a2\*distance\*distance)

proc getA2*(this: PolylightNode): float32 {.importcpp: "#->get_a2()".} ## \
## Get the quadratic attenuation factor a2 fd = 1 / ( a0 + a1\*distance +
## a2\*distance\*distance)

proc flickerOn*(this: PolylightNode) {.importcpp: "#->flicker_on()".} ## \
## Set flickering to true so at every loop this light's color is varied based
## on flicker_type

proc flickerOff*(this: PolylightNode) {.importcpp: "#->flicker_off()".} ## \
## Turn flickering off

proc isFlickering*(this: PolylightNode): bool {.importcpp: "#->is_flickering()".} ## \
## Check is this light is flickering

proc setOffset*(this: PolylightNode, offset: float32) {.importcpp: "#->set_offset(#)".} ## \
## Set the offset value for the random and sin flicker variations... used to
## tweak the flicker This value is added to the variation

proc getOffset*(this: PolylightNode): float32 {.importcpp: "#->get_offset()".} ## \
## Get the offset value for the random and sin flicker variations

proc setScale*(this: PolylightNode, scale: float32) {.importcpp: "#->set_scale(#)".} ## \
## Set the scale value for the random and sin flicker variations... used to
## tweak the flicker This value is multiplied with the variation

proc getScale*(this: PolylightNode): float32 {.importcpp: "#->get_scale()".} ## \
## Get the scale value for the random and sin flicker variations

proc setStepSize*(this: PolylightNode, step: float32) {.importcpp: "#->set_step_size(#)".} ## \
## Set the step size for the sin function in flicker This is the increment
## size for the value supplied to the sin function

proc getStepSize*(this: PolylightNode): float32 {.importcpp: "#->get_step_size()".} ## \
## Get the step size for the sin function in flicker This is the increment
## size for the value supplied to the sin function

proc setFreq*(this: PolylightNode, f: float32) {.importcpp: "#->set_freq(#)".} ## \
## Set frequency of sin flicker

proc getFreq*(this: PolylightNode): float32 {.importcpp: "#->get_freq()".} ## \
## Get frequency of sin flicker

proc `==`*(this: PolylightNode, other: PolylightNode): bool {.importcpp: "#->operator ==(#)".} ## \
## Comparison methods

proc `!=`*(this: PolylightNode, other: PolylightNode): bool {.importcpp: "#->operator !=(#)".}

proc `<`*(this: PolylightNode, other: PolylightNode): bool {.importcpp: "#->operator <(#)".}

proc compareTo*(this: PolylightNode, other: PolylightNode): int {.importcpp: "#->compare_to(#)".} ## \
## Returns a number less than zero if this PolylightNode sorts before the
## other one, greater than zero if it sorts after, or zero if they are
## equivalent.
##
## Two PolylightNodes are considered equivalent if they consist of exactly the
## same properties Otherwise, they are different; different PolylightNodes
## will be ranked in a consistent but undefined ordering; the ordering is
## useful only for placing the PolylightNodes in a sorted container like an
## STL set.

proc isEnabled*(this: PolylightNode): bool {.importcpp: "#->is_enabled()".} ## \
## Is this light is enabled/disabled?

converter getClassType*(_: typedesc[PolylightNode]): TypeHandle {.importcpp: "PolylightNode::get_class_type()", header: "polylightNode.h".}

proc make*(_: typedesc[PolylightEffect]): RenderEffect {.importcpp: "deconstify(PolylightEffect::make())", header: "polylightEffect.h".} ## \
## Constructs a new PolylightEffect object.

proc addLight*(this: PolylightEffect, newlight: NodePath): RenderEffect {.importcpp: "deconstify(#->add_light(#))", header: deconstifyCode.} ## \
## Add a PolylightNode object to this effect and return a new effect

proc removeLight*(this: PolylightEffect, newlight: NodePath): RenderEffect {.importcpp: "deconstify(#->remove_light(#))", header: deconstifyCode.} ## \
## Remove a light from this effect.  Return the new updated effect

proc setWeight*(this: PolylightEffect, w: float32): RenderEffect {.importcpp: "deconstify(#->set_weight(#))", header: deconstifyCode.} ## \
## Set weight and return a new effect... the reason this couldnt be done
## through make was because that would return a new effect without the
## lightgroup which is static and cant be accessed Here, we just pass that to
## the make

proc setEffectCenter*(this: PolylightEffect, ec: LPoint3): RenderEffect {.importcpp: "deconstify(#->set_effect_center(#))", header: deconstifyCode.} ## \
## Set weight and return a new effect... the reason this couldnt be done
## through make was because that would return a new effect without the
## lightgroup which is static and cant be accessed Here, we just pass that to
## the make

proc getWeight*(this: PolylightEffect): float32 {.importcpp: "#->get_weight()".} ## \
## Get the weight value

proc getEffectCenter*(this: PolylightEffect): LPoint3 {.importcpp: "#->get_effect_center()".} ## \
## Return the value of the _effect_center

proc hasLight*(this: PolylightEffect, light: NodePath): bool {.importcpp: "#->has_light(#)".} ## \
## Returns true if the indicated light is listed in the PolylightEffect, false
## otherwise.

converter getClassType*(_: typedesc[PolylightEffect]): TypeHandle {.importcpp: "PolylightEffect::get_class_type()", header: "polylightEffect.h".}

proc make*(_: typedesc[ShaderAttrib], shader: Shader, priority: int): RenderAttrib {.importcpp: "deconstify(#ShaderAttrib::make(#, #))", header: "shaderAttrib.h".} ## \
## Constructs a new ShaderAttrib object with nothing set.

proc make*(_: typedesc[ShaderAttrib], shader: Shader): RenderAttrib {.importcpp: "deconstify(#ShaderAttrib::make(#))", header: "shaderAttrib.h".} ## \
## Constructs a new ShaderAttrib object with nothing set.

proc make*(_: typedesc[ShaderAttrib]): RenderAttrib {.importcpp: "deconstify(ShaderAttrib::make())", header: "shaderAttrib.h".} ## \
## Constructs a new ShaderAttrib object with nothing set.

proc makeOff*(_: typedesc[ShaderAttrib]): RenderAttrib {.importcpp: "deconstify(ShaderAttrib::make_off())", header: "shaderAttrib.h".} ## \
## Constructs a new ShaderAttrib object that disables the use of shaders (it
## does not clear out all shader data, however.)

proc makeDefault*(_: typedesc[ShaderAttrib]): RenderAttrib {.importcpp: "deconstify(ShaderAttrib::make_default())", header: "shaderAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc hasShader*(this: ShaderAttrib): bool {.importcpp: "#->has_shader()".} ## \
## If true, the shader field of this attribute overrides the shader field of
## the parent attribute.

proc autoShader*(this: ShaderAttrib): bool {.importcpp: "#->auto_shader()".} ## \
## If true, then this ShaderAttrib does not contain an explicit shader -
## instead, it requests the automatic generation of a shader.

proc getShaderPriority*(this: ShaderAttrib): int {.importcpp: "#->get_shader_priority()".}

proc getInstanceCount*(this: ShaderAttrib): int {.importcpp: "#->get_instance_count()".} ## \
## Returns the number of geometry instances.  A value of 0 means not to use
## instancing at all.

proc autoNormalOn*(this: ShaderAttrib): bool {.importcpp: "#->auto_normal_on()".}

proc autoGlowOn*(this: ShaderAttrib): bool {.importcpp: "#->auto_glow_on()".}

proc autoGlossOn*(this: ShaderAttrib): bool {.importcpp: "#->auto_gloss_on()".}

proc autoRampOn*(this: ShaderAttrib): bool {.importcpp: "#->auto_ramp_on()".}

proc autoShadowOn*(this: ShaderAttrib): bool {.importcpp: "#->auto_shadow_on()".}

proc setShader*(this: ShaderAttrib, s: Shader, priority: int): RenderAttrib {.importcpp: "deconstify(#->set_shader(#, #))", header: deconstifyCode.}

proc setShader*(this: ShaderAttrib, s: Shader): RenderAttrib {.importcpp: "deconstify(#->set_shader(#))", header: deconstifyCode.}

proc setShaderOff*(this: ShaderAttrib, priority: int): RenderAttrib {.importcpp: "deconstify(#->set_shader_off(#))", header: deconstifyCode.}

proc setShaderOff*(this: ShaderAttrib): RenderAttrib {.importcpp: "deconstify(#->set_shader_off())", header: deconstifyCode.}

proc setShaderAuto*(this: ShaderAttrib, shader_switch: BitMask32, priority: int): RenderAttrib {.importcpp: "deconstify(#->set_shader_auto(#, #))", header: deconstifyCode.} ## \
## Set auto shader with bitmask to customize use, e.g., to keep normal, glow,
## etc., on or off

proc setShaderAuto*(this: ShaderAttrib, shader_switch: BitMask32): RenderAttrib {.importcpp: "deconstify(#->set_shader_auto(#))", header: deconstifyCode.} ## \
## Set auto shader with bitmask to customize use, e.g., to keep normal, glow,
## etc., on or off

proc setShaderAuto*(this: ShaderAttrib, priority: int): RenderAttrib {.importcpp: "deconstify(#->set_shader_auto(#))", header: deconstifyCode.}

proc setShaderAuto*(this: ShaderAttrib): RenderAttrib {.importcpp: "deconstify(#->set_shader_auto())", header: deconstifyCode.}

proc clearShader*(this: ShaderAttrib): RenderAttrib {.importcpp: "deconstify(#->clear_shader())", header: deconstifyCode.}

proc setShaderInput*(this: ShaderAttrib, input: ShaderInput): RenderAttrib {.importcpp: "deconstify(#->set_shader_input(#))", header: deconstifyCode.} ## \
## Shader Inputs

proc setInstanceCount*(this: ShaderAttrib, instance_count: int): RenderAttrib {.importcpp: "deconstify(#->set_instance_count(#))", header: deconstifyCode.} ## \
## Sets the geometry instance count.  Do not confuse this with instanceTo,
## which is used for animation instancing, and has nothing to do with this.  A
## value of 0 means not to use instancing at all.

proc setFlag*(this: ShaderAttrib, flag: int, value: bool): RenderAttrib {.importcpp: "deconstify(#->set_flag(#, #))", header: deconstifyCode.}

proc clearFlag*(this: ShaderAttrib, flag: int): RenderAttrib {.importcpp: "deconstify(#->clear_flag(#))", header: deconstifyCode.}

proc clearShaderInput*(this: ShaderAttrib, id: InternalName): RenderAttrib {.importcpp: "deconstify(#->clear_shader_input(#))", header: deconstifyCode.}

proc clearShaderInput*(this: ShaderAttrib, id: string): RenderAttrib {.importcpp: "deconstify(#->clear_shader_input(nimStringToStdString(#)))", header: deconstifyCode.}

proc clearAllShaderInputs*(this: ShaderAttrib): RenderAttrib {.importcpp: "deconstify(#->clear_all_shader_inputs())", header: deconstifyCode.} ## \
## Clears all the shader inputs on the attrib.

proc getFlag*(this: ShaderAttrib, flag: int): bool {.importcpp: "#->get_flag(#)".}

proc hasShaderInput*(this: ShaderAttrib, id: InternalName): bool {.importcpp: "#->has_shader_input(#)".} ## \
## Returns true if there is a ShaderInput of the given name.

proc getShader*(this: ShaderAttrib): Shader {.importcpp: "deconstify(#->get_shader())", header: deconstifyCode.} ## \
## Returns the shader object associated with the node.  If get_override
## returns true, but get_shader returns NULL, that means that this attribute
## should disable the shader.

proc getShaderInput*(this: ShaderAttrib, id: InternalName): ShaderInput {.importcpp: "#->get_shader_input(#)".} ## \
## Returns the ShaderInput of the given name.  If no such name is found, this
## function does not return NULL --- it returns the "blank" ShaderInput.

proc getShaderInput*(this: ShaderAttrib, id: string): ShaderInput {.importcpp: "#->get_shader_input(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the ShaderInput of the given name.  If no such name is found, this
## function does not return NULL --- it returns the "blank" ShaderInput.

proc getShaderInputNodepath*(this: ShaderAttrib, id: InternalName): NodePath {.importcpp: "#->get_shader_input_nodepath(#)".} ## \
## Returns the ShaderInput as a nodepath.  Assertion fails if there is none,
## or if it is not a nodepath.

proc getShaderInputVector*(this: ShaderAttrib, id: InternalName): LVecBase4 {.importcpp: "#->get_shader_input_vector(#)".} ## \
## Returns the ShaderInput as a vector.  Assertion fails if there is none, or
## if it is not a vector.

proc getShaderInputTexture*(this: ShaderAttrib, id: InternalName, sampler: SamplerState): Texture {.importcpp: "#->get_shader_input_texture(#, #)".} ## \
## Returns the ShaderInput as a texture.  Assertion fails if there is none, or
## if it is not a texture.
##
## If sampler is not NULL, the sampler state to use for this texture is
## assigned to it.

proc getShaderInputTexture*(this: ShaderAttrib, id: InternalName): Texture {.importcpp: "#->get_shader_input_texture(#)".} ## \
## Returns the ShaderInput as a texture.  Assertion fails if there is none, or
## if it is not a texture.
##
## If sampler is not NULL, the sampler state to use for this texture is
## assigned to it.

proc getShaderInputMatrix*(this: ShaderAttrib, id: InternalName, matrix: LMatrix4): LMatrix4 {.importcpp: "#->get_shader_input_matrix(#, #)".} ## \
## Returns the ShaderInput as a matrix.  Assertion fails if there is none, or
## if it is not a matrix or NodePath.

proc getShaderInputBuffer*(this: ShaderAttrib, id: InternalName): ShaderBuffer {.importcpp: "#->get_shader_input_buffer(#)".} ## \
## Returns the ShaderInput as a ShaderBuffer.  Assertion fails if there is
## none, or if it is not a ShaderBuffer.

proc registerWithReadFactory*(_: typedesc[ShaderAttrib]) {.importcpp: "ShaderAttrib::register_with_read_factory()", header: "shaderAttrib.h".} ## \
## Factory method to generate a Shader object

proc getClassSlot*(_: typedesc[ShaderAttrib]): int {.importcpp: "ShaderAttrib::get_class_slot()", header: "shaderAttrib.h".}

converter getClassType*(_: typedesc[ShaderAttrib]): TypeHandle {.importcpp: "ShaderAttrib::get_class_type()", header: "shaderAttrib.h".}

proc make*(_: typedesc[ShowBoundsEffect], tight: bool): RenderEffect {.importcpp: "deconstify(#ShowBoundsEffect::make(#))", header: "showBoundsEffect.h".} ## \
## Constructs a new ShowBoundsEffect object.

proc make*(_: typedesc[ShowBoundsEffect]): RenderEffect {.importcpp: "deconstify(ShowBoundsEffect::make())", header: "showBoundsEffect.h".} ## \
## Constructs a new ShowBoundsEffect object.

proc getTight*(this: ShowBoundsEffect): bool {.importcpp: "#->get_tight()".} ## \
## Returns true if the "tight" flag was set, meaning the effect should compute
## and draw the tight bounding-box of the node's vertices every frame.

converter getClassType*(_: typedesc[ShowBoundsEffect]): TypeHandle {.importcpp: "ShowBoundsEffect::get_class_type()", header: "showBoundsEffect.h".}

proc make*(_: typedesc[TexProjectorEffect]): RenderEffect {.importcpp: "deconstify(TexProjectorEffect::make())", header: "texProjectorEffect.h".} ## \
## Constructs a TexProjectorEffect that modifies no stages at all.

proc addStage*(this: TexProjectorEffect, stage: TextureStage, `from`: NodePath, to: NodePath, lens_index: int): RenderEffect {.importcpp: "deconstify(#->add_stage(#, #, #, #))", header: deconstifyCode.} ## \
## Returns a new TexProjectorEffect just like this one, with the indicated
## projection for the given stage.  If this stage already exists, its
## projection definition is replaced.
##
## The relative transform between the "from" and the "to" nodes is
## automatically applied to the texture transform each frame.
##
## Furthermore, if the "to" node is a LensNode, its projection matrix is also
## applied to the texture transform.  In this case, the lens_index may be used
## to select the particular lens that should be used.

proc addStage*(this: TexProjectorEffect, stage: TextureStage, `from`: NodePath, to: NodePath): RenderEffect {.importcpp: "deconstify(#->add_stage(#, #, #))", header: deconstifyCode.} ## \
## Returns a new TexProjectorEffect just like this one, with the indicated
## projection for the given stage.  If this stage already exists, its
## projection definition is replaced.
##
## The relative transform between the "from" and the "to" nodes is
## automatically applied to the texture transform each frame.
##
## Furthermore, if the "to" node is a LensNode, its projection matrix is also
## applied to the texture transform.  In this case, the lens_index may be used
## to select the particular lens that should be used.

proc removeStage*(this: TexProjectorEffect, stage: TextureStage): RenderEffect {.importcpp: "deconstify(#->remove_stage(#))", header: deconstifyCode.} ## \
## Returns a new TexProjectorEffect just like this one, with the indicated
## stage removed.

proc isEmpty*(this: TexProjectorEffect): bool {.importcpp: "#->is_empty()".} ## \
## Returns true if no stages are defined in the TexProjectorEffect, false if
## at least one is.

proc hasStage*(this: TexProjectorEffect, stage: TextureStage): bool {.importcpp: "#->has_stage(#)".} ## \
## Returns true if there is a transform associated with the indicated stage,
## or false otherwise (in which case get_transform(stage) will return the
## identity transform).

proc getFrom*(this: TexProjectorEffect, stage: TextureStage): NodePath {.importcpp: "#->get_from(#)".} ## \
## Returns the "from" node associated with the TexProjectorEffect on the
## indicated stage.  The relative transform between the "from" and the "to"
## nodes is automatically applied to the texture transform each frame.

proc getTo*(this: TexProjectorEffect, stage: TextureStage): NodePath {.importcpp: "#->get_to(#)".} ## \
## Returns the "to" node associated with the TexProjectorEffect on the
## indicated stage.  The relative transform between the "from" and the "to"
## nodes is automatically applied to the texture transform each frame.
##
## Furthermore, if the "to" node is a LensNode, its projection matrix is also
## applied to the texture transform.

proc getLensIndex*(this: TexProjectorEffect, stage: TextureStage): int {.importcpp: "#->get_lens_index(#)".} ## \
## Returns the lens_index associated with the TexProjectorEffect on the
## indicated stage.  This is only used if the "to" node is a LensNode, in
## which case it specifies the particular lens that should be used.

converter getClassType*(_: typedesc[TexProjectorEffect]): TypeHandle {.importcpp: "TexProjectorEffect::get_class_type()", header: "texProjectorEffect.h".}

proc makeScreen*(_: typedesc[ScissorEffect], frame: LVecBase4, clip: bool): RenderEffect {.importcpp: "deconstify(#ScissorEffect::make_screen(#, #))", header: "scissorEffect.h".} ## \
## Constructs a new screen-relative ScissorEffect.  The frame defines a left,
## right, bottom, top region, relative to the DisplayRegion.  See
## ScissorAttrib.

proc makeScreen*(_: typedesc[ScissorEffect], frame: LVecBase4): RenderEffect {.importcpp: "deconstify(#ScissorEffect::make_screen(#))", header: "scissorEffect.h".} ## \
## Constructs a new screen-relative ScissorEffect.  The frame defines a left,
## right, bottom, top region, relative to the DisplayRegion.  See
## ScissorAttrib.

proc makeNode*(_: typedesc[ScissorEffect], a: LPoint3, b: LPoint3, c: LPoint3, d: LPoint3, node: NodePath): RenderEffect {.importcpp: "deconstify(#ScissorEffect::make_node(#, #, #, #, #))", header: "scissorEffect.h".} ## \
## Constructs a new node-relative ScissorEffect.  The four points are
## understood to be relative to the indicated node, or the current node if the
## indicated NodePath is empty, and determine four points surrounding the
## scissor region.

proc makeNode*(_: typedesc[ScissorEffect], a: LPoint3, b: LPoint3, c: LPoint3, d: LPoint3): RenderEffect {.importcpp: "deconstify(#ScissorEffect::make_node(#, #, #, #))", header: "scissorEffect.h".} ## \
## Constructs a new node-relative ScissorEffect.  The four points are
## understood to be relative to the indicated node, or the current node if the
## indicated NodePath is empty, and determine four points surrounding the
## scissor region.

proc makeNode*(_: typedesc[ScissorEffect], a: LPoint3, b: LPoint3, node: NodePath): RenderEffect {.importcpp: "deconstify(#ScissorEffect::make_node(#, #, #))", header: "scissorEffect.h".} ## \
## Constructs a new node-relative ScissorEffect.  The two points are
## understood to be relative to the indicated node, or the current node if the
## NodePath is empty, and determine the diagonally opposite corners of the
## scissor region.

proc makeNode*(_: typedesc[ScissorEffect], a: LPoint3, b: LPoint3): RenderEffect {.importcpp: "deconstify(#ScissorEffect::make_node(#, #))", header: "scissorEffect.h".} ## \
## Constructs a new node-relative ScissorEffect.  The two points are
## understood to be relative to the indicated node, or the current node if the
## NodePath is empty, and determine the diagonally opposite corners of the
## scissor region.

proc makeNode*(_: typedesc[ScissorEffect], clip: bool): RenderEffect {.importcpp: "deconstify(#ScissorEffect::make_node(#))", header: "scissorEffect.h".} ## \
## Constructs a new node-relative ScissorEffect, with no points.  This empty
## ScissorEffect does nothing.  You must then call add_point a number of times
## to add the points you require.

proc makeNode*(_: typedesc[ScissorEffect]): RenderEffect {.importcpp: "deconstify(ScissorEffect::make_node())", header: "scissorEffect.h".} ## \
## Constructs a new node-relative ScissorEffect, with no points.  This empty
## ScissorEffect does nothing.  You must then call add_point a number of times
## to add the points you require.

proc addPoint*(this: ScissorEffect, point: LPoint3, node: NodePath): RenderEffect {.importcpp: "deconstify(#->add_point(#, #))", header: deconstifyCode.} ## \
## Returns a new ScissorEffect with the indicated point added.  It is only
## valid to call this on a "node" type ScissorEffect.  The full set of points,
## projected into screen space, defines the bounding volume of the rectangular
## scissor region.
##
## Each point may be relative to a different node, if desired.

proc addPoint*(this: ScissorEffect, point: LPoint3): RenderEffect {.importcpp: "deconstify(#->add_point(#))", header: deconstifyCode.} ## \
## Returns a new ScissorEffect with the indicated point added.  It is only
## valid to call this on a "node" type ScissorEffect.  The full set of points,
## projected into screen space, defines the bounding volume of the rectangular
## scissor region.
##
## Each point may be relative to a different node, if desired.

proc isScreen*(this: ScissorEffect): bool {.importcpp: "#->is_screen()".} ## \
## Returns true if the ScissorEffect is a screen-based effect, meaning
## get_frame() has a meaningful value, but get_a() and get_b() do not.

proc getFrame*(this: ScissorEffect): LVecBase4 {.importcpp: "#->get_frame()".} ## \
## If is_screen() returns true, this method may be called to query the screen-
## based scissor frame.  This is a series of left, right, bottom, top,
## representing the scissor frame relative to the current DisplayRegion.  See
## ScissorAttrib.

proc getNumPoints*(this: ScissorEffect): int {.importcpp: "#->get_num_points()".} ## \
## Returns the number of node-based scissor points.  See get_point().

proc getPoint*(this: ScissorEffect, n: int): LPoint3 {.importcpp: "#->get_point(#)".} ## \
## If is_screen() returns false, then get_num_points() and get_point() may be
## called to query the node-based scissor frame.  These return n points (at
## least two), which are understood to be in the space of this node, and which
## define any opposite corners of the scissor frame.

proc getNode*(this: ScissorEffect, n: int): NodePath {.importcpp: "#->get_node(#)".} ## \
## Returns the node to which the nth point is relative, or empty NodePath to
## indicate the current node.

proc getClip*(this: ScissorEffect): bool {.importcpp: "#->get_clip()".} ## \
## Returns true if this ScissorEffect actually enables scissoring, or false if
## it culls only.

converter getClassType*(_: typedesc[ScissorEffect]): TypeHandle {.importcpp: "ScissorEffect::get_class_type()", header: "scissorEffect.h".}

proc initSceneGraphReducer*(gsg: GraphicsStateGuardianBase): SceneGraphReducer {.importcpp: "SceneGraphReducer(#)".}

proc initSceneGraphReducer*(): SceneGraphReducer {.importcpp: "SceneGraphReducer()".}

proc initSceneGraphReducer*(param0: SceneGraphReducer): SceneGraphReducer {.importcpp: "SceneGraphReducer(#)".}

proc setGsg*(this: SceneGraphReducer, gsg: GraphicsStateGuardianBase) {.importcpp: "#.set_gsg(#)".} ## \
## Specifies the particular GraphicsStateGuardian that this object will
## attempt to optimize to.  The GSG may specify parameters such as maximum
## number of vertices per vertex data, max number of vertices per primitive,
## and whether triangle strips are preferred.  It also affects the types of
## vertex column data that is created by premunge().

proc clearGsg*(this: SceneGraphReducer) {.importcpp: "#.clear_gsg()".} ## \
## Specifies that no particular GraphicsStateGuardian will be used to guide
## the optimization.  The SceneGraphReducer will instead use config variables
## such as max-collect-vertices and max-collect-indices.

proc getGsg*(this: SceneGraphReducer): GraphicsStateGuardianBase {.importcpp: "#.get_gsg()".} ## \
## Returns the particular GraphicsStateGuardian that this object will attempt
## to optimize to.  See set_gsg().

proc setCombineRadius*(this: SceneGraphReducer, combine_radius: float32) {.importcpp: "#.set_combine_radius(#)".} ## \
## Specifies the radius that is used in conjunction with CS_within_radius to
## decide whether a subgraph's siblings should be combined into a single node
## or not.
##
## If the CS_within_radius bit is included in the combine_siblings_bits
## parameter passed to flatten, than any nodes whose bounding volume is
## smaller than the indicated radius will be combined together (as if CS_other
## were set).

proc getCombineRadius*(this: SceneGraphReducer): float32 {.importcpp: "#.get_combine_radius()".} ## \
## Returns the radius that is used in conjunction with CS_within_radius.  See
## set_combine_radius().

proc applyAttribs*(this: SceneGraphReducer, node: PandaNode, attrib_types: int) {.importcpp: "#.apply_attribs(#, #)".} ## \
## Walks the scene graph, accumulating attribs of the indicated types,
## applying them to the vertices, and removing them from the scene graph.
## This has a performance optimization benefit in itself, but is especially
## useful to pave the way for a call to flatten() and greatly improve the
## effectiveness of the flattening operation.
##
## Multiply instanced geometry is duplicated before the attribs are applied.
##
## Of course, this operation does make certain dynamic operations impossible.

proc applyAttribs*(this: SceneGraphReducer, node: PandaNode) {.importcpp: "#.apply_attribs(#)".} ## \
## Walks the scene graph, accumulating attribs of the indicated types,
## applying them to the vertices, and removing them from the scene graph.
## This has a performance optimization benefit in itself, but is especially
## useful to pave the way for a call to flatten() and greatly improve the
## effectiveness of the flattening operation.
##
## Multiply instanced geometry is duplicated before the attribs are applied.
##
## Of course, this operation does make certain dynamic operations impossible.

proc flatten*(this: SceneGraphReducer, root: PandaNode, combine_siblings_bits: int): int {.importcpp: "#.flatten(#, #)".} ## \
## Simplifies the graph by removing unnecessary nodes and nodes.
##
## In general, a node (and its parent node) is a candidate for removal if the
## node has no siblings and the node has no special properties.
##
## If combine_siblings_bits is nonzero, some sibling nodes (according to the
## bits set in combine_siblings_bits) may also be collapsed into a single
## node.  This will further reduce scene graph complexity, sometimes
## substantially, at the cost of reduced spatial separation.
##
## Returns the number of nodes removed from the graph.

proc removeColumn*(this: SceneGraphReducer, root: PandaNode, column: InternalName): int {.importcpp: "#.remove_column(#, #)".} ## \
## Removes the indicated data column from any GeomVertexDatas found at the
## indicated root and below.  Returns the number of GeomNodes modified.

proc makeCompatibleState*(this: SceneGraphReducer, root: PandaNode): int {.importcpp: "#.make_compatible_state(#)".} ## \
## Searches for GeomNodes that contain multiple Geoms that differ only in
## their ColorAttribs.  If such a GeomNode is found, then all the colors are
## pushed down into the vertices.  This makes it feasible for the geoms to be
## unified later.

proc makeCompatibleFormat*(this: SceneGraphReducer, root: PandaNode, collect_bits: int): int {.importcpp: "#.make_compatible_format(#, #)".} ## \
## Walks through the tree at this node and below and unifies the
## GeomVertexFormat for any GeomVertexData objects that are found, so that all
## eligible vdatas (according to collect_bits; see collect_vertex_data) will
## share the same vertex format.
##
## This will add unused columns where necessary to match formats.  It can
## result in suboptimal performance if used needlessly.
##
## There is usually no reason to call this explicitly, since
## collect_vertex_data() will do this anyway if it has not been done already.
## However, calling it ahead of time can make that future call to
## collect_vertex_data() run a little bit faster.
##
## The return value is the number of vertex datas modified.

proc makeCompatibleFormat*(this: SceneGraphReducer, root: PandaNode): int {.importcpp: "#.make_compatible_format(#)".} ## \
## Walks through the tree at this node and below and unifies the
## GeomVertexFormat for any GeomVertexData objects that are found, so that all
## eligible vdatas (according to collect_bits; see collect_vertex_data) will
## share the same vertex format.
##
## This will add unused columns where necessary to match formats.  It can
## result in suboptimal performance if used needlessly.
##
## There is usually no reason to call this explicitly, since
## collect_vertex_data() will do this anyway if it has not been done already.
## However, calling it ahead of time can make that future call to
## collect_vertex_data() run a little bit faster.
##
## The return value is the number of vertex datas modified.

proc decompose*(this: SceneGraphReducer, root: PandaNode) {.importcpp: "#.decompose(#)".} ## \
## Calls decompose() on every GeomNode at this level and below.
##
## There is usually no reason to call this explicitly, since unify() will do
## this anyway if it needs to be done.  However, calling it ahead of time can
## make that future call to unify() run a little bit faster.
##
## This operation has no effect if the config variable preserve-triangle-
## strips has been set true.

proc collectVertexData*(this: SceneGraphReducer, root: PandaNode, collect_bits: int): int {.importcpp: "#.collect_vertex_data(#, #)".} ## \
## Collects all different GeomVertexData blocks that have compatible formats
## at this node and below into a single, unified block (or at least multiple
## larger blocks).  This is intended to reduce rendering overhead incurred by
## switching vertex buffers.  It can also make a subsequent call to unify()
## much more effective than it would have been otherwise.
##
## The set of bits passed in collect_bits indicates which properties are used
## to differentiate GeomVertexData blocks.  If it is 0, then more blocks will
## be combined together than if it is nonzero.

proc collectVertexData*(this: SceneGraphReducer, root: PandaNode): int {.importcpp: "#.collect_vertex_data(#)".} ## \
## Collects all different GeomVertexData blocks that have compatible formats
## at this node and below into a single, unified block (or at least multiple
## larger blocks).  This is intended to reduce rendering overhead incurred by
## switching vertex buffers.  It can also make a subsequent call to unify()
## much more effective than it would have been otherwise.
##
## The set of bits passed in collect_bits indicates which properties are used
## to differentiate GeomVertexData blocks.  If it is 0, then more blocks will
## be combined together than if it is nonzero.

proc makeNonindexed*(this: SceneGraphReducer, root: PandaNode, nonindexed_bits: int): int {.importcpp: "#.make_nonindexed(#, #)".} ## \
## Converts indexed geometry to nonindexed geometry at the indicated node and
## below, by duplicating vertices where necessary.  The parameter
## nonindexed_bits is a union of bits defined in
## SceneGraphReducer::MakeNonindexed, which specifes which types of geometry
## to avoid making nonindexed.

proc makeNonindexed*(this: SceneGraphReducer, root: PandaNode): int {.importcpp: "#.make_nonindexed(#)".} ## \
## Converts indexed geometry to nonindexed geometry at the indicated node and
## below, by duplicating vertices where necessary.  The parameter
## nonindexed_bits is a union of bits defined in
## SceneGraphReducer::MakeNonindexed, which specifes which types of geometry
## to avoid making nonindexed.

proc unify*(this: SceneGraphReducer, root: PandaNode, preserve_order: bool) {.importcpp: "#.unify(#, #)".} ## \
## Calls unify() on every GeomNode at this level and below.  This attempts to
## reduce the total number of individual Geoms and GeomPrimitives by combining
## these objects wherever possible.  See GeomNode::unify().

proc removeUnusedVertices*(this: SceneGraphReducer, root: PandaNode) {.importcpp: "#.remove_unused_vertices(#)".} ## \
## Removes any vertices in GeomVertexDatas that are no longer used at this
## level and below.  This requires remapping vertex indices in all of the
## GeomPrimitives, to remove holes in the GeomVertexDatas.  It is normally not
## necessary to call this explicitly.

proc premunge*(this: SceneGraphReducer, root: PandaNode, initial_state: RenderState) {.importcpp: "#.premunge(#, #)".} ## \
## Walks the scene graph rooted at this node and below, and uses the indicated
## GSG to premunge every Geom found to optimize it for eventual rendering on
## the indicated GSG.  If there is no GSG indicated for the SceneGraphReducer,
## this is a no-op.
##
## This operation will also apply to stashed children.

proc checkLiveFlatten*(this: SceneGraphReducer, node: PandaNode): bool {.importcpp: "#.check_live_flatten(#)".} ## \
## In a non-release build, returns false if the node is correctly not in a
## live scene graph.  (Calling flatten on a node that is part of a live scene
## graph, for instance, a node somewhere under render, can cause problems in a
## multithreaded environment.)
##
## If allow_live_flatten is true, or in a release build, this always returns
## true.

proc newPortalNode*(name: string): PortalNode {.importcpp: "new PortalNode(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Default constructor, just an empty node, no geo This is used to read portal
## from model.  You can also use this from python to create an empty portal.
## Then you can set the vertices yourself, with addVertex.

proc newPortalNode*(name: string, pos: LPoint3, scale: float32): PortalNode {.importcpp: "new PortalNode(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Create a default rectangle as portal.  Use this to create an arbitrary
## portal and setup from Python

proc newPortalNode*(name: string, pos: LPoint3): PortalNode {.importcpp: "new PortalNode(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Create a default rectangle as portal.  Use this to create an arbitrary
## portal and setup from Python

proc setPortalMask*(this: PortalNode, mask: PortalMask) {.importcpp: "#->set_portal_mask(#)".} ## \
## Simultaneously sets both the "from" and "into" PortalMask values to the
## same thing.

proc setFromPortalMask*(this: PortalNode, mask: PortalMask) {.importcpp: "#->set_from_portal_mask(#)".} ## \
## Sets the "from" PortalMask.  In order for a portal to be detected from this
## object into another object, the intersection of this object's "from" mask
## and the other object's "into" mask must be nonzero.

proc setIntoPortalMask*(this: PortalNode, mask: PortalMask) {.importcpp: "#->set_into_portal_mask(#)".} ## \
## Sets the "into" PortalMask.  In order for a portal to be detected from
## another object into this object, the intersection of the other object's
## "from" mask and this object's "into" mask must be nonzero.

proc getFromPortalMask*(this: PortalNode): PortalMask {.importcpp: "#->get_from_portal_mask()".} ## \
## Returns the current "from" PortalMask.  In order for a portal to be
## detected from this object into another object, the intersection of this
## object's "from" mask and the other object's "into" mask must be nonzero.

proc getIntoPortalMask*(this: PortalNode): PortalMask {.importcpp: "#->get_into_portal_mask()".} ## \
## Returns the current "into" PortalMask.  In order for a portal to be
## detected from another object into this object, the intersection of the
## other object's "from" mask and this object's "into" mask must be nonzero.

proc setPortalGeom*(this: PortalNode, flag: bool) {.importcpp: "#->set_portal_geom(#)".} ## \
## Sets the state of the "portal geom" flag for this PortalNode.  Normally,
## this is false; when this is set true, the PortalSolids in this node will
## test for portals with actual renderable geometry, in addition to whatever
## PortalSolids may be indicated by the from_portal_mask.
##
## Setting this to true causes this to test \*all\* GeomNodes for portals.  It
## is an all-or-none thing; there is no way to portal with only some
## GeomNodes, as GeomNodes have no into_portal_mask.

proc getPortalGeom*(this: PortalNode): bool {.importcpp: "#->get_portal_geom()".} ## \
## Returns the current state of the portal_geom flag.  See set_portal_geom().

proc clearVertices*(this: PortalNode) {.importcpp: "#->clear_vertices()".} ## \
## Resets the vertices of the portal to the empty list.

proc addVertex*(this: PortalNode, vertex: LPoint3) {.importcpp: "#->add_vertex(#)".} ## \
## Adds a new vertex to the portal polygon.  The vertices should be defined in
## a counterclockwise orientation when viewing through the portal.

proc getNumVertices*(this: PortalNode): int {.importcpp: "#->get_num_vertices()".} ## \
## Returns the number of vertices in the portal polygon.

proc getVertex*(this: PortalNode, n: int): LPoint3 {.importcpp: "#->get_vertex(#)".} ## \
## Returns the nth vertex of the portal polygon.

proc setCellIn*(this: PortalNode, cell: NodePath) {.importcpp: "#->set_cell_in(#)".} ## \
## Sets the cell that this portal belongs to

proc getCellIn*(this: PortalNode): NodePath {.importcpp: "#->get_cell_in()".} ## \
## Sets the cell that this portal belongs to

proc setCellOut*(this: PortalNode, cell: NodePath) {.importcpp: "#->set_cell_out(#)".} ## \
## Sets the cell that this portal leads out to

proc getCellOut*(this: PortalNode): NodePath {.importcpp: "#->get_cell_out()".} ## \
## Sets the cell that this portal leads out to

proc setClipPlane*(this: PortalNode, value: bool) {.importcpp: "#->set_clip_plane(#)".} ## \
## this is set if the portal will clip against its left and right planes

proc isClipPlane*(this: PortalNode): bool {.importcpp: "#->is_clip_plane()".} ## \
## Is this portal clipping against its left-right planes

proc setVisible*(this: PortalNode, value: bool) {.importcpp: "#->set_visible(#)".} ## \
## this is set if the portal is facing camera

proc isVisible*(this: PortalNode): bool {.importcpp: "#->is_visible()".} ## \
## Is this portal facing the camera

proc setMaxDepth*(this: PortalNode, value: int) {.importcpp: "#->set_max_depth(#)".} ## \
## Set the maximum depth this portal will be visible at

proc getMaxDepth*(this: PortalNode): int {.importcpp: "#->get_max_depth()".} ## \
## Returns the maximum depth this portal will be visible at

proc setOpen*(this: PortalNode, value: bool) {.importcpp: "#->set_open(#)".} ## \
## Python sets this based on curent camera zone

proc isOpen*(this: PortalNode): bool {.importcpp: "#->is_open()".} ## \
## Is this portal open from current camera zone

converter getClassType*(_: typedesc[PortalNode]): TypeHandle {.importcpp: "PortalNode::get_class_type()", header: "portalNode.h".}

proc makeOff*(_: typedesc[ScissorAttrib]): RenderAttrib {.importcpp: "deconstify(ScissorAttrib::make_off())", header: "scissorAttrib.h".} ## \
## Constructs a new ScissorAttrib object that removes the scissor region and
## fills the DisplayRegion.

proc make*(_: typedesc[ScissorAttrib], frame: LVecBase4): RenderAttrib {.importcpp: "deconstify(#ScissorAttrib::make(#))", header: "scissorAttrib.h".} ## \
## Constructs a ScissorAttrib that restricts rendering to the indicated frame
## within the current DisplayRegion.  (0,0) is the lower-left corner of the
## DisplayRegion, and (1,1) is the upper-right corner.

proc make*(_: typedesc[ScissorAttrib], left: float32, right: float32, bottom: float32, top: float32): RenderAttrib {.importcpp: "deconstify(#ScissorAttrib::make(#, #, #, #))", header: "scissorAttrib.h".} ## \
## Constructs a ScissorAttrib that restricts rendering to the indicated frame
## within the current DisplayRegion.  (0,0) is the lower-left corner of the
## DisplayRegion, and (1,1) is the upper-right corner.

proc makeDefault*(_: typedesc[ScissorAttrib]): RenderAttrib {.importcpp: "deconstify(ScissorAttrib::make_default())", header: "scissorAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc isOff*(this: ScissorAttrib): bool {.importcpp: "#->is_off()".} ## \
## Returns true if the ScissorAttrib is an 'off' ScissorAttrib, indicating
## that scissor testing is disabled.

proc getFrame*(this: ScissorAttrib): LVecBase4 {.importcpp: "#->get_frame()".} ## \
## Returns the left, right, bottom, top coordinates of the scissor frame.
## This defines a frame within the current DisplayRegion, where 0,0 is the
## lower-left corner of the DisplayRegion, and 1,1 is the upper-right corner.

proc getClassSlot*(_: typedesc[ScissorAttrib]): int {.importcpp: "ScissorAttrib::get_class_slot()", header: "scissorAttrib.h".}

converter getClassType*(_: typedesc[ScissorAttrib]): TypeHandle {.importcpp: "ScissorAttrib::get_class_type()", header: "scissorAttrib.h".}

proc makeDefault*(_: typedesc[ShadeModelAttrib]): RenderAttrib {.importcpp: "deconstify(ShadeModelAttrib::make_default())", header: "shadeModelAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc getClassSlot*(_: typedesc[ShadeModelAttrib]): int {.importcpp: "ShadeModelAttrib::get_class_slot()", header: "shadeModelAttrib.h".}

converter getClassType*(_: typedesc[ShadeModelAttrib]): TypeHandle {.importcpp: "ShadeModelAttrib::get_class_type()", header: "shadeModelAttrib.h".}

proc makeOff*(_: typedesc[StencilAttrib]): RenderAttrib {.importcpp: "deconstify(StencilAttrib::make_off())", header: "stencilAttrib.h".} ## \
## Constructs a StencilAttrib that has stenciling turned off.

proc makeDefault*(_: typedesc[StencilAttrib]): RenderAttrib {.importcpp: "deconstify(StencilAttrib::make_default())", header: "stencilAttrib.h".} ## \
## Returns a RenderAttrib that corresponds to whatever the standard default
## properties for render attributes of this type ought to be.

proc getClassSlot*(_: typedesc[StencilAttrib]): int {.importcpp: "StencilAttrib::get_class_slot()", header: "stencilAttrib.h".}

converter getClassType*(_: typedesc[StencilAttrib]): TypeHandle {.importcpp: "StencilAttrib::get_class_type()", header: "stencilAttrib.h".}

proc hasShader*(_: typedesc[ShaderPool], filename: Filename): bool {.importcpp: "#ShaderPool::has_shader(#)", header: "shaderPool.h".} ## \
## Returns true if the shader has ever been loaded, false otherwise.

proc verifyShader*(_: typedesc[ShaderPool], filename: Filename): bool {.importcpp: "#ShaderPool::verify_shader(#)", header: "shaderPool.h".} ## \
## Loads the given filename up into a shader, if it has not already been
## loaded, and returns true to indicate success, or false to indicate failure.
## If this returns true, it is guaranteed that a subsequent call to
## load_shader() with the same shader name will return a valid Shader pointer.

proc loadShader*(_: typedesc[ShaderPool], filename: Filename): Shader {.importcpp: "#ShaderPool::load_shader(#)", header: "shaderPool.h".} ## \
## Loads the given filename up into a shader, if it has not already been
## loaded, and returns the new shader.  If a shader with the same filename was
## previously loaded, returns that one instead.  If the shader file cannot be
## found, returns NULL.

proc addShader*(_: typedesc[ShaderPool], filename: Filename, shader: Shader) {.importcpp: "#ShaderPool::add_shader(#, #)", header: "shaderPool.h".} ## \
## Adds the indicated already-loaded shader to the pool.  The shader will
## always replace any previously-loaded shader in the pool that had the same
## filename.

proc releaseShader*(_: typedesc[ShaderPool], filename: Filename) {.importcpp: "#ShaderPool::release_shader(#)", header: "shaderPool.h".} ## \
## Removes the indicated shader from the pool, indicating it will never be
## loaded again; the shader may then be freed.  If this function is never
## called, a reference count will be maintained on every shader every loaded,
## and shaders will never be freed.

proc releaseAllShaders*(_: typedesc[ShaderPool]) {.importcpp: "ShaderPool::release_all_shaders()", header: "shaderPool.h".} ## \
## Releases all shaders in the pool and restores the pool to the empty state.

proc garbageCollect*(_: typedesc[ShaderPool]): int {.importcpp: "ShaderPool::garbage_collect()", header: "shaderPool.h".} ## \
## Releases only those shaders in the pool that have a reference count of
## exactly 1; i.e.  only those shaders that are not being used outside of the
## pool.  Returns the number of shaders released.

proc listContents*(_: typedesc[ShaderPool], `out`: ostream) {.importcpp: "#ShaderPool::list_contents(#)", header: "shaderPool.h".} ## \
## Lists the contents of the shader pool to the indicated output stream.

proc write*(_: typedesc[ShaderPool], `out`: ostream) {.importcpp: "#ShaderPool::write(#)", header: "shaderPool.h".} ## \
## Lists the contents of the shader pool to the indicated output stream.

converter upcastToTypedWritableReferenceCount*(this: MovieAudio): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcastToNamable*(this: MovieAudio): Namable {.importcpp: "((Namable *)(MovieAudio *)(#))".}

proc newMovieAudio*(param0: MovieAudio): MovieAudio {.importcpp: "new MovieAudio(#)".}

proc newMovieAudio*(name: string): MovieAudio {.importcpp: "new MovieAudio(nimStringToStdString(#))", header: stringConversionCode.} ## \
## This constructor returns a null audio stream --- a stream of total silence,
## at 8000 samples per second.  To get more interesting audio, you need to
## construct a subclass of this class.

proc newMovieAudio*(): MovieAudio {.importcpp: "new MovieAudio()".} ## \
## This constructor returns a null audio stream --- a stream of total silence,
## at 8000 samples per second.  To get more interesting audio, you need to
## construct a subclass of this class.

proc open*(this: MovieAudio): MovieAudioCursor {.importcpp: "#->open()".} ## \
## Open this audio, returning a MovieAudioCursor

proc get*(_: typedesc[MovieAudio], name: Filename): MovieAudio {.importcpp: "#MovieAudio::get(#)", header: "movieAudio.h".} ## \
## Obtains a MovieAudio that references a file.  Just calls
## MovieTypeRegistry::make_audio().

proc getFilename*(this: MovieAudio): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the movie's filename.  A movie is not guaranteed to have a
## filename, if not, then this function returns a null filename.

converter getClassType*(_: typedesc[MovieAudio]): TypeHandle {.importcpp: "MovieAudio::get_class_type()", header: "movieAudio.h".}

proc newFlacAudio*(name: Filename): FlacAudio {.importcpp: "new FlacAudio(#)".} ## \
## xxx

proc newFlacAudio*(param0: FlacAudio): FlacAudio {.importcpp: "new FlacAudio(#)".}

proc make*(_: typedesc[FlacAudio], name: Filename): MovieAudio {.importcpp: "#FlacAudio::make(#)", header: "flacAudio.h".} ## \
## Obtains a MovieAudio that references a file.

converter getClassType*(_: typedesc[FlacAudio]): TypeHandle {.importcpp: "FlacAudio::get_class_type()", header: "flacAudio.h".}

proc newMovieAudioCursor*(src: MovieAudio): MovieAudioCursor {.importcpp: "new MovieAudioCursor(#)".} ## \
## This constructor returns a null audio stream --- a stream of total silence,
## at 8000 samples per second.  To get more interesting audio, you need to
## construct a subclass of this class.

proc newMovieAudioCursor*(param0: MovieAudioCursor): MovieAudioCursor {.importcpp: "new MovieAudioCursor(#)".}

proc getSource*(this: MovieAudioCursor): MovieAudio {.importcpp: "#->get_source()".} ## \
## Returns the MovieAudio which this cursor references.

proc audioRate*(this: MovieAudioCursor): int {.importcpp: "#->audio_rate()".} ## \
## Returns the audio sample rate.

proc audioChannels*(this: MovieAudioCursor): int {.importcpp: "#->audio_channels()".} ## \
## Returns the number of audio channels (ie, two for stereo, one for mono).

proc length*(this: MovieAudioCursor): float64 {.importcpp: "#->length()".} ## \
## Returns the length of the movie.  Attempting to read audio samples beyond
## the specified length will produce silent samples.
##
## Some kinds of Movie, such as internet TV station, might not have a
## predictable length.  In that case, the length will be set to a very large
## number: 1.0E10.
##
## Some AVI files have incorrect length values encoded into them - they may be
## a second or two long or short.  When playing such an AVI using the Movie
## class, you may see a slightly truncated video, or a slightly elongated
## video (padded with black frames).  There are utilities out there to fix the
## length values in AVI files.
##
## An audio consumer needs to check the length, the ready status, and the
## aborted flag.

proc canSeek*(this: MovieAudioCursor): bool {.importcpp: "#->can_seek()".} ## \
## Returns true if the movie can seek.  If this is true, seeking is still not
## guaranteed to be fast: for some movies, seeking is implemented by rewinding
## to the beginning and then fast-forwarding to the desired location.  Even if
## the movie cannot seek, the seek method can still advance to an arbitrary
## location by reading samples and discarding them.  However, to move
## backward, can_seek must return true.

proc canSeekFast*(this: MovieAudioCursor): bool {.importcpp: "#->can_seek_fast()".} ## \
## Returns true if seek operations are constant time.

proc tell*(this: MovieAudioCursor): float64 {.importcpp: "#->tell()".} ## \
## Returns the current offset within the file.

proc skipSamples*(this: MovieAudioCursor, n: int) {.importcpp: "#->skip_samples(#)".} ## \
## Skip audio samples from the stream.  This is mostly for debugging purposes.

proc aborted*(this: MovieAudioCursor): bool {.importcpp: "#->aborted()".} ## \
## If aborted is true, it means that the "ready" samples are not being
## replenished.  See the method "ready" for an explanation.

proc ready*(this: MovieAudioCursor): int {.importcpp: "#->ready()".} ## \
## Returns the number of audio samples that are ready to read.  This is
## primarily relevant for sources like microphones which produce samples at a
## fixed rate.  If you try to read more samples than are ready, the result
## will be silent samples.
##
## Some audio streams do not have a limit on how fast they can produce
## samples.  Such streams will always return 0x40000000 as the ready-count.
## This may well exceed the length of the audio stream.  You therefore need to
## check length separately.
##
## If the aborted flag is set, that means the ready count is no longer being
## replenished.  For example, a MovieAudioCursor might be reading from an
## internet radio station, and it might buffer data to avoid underruns.  If it
## loses connection to the radio station, it will set the aborted flag to
## indicate that the buffer is no longer being replenished.  But it is still
## ok to read the samples that are in the buffer, at least until they run out.
## Once those are gone, there will be no more.
##
## An audio consumer needs to check the length, the ready status, and the
## aborted flag.

proc seek*(this: MovieAudioCursor, offset: float64) {.importcpp: "#->seek(#)".} ## \
## Skips to the specified offset within the file.
##
## If the movie reports that it cannot seek, then this method can still
## advance by reading samples and discarding them.  However, to move backward,
## can_seek must be true.
##
## If the movie reports that it can_seek, it doesn't mean that it can do so
## quickly.  It may have to rewind the movie and then fast forward to the
## desired location.  Only if can_seek_fast returns true can seek operations
## be done in constant time.
##
## Seeking may not be precise, because AVI files often have inaccurate
## indices.  After seeking, tell will indicate that the cursor is at the
## target location.  However, in truth, the data you read may come from a
## slightly offset location.

proc readSamples*(this: MovieAudioCursor, n: int): string {.importcpp: "nimStringFromStdString(#->read_samples(#))", header: stringConversionCode.} ## \
## Read audio samples from the stream and returns them as a string.  The
## samples are stored little-endian in the string.  N is the number of samples
## you wish to read.  Multiple-channel audio will be interleaved.
##
## This is not particularly efficient, but it may be a convenient way to
## manipulate samples in python.

proc readSamples*(this: MovieAudioCursor, n: int, dg: Datagram) {.importcpp: "#->read_samples(#, #)".} ## \
## Read audio samples from the stream into a Datagram.  N is the number of
## samples you wish to read.  Multiple-channel audio will be interleaved.
##
## This is not particularly efficient, but it may be a convenient way to
## manipulate samples in python.

converter getClassType*(_: typedesc[MovieAudioCursor]): TypeHandle {.importcpp: "MovieAudioCursor::get_class_type()", header: "movieAudioCursor.h".}

proc newFlacAudioCursor*(src: FlacAudio, stream: istream): FlacAudioCursor {.importcpp: "new FlacAudioCursor(#, #)".} ## \
## Reads the .wav header from the indicated stream.  This leaves the read
## pointer positioned at the start of the data.

proc newFlacAudioCursor*(param0: FlacAudioCursor): FlacAudioCursor {.importcpp: "new FlacAudioCursor(#)".}

converter getClassType*(_: typedesc[FlacAudioCursor]): TypeHandle {.importcpp: "FlacAudioCursor::get_class_type()", header: "flacAudioCursor.h".}

converter upcastToTypedWritableReferenceCount*(this: MovieVideo): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcastToNamable*(this: MovieVideo): Namable {.importcpp: "((Namable *)(MovieVideo *)(#))".}

proc newMovieVideo*(param0: MovieVideo): MovieVideo {.importcpp: "new MovieVideo(#)".}

proc newMovieVideo*(name: string): MovieVideo {.importcpp: "new MovieVideo(nimStringToStdString(#))", header: stringConversionCode.} ## \
## This constructor returns a null video stream --- a stream of plain blue and
## white frames that last one second each.  To get more interesting video, you
## need to construct a subclass of this class.

proc newMovieVideo*(): MovieVideo {.importcpp: "new MovieVideo()".} ## \
## This constructor returns a null video stream --- a stream of plain blue and
## white frames that last one second each.  To get more interesting video, you
## need to construct a subclass of this class.

proc open*(this: MovieVideo): MovieVideoCursor {.importcpp: "#->open()".} ## \
## Open this video, returning a MovieVideoCursor of the appropriate type.
## Returns NULL on error.

proc get*(_: typedesc[MovieVideo], name: Filename): MovieVideo {.importcpp: "#MovieVideo::get(#)", header: "movieVideo.h".} ## \
## Obtains a MovieVideo that references a file.  Just calls
## MovieTypeRegistry::make_video().

proc getFilename*(this: MovieVideo): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the movie's filename.  A movie is not guaranteed to have a
## filename, if not, then this function returns an empty filename.

proc getSubfileInfo*(this: MovieVideo): SubfileInfo {.importcpp: "#->get_subfile_info()".} ## \
## If the movie is to be loaded from a subfile on disk, this returns the
## subfile info.  Check info.is_empty() to see if this is valid data.

converter getClassType*(_: typedesc[MovieVideo]): TypeHandle {.importcpp: "MovieVideo::get_class_type()", header: "movieVideo.h".}

proc newInkblotVideo*(param0: InkblotVideo): InkblotVideo {.importcpp: "new InkblotVideo(#)".}

proc newInkblotVideo*(x: int, y: int, fps: int): InkblotVideo {.importcpp: "new InkblotVideo(#, #, #)".} ## \
## xxx

converter getClassType*(_: typedesc[InkblotVideo]): TypeHandle {.importcpp: "InkblotVideo::get_class_type()", header: "inkblotVideo.h".}

proc getSource*(this: MovieVideoCursor): MovieVideo {.importcpp: "#->get_source()".} ## \
## Get the MovieVideo which this cursor references.

proc sizeX*(this: MovieVideoCursor): int {.importcpp: "#->size_x()".} ## \
## Get the horizontal size of the movie.

proc sizeY*(this: MovieVideoCursor): int {.importcpp: "#->size_y()".} ## \
## Get the vertical size of the movie.

proc getNumComponents*(this: MovieVideoCursor): int {.importcpp: "#->get_num_components()".} ## \
## Returns 4 if the movie has an alpha channel, 3 otherwise.

proc length*(this: MovieVideoCursor): float64 {.importcpp: "#->length()".} ## \
## Returns the length of the movie.
##
## Some kinds of Movie, such as internet TV station, might not have a
## predictable length.  In that case, the length will be set to a very large
## number: 1.0E10. If the internet TV station goes offline, the video or audio
## stream will set its abort flag.  Reaching the end of the movie (ie, the
## specified length) normally does not cause the abort flag to be set.
##
## The video and audio streams produced by get_video and get_audio are always
## of unlimited duration - you can always read another video frame or another
## audio sample.  This is true even if the specified length is reached, or an
## abort is flagged.  If either stream runs out of data, it will synthesize
## blank video frames and silent audio samples as necessary to satisfy read
## requests.
##
## Some AVI files have incorrect length values encoded into them - usually,
## they're a second or two long or short.  When playing such an AVI using the
## Movie class, you may see a slightly truncated video, or a slightly
## elongated video (padded with black frames).  There are utilities out there
## to fix the length values in AVI files.

proc canSeek*(this: MovieVideoCursor): bool {.importcpp: "#->can_seek()".} ## \
## Returns true if the movie can seek.  If this is true, seeking is still not
## guaranteed to be fast: for some movies, seeking is implemented by rewinding
## to the beginning and then fast-forwarding to the desired location.  Even if
## the movie cannot seek, the fetch methods can still advance to an arbitrary
## location by reading frames and discarding them.  However, to move backward,
## can_seek must return true.

proc canSeekFast*(this: MovieVideoCursor): bool {.importcpp: "#->can_seek_fast()".} ## \
## Returns true if seek operations are constant time.

proc aborted*(this: MovieVideoCursor): bool {.importcpp: "#->aborted()".} ## \
## Returns true if the video has aborted prematurely.  For example, this could
## occur if the Movie was actually an internet TV station, and the connection
## was lost.  Reaching the normal end of the video does not constitute an
## 'abort' condition.

proc ready*(this: MovieVideoCursor): bool {.importcpp: "#->ready()".} ## \
## Returns true if the cursor is a streaming source, and if a video frame is
## ready to be read.  For non- streaming sources, this is always false.

proc streaming*(this: MovieVideoCursor): bool {.importcpp: "#->streaming()".} ## \
## Returns true if the video frames are being "pushed" at us by something that
## operates at its own speed - for example, a webcam.  In this case, the
## frames come when they're ready to come.  Attempting to read too soon will
## produce nothing, reading too late will cause frames to be dropped.  In this
## case, the ready flag can be used to determine whether or not a frame is
## ready for reading.
##
## When streaming, you should still pay attention to last_start, but the value
## of next_start is only a guess.

proc setupTexture*(this: MovieVideoCursor, tex: Texture) {.importcpp: "#->setup_texture(#)".} ## \
## Set up the specified Texture object to contain content from this movie.
## This should be called once, not every frame.

proc setTime*(this: MovieVideoCursor, timestamp: float64, loop_count: int): bool {.importcpp: "#->set_time(#, #)".} ## \
## Updates the cursor to the indicated time.  If loop_count >= 1, the time is
## clamped to the movie's length \* loop_count.  If loop_count <= 0, the time
## is understood to be modulo the movie's length.
##
## Returns true if a new frame is now available, false otherwise.  If this
## returns true, you should immediately follow this with exactly \*one\* call to
## fetch_buffer().
##
## If the movie reports that it can_seek, you may also specify a time value
## less than the previous value you passed to set_time().  Otherwise, you may
## only specify a time value greater than or equal to the previous value.
##
## If the movie reports that it can_seek, it doesn't mean that it can do so
## quickly.  It may have to rewind the movie and then fast forward to the
## desired location.  Only if can_seek_fast returns true can it seek rapidly.

converter getClassType*(_: typedesc[MovieVideoCursor]): TypeHandle {.importcpp: "MovieVideoCursor::get_class_type()", header: "movieVideoCursor.h".}

proc newMovieVideoCursor*(param0: MovieVideoCursor): MovieVideoCursor {.importcpp: "new MovieVideoCursor(#)".}

proc newInkblotVideoCursor*(src: InkblotVideo): InkblotVideoCursor {.importcpp: "new InkblotVideoCursor(#)".} ## \
## xxx

proc newInkblotVideoCursor*(param0: InkblotVideoCursor): InkblotVideoCursor {.importcpp: "new InkblotVideoCursor(#)".}

converter getClassType*(_: typedesc[InkblotVideoCursor]): TypeHandle {.importcpp: "InkblotVideoCursor::get_class_type()", header: "inkblotVideoCursor.h".}

proc getNumOptions*(_: typedesc[MicrophoneAudio]): int {.importcpp: "MicrophoneAudio::get_num_options()", header: "microphoneAudio.h".} ## \
## Returns the number of microphone options.  An "option" consists of a device
## plus a set of configuration parameters.  For example, "Soundblaster Audigy
## Line in at 44,100 samples/sec" would be an option.

proc getOption*(_: typedesc[MicrophoneAudio], n: int): MicrophoneAudio {.importcpp: "#MicrophoneAudio::get_option(#)", header: "microphoneAudio.h".} ## \
## Returns the nth microphone option.

proc getChannels*(this: MicrophoneAudio): int {.importcpp: "#->get_channels()".} ## \
## Returns the number of channels.

proc getRate*(this: MicrophoneAudio): int {.importcpp: "#->get_rate()".} ## \
## Returns the sample rate.

converter getClassType*(_: typedesc[MicrophoneAudio]): TypeHandle {.importcpp: "MicrophoneAudio::get_class_type()", header: "microphoneAudio.h".}

proc newOpusAudio*(name: Filename): OpusAudio {.importcpp: "new OpusAudio(#)".} ## \
## xxx

proc newOpusAudio*(param0: OpusAudio): OpusAudio {.importcpp: "new OpusAudio(#)".}

proc make*(_: typedesc[OpusAudio], name: Filename): MovieAudio {.importcpp: "#OpusAudio::make(#)", header: "opusAudio.h".} ## \
## Obtains a MovieAudio that references a file.

converter getClassType*(_: typedesc[OpusAudio]): TypeHandle {.importcpp: "OpusAudio::get_class_type()", header: "opusAudio.h".}

proc newOpusAudioCursor*(src: OpusAudio, stream: istream): OpusAudioCursor {.importcpp: "new OpusAudioCursor(#, #)".} ## \
## Reads the .wav header from the indicated stream.  This leaves the read
## pointer positioned at the start of the data.

proc newOpusAudioCursor*(param0: OpusAudioCursor): OpusAudioCursor {.importcpp: "new OpusAudioCursor(#)".}

converter getClassType*(_: typedesc[OpusAudioCursor]): TypeHandle {.importcpp: "OpusAudioCursor::get_class_type()", header: "opusAudioCursor.h".}

proc newUserDataAudio*(param0: UserDataAudio): UserDataAudio {.importcpp: "new UserDataAudio(#)".}

proc newUserDataAudio*(rate: int, channels: int, remove_after_read: bool): UserDataAudio {.importcpp: "new UserDataAudio(#, #, #)".} ## \
## This constructor returns a UserDataAudio --- a means to supply raw audio
## samples manually.

proc newUserDataAudio*(rate: int, channels: int): UserDataAudio {.importcpp: "new UserDataAudio(#, #)".} ## \
## This constructor returns a UserDataAudio --- a means to supply raw audio
## samples manually.

proc append*(this: UserDataAudio, src: DatagramIterator, len: int) {.importcpp: "#->append(#, #)".} ## \
## Appends audio samples to the buffer from a datagram.  This is intended to
## make it easy to send streaming raw audio over a network.

proc append*(this: UserDataAudio, src: DatagramIterator) {.importcpp: "#->append(#)".} ## \
## Appends audio samples to the buffer from a datagram.  This is intended to
## make it easy to send streaming raw audio over a network.

proc append*(this: UserDataAudio, str: string) {.importcpp: "#->append(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Appends audio samples to the buffer from a string.  The samples must be
## stored little-endian in the string.  This is not particularly efficient,
## but it may be convenient to deal with samples in python.

proc done*(this: UserDataAudio) {.importcpp: "#->done()".} ## \
## Promises not to append any more samples, ie, this marks the end of the
## audio stream.

converter getClassType*(_: typedesc[UserDataAudio]): TypeHandle {.importcpp: "UserDataAudio::get_class_type()", header: "userDataAudio.h".}

proc newUserDataAudioCursor*(src: UserDataAudio): UserDataAudioCursor {.importcpp: "new UserDataAudioCursor(#)".}

proc newUserDataAudioCursor*(param0: UserDataAudioCursor): UserDataAudioCursor {.importcpp: "new UserDataAudioCursor(#)".}

converter getClassType*(_: typedesc[UserDataAudioCursor]): TypeHandle {.importcpp: "UserDataAudioCursor::get_class_type()", header: "userDataAudioCursor.h".}

proc newVorbisAudio*(name: Filename): VorbisAudio {.importcpp: "new VorbisAudio(#)".} ## \
## xxx

proc newVorbisAudio*(param0: VorbisAudio): VorbisAudio {.importcpp: "new VorbisAudio(#)".}

proc make*(_: typedesc[VorbisAudio], name: Filename): MovieAudio {.importcpp: "#VorbisAudio::make(#)", header: "vorbisAudio.h".} ## \
## Obtains a MovieAudio that references a file.

converter getClassType*(_: typedesc[VorbisAudio]): TypeHandle {.importcpp: "VorbisAudio::get_class_type()", header: "vorbisAudio.h".}

proc newVorbisAudioCursor*(src: VorbisAudio, stream: istream): VorbisAudioCursor {.importcpp: "new VorbisAudioCursor(#, #)".} ## \
## Reads the .wav header from the indicated stream.  This leaves the read
## pointer positioned at the start of the data.

proc newVorbisAudioCursor*(param0: VorbisAudioCursor): VorbisAudioCursor {.importcpp: "new VorbisAudioCursor(#)".}

converter getClassType*(_: typedesc[VorbisAudioCursor]): TypeHandle {.importcpp: "VorbisAudioCursor::get_class_type()", header: "vorbisAudioCursor.h".}

proc newWavAudio*(name: Filename): WavAudio {.importcpp: "new WavAudio(#)".} ## \
## xxx

proc newWavAudio*(param0: WavAudio): WavAudio {.importcpp: "new WavAudio(#)".}

proc make*(_: typedesc[WavAudio], name: Filename): MovieAudio {.importcpp: "#WavAudio::make(#)", header: "wavAudio.h".} ## \
## Obtains a MovieAudio that references a file.

converter getClassType*(_: typedesc[WavAudio]): TypeHandle {.importcpp: "WavAudio::get_class_type()", header: "wavAudio.h".}

proc newWavAudioCursor*(src: WavAudio, stream: istream): WavAudioCursor {.importcpp: "new WavAudioCursor(#, #)".} ## \
## Reads the .wav header from the indicated stream.  This leaves the read
## pointer positioned at the start of the data.

proc newWavAudioCursor*(param0: WavAudioCursor): WavAudioCursor {.importcpp: "new WavAudioCursor(#)".}

converter getClassType*(_: typedesc[WavAudioCursor]): TypeHandle {.importcpp: "WavAudioCursor::get_class_type()", header: "wavAudioCursor.h".}

proc initCardMaker*(param0: CardMaker): CardMaker {.importcpp: "CardMaker(#)".}

proc initCardMaker*(name: string): CardMaker {.importcpp: "CardMaker(nimStringToStdString(#))", header: stringConversionCode.}

proc reset*(this: CardMaker) {.importcpp: "#.reset()".} ## \
## Resets all the parameters to their initial defaults.

proc setUvRange*(this: CardMaker, ll: LTexCoord, ur: LTexCoord) {.importcpp: "#.set_uv_range(#, #)".} ## \
## Sets the range of UV's that will be applied to the vertices.  If
## set_has_uvs() is true (as it is by default), the vertices will be generated
## with the indicated range of UV's, which will be useful if a texture is
## applied.

proc setUvRange*(this: CardMaker, ll: LTexCoord, lr: LTexCoord, ur: LTexCoord, ul: LTexCoord) {.importcpp: "#.set_uv_range(#, #, #, #)".} ## \
## Sets the range of UV's that will be applied to the vertices.  If
## set_has_uvs() is true (as it is by default), the vertices will be generated
## with the indicated range of UV's, which will be useful if a texture is
## applied.

proc setUvRange*(this: CardMaker, ll: LTexCoord3, lr: LTexCoord3, ur: LTexCoord3, ul: LTexCoord3) {.importcpp: "#.set_uv_range(#, #, #, #)".} ## \
## Sets the range of UV's that will be applied to the vertices.  If
## set_has_uvs() is true (as it is by default), the vertices will be generated
## with the indicated range of UV's, which will be useful if a texture is
## applied.

proc setUvRange*(this: CardMaker, x: LVector4, y: LVector4, z: LVector4) {.importcpp: "#.set_uv_range(#, #, #)".} ## \
## Sets the range of UV's that will be applied to the vertices.  If
## set_has_uvs() is true (as it is by default), the vertices will be generated
## with the indicated range of UV's, which will be useful if a texture is
## applied.

proc setUvRange*(this: CardMaker, tex: Texture) {.importcpp: "#.set_uv_range(#)".} ## \
## Sets the range of UV's that will be applied to the vertices appropriately
## to show the non-pad region of the texture.

proc setUvRangeCube*(this: CardMaker, face: int) {.importcpp: "#.set_uv_range_cube(#)".} ## \
## Sets the range of UV's that will be applied to the vertices appropriately
## for a cube-map face.

proc setHasUvs*(this: CardMaker, flag: bool) {.importcpp: "#.set_has_uvs(#)".} ## \
## Sets the flag indicating whether vertices will be generated with UV's or
## not.

proc setHas3dUvs*(this: CardMaker, flag: bool) {.importcpp: "#.set_has_3d_uvs(#)".} ## \
## Sets the flag indicating whether vertices will be generated with
## 3-component UVW's (true) or 2-component UV's (the default, false).
## Normally, this will be implicitly set by setting the uv_range.

proc setFrame*(this: CardMaker, frame: LVecBase4) {.importcpp: "#.set_frame(#)".} ## \
## Sets the size of the card.

proc setFrame*(this: CardMaker, ll: LVertex, lr: LVertex, ur: LVertex, ul: LVertex) {.importcpp: "#.set_frame(#, #, #, #)".} ## \
## Sets the size of the card.

proc setFrame*(this: CardMaker, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#.set_frame(#, #, #, #)".} ## \
## Sets the size of the card.

proc setFrameFullscreenQuad*(this: CardMaker) {.importcpp: "#.set_frame_fullscreen_quad()".} ## \
## Sets the card to (-1,1,-1,1), which is appropriate if you plan to parent it
## to render2d and use it as a fullscreen quad.

proc setColor*(this: CardMaker, color: LColor) {.importcpp: "#.set_color(#)".}

proc setColor*(this: CardMaker, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_color(#, #, #, #)".} ## \
## Sets the color of the card.

proc setHasNormals*(this: CardMaker, flag: bool) {.importcpp: "#.set_has_normals(#)".} ## \
## Sets the flag indicating whether vertices will be generated with normals or
## not.  Normals are required if you intend to enable lighting on the card,
## but are just wasted space and bandwidth otherwise, so there is a (slight)
## optimization for disabling them.  If enabled, the normals will be generated
## perpendicular to the card's face.

proc setSourceGeometry*(this: CardMaker, node: PandaNode, frame: LVecBase4) {.importcpp: "#.set_source_geometry(#, #)".} ## \
## Sets a node that will be copied (and scaled and translated) to generate the
## frame, instead of generating a new polygon.  The node may contain arbitrary
## geometry that describes a flat polygon contained within the indicated left,
## right, bottom, top frame.
##
## When generate() is called, the geometry in this node will be scaled and
## translated appropriately to give it the size and aspect ratio specified by
## set_frame().

proc clearSourceGeometry*(this: CardMaker) {.importcpp: "#.clear_source_geometry()".} ## \
## Removes the node specified by an earlier call to set_source_geometry().

proc generate*(this: CardMaker): PandaNode {.importcpp: "#.generate()".} ## \
## Generates a GeomNode that renders the specified geometry.

proc initFisheyeMaker*(param0: FisheyeMaker): FisheyeMaker {.importcpp: "FisheyeMaker(#)".}

proc initFisheyeMaker*(name: string): FisheyeMaker {.importcpp: "FisheyeMaker(nimStringToStdString(#))", header: stringConversionCode.}

proc reset*(this: FisheyeMaker) {.importcpp: "#.reset()".} ## \
## Resets all the parameters to their initial defaults.

proc setFov*(this: FisheyeMaker, fov: float32) {.importcpp: "#.set_fov(#)".} ## \
## Specifies the field of view of the fisheye projection.  A sphere map will
## have a 360-degree field of view (and this is the default).

proc setNumVertices*(this: FisheyeMaker, num_vertices: int) {.importcpp: "#.set_num_vertices(#)".} ## \
## Specifies the approximate number of vertices to be used to generate the
## rose.  This is the approximate number of vertices that will be located
## within the rose's unit circle, not counting the inscribing square (if any).
## The actual number of vertices used may be +/- 25% of this value.

proc setSquareInscribed*(this: FisheyeMaker, square_inscribed: bool, square_radius: float32) {.importcpp: "#.set_square_inscribed(#, #)".} ## \
## Sets the flag that indicates whether the rose should be inscribed within a
## square.  When this is true, an additional square is generated to inscribed
## the circular rose, with the indicated "radius" (the sides of the square
## will be 2 \* square_radius).  The texture coordinates of the square will
## uniformly map to the back pole of the cube map.
##
## This is mainly useful to provide a good uniform background color for a
## sphere map so that it does not have a sharp circular edge that might
## produce artifacts due to numerical imprecision when mapping.

proc setReflection*(this: FisheyeMaker, reflection: bool) {.importcpp: "#.set_reflection(#)".} ## \
## Sets the flag indicating whether the texture image should be mirrored
## (true) or normal (false).  When this is true, the 3-D texture coordinates
## will be reversed so that the image is appropriate for a reflection.  This
## is the best choice for generating a sphere map from a cube map.  The
## default is false.

proc generate*(this: FisheyeMaker): PandaNode {.importcpp: "#.generate()".} ## \
## Generates a GeomNode that renders the specified geometry.

proc newFrameRateMeter*(param0: FrameRateMeter): FrameRateMeter {.importcpp: "new FrameRateMeter(#)".}

proc newFrameRateMeter*(name: string): FrameRateMeter {.importcpp: "new FrameRateMeter(nimStringToStdString(#))", header: stringConversionCode.}

proc setupWindow*(this: FrameRateMeter, window: GraphicsOutput) {.importcpp: "#->setup_window(#)".} ## \
## Sets up the frame rate meter to create a DisplayRegion to render itself
## into the indicated window.

proc clearWindow*(this: FrameRateMeter) {.importcpp: "#->clear_window()".} ## \
## Undoes the effect of a previous call to setup_window().

proc getWindow*(this: FrameRateMeter): GraphicsOutput {.importcpp: "#->get_window()".} ## \
## Returns the GraphicsOutput that was passed to setup_window(), or NULL if
## setup_window() has not been called.

proc getDisplayRegion*(this: FrameRateMeter): DisplayRegion {.importcpp: "#->get_display_region()".} ## \
## Returns the DisplayRegion that the meter has created to render itself into
## the window to setup_window(), or NULL if setup_window() has not been
## called.

proc setUpdateInterval*(this: FrameRateMeter, update_interval: float64) {.importcpp: "#->set_update_interval(#)".} ## \
## Specifies the number of seconds that should elapse between updates to the
## frame rate indication.  This should be reasonably slow (e.g.  0.2 to 1.0)
## so that the calculation of the frame rate text does not itself dominate the
## frame rate.

proc getUpdateInterval*(this: FrameRateMeter): float64 {.importcpp: "#->get_update_interval()".} ## \
## Returns the number of seconds that will elapse between updates to the frame
## rate indication.

proc setTextPattern*(this: FrameRateMeter, text_pattern: string) {.importcpp: "#->set_text_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the sprintf() pattern that is used to format the text.  The string
## "%f" or some variant will be replaced with the current frame rate in frames
## per second.

proc getTextPattern*(this: FrameRateMeter): string {.importcpp: "nimStringFromStdString(#->get_text_pattern())", header: stringConversionCode.} ## \
## Returns the sprintf() pattern that is used to format the text.

proc setClockObject*(this: FrameRateMeter, clock_object: ClockObject) {.importcpp: "#->set_clock_object(#)".} ## \
## Sets the clock that is used to determine the frame rate.  The default is
## the application's global clock (ClockObject::get_global_clock()).

proc getClockObject*(this: FrameRateMeter): ClockObject {.importcpp: "#->get_clock_object()".} ## \
## Returns the clock that is used to determine the frame rate.

proc update*(this: FrameRateMeter) {.importcpp: "#->update()".} ## \
## You can call this to explicitly force the FrameRateMeter to update itself
## with the latest frame rate information.  Normally, it is not necessary to
## call this explicitly.

converter getClassType*(_: typedesc[FrameRateMeter]): TypeHandle {.importcpp: "FrameRateMeter::get_class_type()", header: "frameRateMeter.h".}

proc initGeoMipTerrain*(name: string): GeoMipTerrain {.importcpp: "GeoMipTerrain(nimStringToStdString(#))", header: stringConversionCode.}

proc heightfield*(this: GeoMipTerrain): PNMImage {.importcpp: "#.heightfield()".} ## \
## Returns a reference to the heightfield (a PNMImage) contained inside
## GeoMipTerrain.  You can use the reference to alter the heightfield.

proc setHeightfield*(this: GeoMipTerrain, filename: Filename, `type`: PNMFileType): bool {.importcpp: "#.set_heightfield(#, #)".} ## \
## Loads the specified heightmap image file into the heightfield.  Returns
## true if succeeded, or false if an error has occured.  If the heightmap is
## not a power of two plus one, it is scaled up using a gaussian filter.

proc setHeightfield*(this: GeoMipTerrain, filename: Filename): bool {.importcpp: "#.set_heightfield(#)".} ## \
## Loads the specified heightmap image file into the heightfield.  Returns
## true if succeeded, or false if an error has occured.  If the heightmap is
## not a power of two plus one, it is scaled up using a gaussian filter.

proc setHeightfield*(this: GeoMipTerrain, image: PNMImage): bool {.importcpp: "#.set_heightfield(#)".} ## \
## Loads the specified heightmap image file into the heightfield.  Returns
## true if succeeded, or false if an error has occured.  If the heightmap is
## not a power of two plus one, it is scaled up using a gaussian filter.

proc colorMap*(this: GeoMipTerrain): PNMImage {.importcpp: "#.color_map()".} ## \
## Returns a reference to the color map (a PNMImage) contained inside
## GeoMipTerrain.  You can use the reference to alter the color map.

proc setColorMap*(this: GeoMipTerrain, filename: Filename, `type`: PNMFileType): bool {.importcpp: "#.set_color_map(#, #)".} ## \
## Loads the specified image as color map.  The next time generate() is
## called, the terrain is painted with this color map using the vertex color
## column.  Returns a boolean indicating whether the operation has succeeded.

proc setColorMap*(this: GeoMipTerrain, filename: Filename): bool {.importcpp: "#.set_color_map(#)".} ## \
## Loads the specified image as color map.  The next time generate() is
## called, the terrain is painted with this color map using the vertex color
## column.  Returns a boolean indicating whether the operation has succeeded.

proc setColorMap*(this: GeoMipTerrain, image: PNMImage): bool {.importcpp: "#.set_color_map(#)".}

proc setColorMap*(this: GeoMipTerrain, image: Texture): bool {.importcpp: "#.set_color_map(#)".}

proc setColorMap*(this: GeoMipTerrain, path: string): bool {.importcpp: "#.set_color_map(nimStringToStdString(#))", header: stringConversionCode.}

proc hasColorMap*(this: GeoMipTerrain): bool {.importcpp: "#.has_color_map()".} ## \
## Returns whether a color map has been set.

proc clearColorMap*(this: GeoMipTerrain) {.importcpp: "#.clear_color_map()".} ## \
## Clears the color map.

proc calcAmbientOcclusion*(this: GeoMipTerrain, radius: float32, contrast: float32, brightness: float32) {.importcpp: "#.calc_ambient_occlusion(#, #, #)".} ## \
## Calculates an approximate for the ambient occlusion and stores it in the
## color map, so that it will be written to the vertex colors.  Any existing
## color map will be discarded.  You need to call this before generating the
## geometry.

proc calcAmbientOcclusion*(this: GeoMipTerrain, radius: float32, contrast: float32) {.importcpp: "#.calc_ambient_occlusion(#, #)".} ## \
## Calculates an approximate for the ambient occlusion and stores it in the
## color map, so that it will be written to the vertex colors.  Any existing
## color map will be discarded.  You need to call this before generating the
## geometry.

proc calcAmbientOcclusion*(this: GeoMipTerrain, radius: float32) {.importcpp: "#.calc_ambient_occlusion(#)".} ## \
## Calculates an approximate for the ambient occlusion and stores it in the
## color map, so that it will be written to the vertex colors.  Any existing
## color map will be discarded.  You need to call this before generating the
## geometry.

proc calcAmbientOcclusion*(this: GeoMipTerrain) {.importcpp: "#.calc_ambient_occlusion()".} ## \
## Calculates an approximate for the ambient occlusion and stores it in the
## color map, so that it will be written to the vertex colors.  Any existing
## color map will be discarded.  You need to call this before generating the
## geometry.

proc getElevation*(this: GeoMipTerrain, x: float64, y: float64): float64 {.importcpp: "#.get_elevation(#, #)".} ## \
## Fetches the elevation at (x, y), where the input coordinate is specified in
## pixels.  This ignores the current LOD level and instead provides an
## accurate number.  Linear blending is used for non-integral coordinates.
## Terrain scale is NOT taken into account!  To get accurate normals, please
## multiply this with the terrain Z scale!
##
## trueElev = terr.get_elevation(x,y) \* terr.get_sz();

proc getNormal*(this: GeoMipTerrain, x: int, y: int): LVector3 {.importcpp: "#.get_normal(#, #)".} ## \
## Fetches the terrain normal at (x, y), where the input coordinate is
## specified in pixels.  This ignores the current LOD level and instead
## provides an accurate number.  Terrain scale is NOT taken into account!  To
## get accurate normals, please divide it by the terrain scale and normalize
## it again, like this:
##
## LVector3 normal (terr.get_normal(x, y)); normal.set(normal.get_x() /
## root.get_sx(), normal.get_y() / root.get_sy(), normal.get_z() /
## root.get_sz()); normal.normalize();

proc getNormal*(this: GeoMipTerrain, mx: int, my: int, x: int, y: int): LVector3 {.importcpp: "#.get_normal(#, #, #, #)".} ## \
## Fetches the terrain normal at (x,y), where the input coordinate is
## specified in pixels.  This ignores the current LOD level and instead
## provides an accurate number.  Terrain scale is NOT taken into account!  To
## get accurate normals, please divide it by the terrain scale and normalize
## it again!

proc setBruteforce*(this: GeoMipTerrain, bf: bool) {.importcpp: "#.set_bruteforce(#)".} ## \
## Sets a boolean specifying whether the terrain will be rendered bruteforce.
## If the terrain is rendered bruteforce, there will be no Level of Detail,
## and the update() call will only update the terrain if it is marked dirty.

proc getBruteforce*(this: GeoMipTerrain): bool {.importcpp: "#.get_bruteforce()".} ## \
## Returns a boolean whether the terrain is rendered bruteforce or not.  See
## set_bruteforce for more information.

proc setAutoFlatten*(this: GeoMipTerrain, mode: int) {.importcpp: "#.set_auto_flatten(#)".} ## \
## The terrain can be automatically flattened (using flatten_light,
## flatten_medium, or flatten_strong) after each update.  This only affects
## future updates, it doesn't flatten the current terrain.

proc setFocalPoint*(this: GeoMipTerrain, fp: LPoint2d) {.importcpp: "#.set_focal_point(#)".} ## \
## The focal point is the point at which the terrain will have the highest
## quality (lowest level of detail). Parts farther away from the focal point
## will have a lower quality (higher level of detail). The focal point is
## not taken in respect if bruteforce is set true.

proc setFocalPoint*(this: GeoMipTerrain, fp: LPoint2f) {.importcpp: "#.set_focal_point(#)".}

proc setFocalPoint*(this: GeoMipTerrain, fp: LPoint3d) {.importcpp: "#.set_focal_point(#)".}

proc setFocalPoint*(this: GeoMipTerrain, fp: LPoint3f) {.importcpp: "#.set_focal_point(#)".}

proc setFocalPoint*(this: GeoMipTerrain, fnp: NodePath) {.importcpp: "#.set_focal_point(#)".}

proc setFocalPoint*(this: GeoMipTerrain, x: float64, y: float64) {.importcpp: "#.set_focal_point(#, #)".} ## \
## Sets the focal point.  GeoMipTerrain generates high-resolution terrain
## around the focal point, and progressively lower and lower resolution
## terrain as you get farther away.  If a point is supplied and not a
## NodePath, make sure it's relative to the terrain.  Only the x and y
## coordinates of the focal point are taken in respect.

proc getFocalPoint*(this: GeoMipTerrain): NodePath {.importcpp: "#.get_focal_point()".} ## \
## Returns the focal point, as a NodePath.  If you have set it to be just a
## point, it will return an empty node at the focal position.

proc getRoot*(this: GeoMipTerrain): NodePath {.importcpp: "#.get_root()".} ## \
## Returns the root of the terrain.  This is a single PandaNode to which all
## the rest of the terrain is parented.  The generate and update operations
## replace the nodes which are parented to this root, but they don't replace
## this root itself.

proc setBlockSize*(this: GeoMipTerrain, newbs: int) {.importcpp: "#.set_block_size(#)".} ## \
## Sets the block size.  If it is not a power of two, the closest power of two
## is used.

proc getBlockSize*(this: GeoMipTerrain): int {.importcpp: "#.get_block_size()".} ## \
## Gets the block size.

proc getMaxLevel*(this: GeoMipTerrain): int {.importcpp: "#.get_max_level()".} ## \
## Returns the highest level possible for this block size.  When a block is at
## this level, it will be the worst quality possible.

proc setMinLevel*(this: GeoMipTerrain, minlevel: int) {.importcpp: "#.set_min_level(#)".} ## \
## Sets the minimum level of detail at which blocks may be generated by
## generate() or update(). The default value is 0, which is the highest
## quality.  This value is also taken in respect when generating the terrain
## bruteforce.

proc getMinLevel*(this: GeoMipTerrain): int {.importcpp: "#.get_min_level()".} ## \
## Gets the minimum level of detail at which blocks may be generated by
## generate() or update(). The default value is 0, which is the highest
## quality.

proc isDirty*(this: GeoMipTerrain): bool {.importcpp: "#.is_dirty()".} ## \
## Returns a bool indicating whether the terrain is marked 'dirty', that means
## the terrain has to be regenerated on the next update() call, because for
## instance the heightfield has changed.  Once the terrain has been
## regenerated, the dirty flag automatically gets reset internally.

proc setFactor*(this: GeoMipTerrain, factor: float32) {.importcpp: "#.set_factor(#)".} ## \
## DEPRECATED method.  Use set_near/far instead.  Sets the quality factor at
## which blocks must be generated.  The higher this level, the better quality
## the terrain will be, but more expensive to render.  A value of 0 makes the
## terrain the lowest quality possible, depending on blocksize.  The default
## value is 100.

proc setNearFar*(this: GeoMipTerrain, input_near: float64, input_far: float64) {.importcpp: "#.set_near_far(#, #)".} ## \
## Sets the near and far LOD distances in one call.

proc setNear*(this: GeoMipTerrain, input_near: float64) {.importcpp: "#.set_near(#)".} ## \
## Sets the near LOD distance, at which the terrain will be rendered at
## highest quality.  This distance is in the terrain's coordinate space!

proc setFar*(this: GeoMipTerrain, input_far: float64) {.importcpp: "#.set_far(#)".} ## \
## Sets the far LOD distance, at which the terrain will be rendered at lowest
## quality.  This distance is in the terrain's coordinate space!

proc getBlockNodePath*(this: GeoMipTerrain, mx: int, my: int): NodePath {.importcpp: "#.get_block_node_path(#, #)".} ## \
## Returns the NodePath of the specified block.  If auto-flatten is enabled
## and the node is getting removed during the flattening process, it will
## still return a NodePath with the appropriate terrain chunk, but it will be
## in a temporary scenegraph.  Please note that this returns a const object
## and you can not modify the node.  Modify the heightfield instead.

proc getBlockFromPos*(this: GeoMipTerrain, x: float64, y: float64): LVecBase2 {.importcpp: "#.get_block_from_pos(#, #)".} ## \
## Gets the coordinates of the block at the specified position.  This position
## must be relative to the terrain, not to render.  Returns an array
## containing two values: the block x and the block y coords.  If the
## positions are out of range, the closest block is taken.  Note that the
## VecBase returned does not represent a vector, position, or rotation, but it
## contains the block index of the block which you can use in
## GeoMipTerrain::get_block_node_path.

proc setBorderStitching*(this: GeoMipTerrain, stitching: bool) {.importcpp: "#.set_border_stitching(#)".} ## \
## If this value is true, the LOD level at the borders of the terrain will be
## 0. This is useful if you have multiple terrains attached and you want to
## stitch them together, to fix seams.  This setting also has effect when
## bruteforce is enabled, although in that case you are probably better off
## with setting the minlevels to the same value.

proc getBorderStitching*(this: GeoMipTerrain): bool {.importcpp: "#.get_border_stitching()".} ## \
## Returns the current stitching setting.  False by default, unless
## set_stitching has been set.

proc getFar*(this: GeoMipTerrain): float64 {.importcpp: "#.get_far()".} ## \
## Returns the far LOD distance in the terrain coordinate space

proc getNear*(this: GeoMipTerrain): float64 {.importcpp: "#.get_near()".} ## \
## Returns the near LOD distance in the terrain coordinate space

proc getFlattenMode*(this: GeoMipTerrain): int {.importcpp: "#.get_flatten_mode()".} ## \
## Returns the automatic-flatten mode (e.g., off, flatten_light,
## flatten_medium, or flatten_strong)

proc makeSlopeImage*(this: GeoMipTerrain): PNMImage {.importcpp: "#.make_slope_image()".} ## \
## Returns a new grayscale image containing the slope angles.  A white pixel
## value means a vertical slope, while a black pixel will mean that the
## terrain is entirely flat at that pixel.  You can translate it to degrees by
## mapping the greyscale values from 0 to 90 degrees.  The resulting image
## will have the same size as the heightfield image.  The scale will be taken
## into respect -- meaning, if you change the terrain scale, the slope image
## will need to be regenerated in order to be correct.

proc generate*(this: GeoMipTerrain) {.importcpp: "#.generate()".} ## \
## (Re)generates the entire terrain, erasing the current.  This call un-
## flattens the terrain, so make sure you have set auto-flatten if you want to
## keep your terrain flattened.

proc update*(this: GeoMipTerrain): bool {.importcpp: "#.update()".} ## \
## Loops through all of the terrain blocks, and checks whether they need to be
## updated.  If that is indeed the case, it regenerates the mipmap.  Returns a
## true when the terrain has changed.  Returns false when the terrain isn't
## updated at all.  If there is no terrain yet, it generates the entire
## terrain.  This call un-flattens the terrain, so make sure you have set
## auto-flatten if you want to keep your terrain flattened.

converter getClassType*(_: typedesc[GeoMipTerrain]): TypeHandle {.importcpp: "GeoMipTerrain::get_class_type()", header: "geoMipTerrain.h".}

proc initHeightfieldTesselator*(param0: HeightfieldTesselator): HeightfieldTesselator {.importcpp: "HeightfieldTesselator(#)".}

proc initHeightfieldTesselator*(name: string): HeightfieldTesselator {.importcpp: "HeightfieldTesselator(nimStringToStdString(#))", header: stringConversionCode.}

proc heightfield*(this: HeightfieldTesselator): PNMImage {.importcpp: "#.heightfield()".} ## \
## Returns a reference to the heightfield (a PNMImage) contained inside the
## HeightfieldTesselator.  You can use the reference to alter the heightfield.

proc setHeightfield*(this: HeightfieldTesselator, filename: Filename, `type`: PNMFileType): bool {.importcpp: "#.set_heightfield(#, #)".} ## \
## Loads the specified greyscale image file into the heightfield.

proc setHeightfield*(this: HeightfieldTesselator, filename: Filename): bool {.importcpp: "#.set_heightfield(#)".} ## \
## Loads the specified greyscale image file into the heightfield.

proc setPolyCount*(this: HeightfieldTesselator, n: int) {.importcpp: "#.set_poly_count(#)".} ## \
## Sets the polygon-count target.  The tesselator usually manages to come
## within about 20% of the target, plus or minus.

proc setVisibilityRadius*(this: HeightfieldTesselator, r: int) {.importcpp: "#.set_visibility_radius(#)".} ## \
## Sets the visibility radius.  Polygons that are completely outside the
## radius (relative to the focal point) are cropped away.  The cropping is
## imperfect (all approximations are conservative), so this should be used in
## conjunction with a far clipping plane, fog, or some other visibility
## limiting mechanism.  The units are in pixels.

proc setFocalPoint*(this: HeightfieldTesselator, x: int, y: int) {.importcpp: "#.set_focal_point(#, #)".} ## \
## Sets the focal point.  The tesselator generates high-resolution terrain
## around the focal point, and progressively lower and lower resolution
## terrain as you get farther away.  The units are in pixels.

proc setHorizontalScale*(this: HeightfieldTesselator, h: float64) {.importcpp: "#.set_horizontal_scale(#)".} ## \
## Sets the horizontal scale.  The default scale is 1.0, meaning that each
## pixel in the heightfield is 1x1 panda units wide.

proc setVerticalScale*(this: HeightfieldTesselator, v: float64) {.importcpp: "#.set_vertical_scale(#)".} ## \
## Sets the vertical scale.  The default scale is 255.0, meaning that each as
## the gray value ranges from (0-1), the elevation ranges from (0-255) feet.

proc setMaxTriangles*(this: HeightfieldTesselator, n: int) {.importcpp: "#.set_max_triangles(#)".} ## \
## Sets the max triangles per geom.

proc getElevation*(this: HeightfieldTesselator, x: float64, y: float64): float64 {.importcpp: "#.get_elevation(#, #)".} ## \
## Fetches the elevation at (x,y), where the input coordinate is specified in
## pixels.  This ignores the current tesselation level and instead provides an
## accurate number.  Linear blending is used for non-integral coordinates.

proc generate*(this: HeightfieldTesselator): NodePath {.importcpp: "#.generate()".} ## \
## Generates a tree of nodes that represents the heightfield.  This can be
## reparented into the scene.

proc initLineSegs*(param0: LineSegs): LineSegs {.importcpp: "LineSegs(#)".}

proc initLineSegs*(name: string): LineSegs {.importcpp: "LineSegs(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Constructs a LineSegs object, which can be used to create any number of
## disconnected lines or points of various thicknesses and colors through the
## visible scene.  After creating the object, call move_to() and draw_to()
## repeatedly to describe the path, then call create() to create a GeomNode
## which will render the described path.

proc initLineSegs*(): LineSegs {.importcpp: "LineSegs()".} ## \
## Constructs a LineSegs object, which can be used to create any number of
## disconnected lines or points of various thicknesses and colors through the
## visible scene.  After creating the object, call move_to() and draw_to()
## repeatedly to describe the path, then call create() to create a GeomNode
## which will render the described path.

proc reset*(this: LineSegs) {.importcpp: "#.reset()".} ## \
## Removes any lines in progress and resets to the initial empty state.

proc setColor*(this: LineSegs, color: LColor) {.importcpp: "#.set_color(#)".} ## \
## Establishes the color that will be assigned to all vertices created by
## future calls to move_to() and draw_to().

proc setColor*(this: LineSegs, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_color(#, #, #, #)".} ## \
## Establishes the color that will be assigned to all vertices created by
## future calls to move_to() and draw_to().

proc setColor*(this: LineSegs, r: float32, g: float32, b: float32) {.importcpp: "#.set_color(#, #, #)".} ## \
## Establishes the color that will be assigned to all vertices created by
## future calls to move_to() and draw_to().

proc setThickness*(this: LineSegs, thick: float32) {.importcpp: "#.set_thickness(#)".} ## \
## Establishes the line thickness or point size in pixels that will be
## assigned to all lines and points created by future calls to create().

proc moveTo*(this: LineSegs, v: LVecBase3) {.importcpp: "#.move_to(#)".} ## \
## Moves the pen to the given point without drawing a line.  When followed by
## draw_to(), this marks the first point of a line segment; when followed by
## move_to() or create(), this creates a single point.

proc moveTo*(this: LineSegs, x: float32, y: float32, z: float32) {.importcpp: "#.move_to(#, #, #)".} ## \
## Moves the pen to the given point without drawing a line.  When followed by
## draw_to(), this marks the first point of a line segment; when followed by
## move_to() or create(), this creates a single point.

proc drawTo*(this: LineSegs, v: LVecBase3) {.importcpp: "#.draw_to(#)".} ## \
## Draws a line segment from the pen's last position (the last call to move_to
## or draw_to) to the indicated point.  move_to() and draw_to() only update
## tables; the actual drawing is performed when create() is called.

proc drawTo*(this: LineSegs, x: float32, y: float32, z: float32) {.importcpp: "#.draw_to(#, #, #)".} ## \
## Draws a line segment from the pen's last position (the last call to move_to
## or draw_to) to the indicated point.  move_to() and draw_to() only update
## tables; the actual drawing is performed when create() is called.

proc getCurrentPosition*(this: LineSegs): LVertex {.importcpp: "#.get_current_position()".} ## \
## Returns the pen's current position.  The next call to draw_to() will draw a
## line segment from this point.

proc isEmpty*(this: LineSegs): bool {.importcpp: "#.is_empty()".} ## \
## Returns true if move_to() or draw_to() have not been called since the last
## reset() or create(), false otherwise.

proc create*(this: LineSegs, previous: GeomNode, dynamic: bool): GeomNode {.importcpp: "#.create(#, #)".} ## \
## Appends to an existing GeomNode a new Geom that will render the series of
## line segments and points described via calls to move_to() and draw_to().
## The lines and points are created with the color and thickness established
## by calls to set_color() and set_thickness().
##
## If dynamic is true, the line segments will be created with the dynamic Geom
## setting, optimizing them for runtime vertex animation.

proc create*(this: LineSegs, previous: GeomNode): GeomNode {.importcpp: "#.create(#)".} ## \
## Appends to an existing GeomNode a new Geom that will render the series of
## line segments and points described via calls to move_to() and draw_to().
## The lines and points are created with the color and thickness established
## by calls to set_color() and set_thickness().
##
## If dynamic is true, the line segments will be created with the dynamic Geom
## setting, optimizing them for runtime vertex animation.

proc create*(this: LineSegs, dynamic: bool): GeomNode {.importcpp: "#.create(#)".} ## \
## Creates a new GeomNode that will render the series of line segments and
## points described via calls to move_to() and draw_to().  The lines and
## points are created with the color and thickness established by calls to
## set_color() and set_thickness().
##
## If dynamic is true, the line segments will be created with the dynamic Geom
## setting, optimizing them for runtime vertex animation.

proc create*(this: LineSegs): GeomNode {.importcpp: "#.create()".} ## \
## Creates a new GeomNode that will render the series of line segments and
## points described via calls to move_to() and draw_to().  The lines and
## points are created with the color and thickness established by calls to
## set_color() and set_thickness().
##
## If dynamic is true, the line segments will be created with the dynamic Geom
## setting, optimizing them for runtime vertex animation.

proc getNumVertices*(this: LineSegs): int {.importcpp: "#.get_num_vertices()".} ## \
## Returns the total number of line segment and point vertices generated by
## the last call to create().  The positions of these vertices may be read and
## adjusted through get_vertex() and set_vertex().

proc getVertex*(this: LineSegs, n: int): LVertex {.importcpp: "#.get_vertex(#)".} ## \
## Returns the nth point or vertex of the line segment sequence generated by
## the last call to create().  The first move_to() generates vertex 0;
## subsequent move_to() and draw_to() calls generate consecutively higher
## vertex numbers.

proc setVertex*(this: LineSegs, n: int, vert: LVertex) {.importcpp: "#.set_vertex(#, #)".} ## \
## Moves the nth point or vertex of the line segment sequence generated by the
## last call to create().  The first move_to() generates vertex 0; subsequent
## move_to() and draw_to() calls generate consecutively higher vertex numbers.

proc setVertex*(this: LineSegs, vertex: int, x: float32, y: float32, z: float32) {.importcpp: "#.set_vertex(#, #, #, #)".} ## \
## Moves the nth point or vertex of the line segment sequence generated by the
## last call to create().  The first move_to() generates vertex 0; subsequent
## move_to() and draw_to() calls generate consecutively higher vertex numbers.

proc getVertexColor*(this: LineSegs, vertex: int): LColor {.importcpp: "#.get_vertex_color(#)".} ## \
## Returns the color of the nth point or vertex.

proc setVertexColor*(this: LineSegs, vertex: int, c: LColor) {.importcpp: "#.set_vertex_color(#, #)".} ## \
## Changes the vertex color of the nth point or vertex.  See set_vertex().

proc setVertexColor*(this: LineSegs, vertex: int, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_vertex_color(#, #, #, #, #)".} ## \
## Changes the vertex color of the nth point or vertex.  See set_vertex().

proc setVertexColor*(this: LineSegs, vertex: int, r: float32, g: float32, b: float32) {.importcpp: "#.set_vertex_color(#, #, #, #)".} ## \
## Changes the vertex color of the nth point or vertex.  See set_vertex().

proc initMeshDrawer*(): MeshDrawer {.importcpp: "MeshDrawer()".} ## \
## Creates the MeshDrawer low level system.

proc setBudget*(this: MeshDrawer, budget: int) {.importcpp: "#.set_budget(#)".} ## \
## Sets the total triangle budget of the drawer.  This will not be exceeded.
## Don't set some thing too large because it will be slow

proc getBudget*(this: MeshDrawer): int {.importcpp: "#.get_budget()".} ## \
## Gets the total triangle budget of the drawer

proc getRoot*(this: MeshDrawer): NodePath {.importcpp: "#.get_root()".} ## \
## Returns the root NodePath.  You should use this node to reparent mesh
## drawer onto the scene might also want to disable depth draw or enable
## transparency.

proc begin*(this: MeshDrawer, camera: NodePath, render: NodePath) {.importcpp: "#.begin(#, #)".} ## \
## Pass the current camera node and the root node.  Passing the camera is
## required to generate bill boards that face it.

proc tri*(this: MeshDrawer, v1: LVector3, c1: LVector4, uv1: LVector2, v2: LVector3, c2: LVector4, uv2: LVector2, v3: LVector3, c3: LVector4, uv3: LVector2) {.importcpp: "#.tri(#, #, #, #, #, #, #, #, #)".} ## \
## Draws a triangle with the given parameters.

proc particle*(this: MeshDrawer, pos: LVector3, frame: LVector4, size: float32, color: LVector4, rotation: float32) {.importcpp: "#.particle(#, #, #, #, #)".} ## \
## Draws a particle that is sort of like a bill board but has an extra
## rotation component.  Frame contains u,v,u-size,v-size quadruple.

proc blendedParticle*(this: MeshDrawer, pos: LVector3, frame1: LVector4, frame2: LVector4, blend: float32, size: float32, color: LVector4, rotation: float32) {.importcpp: "#.blended_particle(#, #, #, #, #, #, #)".} ## \
## Works just like particle but accepts 2 frames and a blend (from 0 to 1)
## component between them Frame contains u,v,u-size,v-size quadruple.

proc billboard*(this: MeshDrawer, pos: LVector3, frame: LVector4, size: float32, color: LVector4) {.importcpp: "#.billboard(#, #, #, #)".} ## \
## Draws a billboard - particle with no rotation.  Billboards always face the
## camera.  Frame contains u,v,u-size,v-size quadruple.

proc segment*(this: MeshDrawer, start: LVector3, stop: LVector3, frame: LVector4, thickness: float32, color: LVector4) {.importcpp: "#.segment(#, #, #, #, #)".} ## \
## Draws a segment a line with a thickness.  That has billboarding effect.
## Frame contains u,v,u-size,v-size quadruple.

proc crossSegment*(this: MeshDrawer, start: LVector3, stop: LVector3, frame: LVector4, thickness: float32, color: LVector4) {.importcpp: "#.cross_segment(#, #, #, #, #)".} ## \
## Draws a segment a line with a thickness.  This segment does not use the
## bill boarding behavior and instead draws 2 planes in a cross.  Stars at
## start and ends at stop.  Frame contains u,v,u-size,v-size quadruple.

proc unevenSegment*(this: MeshDrawer, start: LVector3, stop: LVector3, frame: LVector4, thickness_start: float32, color_start: LVector4, thickness_stop: float32, color_stop: LVector4) {.importcpp: "#.uneven_segment(#, #, #, #, #, #, #)".} ## \
## Draws a segment a line with different thickness and color on both sides.
## Stars at start and ends at stop.  Frame contains u,v,u-size,v-size
## quadruple.

proc linkSegment*(this: MeshDrawer, pos: LVector3, frame: LVector4, thickness: float32, color: LVector4) {.importcpp: "#.link_segment(#, #, #, #)".} ## \
## Stars or continues linked segment.  Control position, frame, thickness and
## color with parameters.  Frame contains u,v,u-size,v-size quadruple.

proc linkSegmentEnd*(this: MeshDrawer, frame: LVector4, color: LVector4) {.importcpp: "#.link_segment_end(#, #)".} ## \
## Finish drawing linked segments, needs at least two calls to link_segment
## before it can end the linked segment.  Frame contains u,v,u-size,v-size
## quadruple.

proc explosion*(this: MeshDrawer, pos: LVector3, frame: LVector4, size: float32, color: LVector4, seed: int, number: int, distance: float32) {.importcpp: "#.explosion(#, #, #, #, #, #, #)".} ## \
## Draws number of particles in a sphere like emitter.  Frame contains
## u,v,u-size,v-size quadruple.

proc stream*(this: MeshDrawer, start: LVector3, stop: LVector3, frame: LVector4, size: float32, color: LVector4, number: int, offset: float32) {.importcpp: "#.stream(#, #, #, #, #, #, #)".} ## \
## Draws a number of particles in a big line with a shift dictated by the
## offset.  Frame contains u,v,u-size,v-size quadruple.

proc geometry*(this: MeshDrawer, node: NodePath) {.importcpp: "#.geometry(#)".} ## \
## Draws the geometry that is inside this node path into the MeshDrawer
## object.  This performs a similar functions as RigidBodyCombiner but for
## very dynamic situations that share the same texture like physcal chunks of
## explosions.  It can be a little slow

converter getClassType*(_: typedesc[MeshDrawer]): TypeHandle {.importcpp: "MeshDrawer::get_class_type()", header: "meshDrawer.h".}

proc initMeshDrawer2D*(): MeshDrawer2D {.importcpp: "MeshDrawer2D()".} ## \
## Creates the MeshDrawer2D low level system.

proc setBudget*(this: MeshDrawer2D, budget: int) {.importcpp: "#.set_budget(#)".} ## \
## Sets the total triangle budget of the drawer.

proc getBudget*(this: MeshDrawer2D): int {.importcpp: "#.get_budget()".} ## \
## Gets the total triangle budget of the drawer.

proc getRoot*(this: MeshDrawer2D): NodePath {.importcpp: "#.get_root()".} ## \
## Returns the root NodePath.

proc quadRaw*(this: MeshDrawer2D, v1: LVector3, c1: LVector4, uv1: LVector2, v2: LVector3, c2: LVector4, uv2: LVector2, v3: LVector3, c3: LVector4, uv3: LVector2, v4: LVector3, c4: LVector4, uv4: LVector2) {.importcpp: "#.quad_raw(#, #, #, #, #, #, #, #, #, #, #, #)".} ## \
## Draws a 2D rectangle.  Ignores the clipping rectangle.

proc rectangleRaw*(this: MeshDrawer2D, x: float32, y: float32, w: float32, h: float32, u: float32, v: float32, us: float32, vs: float32, color: LVector4) {.importcpp: "#.rectangle_raw(#, #, #, #, #, #, #, #, #)".}

proc setClip*(this: MeshDrawer2D, x: float32, y: float32, w: float32, h: float32) {.importcpp: "#.set_clip(#, #, #, #)".} ## \
## Sets the clipping rectangle.

proc rectangle*(this: MeshDrawer2D, x: float32, y: float32, w: float32, h: float32, u: float32, v: float32, us: float32, vs: float32, color: LVector4) {.importcpp: "#.rectangle(#, #, #, #, #, #, #, #, #)".} ## \
## Draws a 2D rectangle which can be clipped.

proc rectangleBorder*(this: MeshDrawer2D, x: float32, y: float32, w: float32, h: float32, r: float32, t: float32, l: float32, b: float32, tr: float32, tt: float32, tl: float32, tb: float32, u: float32, v: float32, us: float32, vs: float32, color: LVector4) {.importcpp: "#.rectangle_border(#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)".} ## \
## Draws a 2d rectangle, with borders and corders, taken from the surrounding
## texture

proc rectangleBorderTiled*(this: MeshDrawer2D, x: float32, y: float32, w: float32, h: float32, r: float32, t: float32, l: float32, b: float32, tr: float32, tt: float32, tl: float32, tb: float32, u: float32, v: float32, us: float32, vs: float32, color: LVector4) {.importcpp: "#.rectangle_border_tiled(#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)".} ## \
## Draws a 2d rectangle, with borders and corders, taken from the surrounding
## texture

proc rectangleTiled*(this: MeshDrawer2D, x: float32, y: float32, w: float32, h: float32, u: float32, v: float32, us: float32, vs: float32, color: LVector4) {.importcpp: "#.rectangle_tiled(#, #, #, #, #, #, #, #, #)".} ## \
## Draws a tiled rectangle, size of tiles is in us and vs

proc begin*(this: MeshDrawer2D) {.importcpp: "#.begin()".} ## \
## Opens up the geom for drawing, don't forget to call MeshDrawer2D::end()

converter getClassType*(_: typedesc[MeshDrawer2D]): TypeHandle {.importcpp: "MeshDrawer2D::get_class_type()", header: "meshDrawer2D.h".}

proc newMovieTexture*(video: MovieVideo): MovieTexture {.importcpp: "new MovieTexture(#)".} ## \
## Creates a texture playing the specified movie.

proc newMovieTexture*(name: string): MovieTexture {.importcpp: "new MovieTexture(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates a blank movie texture.  Movies must be added using do_read_one or
## do_load_one.

proc getVideoLength*(this: MovieTexture): float64 {.importcpp: "#->get_video_length()".} ## \
## Returns the length of the video.

proc getVideoWidth*(this: MovieTexture): int {.importcpp: "#->get_video_width()".} ## \
## Returns the width in texels of the source video stream.  This is not
## necessarily the width of the actual texture, since the texture may have
## been expanded to raise it to a power of 2.

proc getVideoHeight*(this: MovieTexture): int {.importcpp: "#->get_video_height()".} ## \
## Returns the height in texels of the source video stream.  This is not
## necessarily the height of the actual texture, since the texture may have
## been expanded to raise it to a power of 2.

proc getColorCursor*(this: MovieTexture, page: int): MovieVideoCursor {.importcpp: "#->get_color_cursor(#)".} ## \
## Returns the MovieVideoCursor that is feeding the color channels for the
## indicated page, where 0 <= page < get_num_pages().

proc getAlphaCursor*(this: MovieTexture, page: int): MovieVideoCursor {.importcpp: "#->get_alpha_cursor(#)".} ## \
## Returns the MovieVideoCursor that is feeding the alpha channel for the
## indicated page, where 0 <= page < get_num_pages().

proc restart*(this: MovieTexture) {.importcpp: "#->restart()".} ## \
## Start playing the movie from where it was last paused.  Has no effect if
## the movie is not paused, or if the movie's cursor is already at the end.

proc stop*(this: MovieTexture) {.importcpp: "#->stop()".} ## \
## Stops a currently playing or looping movie right where it is.  The movie's
## cursor remains frozen at the point where it was stopped.

proc play*(this: MovieTexture) {.importcpp: "#->play()".} ## \
## Plays the movie from the beginning.

proc setTime*(this: MovieTexture, t: float64) {.importcpp: "#->set_time(#)".} ## \
## Sets the movie's cursor.

proc getTime*(this: MovieTexture): float64 {.importcpp: "#->get_time()".} ## \
## Returns the current value of the movie's cursor.  If the movie's loop count
## is greater than one, then its length is effectively multiplied for the
## purposes of this function.  In other words, the return value will be in the
## range 0.0 to (length \* loopcount).

proc setLoop*(this: MovieTexture, enable: bool) {.importcpp: "#->set_loop(#)".} ## \
## If true, sets the movie's loop count to 1 billion.  If false, sets the
## movie's loop count to one.

proc getLoop*(this: MovieTexture): bool {.importcpp: "#->get_loop()".} ## \
## Returns true if the movie's loop count is not equal to one.

proc setLoopCount*(this: MovieTexture, count: int) {.importcpp: "#->set_loop_count(#)".} ## \
## Sets the movie's loop count to the desired value.

proc getLoopCount*(this: MovieTexture): int {.importcpp: "#->get_loop_count()".} ## \
## Returns the movie's loop count.

proc setPlayRate*(this: MovieTexture, play_rate: float64) {.importcpp: "#->set_play_rate(#)".} ## \
## Sets the movie's play-rate.  This is the speed at which the movie's cursor
## advances.  The default is to advance 1.0 movie-seconds per real-time
## second.

proc getPlayRate*(this: MovieTexture): float64 {.importcpp: "#->get_play_rate()".} ## \
## Gets the movie's play-rate.

proc isPlaying*(this: MovieTexture): bool {.importcpp: "#->is_playing()".} ## \
## Returns true if the movie's cursor is advancing.

proc synchronizeTo*(this: MovieTexture, sound: AudioSound) {.importcpp: "#->synchronize_to(#)".} ## \
## Synchronize this texture to a sound.  Typically, you would load the texture
## and the sound from the same AVI file.

proc unsynchronize*(this: MovieTexture) {.importcpp: "#->unsynchronize()".} ## \
## Stop synchronizing with a sound.

converter getClassType*(_: typedesc[MovieTexture]): TypeHandle {.importcpp: "MovieTexture::get_class_type()", header: "movieTexture.h".}

proc initMultitexReducer*(): MultitexReducer {.importcpp: "MultitexReducer()".}

proc initMultitexReducer*(param0: MultitexReducer): MultitexReducer {.importcpp: "MultitexReducer(#)".}

proc clear*(this: MultitexReducer) {.importcpp: "#.clear()".}

proc scan*(this: MultitexReducer, node: NodePath) {.importcpp: "#.scan(#)".} ## \
## Starts scanning the hierarchy beginning at the indicated node.  Any
## GeomNodes discovered in the hierarchy with multitexture will be added to
## internal structures in the MultitexReducer so that a future call to
## flatten() will operate on all of these at once.
##
## This version of this method does not accumulate state from the parents of
## the indicated node; thus, only multitexture effects that have been applied
## at node and below will be considered.

proc scan*(this: MultitexReducer, node: NodePath, state_from: NodePath) {.importcpp: "#.scan(#, #)".} ## \
## Starts scanning the hierarchy beginning at the indicated node.  Any
## GeomNodes discovered in the hierarchy with multitexture will be added to
## internal structures in the MultitexReducer so that a future call to
## flatten() will operate on all of these at once.
##
## The second parameter represents the NodePath from which to accumulate the
## state that is considered for the multitexture.  Pass an empty NodePath to
## accumulate all the state from the root of the graph, or you may specify
## some other node here in order to not consider nodes above that as
## contributing to the state to be flattened.  This is particularly useful if
## you have some texture stage which is applied globally to a scene (for
## instance, a caustics effect), which you don't want to be considered for
## flattening by the MultitexReducer.

proc scan*(this: MultitexReducer, node: PandaNode, state: RenderState, transform: TransformState) {.importcpp: "#.scan(#, #, #)".}

proc setTarget*(this: MultitexReducer, stage: TextureStage) {.importcpp: "#.set_target(#)".}

proc setUseGeom*(this: MultitexReducer, use_geom: bool) {.importcpp: "#.set_use_geom(#)".}

proc setAllowTexMat*(this: MultitexReducer, allow_tex_mat: bool) {.importcpp: "#.set_allow_tex_mat(#)".}

proc flatten*(this: MultitexReducer, window: GraphicsOutput) {.importcpp: "#.flatten(#)".}

proc newNodeVertexTransform*(node: PandaNode, prev: VertexTransform): NodeVertexTransform {.importcpp: "new NodeVertexTransform(#, #)".}

proc newNodeVertexTransform*(node: PandaNode): NodeVertexTransform {.importcpp: "new NodeVertexTransform(#)".}

proc getNode*(this: NodeVertexTransform): PandaNode {.importcpp: "deconstify(#->get_node())", header: deconstifyCode.} ## \
## Returns the PandaNode whose transform supplies this object.

proc getPrev*(this: NodeVertexTransform): VertexTransform {.importcpp: "deconstify(#->get_prev())", header: deconstifyCode.} ## \
## Returns the VertexTransform object whose matrix will be composed with the
## result of this node's transform.

converter getClassType*(_: typedesc[NodeVertexTransform]): TypeHandle {.importcpp: "NodeVertexTransform::get_class_type()", header: "nodeVertexTransform.h".}

proc newShaderTerrainMesh*(): ShaderTerrainMesh {.importcpp: "new ShaderTerrainMesh()".} ## \
## @brief Constructs a new Terrain Mesh
## @details This constructs a new terrain mesh. By default, no transform is set
## on the mesh, causing it to range over the unit box from (0, 0, 0) to
## (1, 1, 1). Usually you want to set a custom transform with NodePath::set_scale()

proc setHeightfield*(this: ShaderTerrainMesh, heightfield: Texture) {.importcpp: "#->set_heightfield(#)".} ## \
## @brief Sets the heightfield texture
## @details This sets the heightfield texture. It should be 16bit
## single channel, and have a power-of-two resolution greater than 32.
## Common sizes are 2048x2048 or 4096x4096.
##
## You should call generate() after setting the heightfield.
##
## @param filename Heightfield texture

proc getHeightfield*(this: ShaderTerrainMesh): Texture {.importcpp: "#->get_heightfield()".} ## \
## @brief Returns the heightfield
## @details This returns the terrain heightfield, previously set with
## set_heightfield()
##
## @return Path to the heightfield

proc setChunkSize*(this: ShaderTerrainMesh, chunk_size: clonglong) {.importcpp: "#->set_chunk_size(#)".} ## \
## @brief Sets the chunk size
## @details This sets the chunk size of the terrain. A chunk is basically the
## smallest unit in LOD. If the chunk size is too small, the terrain will
## perform bad, since there will be way too many chunks. If the chunk size
## is too big, you will not get proper LOD, and might also get bad performance.
##
## For terrains of the size 4096x4096 or 8192x8192, a chunk size of 32 seems
## to produce good results. For smaller resolutions, you should try out a
## size of 16 or even 8 for very small terrains.
##
## The amount of chunks generated for the last level equals to
## (heightfield_size / chunk_size) \*\* 2. The chunk size has to be a power
## of two.
##
## @param chunk_size Size of the chunks, has to be a power of two

proc getChunkSize*(this: ShaderTerrainMesh): clonglong {.importcpp: "#->get_chunk_size()".} ## \
## @brief Returns the chunk size
## @details This returns the chunk size, previously set with set_chunk_size()
## @return Chunk size

proc setGeneratePatches*(this: ShaderTerrainMesh, generate_patches: bool) {.importcpp: "#->set_generate_patches(#)".} ## \
## @brief Sets whether to generate patches
## @details If this option is set to true, GeomPatches will be used instead of
## GeomTriangles. This is required when the terrain is used with tesselation
## shaders, since patches are required for tesselation, whereas triangles
## are required for regular rendering.
##
## If this option is set to true while not using a tesselation shader, the
## terrain will not get rendered, or even produce errors. The same applies
## when this is option is not set, but the terrain is used with tesselation
## shaders.
##
## @param generate_patches [description]

proc getGeneratePatches*(this: ShaderTerrainMesh): bool {.importcpp: "#->get_generate_patches()".} ## \
## @brief Returns whether to generate patches
## @details This returns whether patches are generated, previously set with
## set_generate_patches()
##
## @return Whether to generate patches

proc setUpdateEnabled*(this: ShaderTerrainMesh, update_enabled: bool) {.importcpp: "#->set_update_enabled(#)".} ## \
## @brief Sets whether to enable terrain updates
## @details This flag controls whether the terrain should be updated. If this value
## is set to false, no updating of the terrain will happen. This can be useful
## to debug the culling algorithm used by the terrain.
##
## @param update_enabled Whether to update the terrain

proc getUpdateEnabled*(this: ShaderTerrainMesh): bool {.importcpp: "#->get_update_enabled()".} ## \
## @brief Returns whether the terrain is getting updated
## @details This returns whether the terrain is getting updates, previously set with
## set_update_enabled()
##
## @return Whether to update the terrain

proc setTargetTriangleWidth*(this: ShaderTerrainMesh, target_triangle_width: float32) {.importcpp: "#->set_target_triangle_width(#)".} ## \
## @brief Sets the desired triangle width
## @details This sets the desired width a triangle should have in pixels.
## A value of 10.0 for example will make the terrain tesselate everything
## in a way that each triangle edge roughly is 10 pixels wide.
## Of course this will not always accurately match, however you can use this
## setting to control the LOD algorithm of the terrain.
##
## @param target_triangle_width Desired triangle width in pixels

proc getTargetTriangleWidth*(this: ShaderTerrainMesh): float32 {.importcpp: "#->get_target_triangle_width()".} ## \
## @brief Returns the target triangle width
## @details This returns the target triangle width, previously set with
## ShaderTerrainMesh::set_target_triangle_width()
##
## @return Target triangle width

proc uvToWorld*(this: ShaderTerrainMesh, coord: LTexCoord): LPoint3 {.importcpp: "#->uv_to_world(#)".} ## \
## @brief Transforms a texture coordinate to world space
## @details This transforms a texture coordinatefrom uv-space (0 to 1) to world
## space. This takes the terrains transform into account, and also samples the
## heightmap. This method should be called after generate().
##
## @param coord Coordinate in uv-space from 0, 0 to 1, 1
## @return World-Space point

proc uvToWorld*(this: ShaderTerrainMesh, u: float32, v: float32): LPoint3 {.importcpp: "#->uv_to_world(#, #)".} ## \
## @see ShaderTerrainMesh::uv_to_world(LTexCoord)

proc generate*(this: ShaderTerrainMesh): bool {.importcpp: "#->generate()".} ## \
## @brief Generates the terrain mesh
## @details This generates the terrain mesh, initializing all chunks of the
## internal used quadtree. At this point, a heightfield and a chunk size should
## have been set, otherwise an error is thrown.
##
## If anything goes wrong, like a missing heightfield, then an error is printed
## and false is returned.
##
## @return true if the terrain was initialized, false if an error occured

converter getClassType*(_: typedesc[ShaderTerrainMesh]): TypeHandle {.importcpp: "ShaderTerrainMesh::get_class_type()", header: "shaderTerrainMesh.h".}

proc newSceneGraphAnalyzerMeter*(param0: SceneGraphAnalyzerMeter): SceneGraphAnalyzerMeter {.importcpp: "new SceneGraphAnalyzerMeter(#)".}

proc newSceneGraphAnalyzerMeter*(name: string, node: PandaNode): SceneGraphAnalyzerMeter {.importcpp: "new SceneGraphAnalyzerMeter(nimStringToStdString(#), #)", header: stringConversionCode.}

proc setupWindow*(this: SceneGraphAnalyzerMeter, window: GraphicsOutput) {.importcpp: "#->setup_window(#)".} ## \
## Sets up the frame rate meter to create a DisplayRegion to render itself
## into the indicated window.

proc clearWindow*(this: SceneGraphAnalyzerMeter) {.importcpp: "#->clear_window()".} ## \
## Undoes the effect of a previous call to setup_window().

proc getWindow*(this: SceneGraphAnalyzerMeter): GraphicsOutput {.importcpp: "#->get_window()".} ## \
## Returns the GraphicsOutput that was passed to setup_window(), or NULL if
## setup_window() has not been called.

proc getDisplayRegion*(this: SceneGraphAnalyzerMeter): DisplayRegion {.importcpp: "#->get_display_region()".} ## \
## Returns the DisplayRegion that the meter has created to render itself into
## the window to setup_window(), or NULL if setup_window() has not been
## called.

proc setUpdateInterval*(this: SceneGraphAnalyzerMeter, update_interval: float64) {.importcpp: "#->set_update_interval(#)".} ## \
## Specifies the number of seconds that should elapse between updates to the
## meter.  This should be reasonably slow (e.g.  0.5 to 2.0) so that the
## calculation of the scene graph analysis does not itself dominate the frame
## rate.

proc getUpdateInterval*(this: SceneGraphAnalyzerMeter): float64 {.importcpp: "#->get_update_interval()".} ## \
## Returns the number of seconds that will elapse between updates to the frame
## rate indication.

proc setNode*(this: SceneGraphAnalyzerMeter, node: PandaNode) {.importcpp: "#->set_node(#)".} ## \
## Sets the node to be analyzed.

proc getNode*(this: SceneGraphAnalyzerMeter): PandaNode {.importcpp: "#->get_node()".} ## \
## Returns the node to be analyzed.

proc update*(this: SceneGraphAnalyzerMeter) {.importcpp: "#->update()".} ## \
## You can call this to explicitly force the SceneGraphAnalyzerMeter to update
## itself with the latest scene graph analysis information.  Normally, it is
## not necessary to call this explicitly.

converter getClassType*(_: typedesc[SceneGraphAnalyzerMeter]): TypeHandle {.importcpp: "SceneGraphAnalyzerMeter::get_class_type()", header: "sceneGraphAnalyzerMeter.h".}

proc newRigidBodyCombiner*(name: string): RigidBodyCombiner {.importcpp: "new RigidBodyCombiner(nimStringToStdString(#))", header: stringConversionCode.}

proc collect*(this: RigidBodyCombiner) {.importcpp: "#->collect()".} ## \
## Walks through the entire subgraph of nodes rooted at this node, accumulates
## all of the RenderAttribs and Geoms below this node, flattening them into
## just one Geom (or as few as possible, if there are multiple different
## states).
##
## Nodes that have transforms on them at the time of collect(), or any
## ModelNodes with the preserve_transform flag, will be identified as "moving"
## nodes, and their transforms will be monitored as they change in future
## frames and each new transform directly applied to the vertices.
##
## This call must be made after adding any nodes to or removing any nodes from
## the subgraph rooted at this node.  It should not be made too often, as it
## is a relatively expensive call.  If you need to hide children of this node,
## consider scaling them to zero (or very near zero), or moving them behind
## the camera, instead.

proc getInternalScene*(this: RigidBodyCombiner): NodePath {.importcpp: "#->get_internal_scene()".} ## \
## Returns a special NodePath that represents the internal node of this
## object.  This is the node that is actually sent to the graphics card for
## rendering; it contains the collection of the children of this node into as
## few Geoms as possible.
##
## This node is filled up by the last call to collect().

converter getClassType*(_: typedesc[RigidBodyCombiner]): TypeHandle {.importcpp: "RigidBodyCombiner::get_class_type()", header: "rigidBodyCombiner.h".}

converter upcastToCullTraverser*(this: PipeOcclusionCullTraverser): CullTraverser {.importcpp: "(PT(CullTraverser)(#))".}

proc newPipeOcclusionCullTraverser*(host: GraphicsOutput): PipeOcclusionCullTraverser {.importcpp: "new PipeOcclusionCullTraverser(#)".}

proc setScene*(this: PipeOcclusionCullTraverser, scene_setup: SceneSetup, gsg: GraphicsStateGuardianBase, dr_incomplete_render: bool) {.importcpp: "#->set_scene(#, #, #)".}

proc endTraverse*(this: PipeOcclusionCullTraverser) {.importcpp: "#->end_traverse()".} ## \
## Should be called when the traverser has finished traversing its scene, this
## gives it a chance to do any necessary finalization.

proc getBuffer*(this: PipeOcclusionCullTraverser): GraphicsOutput {.importcpp: "#->get_buffer()".}

proc getTexture*(this: PipeOcclusionCullTraverser): Texture {.importcpp: "#->get_texture()".} ## \
## Returns a Texture that can be used to visualize the efforts of the
## occlusion cull.

proc setOcclusionMask*(this: PipeOcclusionCullTraverser, occlusion_mask: DrawMask) {.importcpp: "#->set_occlusion_mask(#)".} ## \
## Specifies the DrawMask that should be set on occlusion polygons for this
## scene.  This identifies the polygons that are to be treated as occluders.
## Polygons that do not have this draw mask set will not be considered
## occluders.

proc getOcclusionMask*(this: PipeOcclusionCullTraverser): DrawMask {.importcpp: "#->get_occlusion_mask()".} ## \
## Returns the DrawMask for occlusion polygons.  See set_occlusion_mask().

converter getClassType*(_: typedesc[PipeOcclusionCullTraverser]): TypeHandle {.importcpp: "PipeOcclusionCullTraverser::get_class_type()", header: "pipeOcclusionCullTraverser.h".}

proc initPfmVizzer*(pfm: PfmFile): PfmVizzer {.importcpp: "PfmVizzer(#)".} ## \
## The PfmVizzer constructor receives a reference to a PfmFile which it will
## operate on.  It does not keep ownership of this reference; it is your
## responsibility to ensure the PfmFile does not destruct during the lifetime
## of the PfmVizzer.

proc initPfmVizzer*(param0: PfmVizzer): PfmVizzer {.importcpp: "PfmVizzer(#)".}

proc getPfm*(this: PfmVizzer): PfmFile {.importcpp: "#.get_pfm()".} ## \
## Returns the reference to the PfmFile manipulated by this PfmVizzer.

proc project*(this: PfmVizzer, lens: Lens, undist_lut: PfmFile) {.importcpp: "#.project(#, #)".} ## \
## Adjusts each (x, y, z) point of the Pfm file by projecting it through the
## indicated lens, converting each point to a (u, v, w) texture coordinate.
## The resulting file can be generated to a mesh (with set_vis_inverse(true)
## and generate_vis_mesh()) that will apply the lens distortion to an
## arbitrary texture image.

proc project*(this: PfmVizzer, lens: Lens) {.importcpp: "#.project(#)".} ## \
## Adjusts each (x, y, z) point of the Pfm file by projecting it through the
## indicated lens, converting each point to a (u, v, w) texture coordinate.
## The resulting file can be generated to a mesh (with set_vis_inverse(true)
## and generate_vis_mesh()) that will apply the lens distortion to an
## arbitrary texture image.

proc extrude*(this: PfmVizzer, lens: Lens) {.importcpp: "#.extrude(#)".} ## \
## Converts each (u, v, depth) point of the Pfm file to an (x, y, z) point, by
## reversing project().  If the original file is only a 1-d file, assumes that
## it is a depth map with implicit (u, v) coordinates.
##
## This method is only valid for a linear lens (e.g.  a PerspectiveLens or
## OrthographicLens).  Non-linear lenses don't necessarily compute a sensible
## depth coordinate.

proc setVisInverse*(this: PfmVizzer, vis_inverse: bool) {.importcpp: "#.set_vis_inverse(#)".} ## \
## Sets the vis_inverse flag.  When this flag is true, vis meshes and point
## clouds are generated with the 3-d depth value in the texture coordinates,
## and the 2-d index value in the vertex position.  When it is false, meshes
## are generated normally, with the 3-d depth value in the vertex position and
## the 2-d index value in the texture coordinates.
##
## This may be used in lieu of the lower-level add_vis_column().

proc getVisInverse*(this: PfmVizzer): bool {.importcpp: "#.get_vis_inverse()".} ## \
## Returns the vis_inverse flag.  See set_vis_inverse().

proc setFlatTexcoordName*(this: PfmVizzer, flat_texcoord_name: InternalName) {.importcpp: "#.set_flat_texcoord_name(#)".} ## \
## If the flat_texcoord_name is specified, it is the name of an additional
## vertex column that will be created for the "flat" texture coordinates, i.e.
## the original 0..1 values that correspond to the 2-D index position of each
## point in the original pfm file.
##
## These are the same values that will be assigned to the default texture
## coordinates if the vis_inverse flag is \*not\* true.
##
## This may be used in lieu of the lower-level add_vis_column().

proc clearFlatTexcoordName*(this: PfmVizzer) {.importcpp: "#.clear_flat_texcoord_name()".} ## \
## Resets the flat_texcoord_name to empty, so that additional texture
## coordinates are not created.
##
## This may be used in lieu of the lower-level add_vis_column().

proc getFlatTexcoordName*(this: PfmVizzer): InternalName {.importcpp: "#.get_flat_texcoord_name()".} ## \
## Returns the flat_texcoord_name.  See set_flat_texcoord_name().

proc setVis2d*(this: PfmVizzer, vis_2d: bool) {.importcpp: "#.set_vis_2d(#)".} ## \
## Sets the vis_2d flag.  When this flag is true, only the first two (x, y)
## value of each depth point is considered meaningful; the z component is
## ignored.  This is only relevant for generating visualizations.
##
## This may be used in lieu of the lower-level add_vis_column().

proc getVis2d*(this: PfmVizzer): bool {.importcpp: "#.get_vis_2d()".} ## \
## Returns the vis_2d flag.  See set_vis_2d().

proc setKeepBeyondLens*(this: PfmVizzer, keep_beyond_lens: bool) {.importcpp: "#.set_keep_beyond_lens(#)".} ## \
## Sets the keep_beyond_lens flag.  When this flag is true, points that fall
## outside of the normal lens range in project() or in add_vis_column() will
## be retained anyway; when it is false, these points will be discarded.

proc getKeepBeyondLens*(this: PfmVizzer): bool {.importcpp: "#.get_keep_beyond_lens()".} ## \
## Returns the keep_beyond_lens flag.  See set_keep_beyond_lens().

proc setVisBlend*(this: PfmVizzer, vis_blend: PNMImage) {.importcpp: "#.set_vis_blend(#)".} ## \
## Specifies a blending map--a grayscale image--that will be applied to the
## vertex color during generate_vis_mesh() and generate_vis_points().  The
## image size must exactly match the mesh size of the PfmVizzer.
##
## Ownership of the pointer is not kept by the PfmVizzer; it is your
## responsibility to ensure it does not destruct during the lifetime of the
## PfmVizzer (or at least not before your subsequent call to
## generate_vis_mesh()).

proc clearVisBlend*(this: PfmVizzer) {.importcpp: "#.clear_vis_blend()".} ## \
## Removes the blending map set by a prior call to set_vis_blend().

proc getVisBlend*(this: PfmVizzer): PNMImage {.importcpp: "#.get_vis_blend()".} ## \
## Returns the blending map set by the most recent call to set_vis_blend(), or
## NULL if there is no blending map in effect.

proc setAuxPfm*(this: PfmVizzer, pfm: PfmFile) {.importcpp: "#.set_aux_pfm(#)".} ## \
## Assigns an auxiliary PfmFile to this PfmVizzer.  This file will be queried
## by column types CT_aux_vertex1/2/3, but has no other meaning to the vizzer.
## This size of this PfmFile should exactly match the base PfmFile.  No
## reference count is held and no copy is made; the caller is responsible for
## ensuring that the auxiliary PfmFile will persist throughout the lifetime of
## the PfmVizzer it is assigned to.

proc clearAuxPfm*(this: PfmVizzer) {.importcpp: "#.clear_aux_pfm()".} ## \
## Removes the auxiliary PfmFile from this PfmVizzer.

proc getAuxPfm*(this: PfmVizzer): PfmFile {.importcpp: "#.get_aux_pfm()".} ## \
## Returns the reference to the auxiliary PfmFile queried by this PfmVizzer.
## This contains the values that will be reflected in CT_aux_vertex3 etc.  See
## set_aux_pfm().

proc clearVisColumns*(this: PfmVizzer) {.importcpp: "#.clear_vis_columns()".} ## \
## Removes all of the previously-added vis columns in preparation for building
## a new list.  See add_vis_column().

proc generateVisPoints*(this: PfmVizzer): NodePath {.importcpp: "#.generate_vis_points()".} ## \
## Creates a point cloud with the points of the pfm as 3-d coordinates in
## space, and texture coordinates ranging from 0 .. 1 based on the position
## within the pfm grid.

proc generateVisMesh*(this: PfmVizzer): NodePath {.importcpp: "#.generate_vis_mesh()".} ## \
## Creates a triangle mesh with the points of the pfm as 3-d coordinates in
## space, and texture coordinates ranging from 0 .. 1 based on the position
## within the pfm grid.

proc calcMaxUDisplacement*(this: PfmVizzer): float64 {.importcpp: "#.calc_max_u_displacement()".} ## \
## Computes the maximum amount of shift, in pixels either left or right, of
## any pixel in the distortion map.  This can be passed to
## make_displacement(); see that function for more information.

proc calcMaxVDisplacement*(this: PfmVizzer): float64 {.importcpp: "#.calc_max_v_displacement()".} ## \
## Computes the maximum amount of shift, in pixels either up or down, of any
## pixel in the distortion map.  This can be passed to make_displacement();
## see that function for more information.

proc makeDisplacement*(this: PfmVizzer, result: PNMImage, max_u: float64, max_v: float64, for_32bit: bool) {.importcpp: "#.make_displacement(#, #, #, #)".} ## \
## Assuming the underlying PfmFile is a 2-d distortion mesh, with the U and V
## in the first two components and the third component unused, this computes
## an AfterEffects-style displacement map that represents the same distortion.
## The indicated PNMImage will be filled in with a displacement map image,
## with horizontal shift in the red channel and vertical shift in the green
## channel, where a fully bright (or fully black) pixel indicates a shift of
## max_u or max_v pixels.
##
## Use calc_max_u_displacement() and calc_max_v_displacement() to compute
## suitable values for max_u and max_v.
##
## This generates an integer 16-bit displacement image.  It is a good idea,
## though not necessarily essential, to check "Preserve RGB" in the interpret
## footage section for each displacement image.  Set for_32bit true if this is
## meant to be used in a 32-bit project file, and false if it is meant to be
## used in a 16-bit project file.

proc makeDisplacement*(this: PfmVizzer, result: PfmFile, max_u: float64, max_v: float64, for_32bit: bool) {.importcpp: "#.make_displacement(#, #, #, #)".} ## \
## Assuming the underlying PfmFile is a 2-d distortion mesh, with the U and V
## in the first two components and the third component unused, this computes
## an AfterEffects-style displacement map that represents the same distortion.
## The indicated PNMImage will be filled in with a displacement map image,
## with horizontal shift in the red channel and vertical shift in the green
## channel, where a fully bright (or fully black) pixel indicates a shift of
## max_u or max_v pixels.
##
## Use calc_max_u_displacement() and calc_max_v_displacement() to compute
## suitable values for max_u and max_v.
##
## This generates a 32-bit floating-point displacement image.  It is essential
## to check "Preserve RGB" in the interpret footage section for each
## displacement image.  Set for_32bit true if this is meant to be used in a
## 32-bit project file, and false if it is meant to be used in a 16-bit
## project file.

converter upcastToTypedWritableReferenceCount*(this: AnimGroup): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcastToNamable*(this: AnimGroup): Namable {.importcpp: "((Namable *)(AnimGroup *)(#))".}

proc newAnimGroup*(parent: AnimGroup, name: string): AnimGroup {.importcpp: "new AnimGroup(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates the AnimGroup, and adds it to the indicated parent.  The only way
## to delete it subsequently is to delete the entire hierarchy.

proc newAnimGroup*(param0: AnimGroup): AnimGroup {.importcpp: "new AnimGroup(#)".}

proc getNumChildren*(this: AnimGroup): int {.importcpp: "#->get_num_children()".} ## \
## Returns the number of child nodes of the group.

proc getChild*(this: AnimGroup, n: int): AnimGroup {.importcpp: "#->get_child(#)".} ## \
## Returns the nth child of the group.

proc getChildNamed*(this: AnimGroup, name: string): AnimGroup {.importcpp: "#->get_child_named(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the first child found with the indicated name, or NULL if no such
## child exists.  This method searches only the children of this particular
## AnimGroup; it does not recursively search the entire graph.  See also
## find_child().

proc findChild*(this: AnimGroup, name: string): AnimGroup {.importcpp: "#->find_child(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the first descendant found with the indicated name, or NULL if no
## such descendant exists.  This method searches the entire graph beginning at
## this AnimGroup; see also get_child_named().

proc sortDescendants*(this: AnimGroup) {.importcpp: "#->sort_descendants()".} ## \
## Sorts the children nodes at each level of the hierarchy into alphabetical
## order.  This should be done after creating the hierarchy, to guarantee that
## the correct names will match up together when the AnimBundle is later bound
## to a PlayerRoot.

proc output*(this: AnimGroup, `out`: ostream) {.importcpp: "#->output(#)".} ## \
## Writes a one-line description of the group.

proc write*(this: AnimGroup, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".} ## \
## Writes a brief description of the group and all of its descendants.

converter getClassType*(_: typedesc[AnimGroup]): TypeHandle {.importcpp: "AnimGroup::get_class_type()", header: "animGroup.h".}

proc newAnimBundle*(param0: AnimBundle): AnimBundle {.importcpp: "new AnimBundle(#)".}

proc newAnimBundle*(name: string, fps: float32, num_frames: int): AnimBundle {.importcpp: "new AnimBundle(nimStringToStdString(#), #, #)", header: stringConversionCode.}

proc copyBundle*(this: AnimBundle): AnimBundle {.importcpp: "#->copy_bundle()".} ## \
## Returns a full copy of the bundle and its entire tree of nested AnimGroups.
## However, the actual data stored in the leaves--that is, animation tables,
## such as those stored in an AnimChannelMatrixXfmTable--will be shared.

proc getBaseFrameRate*(this: AnimBundle): float64 {.importcpp: "#->get_base_frame_rate()".} ## \
## Returns the ideal number of frames per second of the animation, when it is
## running at normal speed.  This may not be the same as the actual playing
## frame rate, as it might have been adjusted through set_play_rate() on the
## AnimControl object.  See AnimControl::get_effective_frame_rate().

proc getNumFrames*(this: AnimBundle): int {.importcpp: "#->get_num_frames()".} ## \
## Returns the number of frames of animation, or 0 if the animation has no
## fixed number of frames.

converter getClassType*(_: typedesc[AnimBundle]): TypeHandle {.importcpp: "AnimBundle::get_class_type()", header: "animBundle.h".}

proc newAnimBundleNode*(name: string, bundle: AnimBundle): AnimBundleNode {.importcpp: "new AnimBundleNode(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## The AnimBundle and its node should be constructed together.  Generally, the
## derived classes of AnimBundleNode will automatically create a AnimBundle of
## the appropriate type, and pass it up to this constructor.

proc getBundle*(this: AnimBundleNode): AnimBundle {.importcpp: "#->get_bundle()".}

proc findAnimBundle*(_: typedesc[AnimBundleNode], root: PandaNode): AnimBundle {.importcpp: "#AnimBundleNode::find_anim_bundle(#)", header: "animBundleNode.h".} ## \
## Recursively walks the scene graph beginning at the indicated node (which
## need not be an AnimBundleNode), and returns the first AnimBundle found.
## Returns NULL if no AnimBundle can be found.

converter getClassType*(_: typedesc[AnimBundleNode]): TypeHandle {.importcpp: "AnimBundleNode::get_class_type()", header: "animBundleNode.h".}

converter upcastToTypedWritableReferenceCount*(this: PartGroup): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcastToNamable*(this: PartGroup): Namable {.importcpp: "((Namable *)(PartGroup *)(#))".}

proc newPartGroup*(parent: PartGroup, name: string): PartGroup {.importcpp: "new PartGroup(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates the PartGroup, and adds it to the indicated parent.  The only way
## to delete it subsequently is to delete the entire hierarchy.

proc isCharacterJoint*(this: PartGroup): bool {.importcpp: "#->is_character_joint()".} ## \
## Returns true if this part is a CharacterJoint, false otherwise.  This is a
## tiny optimization over is_of_type(CharacterType::get_class_type()).

proc makeCopy*(this: PartGroup): PartGroup {.importcpp: "#->make_copy()".} ## \
## Allocates and returns a new copy of the node.  Children are not copied, but
## see copy_subgraph().

proc copySubgraph*(this: PartGroup): PartGroup {.importcpp: "#->copy_subgraph()".} ## \
## Allocates and returns a new copy of this node and of all of its children.

proc getNumChildren*(this: PartGroup): int {.importcpp: "#->get_num_children()".} ## \
## Returns the number of child nodes of the group.

proc getChild*(this: PartGroup, n: int): PartGroup {.importcpp: "#->get_child(#)".} ## \
## Returns the nth child of the group.

proc getChildNamed*(this: PartGroup, name: string): PartGroup {.importcpp: "#->get_child_named(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the first child found with the indicated name, or NULL if no such
## child exists.  This method searches only the children of this particular
## PartGroup; it does not recursively search the entire graph.  See also
## find_child().

proc findChild*(this: PartGroup, name: string): PartGroup {.importcpp: "#->find_child(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the first descendant found with the indicated name, or NULL if no
## such descendant exists.  This method searches the entire graph beginning at
## this PartGroup; see also get_child_named().

proc sortDescendants*(this: PartGroup) {.importcpp: "#->sort_descendants()".} ## \
## Sorts the children nodes at each level of the hierarchy into alphabetical
## order.  This should be done after creating the hierarchy, to guarantee that
## the correct names will match up together when the AnimBundle is later bound
## to a PlayerRoot.

proc applyFreeze*(this: PartGroup, transform: TransformState): bool {.importcpp: "#->apply_freeze(#)".} ## \
## Freezes this particular joint so that it will always hold the specified
## transform.  Returns true if this is a joint that can be so frozen, false
## otherwise.
##
## This is normally only called internally by PartBundle::freeze_joint(), but
## you may also call it directly.

proc applyFreezeMatrix*(this: PartGroup, pos: LVecBase3, hpr: LVecBase3, scale: LVecBase3): bool {.importcpp: "#->apply_freeze_matrix(#, #, #)".} ## \
## Freezes this particular joint so that it will always hold the specified
## transform.  Returns true if this is a joint that can be so frozen, false
## otherwise.
##
## This is normally only called internally by PartBundle::freeze_joint(), but
## you may also call it directly.

proc applyFreezeScalar*(this: PartGroup, value: float32): bool {.importcpp: "#->apply_freeze_scalar(#)".} ## \
## Freezes this particular joint so that it will always hold the specified
## transform.  Returns true if this is a joint that can be so frozen, false
## otherwise.
##
## This is normally only called internally by PartBundle::freeze_joint(), but
## you may also call it directly.

proc applyControl*(this: PartGroup, node: PandaNode): bool {.importcpp: "#->apply_control(#)".} ## \
## Specifies a node to influence this particular joint so that it will always
## hold the node's transform.  Returns true if this is a joint that can be so
## controlled, false otherwise.
##
## This is normally only called internally by PartBundle::control_joint(), but
## you may also call it directly.

proc clearForcedChannel*(this: PartGroup): bool {.importcpp: "#->clear_forced_channel()".} ## \
## Undoes the effect of a previous call to apply_freeze() or apply_control().
## Returns true if the joint was modified, false otherwise.
##
## This is normally only called internally by PartBundle::release_joint(), but
## you may also call it directly.

proc getForcedChannel*(this: PartGroup): AnimChannelBase {.importcpp: "#->get_forced_channel()".} ## \
## Returns the AnimChannelBase that has been forced to this joint by a
## previous call to apply_freeze() or apply_control(), or NULL if no such
## channel has been applied.

proc write*(this: PartGroup, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".} ## \
## Writes a brief description of the group and all of its descendants.

proc writeWithValue*(this: PartGroup, `out`: ostream, indent_level: int) {.importcpp: "#->write_with_value(#, #)".} ## \
## Writes a brief description of the group, showing its current value, and
## that of all of its descendants.

converter getClassType*(_: typedesc[PartGroup]): TypeHandle {.importcpp: "PartGroup::get_class_type()", header: "partGroup.h".}

converter upcastToTypedReferenceCount*(this: AnimControl): TypedReferenceCount {.importcpp: "(PT(TypedReferenceCount)(#))".}

converter upcastToAnimInterface*(this: AnimControl): AnimInterface {.importcpp: "((AnimInterface *)(AnimControl *)(#))".}

converter upcastToNamable*(this: AnimControl): Namable {.importcpp: "((Namable *)(AnimControl *)(#))".}

proc isPending*(this: AnimControl): bool {.importcpp: "#->is_pending()".} ## \
## Returns true if the AnimControl is being bound asynchronously, and has not
## yet finished.  If this is true, the AnimControl's interface is still
## available and will be perfectly useful (though get_anim() might return
## NULL), but nothing visible will happen immediately.

proc waitPending*(this: AnimControl) {.importcpp: "#->wait_pending()".} ## \
## Blocks the current thread until the AnimControl has finished loading and is
## fully bound.

proc hasAnim*(this: AnimControl): bool {.importcpp: "#->has_anim()".} ## \
## Returns true if the AnimControl was successfully loaded, or false if there
## was a problem.  This may return false while is_pending() is true.

proc setPendingDoneEvent*(this: AnimControl, done_event: string) {.importcpp: "#->set_pending_done_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies an event name that will be thrown when the AnimControl is
## finished binding asynchronously.  If the AnimControl has already finished
## binding, the event will be thrown immediately.

proc getPendingDoneEvent*(this: AnimControl): string {.importcpp: "nimStringFromStdString(#->get_pending_done_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the AnimControl is finished
## binding asynchronously.

proc getPart*(this: AnimControl): PartBundle {.importcpp: "#->get_part()".} ## \
## Returns the PartBundle bound in with this AnimControl.

proc getAnim*(this: AnimControl): AnimBundle {.importcpp: "#->get_anim()".} ## \
## Returns the AnimBundle bound in with this AnimControl.

proc getChannelIndex*(this: AnimControl): int {.importcpp: "#->get_channel_index()".} ## \
## Returns the particular channel index associated with this AnimControl.
## This channel index is the slot on which each AnimGroup is bound to its
## associated PartGroup, for each joint in the animation.
##
## It will be true that
## get_part()->find_child("n")->get_bound(get_channel_index()) ==
## get_anim()->find_child("n"), for each joint "n".

proc getBoundJoints*(this: AnimControl): BitArray {.importcpp: "#->get_bound_joints()".} ## \
## Returns the subset of joints controlled by this AnimControl.  Most of the
## time, this will be BitArray::all_on(), for a normal full-body animation.
## For a subset animation, however, this will be just a subset of those bits,
## corresponding to the set of joints and sliders actually bound (as
## enumerated by bind_hierarchy() in depth-first LIFO order).

proc setAnimModel*(this: AnimControl, model: PandaNode) {.importcpp: "#->set_anim_model(#)".} ## \
## Associates the indicated PandaNode with the AnimControl.  By convention,
## this node represents the root node of the model file that corresponds to
## this AnimControl's animation file, though nothing in this code makes this
## assumption or indeed does anything with this node.
##
## The purpose of this is simply to allow the AnimControl to keep a reference
## count on the ModelRoot node that generated it, so that the model will not
## disappear from the model pool until it is no longer referenced.

proc getAnimModel*(this: AnimControl): PandaNode {.importcpp: "#->get_anim_model()".} ## \
## Retrieves the pointer set via set_anim_model().  See set_anim_model().

proc output*(this: AnimControl, `out`: ostream) {.importcpp: "#->output(#)".}

converter getClassType*(_: typedesc[AnimControl]): TypeHandle {.importcpp: "AnimControl::get_class_type()", header: "animControl.h".}

proc getType*(this: AnimChannelBase): TypeHandle {.importcpp: "#->get_type()".}

converter getClassType*(_: typedesc[AnimChannelBase]): TypeHandle {.importcpp: "AnimChannelBase::get_class_type()", header: "animChannelBase.h".}

proc setValue*(this: AnimChannelMatrixDynamic, value: LMatrix4) {.importcpp: "#->set_value(#)".} ## \
## Explicitly sets the matrix value.

proc setValue*(this: AnimChannelMatrixDynamic, value: TransformState) {.importcpp: "#->set_value(#)".} ## \
## Explicitly sets the matrix value, using the indicated TransformState object
## as a convenience.

proc setValueNode*(this: AnimChannelMatrixDynamic, node: PandaNode) {.importcpp: "#->set_value_node(#)".} ## \
## Specifies a node whose transform will be queried each frame to implicitly
## specify the transform of this joint.

proc getValueTransform*(this: AnimChannelMatrixDynamic): TransformState {.importcpp: "deconstify(#->get_value_transform())", header: deconstifyCode.} ## \
## Returns the explicit TransformState value that was set via set_value(), if
## any.

proc getValueNode*(this: AnimChannelMatrixDynamic): PandaNode {.importcpp: "#->get_value_node()".} ## \
## Returns the node that was set via set_value_node(), if any.

converter getClassType*(_: typedesc[AnimChannelMatrixDynamic]): TypeHandle {.importcpp: "AnimChannelMatrixDynamic::get_class_type()", header: "animChannelMatrixDynamic.h".}

proc newAnimChannelMatrixXfmTable*(parent: AnimGroup, name: string): AnimChannelMatrixXfmTable {.importcpp: "new AnimChannelMatrixXfmTable(#, nimStringToStdString(#))", header: stringConversionCode.}

proc isValidId*(_: typedesc[AnimChannelMatrixXfmTable], table_id: char): bool {.importcpp: "#AnimChannelMatrixXfmTable::is_valid_id(#)", header: "animChannelMatrixXfmTable.h".} ## \
## Returns true if the given letter is one of the nine valid table id's.

proc clearAllTables*(this: AnimChannelMatrixXfmTable) {.importcpp: "#->clear_all_tables()".} ## \
## Removes all the tables from the channel, and resets it to its initial
## state.

proc hasTable*(this: AnimChannelMatrixXfmTable, table_id: char): bool {.importcpp: "#->has_table(#)".} ## \
## Returns true if the indicated subtable has been assigned.

proc clearTable*(this: AnimChannelMatrixXfmTable, table_id: char) {.importcpp: "#->clear_table(#)".} ## \
## Removes the indicated table from the definition.

converter getClassType*(_: typedesc[AnimChannelMatrixXfmTable]): TypeHandle {.importcpp: "AnimChannelMatrixXfmTable::get_class_type()", header: "animChannelMatrixXfmTable.h".}

proc setValue*(this: AnimChannelScalarDynamic, value: float32) {.importcpp: "#->set_value(#)".} ## \
## Explicitly sets the value.  This will remove any node assigned via
## set_value_node().

proc setValueNode*(this: AnimChannelScalarDynamic, node: PandaNode) {.importcpp: "#->set_value_node(#)".} ## \
## Specifies a node whose transform will be queried each frame to implicitly
## specify the transform of this joint.  This will override the values set by
## set_value().

converter getClassType*(_: typedesc[AnimChannelScalarDynamic]): TypeHandle {.importcpp: "AnimChannelScalarDynamic::get_class_type()", header: "animChannelScalarDynamic.h".}

proc newAnimChannelScalarTable*(parent: AnimGroup, name: string): AnimChannelScalarTable {.importcpp: "new AnimChannelScalarTable(#, nimStringToStdString(#))", header: stringConversionCode.}

proc hasTable*(this: AnimChannelScalarTable): bool {.importcpp: "#->has_table()".} ## \
## Returns true if the data table has been assigned.

proc clearTable*(this: AnimChannelScalarTable) {.importcpp: "#->clear_table()".} ## \
## Empties the data table.

converter getClassType*(_: typedesc[AnimChannelScalarTable]): TypeHandle {.importcpp: "AnimChannelScalarTable::get_class_type()", header: "animChannelScalarTable.h".}

proc initAnimControlCollection*(): AnimControlCollection {.importcpp: "AnimControlCollection()".} ## \
## Returns the AnimControl associated with the given name, or NULL if no such
## control has been associated.

proc initAnimControlCollection*(param0: AnimControlCollection): AnimControlCollection {.importcpp: "AnimControlCollection(#)".}

proc storeAnim*(this: AnimControlCollection, control: AnimControl, name: string) {.importcpp: "#.store_anim(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Associates the given AnimControl with this collection under the given name.
## The AnimControl will remain associated until a new AnimControl is
## associated with the same name later, or until unbind_anim() is called with
## this name.

proc findAnim*(this: AnimControlCollection, name: string): AnimControl {.importcpp: "#.find_anim(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the AnimControl associated with the given name, or NULL if no such
## control has been associated.

proc unbindAnim*(this: AnimControlCollection, name: string): bool {.importcpp: "#.unbind_anim(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes the AnimControl associated with the given name, if any.  Returns
## true if an AnimControl was removed, false if there was no AnimControl with
## the indicated name.

proc getNumAnims*(this: AnimControlCollection): int {.importcpp: "#.get_num_anims()".} ## \
## Returns the number of AnimControls associated with this collection.

proc getAnim*(this: AnimControlCollection, n: int): AnimControl {.importcpp: "#.get_anim(#)".} ## \
## Returns the nth AnimControl associated with this collection.

proc getAnimName*(this: AnimControlCollection, n: int): string {.importcpp: "nimStringFromStdString(#.get_anim_name(#))", header: stringConversionCode.} ## \
## Returns the name of the nth AnimControl associated with this collection.

proc clearAnims*(this: AnimControlCollection) {.importcpp: "#.clear_anims()".} ## \
## Disassociates all anims from this collection.

proc play*(this: AnimControlCollection, anim_name: string): bool {.importcpp: "#.play(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Starts the named animation playing.

proc play*(this: AnimControlCollection, anim_name: string, `from`: float64, to: float64): bool {.importcpp: "#.play(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Starts the named animation playing.

proc loop*(this: AnimControlCollection, anim_name: string, restart: bool): bool {.importcpp: "#.loop(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Starts the named animation looping.

proc loop*(this: AnimControlCollection, anim_name: string, restart: bool, `from`: float64, to: float64): bool {.importcpp: "#.loop(nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## Starts the named animation looping.

proc stop*(this: AnimControlCollection, anim_name: string): bool {.importcpp: "#.stop(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Stops the named animation.

proc pose*(this: AnimControlCollection, anim_name: string, frame: float64): bool {.importcpp: "#.pose(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Sets to a particular frame in the named animation.

proc playAll*(this: AnimControlCollection) {.importcpp: "#.play_all()".} ## \
## These functions operate on all anims at once.

proc playAll*(this: AnimControlCollection, `from`: float64, to: float64) {.importcpp: "#.play_all(#, #)".} ## \
## Starts all animations playing.

proc loopAll*(this: AnimControlCollection, restart: bool) {.importcpp: "#.loop_all(#)".} ## \
## Starts all animations looping.

proc loopAll*(this: AnimControlCollection, restart: bool, `from`: float64, to: float64) {.importcpp: "#.loop_all(#, #, #)".} ## \
## Starts all animations looping.

proc stopAll*(this: AnimControlCollection): bool {.importcpp: "#.stop_all()".} ## \
## Stops all currently playing animations.  Returns true if any animations
## were stopped, false if none were playing.

proc poseAll*(this: AnimControlCollection, frame: float64) {.importcpp: "#.pose_all(#)".} ## \
## Sets all animations to the indicated frame.

proc getFrame*(this: AnimControlCollection): int {.importcpp: "#.get_frame()".} ## \
## Returns the current frame in the last-started animation.

proc getFrame*(this: AnimControlCollection, anim_name: string): int {.importcpp: "#.get_frame(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the current frame in the named animation, or 0 if the animation is
## not found.

proc getNumFrames*(this: AnimControlCollection): int {.importcpp: "#.get_num_frames()".} ## \
## Returns the total number of frames in the last-started animation.

proc getNumFrames*(this: AnimControlCollection, anim_name: string): int {.importcpp: "#.get_num_frames(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the total number of frames in the named animation, or 0 if the
## animation is not found.

proc isPlaying*(this: AnimControlCollection): bool {.importcpp: "#.is_playing()".} ## \
## Returns true if the last-started animation is currently playing, false
## otherwise.

proc isPlaying*(this: AnimControlCollection, anim_name: string): bool {.importcpp: "#.is_playing(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if the named animation is currently playing, false otherwise.

proc whichAnimPlaying*(this: AnimControlCollection): string {.importcpp: "nimStringFromStdString(#.which_anim_playing())", header: stringConversionCode.} ## \
## Returns the name of the bound AnimControl currently playing, if any.  If
## more than one AnimControl is currently playing, returns all of the names
## separated by spaces.

proc output*(this: AnimControlCollection, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: AnimControlCollection, `out`: ostream) {.importcpp: "#.write(#)".}

proc newAnimPreloadTable*(): AnimPreloadTable {.importcpp: "new AnimPreloadTable()".}

proc getNumAnims*(this: AnimPreloadTable): int {.importcpp: "#->get_num_anims()".} ## \
## Returns the number of animation records in the table.

proc findAnim*(this: AnimPreloadTable, basename: string): int {.importcpp: "#->find_anim(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the index number in the table of the animation record with the
## indicated name, or -1 if the name is not present.  By convention, the
## basename is the filename of the egg or bam file, without the directory part
## and without the extension.  That is, it is
## Filename::get_basename_wo_extension().

proc getBasename*(this: AnimPreloadTable, n: int): string {.importcpp: "nimStringFromStdString(#->get_basename(#))", header: stringConversionCode.} ## \
## Returns the basename stored for the nth animation record.  See find_anim().

proc getBaseFrameRate*(this: AnimPreloadTable, n: int): float32 {.importcpp: "#->get_base_frame_rate(#)".} ## \
## Returns the frame rate stored for the nth animation record.

proc getNumFrames*(this: AnimPreloadTable, n: int): int {.importcpp: "#->get_num_frames(#)".} ## \
## Returns the number of frames stored for the nth animation record.

proc clearAnims*(this: AnimPreloadTable) {.importcpp: "#->clear_anims()".} ## \
## Removes all animation records from the table.

proc removeAnim*(this: AnimPreloadTable, n: int) {.importcpp: "#->remove_anim(#)".} ## \
## Removes the nth animation records from the table.  This renumbers indexes
## for following animations.

proc addAnim*(this: AnimPreloadTable, basename: string, base_frame_rate: float32, num_frames: int) {.importcpp: "#->add_anim(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Adds a new animation record to the table.  If there is already a record of
## this name, no operation is performed (the original record is unchanged).
## See find_anim().  This will invalidate existing index numbers.

proc addAnimsFrom*(this: AnimPreloadTable, other: AnimPreloadTable) {.importcpp: "#->add_anims_from(#)".} ## \
## Copies the animation records from the other table into this one.  If a
## given record name exists in both tables, the record in this one supercedes.

proc output*(this: AnimPreloadTable, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: AnimPreloadTable, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

converter getClassType*(_: typedesc[AnimPreloadTable]): TypeHandle {.importcpp: "AnimPreloadTable::get_class_type()", header: "animPreloadTable.h".}

proc autoBind*(root_node: PandaNode, controls: AnimControlCollection, hierarchy_match_flags: int) {.importcpp: "auto_bind(#, #, #)".}

proc autoBind*(root_node: PandaNode, controls: AnimControlCollection) {.importcpp: "auto_bind(#, #)".}

proc initPartSubset*(): PartSubset {.importcpp: "PartSubset()".}

proc initPartSubset*(copy: PartSubset): PartSubset {.importcpp: "PartSubset(#)".}

proc addIncludeJoint*(this: PartSubset, name: GlobPattern) {.importcpp: "#.add_include_joint(#)".} ## \
## Adds the named joint to the list of joints that will be explicitly included
## in the subset.  Any joint at or below a named node will be included in the
## subset (unless a lower node is also listed in the exclude list).
##
## Since the name is a GlobPattern, it may of course include filename globbing
## characters like \* and ?.

proc addExcludeJoint*(this: PartSubset, name: GlobPattern) {.importcpp: "#.add_exclude_joint(#)".} ## \
## Adds the named joint to the list of joints that will be explicitly
## exlcluded from the subset.  Any joint at or below a named node will not be
## included in the subset (unless a lower node is also listed in the include
## list).
##
## Since the name is a GlobPattern, it may of course include filename globbing
## characters like \* and ?.

proc append*(this: PartSubset, other: PartSubset) {.importcpp: "#.append(#)".} ## \
## Appends the include and exclude list from the other object onto this
## object's lists.

proc output*(this: PartSubset, `out`: ostream) {.importcpp: "#.output(#)".}

proc isIncludeEmpty*(this: PartSubset): bool {.importcpp: "#.is_include_empty()".} ## \
## Returns true if the include list is completely empty, false otherwise.  If
## it is empty, it is the same thing as including all joints.

proc matchesInclude*(this: PartSubset, joint_name: string): bool {.importcpp: "#.matches_include(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if the indicated name matches a name on the include list,
## false otherwise.

proc matchesExclude*(this: PartSubset, joint_name: string): bool {.importcpp: "#.matches_exclude(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if the indicated name matches a name on the exclude list,
## false otherwise.

proc newBindAnimRequest*(param0: BindAnimRequest): BindAnimRequest {.importcpp: "new BindAnimRequest(#)".}

proc newBindAnimRequest*(name: string, filename: Filename, options: LoaderOptions, loader: Loader, control: AnimControl, hierarchy_match_flags: int, subset: PartSubset): BindAnimRequest {.importcpp: "new BindAnimRequest(nimStringToStdString(#), #, #, #, #, #, #)", header: stringConversionCode.}

converter getClassType*(_: typedesc[BindAnimRequest]): TypeHandle {.importcpp: "BindAnimRequest::get_class_type()", header: "bindAnimRequest.h".}

proc newPartBundle*(name: string): PartBundle {.importcpp: "new PartBundle(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Normally, a PartBundle constructor should not be called directly--it will
## get created when a PartBundleNode is created.

proc newPartBundle*(): PartBundle {.importcpp: "new PartBundle()".} ## \
## Normally, a PartBundle constructor should not be called directly--it will
## get created when a PartBundleNode is created.

proc getAnimPreload*(this: PartBundle): AnimPreloadTable {.importcpp: "deconstify(#->get_anim_preload())", header: deconstifyCode.} ## \
## Returns the AnimPreloadTable associated with the PartBundle.  This table,
## if present, can be used for the benefit of load_bind_anim() to allow
## asynchronous binding.

proc modifyAnimPreload*(this: PartBundle): AnimPreloadTable {.importcpp: "#->modify_anim_preload()".} ## \
## Returns a modifiable pointer to the AnimPreloadTable associated with the
## PartBundle, if any.

proc setAnimPreload*(this: PartBundle, table: AnimPreloadTable) {.importcpp: "#->set_anim_preload(#)".} ## \
## Replaces the AnimPreloadTable associated with the PartBundle.

proc clearAnimPreload*(this: PartBundle) {.importcpp: "#->clear_anim_preload()".} ## \
## Removes any AnimPreloadTable associated with the PartBundle.

proc mergeAnimPreloads*(this: PartBundle, other: PartBundle) {.importcpp: "#->merge_anim_preloads(#)".} ## \
## Copies the contents of the other PartBundle's preload table into this one.

proc setAnimBlendFlag*(this: PartBundle, anim_blend_flag: bool) {.importcpp: "#->set_anim_blend_flag(#)".} ## \
## Defines the way the character responds to multiple calls to
## set_control_effect()).  By default, this flag is set false, which disallows
## multiple animations.  When this flag is false, it is not necessary to
## explicitly set the control_effect when starting an animation; starting the
## animation will implicitly remove the control_effect from the previous
## animation and set it on the current one.
##
## However, if this flag is set true, the control_effect must be explicitly
## set via set_control_effect() whenever an animation is to affect the
## character.

proc getAnimBlendFlag*(this: PartBundle): bool {.importcpp: "#->get_anim_blend_flag()".} ## \
## Returns whether the character allows multiple different animations to be
## bound simultaneously.  See set_anim_blend_flag().

proc setFrameBlendFlag*(this: PartBundle, frame_blend_flag: bool) {.importcpp: "#->set_frame_blend_flag(#)".} ## \
## Specifies whether the character interpolates (blends) between two
## sequential frames of an active animation, showing a smooth intra-frame
## motion, or whether it holds each frame until the next frame is ready,
## showing precisely the specified animation.
##
## When this value is false, the character holds each frame until the next is
## ready.  When this is true, the character will interpolate between two
## consecutive frames of animation for each frame the animation is onscreen,
## according to the amount of time elapsed between the frames.
##
## The default value of this flag is determined by the interpolate-frames
## Config.prc variable.
##
## Use set_blend_type() to change the algorithm that the character uses to
## interpolate matrix positions.

proc getFrameBlendFlag*(this: PartBundle): bool {.importcpp: "#->get_frame_blend_flag()".} ## \
## Returns whether the character interpolates (blends) between two sequential
## animation frames, or whether it holds the current frame until the next one
## is ready.  See set_frame_blend_flag().

proc setRootXform*(this: PartBundle, root_xform: LMatrix4) {.importcpp: "#->set_root_xform(#)".} ## \
## Specifies the transform matrix which is implicitly applied at the root of
## the animated hierarchy.

proc xform*(this: PartBundle, mat: LMatrix4) {.importcpp: "#->xform(#)".} ## \
## Applies the indicated transform to the root of the animated hierarchy.

proc getRootXform*(this: PartBundle): LMatrix4 {.importcpp: "#->get_root_xform()".} ## \
## Returns the transform matrix which is implicitly applied at the root of the
## animated hierarchy.

proc applyTransform*(this: PartBundle, transform: TransformState): PartBundle {.importcpp: "#->apply_transform(#)".} ## \
## Returns a PartBundle that is a duplicate of this one, but with the
## indicated transform applied.  If this is called multiple times with the
## same TransformState pointer, it returns the same PartBundle each time.

proc getNumNodes*(this: PartBundle): int {.importcpp: "#->get_num_nodes()".} ## \
## Returns the number of PartBundleNodes that contain a pointer to this
## PartBundle.

proc getNode*(this: PartBundle, n: int): PartBundleNode {.importcpp: "#->get_node(#)".} ## \
## Returns the nth PartBundleNode associated with this PartBundle.

proc newPartBundleNode*(name: string, bundle: PartBundle): PartBundleNode {.importcpp: "new PartBundleNode(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## The PartBundle and its node should be constructed together.  Generally, the
## derived classes of PartBundleNode will automatically create a PartBundle of
## the appropriate type, and pass it up to this constructor.

proc getNumBundles*(this: PartBundleNode): int {.importcpp: "#->get_num_bundles()".}

proc getBundle*(this: PartBundleNode, n: int): PartBundle {.importcpp: "#->get_bundle(#)".}

proc getBundleHandle*(this: PartBundleNode, n: int): PartBundleHandle {.importcpp: "#->get_bundle_handle(#)".} ## \
## Returns the PartBundleHandle that wraps around the actual nth PartBundle.
## While the PartBundle pointer might later change due to a future flatten
## operation, the PartBundleHandle will not.

proc newPartBundleHandle*(bundle: PartBundle): PartBundleHandle {.importcpp: "new PartBundleHandle(#)".}

proc newPartBundleHandle*(param0: PartBundleHandle): PartBundleHandle {.importcpp: "new PartBundleHandle(#)".}

proc getBundle*(this: PartBundleHandle): PartBundle {.importcpp: "#->get_bundle()".} ## \
## Returns the actual PartBundle embedded within the handle.

proc setBundle*(this: PartBundleHandle, bundle: PartBundle) {.importcpp: "#->set_bundle(#)".} ## \
## Changes the actual PartBundle embedded within the handle.

converter getClassType*(_: typedesc[PartBundleNode]): TypeHandle {.importcpp: "PartBundleNode::get_class_type()", header: "partBundleNode.h".}

proc clearControlEffects*(this: PartBundle) {.importcpp: "#->clear_control_effects()".} ## \
## Sets the control effect of all AnimControls to zero (but does not "stop"
## the AnimControls).  The character will no longer be affected by any
## animation, and will return to its default pose (unless restore-initial-pose
## is false).
##
## The AnimControls which are no longer associated will not be using any CPU
## cycles, but they may still be in the "playing" state; if they are later
## reassociated with the PartBundle they will resume at their current frame as
## if they'd been running all along.

proc setControlEffect*(this: PartBundle, control: AnimControl, effect: float32) {.importcpp: "#->set_control_effect(#, #)".} ## \
## Sets the amount by which the character is affected by the indicated
## AnimControl (and its associated animation).  Normally, this will only be
## zero or one.  Zero indicates the animation does not affect the character,
## and one means it does.
##
## If the _anim_blend_flag is not false (see set_anim_blend_flag()), it is
## possible to have multiple AnimControls in effect simultaneously.  In this
## case, the effect is a weight that indicates the relative importance of each
## AnimControl to the final animation.

proc getControlEffect*(this: PartBundle, control: AnimControl): float32 {.importcpp: "#->get_control_effect(#)".} ## \
## Returns the amount by which the character is affected by the indicated
## AnimControl and its associated animation.  See set_control_effect().

proc output*(this: PartBundle, `out`: ostream) {.importcpp: "#->output(#)".} ## \
## Writes a one-line description of the bundle.

proc bindAnim*(this: PartBundle, anim: AnimBundle, hierarchy_match_flags: int, subset: PartSubset): AnimControl {.importcpp: "#->bind_anim(#, #, #)".} ## \
## Binds the animation to the bundle, if possible, and returns a new
## AnimControl that can be used to start and stop the animation.  If the anim
## hierarchy does not match the part hierarchy, returns NULL.
##
## If hierarchy_match_flags is 0, only an exact match is accepted; otherwise,
## it may contain a union of PartGroup::HierarchyMatchFlags values indicating
## conditions that will be tolerated (but warnings will still be issued).
##
## If subset is specified, it restricts the binding only to the named subtree
## of joints.
##
## The AnimControl is not stored within the PartBundle; it is the user's
## responsibility to maintain the pointer.  The animation will automatically
## unbind itself when the AnimControl destructs (i.e.  its reference count
## goes to zero).

proc bindAnim*(this: PartBundle, anim: AnimBundle, hierarchy_match_flags: int): AnimControl {.importcpp: "#->bind_anim(#, #)".} ## \
## Binds the animation to the bundle, if possible, and returns a new
## AnimControl that can be used to start and stop the animation.  If the anim
## hierarchy does not match the part hierarchy, returns NULL.
##
## If hierarchy_match_flags is 0, only an exact match is accepted; otherwise,
## it may contain a union of PartGroup::HierarchyMatchFlags values indicating
## conditions that will be tolerated (but warnings will still be issued).
##
## If subset is specified, it restricts the binding only to the named subtree
## of joints.
##
## The AnimControl is not stored within the PartBundle; it is the user's
## responsibility to maintain the pointer.  The animation will automatically
## unbind itself when the AnimControl destructs (i.e.  its reference count
## goes to zero).

proc bindAnim*(this: PartBundle, anim: AnimBundle): AnimControl {.importcpp: "#->bind_anim(#)".} ## \
## Binds the animation to the bundle, if possible, and returns a new
## AnimControl that can be used to start and stop the animation.  If the anim
## hierarchy does not match the part hierarchy, returns NULL.
##
## If hierarchy_match_flags is 0, only an exact match is accepted; otherwise,
## it may contain a union of PartGroup::HierarchyMatchFlags values indicating
## conditions that will be tolerated (but warnings will still be issued).
##
## If subset is specified, it restricts the binding only to the named subtree
## of joints.
##
## The AnimControl is not stored within the PartBundle; it is the user's
## responsibility to maintain the pointer.  The animation will automatically
## unbind itself when the AnimControl destructs (i.e.  its reference count
## goes to zero).

proc loadBindAnim*(this: PartBundle, loader: Loader, filename: Filename, hierarchy_match_flags: int, subset: PartSubset, allow_async: bool): AnimControl {.importcpp: "#->load_bind_anim(#, #, #, #, #)".} ## \
## Binds an animation to the bundle.  The animation is loaded from the disk
## via the indicated Loader object.  In other respects, this behaves similarly
## to bind_anim(), with the addition of asynchronous support.
##
## If allow_aysnc is true, the load will be asynchronous if possible.  This
## requires that the animation basename can be found in the PartBundle's
## preload table (see get_anim_preload()).
##
## In an asynchronous load, the animation file will be loaded and bound in a
## sub-thread.  This means that the animation will not necessarily be
## available at the time this method returns.  You may still use the returned
## AnimControl immediately, though, but no visible effect will occur until the
## animation eventually becomes available.
##
## You can test AnimControl::is_pending() to see if the animation has been
## loaded yet, or wait for it to finish with AnimControl::wait_pending() or
## even PartBundle::wait_pending().  You can also set an event to be triggered
## when the animation finishes loading with
## AnimControl::set_pending_done_event().

proc waitPending*(this: PartBundle) {.importcpp: "#->wait_pending()".} ## \
## Blocks the current thread until all currently-pending AnimControls, with a
## nonzero control effect, have been loaded and are properly bound.

proc freezeJoint*(this: PartBundle, joint_name: string, pos: LVecBase3, hpr: LVecBase3, scale: LVecBase3): bool {.importcpp: "#->freeze_joint(nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## Specifies that the joint with the indicated name should be frozen with the
## specified transform.  It will henceforth always hold this fixed transform,
## regardless of any animations that may subsequently be bound to the joint.
##
## Returns true if the joint is successfully frozen, or false if the named
## child is not a joint (or slider) or does not exist.

proc freezeJoint*(this: PartBundle, joint_name: string, value: float32): bool {.importcpp: "#->freeze_joint(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Specifies that the joint with the indicated name should be frozen with the
## specified transform.  It will henceforth always hold this fixed transform,
## regardless of any animations that may subsequently be bound to the joint.
##
## Returns true if the joint is successfully frozen, or false if the named
## child is not a joint (or slider) or does not exist.

proc freezeJoint*(this: PartBundle, joint_name: string, transform: TransformState): bool {.importcpp: "#->freeze_joint(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Specifies that the joint with the indicated name should be frozen with the
## specified transform.  It will henceforth always hold this fixed transform,
## regardless of any animations that may subsequently be bound to the joint.
##
## Returns true if the joint is successfully frozen, or false if the named
## child is not a joint (or slider) or does not exist.

proc controlJoint*(this: PartBundle, joint_name: string, node: PandaNode): bool {.importcpp: "#->control_joint(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Specifies that the joint with the indicated name should be animated with
## the transform on the indicated node.  It will henceforth always follow the
## node's transform, regardless of any animations that may subsequently be
## bound to the joint.
##
## Returns true if the joint is successfully controlled, or false if the named
## child is not a joint (or slider) or does not exist.

proc releaseJoint*(this: PartBundle, joint_name: string): bool {.importcpp: "#->release_joint(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Releases the named joint from the effects of a previous call to
## freeze_joint() or control_joint(). It will henceforth once again follow
## whatever transforms are dictated by the animation.
##
## Returns true if the joint is released, or false if the named child was not
## previously controlled or frozen, or it does not exist.

proc update*(this: PartBundle): bool {.importcpp: "#->update()".} ## \
## Updates all the parts in the bundle to reflect the data for the current
## frame (as set in each of the AnimControls).
##
## Returns true if any part has changed as a result of this, or false
## otherwise.

proc forceUpdate*(this: PartBundle): bool {.importcpp: "#->force_update()".} ## \
## Updates all the parts in the bundle to reflect the data for the current
## frame, whether we believe it needs it or not.

converter getClassType*(_: typedesc[PartBundle]): TypeHandle {.importcpp: "PartBundle::get_class_type()", header: "partBundle.h".}

proc getMaxBound*(this: MovingPartBase): int {.importcpp: "#->get_max_bound()".} ## \
## Returns the number of channels that might be bound to this PartGroup.  This
## might not be the actual number of channels, since there might be holes in
## the list; it is one more than the index number of the highest bound
## channel.  Thus, it is called get_max_bound() instead of get_num_bound().

proc getBound*(this: MovingPartBase, n: int): AnimChannelBase {.importcpp: "#->get_bound(#)".} ## \
## Returns the nth bound channel on this PartGroup.  n can be determined by
## iterating from 0 to one less than get_max_bound(); or n might be
## AnimControl::get_channel_index().
##
## This will return NULL if there is no channel bound on the indicated index.
## It is an error to call this if n is less than zero or greater than or equal
## to get_max_bound().

proc outputValue*(this: MovingPartBase, `out`: ostream) {.importcpp: "#->output_value(#)".}

converter getClassType*(_: typedesc[MovingPartBase]): TypeHandle {.importcpp: "MovingPartBase::get_class_type()", header: "movingPartBase.h".}

converter getClassType*(_: typedesc[MovingPartMatrix]): TypeHandle {.importcpp: "MovingPartMatrix::get_class_type()", header: "movingPartMatrix.h".}

converter getClassType*(_: typedesc[MovingPartScalar]): TypeHandle {.importcpp: "MovingPartScalar::get_class_type()", header: "movingPartScalar.h".}

proc setClientName*(this: PStatClient, name: string) {.importcpp: "#.set_client_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the name of the client.  This is reported to the PStatsServer, and
## will presumably be written in the title bar or something.

proc getClientName*(this: PStatClient): string {.importcpp: "nimStringFromStdString(#.get_client_name())", header: stringConversionCode.} ## \
## Retrieves the name of the client as set.

proc setMaxRate*(this: PStatClient, rate: float64) {.importcpp: "#.set_max_rate(#)".} ## \
## Controls the number of packets that will be sent to the server.  Normally,
## one packet is sent per frame, but this can flood the server with more
## packets than it can handle if the frame rate is especially good (e.g.  if
## nothing is onscreen at the moment).  Set this parameter to a reasonable
## number to prevent this from happening.
##
## This number specifies the maximum number of packets that will be sent to
## the server per second, per thread.

proc getMaxRate*(this: PStatClient): float64 {.importcpp: "#.get_max_rate()".} ## \
## Returns the maximum number of packets that will be sent to the server per
## second, per thread.  See set_max_rate().

proc getNumCollectors*(this: PStatClient): int {.importcpp: "#.get_num_collectors()".} ## \
## Returns the total number of collectors the Client knows about.

proc getCollector*(this: PStatClient, index: int): PStatCollector {.importcpp: "#.get_collector(#)".} ## \
## Returns the nth collector.

proc getCollectorName*(this: PStatClient, index: int): string {.importcpp: "nimStringFromStdString(#.get_collector_name(#))", header: stringConversionCode.} ## \
## Returns the name of the indicated collector.

proc getCollectorFullname*(this: PStatClient, index: int): string {.importcpp: "nimStringFromStdString(#.get_collector_fullname(#))", header: stringConversionCode.} ## \
## Returns the "full name" of the indicated collector.  This will be the
## concatenation of all of the collector's parents' names (except Frame) and
## the collector's own name.

proc getNumThreads*(this: PStatClient): int {.importcpp: "#.get_num_threads()".} ## \
## Returns the total number of threads the Client knows about.

proc getThread*(this: PStatClient, index: int): PStatThread {.importcpp: "#.get_thread(#)".} ## \
## Returns the nth thread.

proc getThreadName*(this: PStatClient, index: int): string {.importcpp: "nimStringFromStdString(#.get_thread_name(#))", header: stringConversionCode.} ## \
## Returns the name of the indicated thread.

proc getThreadSyncName*(this: PStatClient, index: int): string {.importcpp: "nimStringFromStdString(#.get_thread_sync_name(#))", header: stringConversionCode.} ## \
## Returns the sync_name of the indicated thread.

proc getThreadObject*(this: PStatClient, index: int): Thread {.importcpp: "#.get_thread_object(#)".} ## \
## Returns the Panda Thread object associated with the indicated PStatThread.

proc getMainThread*(this: PStatClient): PStatThread {.importcpp: "#.get_main_thread()".} ## \
## Returns a handle to the client's Main thread.  This is the thread that
## started the application.

proc getCurrentThread*(this: PStatClient): PStatThread {.importcpp: "#.get_current_thread()".} ## \
## Returns a handle to the currently-executing thread.  This is the thread
## that PStatCollectors will be counted in if they do not specify otherwise.

proc getRealTime*(this: PStatClient): float64 {.importcpp: "#.get_real_time()".} ## \
## Returns the time according to to the PStatClient's clock object.  It keeps
## its own clock, instead of using the global clock object, so the stats won't
## get mucked up if you put the global clock in non-real-time mode or
## something.

proc initPStatCollector*(copy: PStatCollector): PStatCollector {.importcpp: "PStatCollector(#)".}

proc initPStatCollector*(parent: PStatCollector, name: string): PStatCollector {.importcpp: "PStatCollector(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates a new PStatCollector, ready to start accumulating data.  The name
## of the collector uniquely identifies it among the other collectors; if two
## collectors share the same name then they are really the same collector.
##
## The parent is the collector that conceptually includes all of the time
## measured for this collector.  For instance, a particular character's
## animation time is owned by the "Animation" collector, which is in turn
## owned by the "Frame" collector.  It is not strictly necessary that all of
## the time spent in a particular collector is completely nested within time
## spent in its parent's collector.  If parent is the empty string, the
## collector is owned by "Frame".
##
## This constructor does not take a client pointer; it always creates the new
## collector on the same client as its parent.

proc initPStatCollector*(name: string, client: PStatClient): PStatCollector {.importcpp: "PStatCollector(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Creates a new PStatCollector, ready to start accumulating data.  The name
## of the collector uniquely identifies it among the other collectors; if two
## collectors share the same name then they are really the same collector.
##
## The name may also be a compound name, something like "Cull:Sort", which
## indicates that this is a collector named "Sort", a child of the collector
## named "Cull". The parent may also be named explicitly by reference in the
## other flavor of the constructor; see further comments on this for that
## constructor.
##
## If the client pointer is non-null, it specifies a particular client to
## register the collector with; otherwise, the global client is used.

proc initPStatCollector*(name: string): PStatCollector {.importcpp: "PStatCollector(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates a new PStatCollector, ready to start accumulating data.  The name
## of the collector uniquely identifies it among the other collectors; if two
## collectors share the same name then they are really the same collector.
##
## The name may also be a compound name, something like "Cull:Sort", which
## indicates that this is a collector named "Sort", a child of the collector
## named "Cull". The parent may also be named explicitly by reference in the
## other flavor of the constructor; see further comments on this for that
## constructor.
##
## If the client pointer is non-null, it specifies a particular client to
## register the collector with; otherwise, the global client is used.

proc isValid*(this: PStatCollector): bool {.importcpp: "#.is_valid()".} ## \
## Returns true if collector is valid and may be used, or false if it was
## constructed with the default constructor (in which case any attempt to use
## it will crash).

proc getName*(this: PStatCollector): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the local name of this collector.  This is the rightmost part of
## the fullname, after the rightmost colon.

proc getFullname*(this: PStatCollector): string {.importcpp: "nimStringFromStdString(#.get_fullname())", header: stringConversionCode.} ## \
## Returns the full name of this collector.  This includes the names of all
## the collector's parents, concatenated together with colons.

proc output*(this: PStatCollector, `out`: ostream) {.importcpp: "#.output(#)".}

proc isActive*(this: PStatCollector): bool {.importcpp: "#.is_active()".} ## \
## Returns true if this particular collector is active on the default thread,
## and we are currently transmitting PStats data.

proc isActive*(this: PStatCollector, thread: PStatThread): bool {.importcpp: "#.is_active(#)".} ## \
## Returns true if this particular collector is active on the indicated
## thread, and we are currently transmitting PStats data.

proc isStarted*(this: PStatCollector): bool {.importcpp: "#.is_started()".} ## \
## Returns true if this particular collector has been started on the default
## thread, or false otherwise.

proc isStarted*(this: PStatCollector, thread: PStatThread): bool {.importcpp: "#.is_started(#)".} ## \
## Returns true if this particular collector has been started on the indicated
## thread, or false otherwise.

proc start*(this: PStatCollector) {.importcpp: "#.start()".} ## \
## Starts this particular timer ticking.  This should be called before the
## code you want to measure.

proc start*(this: PStatCollector, thread: PStatThread) {.importcpp: "#.start(#)".} ## \
## Starts this timer ticking within a particular thread.

proc start*(this: PStatCollector, thread: PStatThread, as_of: float64) {.importcpp: "#.start(#, #)".} ## \
## Marks that the timer should have been started as of the indicated time.
## This must be a time based on the PStatClient's clock (see
## PStatClient::get_clock()), and care should be taken that all such calls
## exhibit a monotonically increasing series of time values.

proc stop*(this: PStatCollector) {.importcpp: "#.stop()".} ## \
## Stops this timer.  This should be called after the code you want to
## measure.

proc stop*(this: PStatCollector, thread: PStatThread) {.importcpp: "#.stop(#)".} ## \
## Stops this timer within a particular thread.

proc stop*(this: PStatCollector, thread: PStatThread, as_of: float64) {.importcpp: "#.stop(#, #)".} ## \
## Marks that the timer should have been stopped as of the indicated time.
## This must be a time based on the PStatClient's clock (see
## PStatClient::get_clock()), and care should be taken that all such calls
## exhibit a monotonically increasing series of time values.

proc clearLevel*(this: PStatCollector) {.importcpp: "#.clear_level()".} ## \
## Removes the level setting associated with this collector for the main
## thread.  The collector will no longer show up on any level graphs in the
## main thread.  This implicitly calls flush_level().

proc clearLevel*(this: PStatCollector, thread: PStatThread) {.importcpp: "#.clear_level(#)".} ## \
## Removes the level setting associated with this collector for the indicated
## thread.  The collector will no longer show up on any level graphs in this
## thread.

proc setLevel*(this: PStatCollector, thread: PStatThread, level: float64) {.importcpp: "#.set_level(#, #)".} ## \
## Sets the level setting associated with this collector for the indicated
## thread to the indicated value.

proc setLevel*(this: PStatCollector, level: float64) {.importcpp: "#.set_level(#)".} ## \
## Sets the level setting associated with this collector for the main thread
## to the indicated value.  This implicitly calls flush_level().

proc addLevel*(this: PStatCollector, thread: PStatThread, increment: float64) {.importcpp: "#.add_level(#, #)".} ## \
## Adds the indicated increment (which may be negative) to the level setting
## associated with this collector for the indicated thread.  If the collector
## did not already have a level setting for this thread, it is initialized to
## 0.

proc addLevel*(this: PStatCollector, increment: float64) {.importcpp: "#.add_level(#)".} ## \
## Adds the indicated increment (which may be negative) to the level setting
## associated with this collector for the main thread.  If the collector did
## not already have a level setting for the main thread, it is initialized to
## 0.
##
## As an optimization, the data is not immediately set to the PStatClient.  It
## will be sent the next time flush_level() is called.

proc subLevel*(this: PStatCollector, thread: PStatThread, decrement: float64) {.importcpp: "#.sub_level(#, #)".} ## \
## Subtracts the indicated decrement (which may be negative) to the level
## setting associated with this collector for the indicated thread.  If the
## collector did not already have a level setting for this thread, it is
## initialized to 0.

proc subLevel*(this: PStatCollector, decrement: float64) {.importcpp: "#.sub_level(#)".} ## \
## Subtracts the indicated decrement (which may be negative) to the level
## setting associated with this collector for the main thread.  If the
## collector did not already have a level setting for the main thread, it is
## initialized to 0.
##
## As an optimization, the data is not immediately set to the PStatClient.  It
## will be sent the next time flush_level() is called.

proc addLevelNow*(this: PStatCollector, increment: float64) {.importcpp: "#.add_level_now(#)".} ## \
## Calls add_level() and immediately calls flush_level().

proc subLevelNow*(this: PStatCollector, decrement: float64) {.importcpp: "#.sub_level_now(#)".} ## \
## Calls sub_level() and immediately calls flush_level().

proc flushLevel*(this: PStatCollector) {.importcpp: "#.flush_level()".} ## \
## Updates the PStatClient with the recent results from add_level() and
## sub_level().

proc getLevel*(this: PStatCollector): float64 {.importcpp: "#.get_level()".} ## \
## Returns the current level value of the given collector in the main thread.
## This implicitly calls flush_level().

proc getLevel*(this: PStatCollector, thread: PStatThread): float64 {.importcpp: "#.get_level(#)".} ## \
## Returns the current level value of the given collector.

proc clearThreadLevel*(this: PStatCollector) {.importcpp: "#.clear_thread_level()".} ## \
## Removes the level setting associated with this collector for the current
## thread.  The collector will no longer show up on any level graphs in the
## current thread.

proc setThreadLevel*(this: PStatCollector, level: float64) {.importcpp: "#.set_thread_level(#)".} ## \
## Sets the level setting associated with this collector for the current
## thread to the indicated value.

proc addThreadLevel*(this: PStatCollector, increment: float64) {.importcpp: "#.add_thread_level(#)".} ## \
## Adds the indicated increment (which may be negative) to the level setting
## associated with this collector for the current thread.  If the collector
## did not already have a level setting for the current thread, it is
## initialized to 0.

proc subThreadLevel*(this: PStatCollector, decrement: float64) {.importcpp: "#.sub_thread_level(#)".} ## \
## Subtracts the indicated decrement (which may be negative) to the level
## setting associated with this collector for the current thread.  If the
## collector did not already have a level setting for the current thread, it
## is initialized to 0.

proc getThreadLevel*(this: PStatCollector): float64 {.importcpp: "#.get_thread_level()".} ## \
## Returns the current level value of the given collector in the current
## thread.

proc getIndex*(this: PStatCollector): int {.importcpp: "#.get_index()".} ## \
## Returns the index number of this particular collector within the
## PStatClient.

proc initPStatThread*(client: PStatClient, index: int): PStatThread {.importcpp: "PStatThread(#, #)".} ## \
## Normally, this constructor is called only from PStatClient.  Use one of the
## constructors below to create your own Thread.

proc initPStatThread*(copy: PStatThread): PStatThread {.importcpp: "PStatThread(#)".}

proc initPStatThread*(thread: Thread, client: PStatClient): PStatThread {.importcpp: "PStatThread(#, #)".} ## \
## Creates a new named thread.  This will be used to unify tasks that share a
## common thread, and differentiate tasks that occur in different threads.

converter initPStatThread*(thread: Thread): PStatThread {.importcpp: "PStatThread(#)".} ## \
## Creates a new named thread.  This will be used to unify tasks that share a
## common thread, and differentiate tasks that occur in different threads.

proc newFrame*(this: PStatThread) {.importcpp: "#.new_frame()".} ## \
## This must be called at the start of every "frame", whatever a frame may be
## deemed to be, to accumulate all the stats that have collected so far for
## the thread and ship them off to the server.
##
## Calling PStatClient::thread_tick() will automatically call this for any
## threads with the indicated sync name.

proc getThread*(this: PStatThread): Thread {.importcpp: "#.get_thread()".} ## \
## Returns the Panda Thread object associated with this particular
## PStatThread.

proc getIndex*(this: PStatThread): int {.importcpp: "#.get_index()".} ## \
## Returns the index number of this particular thread within the PStatClient.

proc connect*(_: typedesc[PStatClient], hostname: string, port: int): bool {.importcpp: "#PStatClient::connect(nimStringToStdString(#), #)", header: "pStatClient.h".} ## \
## Attempts to establish a connection to the indicated PStatServer.  Returns
## true if successful, false on failure.

proc connect*(_: typedesc[PStatClient], hostname: string): bool {.importcpp: "#PStatClient::connect(nimStringToStdString(#))", header: "pStatClient.h".} ## \
## Attempts to establish a connection to the indicated PStatServer.  Returns
## true if successful, false on failure.

proc connect*(_: typedesc[PStatClient]): bool {.importcpp: "PStatClient::connect()", header: "pStatClient.h".} ## \
## Attempts to establish a connection to the indicated PStatServer.  Returns
## true if successful, false on failure.

proc disconnect*(_: typedesc[PStatClient]) {.importcpp: "PStatClient::disconnect()", header: "pStatClient.h".} ## \
## Closes the connection previously established.

proc isConnected*(_: typedesc[PStatClient]): bool {.importcpp: "PStatClient::is_connected()", header: "pStatClient.h".} ## \
## Returns true if the client believes it is connected to a working
## PStatServer, false otherwise.

proc resumeAfterPause*(_: typedesc[PStatClient]) {.importcpp: "PStatClient::resume_after_pause()", header: "pStatClient.h".} ## \
## Resumes the PStatClient after the simulation has been paused for a while.
## This allows the stats to continue exactly where it left off, instead of
## leaving a big gap that would represent a chug.

proc mainTick*(_: typedesc[PStatClient]) {.importcpp: "PStatClient::main_tick()", header: "pStatClient.h".} ## \
## A convenience function to call new_frame() on the global PStatClient's main
## thread, and any other threads with a sync_name of "Main".

proc threadTick*(_: typedesc[PStatClient], sync_name: string) {.importcpp: "#PStatClient::thread_tick(nimStringToStdString(#))", header: "pStatClient.h".} ## \
## A convenience function to call new_frame() on any threads with the
## indicated sync_name

proc clientMainTick*(this: PStatClient) {.importcpp: "#.client_main_tick()".} ## \
## A convenience function to call new_frame() on the given PStatClient's main
## thread, and any other threads with a sync_name of "Main".

proc clientThreadTick*(this: PStatClient, sync_name: string) {.importcpp: "#.client_thread_tick(nimStringToStdString(#))", header: stringConversionCode.} ## \
## A convenience function to call new_frame() on all of the threads with the
## indicated sync name.

proc clientConnect*(this: PStatClient, hostname: string, port: int): bool {.importcpp: "#.client_connect(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## The nonstatic implementation of connect().

proc clientDisconnect*(this: PStatClient) {.importcpp: "#.client_disconnect()".} ## \
## The nonstatic implementation of disconnect().

proc clientIsConnected*(this: PStatClient): bool {.importcpp: "#.client_is_connected()".} ## \
## The nonstatic implementation of is_connected().

proc clientResumeAfterPause*(this: PStatClient) {.importcpp: "#.client_resume_after_pause()".} ## \
## Resumes the PStatClient after the simulation has been paused for a while.
## This allows the stats to continue exactly where it left off, instead of
## leaving a big gap that would represent a chug.

proc getGlobalPstats*(_: typedesc[PStatClient]): PStatClient {.importcpp: "PStatClient::get_global_pstats()", header: "pStatClient.h".} ## \
## Returns a pointer to the global PStatClient object.  It's legal to declare
## your own PStatClient locally, but it's also convenient to have a global one
## that everyone can register with.  This is the global one.

proc newPStatCollectorForward*(col: PStatCollector): PStatCollectorForward {.importcpp: "new PStatCollectorForward(#)".}

proc newCharacterJoint*(character: Character, root: PartBundle, parent: PartGroup, name: string, default_value: LMatrix4): CharacterJoint {.importcpp: "new CharacterJoint(#, #, #, nimStringToStdString(#), #)", header: stringConversionCode.}

proc addNetTransform*(this: CharacterJoint, node: PandaNode): bool {.importcpp: "#->add_net_transform(#)".} ## \
## Adds the indicated node to the list of nodes that will be updated each
## frame with the joint's net transform from the root.  Returns true if the
## node is successfully added, false if it had already been added.
##
## A CharacterJointEffect for this joint's Character will automatically be
## added to the specified node.

proc removeNetTransform*(this: CharacterJoint, node: PandaNode): bool {.importcpp: "#->remove_net_transform(#)".} ## \
## Removes the indicated node from the list of nodes that will be updated each
## frame with the joint's net transform from the root.  Returns true if the
## node is successfully removed, false if it was not on the list.
##
## If the node has a CharacterJointEffect that matches this joint's Character,
## it will be cleared.

proc hasNetTransform*(this: CharacterJoint, node: PandaNode): bool {.importcpp: "#->has_net_transform(#)".} ## \
## Returns true if the node is on the list of nodes that will be updated each
## frame with the joint's net transform from the root, false otherwise.

proc clearNetTransforms*(this: CharacterJoint) {.importcpp: "#->clear_net_transforms()".} ## \
## Removes all nodes from the list of nodes that will be updated each frame
## with the joint's net transform from the root.

proc getNetTransforms*(this: CharacterJoint): NodePathCollection {.importcpp: "#->get_net_transforms()".} ## \
## Returns a list of the net transforms set for this node.  Note that this
## returns a list of NodePaths, even though the net transforms are actually a
## list of PandaNodes.

proc addLocalTransform*(this: CharacterJoint, node: PandaNode): bool {.importcpp: "#->add_local_transform(#)".} ## \
## Adds the indicated node to the list of nodes that will be updated each
## frame with the joint's local transform from its parent.  Returns true if
## the node is successfully added, false if it had already been added.
##
## The Character pointer should be the Character object that owns this joint;
## this will be used to create a CharacterJointEffect for this node.  If it is
## NULL, no such effect will be created.
##
## A CharacterJointEffect for this joint's Character will automatically be
## added to the specified node.

proc removeLocalTransform*(this: CharacterJoint, node: PandaNode): bool {.importcpp: "#->remove_local_transform(#)".} ## \
## Removes the indicated node from the list of nodes that will be updated each
## frame with the joint's local transform from its parent.  Returns true if
## the node is successfully removed, false if it was not on the list.
##
## If the node has a CharacterJointEffect that matches this joint's Character,
## it will be cleared.

proc hasLocalTransform*(this: CharacterJoint, node: PandaNode): bool {.importcpp: "#->has_local_transform(#)".} ## \
## Returns true if the node is on the list of nodes that will be updated each
## frame with the joint's local transform from its parent, false otherwise.

proc clearLocalTransforms*(this: CharacterJoint) {.importcpp: "#->clear_local_transforms()".} ## \
## Removes all nodes from the list of nodes that will be updated each frame
## with the joint's local transform from its parent.

proc getLocalTransforms*(this: CharacterJoint): NodePathCollection {.importcpp: "#->get_local_transforms()".} ## \
## Returns a list of the local transforms set for this node.  Note that this
## returns a list of NodePaths, even though the local transforms are actually
## a list of PandaNodes.

proc getTransform*(this: CharacterJoint): LMatrix4 {.importcpp: "#->get_transform()".} ## \
## Returns the transform matrix of the joint

proc getTransform*(this: CharacterJoint, transform: LMatrix4) {.importcpp: "#->get_transform(#)".} ## \
## Copies the joint's current transform into the indicated matrix.

proc getTransformState*(this: CharacterJoint): TransformState {.importcpp: "deconstify(#->get_transform_state())", header: deconstifyCode.}

proc getNetTransform*(this: CharacterJoint, transform: LMatrix4) {.importcpp: "#->get_net_transform(#)".} ## \
## Copies the joint's current net transform (composed from the root of the
## character joint hierarchy) into the indicated matrix.

proc getCharacter*(this: CharacterJoint): Character {.importcpp: "#->get_character()".} ## \
## Returns the Character that owns this joint.

converter getClassType*(_: typedesc[CharacterJoint]): TypeHandle {.importcpp: "CharacterJoint::get_class_type()", header: "characterJoint.h".}

proc newCharacterSlider*(parent: PartGroup, name: string): CharacterSlider {.importcpp: "new CharacterSlider(#, nimStringToStdString(#))", header: stringConversionCode.}

proc newCharacterSlider*(parent: PartGroup, name: string, default_value: float32): CharacterSlider {.importcpp: "new CharacterSlider(#, nimStringToStdString(#), #)", header: stringConversionCode.}

converter getClassType*(_: typedesc[CharacterSlider]): TypeHandle {.importcpp: "CharacterSlider::get_class_type()", header: "characterSlider.h".}

proc newCharacterVertexSlider*(char_slider: CharacterSlider): CharacterVertexSlider {.importcpp: "new CharacterVertexSlider(#)".} ## \
## Constructs a new object that converts vertices from the indicated joint's
## coordinate space, into the other indicated joint's space.

proc getCharSlider*(this: CharacterVertexSlider): CharacterSlider {.importcpp: "deconstify(#->get_char_slider())", header: deconstifyCode.} ## \
## Returns the CharacterSlider object for which this object returns the slider
## value.

converter getClassType*(_: typedesc[CharacterVertexSlider]): TypeHandle {.importcpp: "CharacterVertexSlider::get_class_type()", header: "characterVertexSlider.h".}

proc newJointVertexTransform*(joint: CharacterJoint): JointVertexTransform {.importcpp: "new JointVertexTransform(#)".} ## \
## Constructs a new object that converts vertices from the indicated joint's
## coordinate space, into the other indicated joint's space.

proc getJoint*(this: JointVertexTransform): CharacterJoint {.importcpp: "deconstify(#->get_joint())", header: deconstifyCode.} ## \
## Returns the joint for which this object returns the transform.

converter getClassType*(_: typedesc[JointVertexTransform]): TypeHandle {.importcpp: "JointVertexTransform::get_class_type()", header: "jointVertexTransform.h".}

proc newCharacter*(param0: Character): Character {.importcpp: "new Character(#)".}

proc newCharacter*(name: string): Character {.importcpp: "new Character(nimStringToStdString(#))", header: stringConversionCode.}

proc getBundle*(this: Character, i: int): CharacterJointBundle {.importcpp: "#->get_bundle(#)".}

proc mergeBundles*(this: Character, old_bundle: PartBundle, other_bundle: PartBundle) {.importcpp: "#->merge_bundles(#, #)".} ## \
## Merges old_bundle with new_bundle.  old_bundle must be one of the
## PartBundles within this node.  At the end of this call, the old_bundle
## pointer within this node will be replaced with the new_bundle pointer, and
## all geometry within this node will be updated to reference new_bundle.
##
## @deprecated Use the newer version of this method, below.

proc mergeBundles*(this: Character, old_bundle_handle: PartBundleHandle, other_bundle_handle: PartBundleHandle) {.importcpp: "#->merge_bundles(#, #)".} ## \
## Merges old_bundle_handle->get_bundle() with new_bundle.  old_bundle_handle
## must be one of the PartBundleHandle within this node.  At the end of this
## call, the bundle pointer within the old_bundle_handle will be replaced with
## that within the new_bundle_handle pointer, and all geometry within this
## node will be updated to reference new_bundle.
##
## Normally, this is called when the two bundles have the same, or nearly the
## same, hierarchies.  In this case, new_bundle will simply be assigned over
## the old_bundle position.  However, if any joints are present in one bundle
## or the other, new_bundle will be modified to contain the union of all
## joints.
##
## The geometry below this node is also updated to reference new_bundle,
## instead of the original old_bundle.
##
## This method is intended to unify two different models that share a common
## skeleton, for instance, different LOD's of the same model.

proc setLodAnimation*(this: Character, center: LPoint3, far_distance: float32, near_distance: float32, delay_factor: float32) {.importcpp: "#->set_lod_animation(#, #, #, #)".} ## \
## Activates a special mode in which the character animates less frequently as
## it gets further from the camera.  This is intended as a simple optimization
## to minimize the effort of computing animation for lots of characters that
## may not necessarily be very important to animate every frame.
##
## If the character is closer to the camera than near_distance, then it is
## animated its normal rate, every frame.  If the character is exactly
## far_distance away, it is animated only every delay_factor seconds (which
## should be a number greater than 0).  If the character is between
## near_distance and far_distance, its animation rate is linearly interpolated
## according to its distance between the two.  The interpolation function
## continues beyond far_distance, so that the character is animated
## increasingly less frequently as it gets farther away.
##
## The distance calculations are made from center, which is a fixed point
## relative to the character node, to the camera's lod center or cull center
## node (or to the camera node itself).
##
## If multiple cameras are viewing the character in any given frame, the
## closest one counts.

proc clearLodAnimation*(this: Character) {.importcpp: "#->clear_lod_animation()".} ## \
## Undoes the effect of a recent call to set_lod_animation().  Henceforth, the
## character will animate every frame, regardless of its distance from the
## camera.

proc findJoint*(this: Character, name: string): CharacterJoint {.importcpp: "#->find_joint(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a pointer to the joint with the given name, if there is such a
## joint, or NULL if there is no such joint.  This will not return a pointer
## to a slider.

proc findSlider*(this: Character, name: string): CharacterSlider {.importcpp: "#->find_slider(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a pointer to the slider with the given name, if there is such a
## slider, or NULL if there is no such slider.  This will not return a pointer
## to a joint.

proc writeParts*(this: Character, `out`: ostream) {.importcpp: "#->write_parts(#)".} ## \
## Writes a list of the Character's joints and sliders, in their hierchical
## structure, to the indicated output stream.

proc writePartValues*(this: Character, `out`: ostream) {.importcpp: "#->write_part_values(#)".} ## \
## Writes a list of the Character's joints and sliders, along with each
## current position, in their hierchical structure, to the indicated output
## stream.

proc updateToNow*(this: Character) {.importcpp: "#->update_to_now()".} ## \
## Advances the character's frame to the current time, and then calls
## update().  This can be used by show code to force an update of the
## character's position to the current frame, regardless of whether the
## character is currently onscreen and animating.
##
## @deprecated Call update() instead.

proc update*(this: Character) {.importcpp: "#->update()".} ## \
## Recalculates the Character's joints and vertices for the current frame.
## Normally this is performed automatically during the render and need not be
## called explicitly.

proc forceUpdate*(this: Character) {.importcpp: "#->force_update()".} ## \
## Recalculates the character even if we think it doesn't need it.

converter getClassType*(_: typedesc[Character]): TypeHandle {.importcpp: "Character::get_class_type()", header: "character.h".}

proc newCharacterJointBundle*(name: string): CharacterJointBundle {.importcpp: "new CharacterJointBundle(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Normally, there is no need to create a CharacterJointBundle directly.  The
## Character node will automatically create one for itself.

proc newCharacterJointBundle*(): CharacterJointBundle {.importcpp: "new CharacterJointBundle()".} ## \
## Normally, there is no need to create a CharacterJointBundle directly.  The
## Character node will automatically create one for itself.

proc getNode*(this: CharacterJointBundle, n: int): Character {.importcpp: "#->get_node(#)".} ## \
## Returns the nth Character associated with this PartBundle.

converter getClassType*(_: typedesc[CharacterJointBundle]): TypeHandle {.importcpp: "CharacterJointBundle::get_class_type()", header: "characterJointBundle.h".}

proc make*(_: typedesc[CharacterJointEffect], character: Character): RenderEffect {.importcpp: "deconstify(#CharacterJointEffect::make(#))", header: "characterJointEffect.h".} ## \
## Constructs a new CharacterJointEffect object that references the indicated
## character.  When a relative get_transform() is called on the node that
## contains the CharacterJointEffect, it will implicitly call
## character->update() first.

proc getCharacter*(this: CharacterJointEffect): Character {.importcpp: "#->get_character()".} ## \
## Returns the Character that will get update() called on it when this node's
## relative transform is queried, or NULL if there is no such character.

converter getClassType*(_: typedesc[CharacterJointEffect]): TypeHandle {.importcpp: "CharacterJointEffect::get_class_type()", header: "characterJointEffect.h".}

proc getCollisionOrigin*(this: CollisionSolid): LPoint3 {.importcpp: "#->get_collision_origin()".}

proc setTangible*(this: CollisionSolid, tangible: bool) {.importcpp: "#->set_tangible(#)".} ## \
## Sets the current state of the 'tangible' flag.  Set this true to make the
## solid tangible, so that a CollisionHandlerPusher will not allow another
## object to intersect it, or false to make it intangible, so that a
## CollisionHandlerPusher will ignore it except to throw an event.

proc isTangible*(this: CollisionSolid): bool {.importcpp: "#->is_tangible()".} ## \
## Returns whether the solid is considered 'tangible' or not.  An intangible
## solid has no effect in a CollisionHandlerPusher (except to throw an event);
## it's useful for defining 'trigger' planes and spheres, that cause an effect
## when passed through.

proc setEffectiveNormal*(this: CollisionSolid, effective_normal: LVector3) {.importcpp: "#->set_effective_normal(#)".} ## \
## Records a false normal for this CollisionSolid that will be reported by the
## collision system with all collisions into it, instead of its actual normal.
## This is useful as a workaround for the problem of an avatar wanting to
## stand on a sloping ground; by storing a false normal, the ground appears to
## be perfectly level, and the avatar does not tend to slide down it.

proc clearEffectiveNormal*(this: CollisionSolid) {.importcpp: "#->clear_effective_normal()".} ## \
## Removes the normal previously set by set_effective_normal().

proc hasEffectiveNormal*(this: CollisionSolid): bool {.importcpp: "#->has_effective_normal()".} ## \
## Returns true if a special normal was set by set_effective_normal(), false
## otherwise.

proc getEffectiveNormal*(this: CollisionSolid): LVector3 {.importcpp: "#->get_effective_normal()".} ## \
## Returns the normal that was set by set_effective_normal().  It is an error
## to call this unless has_effective_normal() returns true.

proc setRespectEffectiveNormal*(this: CollisionSolid, respect_effective_normal: bool) {.importcpp: "#->set_respect_effective_normal(#)".} ## \
## This is only meaningful for CollisionSolids that will be added to a
## traverser as colliders.  It is normally true, but if set false, it means
## that this particular solid does not care about the "effective" normal of
## other solids it meets, but rather always uses the true normal.

proc getRespectEffectiveNormal*(this: CollisionSolid): bool {.importcpp: "#->get_respect_effective_normal()".} ## \
## See set_respect_effective_normal().

proc getBounds*(this: CollisionSolid): BoundingVolume {.importcpp: "deconstify(#->get_bounds())", header: deconstifyCode.} ## \
## Returns the solid's bounding volume.

proc setBounds*(this: CollisionSolid, bounding_volume: BoundingVolume) {.importcpp: "#->set_bounds(#)".} ## \
## Returns the solid's bounding volume.

proc output*(this: CollisionSolid, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: CollisionSolid, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: CollisionSolid, `out`: ostream) {.importcpp: "#->write(#)".}

converter getClassType*(_: typedesc[CollisionSolid]): TypeHandle {.importcpp: "CollisionSolid::get_class_type()", header: "collisionSolid.h".}

proc newCollisionBox*(min: LPoint3, max: LPoint3): CollisionBox {.importcpp: "new CollisionBox(#, #)".} ## \
## Create the Box by Specifying the Diagonal Points

proc newCollisionBox*(center: LPoint3, x: float32, y: float32, z: float32): CollisionBox {.importcpp: "new CollisionBox(#, #, #, #)".} ## \
## Create the Box by giving a Center and distances of each of the sides of
## box from the Center.

proc getNumPoints*(this: CollisionBox): int {.importcpp: "#->get_num_points()".} ## \
## Returns 8: the number of vertices of a rectangular solid.

proc getPointAabb*(this: CollisionBox, n: int): LPoint3 {.importcpp: "#->get_point_aabb(#)".} ## \
## Returns the nth vertex of the Axis Aligned Bounding Box.

proc getPoint*(this: CollisionBox, n: int): LPoint3 {.importcpp: "#->get_point(#)".} ## \
## Returns the nth vertex of the OBB.

proc getNumPlanes*(this: CollisionBox): int {.importcpp: "#->get_num_planes()".} ## \
## Returns 6: the number of faces of a rectangular solid.

proc setPlane*(this: CollisionBox, n: int): LPlane {.importcpp: "#->set_plane(#)".} ## \
## Creates the nth face of the rectangular solid.

proc getPlane*(this: CollisionBox, n: int): LPlane {.importcpp: "#->get_plane(#)".} ## \
## Returns the nth face of the rectangular solid.

proc setCenter*(this: CollisionBox, center: LPoint3) {.importcpp: "#->set_center(#)".}

proc setCenter*(this: CollisionBox, x: float32, y: float32, z: float32) {.importcpp: "#->set_center(#, #, #)".}

proc getCenter*(this: CollisionBox): LPoint3 {.importcpp: "#->get_center()".}

proc getMin*(this: CollisionBox): LPoint3 {.importcpp: "#->get_min()".}

proc getMax*(this: CollisionBox): LPoint3 {.importcpp: "#->get_max()".}

proc getDimensions*(this: CollisionBox): LVector3 {.importcpp: "#->get_dimensions()".}

converter getClassType*(_: typedesc[CollisionBox]): TypeHandle {.importcpp: "CollisionBox::get_class_type()", header: "collisionBox.h".}

proc newCollisionCapsule*(a: LPoint3, db: LPoint3, radius: float32): CollisionCapsule {.importcpp: "new CollisionCapsule(#, #, #)".}

proc newCollisionCapsule*(ax: float32, ay: float32, az: float32, bx: float32, by: float32, bz: float32, radius: float32): CollisionCapsule {.importcpp: "new CollisionCapsule(#, #, #, #, #, #, #)".}

proc setPointA*(this: CollisionCapsule, a: LPoint3) {.importcpp: "#->set_point_a(#)".}

proc setPointA*(this: CollisionCapsule, x: float32, y: float32, z: float32) {.importcpp: "#->set_point_a(#, #, #)".}

proc getPointA*(this: CollisionCapsule): LPoint3 {.importcpp: "#->get_point_a()".}

proc setPointB*(this: CollisionCapsule, b: LPoint3) {.importcpp: "#->set_point_b(#)".}

proc setPointB*(this: CollisionCapsule, x: float32, y: float32, z: float32) {.importcpp: "#->set_point_b(#, #, #)".}

proc getPointB*(this: CollisionCapsule): LPoint3 {.importcpp: "#->get_point_b()".}

proc setRadius*(this: CollisionCapsule, radius: float32) {.importcpp: "#->set_radius(#)".}

proc getRadius*(this: CollisionCapsule): float32 {.importcpp: "#->get_radius()".}

converter getClassType*(_: typedesc[CollisionCapsule]): TypeHandle {.importcpp: "CollisionCapsule::get_class_type()", header: "collisionCapsule.h".}

converter getClassType*(_: typedesc[CollisionHandler]): TypeHandle {.importcpp: "CollisionHandler::get_class_type()", header: "collisionHandler.h".}

proc newCollisionHandler*(param0: CollisionHandler): CollisionHandler {.importcpp: "new CollisionHandler(#)".}

proc newCollisionNode*(name: string): CollisionNode {.importcpp: "new CollisionNode(nimStringToStdString(#))", header: stringConversionCode.}

proc setCollideMask*(this: CollisionNode, mask: CollideMask) {.importcpp: "#->set_collide_mask(#)".} ## \
## Simultaneously sets both the "from" and "into" CollideMask values to the
## same thing.

proc setFromCollideMask*(this: CollisionNode, mask: CollideMask) {.importcpp: "#->set_from_collide_mask(#)".} ## \
## Sets the "from" CollideMask.  In order for a collision to be detected from
## this object into another object, the intersection of this object's "from"
## mask and the other object's "into" mask must be nonzero.

proc setIntoCollideMask*(this: CollisionNode, mask: CollideMask) {.importcpp: "#->set_into_collide_mask(#)".} ## \
## Sets the "into" CollideMask.  In order for a collision to be detected from
## another object into this object, the intersection of the other object's
## "from" mask and this object's "into" mask must be nonzero.

proc getFromCollideMask*(this: CollisionNode): CollideMask {.importcpp: "#->get_from_collide_mask()".} ## \
## Returns the current "from" CollideMask.  In order for a collision to be
## detected from this object into another object, the intersection of this
## object's "from" mask and the other object's "into" mask must be nonzero.

proc getIntoCollideMask*(this: CollisionNode): CollideMask {.importcpp: "#->get_into_collide_mask()".} ## \
## Returns the current "into" CollideMask.  In order for a collision to be
## detected from another object into this object, the intersection of the
## other object's "from" mask and this object's "into" mask must be nonzero.

proc clearSolids*(this: CollisionNode) {.importcpp: "#->clear_solids()".} ## \
## Removes all solids from the node.

proc getNumSolids*(this: CollisionNode): clonglong {.importcpp: "#->get_num_solids()".}

proc getSolid*(this: CollisionNode, n: clonglong): CollisionSolid {.importcpp: "deconstify(#->get_solid(#))", header: deconstifyCode.}

proc modifySolid*(this: CollisionNode, n: clonglong): CollisionSolid {.importcpp: "#->modify_solid(#)".}

proc setSolid*(this: CollisionNode, n: clonglong, solid: CollisionSolid) {.importcpp: "#->set_solid(#, #)".} ## \
## Replaces the solid with the indicated index.

proc insertSolid*(this: CollisionNode, n: clonglong, solid: CollisionSolid) {.importcpp: "#->insert_solid(#, #)".} ## \
## Inserts the indicated solid to the node at the indicated position.

proc removeSolid*(this: CollisionNode, n: clonglong) {.importcpp: "#->remove_solid(#)".} ## \
## Removes the solid with the indicated index.  This will shift all subsequent
## indices down by one.

proc addSolid*(this: CollisionNode, solid: CollisionSolid): clonglong {.importcpp: "#->add_solid(#)".} ## \
## Adds the indicated solid to the node.  Returns the index of the new solid
## within the node's list of solids.

proc getColliderSort*(this: CollisionNode): int {.importcpp: "#->get_collider_sort()".} ## \
## Returns the collider_sort value that has been set for this particular node.
## See set_collider_sort().

proc setColliderSort*(this: CollisionNode, sort: int) {.importcpp: "#->set_collider_sort(#)".} ## \
## Sets a particular collider_sort value on this node.  This controls the
## order in which colliders (that is, "from nodes") are grouped together for
## the collision traversal.
##
## If there are 32 or fewer colliders added to any particular
## CollisionTraverser, then this value has no meaning.  It is only useful if
## there are many colliders, which may force the CollisionTraverser to make
## multiple passes through the data; in that case, it may be a useful
## optimization to group colliders that have similar bounding volumes together
## (by giving them similar sort values).

proc getDefaultCollideMask*(_: typedesc[CollisionNode]): CollideMask {.importcpp: "CollisionNode::get_default_collide_mask()", header: "collisionNode.h".} ## \
## Returns the default into_collide_mask assigned to new CollisionNodes.

converter getClassType*(_: typedesc[CollisionNode]): TypeHandle {.importcpp: "CollisionNode::get_class_type()", header: "collisionNode.h".}

proc initCollisionTraverser*(param0: CollisionTraverser): CollisionTraverser {.importcpp: "CollisionTraverser(#)".}

proc initCollisionTraverser*(name: string): CollisionTraverser {.importcpp: "CollisionTraverser(nimStringToStdString(#))", header: stringConversionCode.}

proc initCollisionTraverser*(): CollisionTraverser {.importcpp: "CollisionTraverser()".}

proc setRespectPrevTransform*(this: CollisionTraverser, flag: bool) {.importcpp: "#.set_respect_prev_transform(#)".} ## \
## Sets the flag that indicates whether the prev_transform stored on a node
## (as updated via set_fluid_pos(), etc.) is respected to calculate
## collisions.  If this is true, certain types of collision tests will be
## enhanced by the information about objects in motion.  If this is false,
## objects are always considered to be static.  The default is false.

proc getRespectPrevTransform*(this: CollisionTraverser): bool {.importcpp: "#.get_respect_prev_transform()".} ## \
## Returns the flag that indicates whether the prev_transform stored on a node
## is respected to calculate collisions.  See set_respect_prev_transform().

proc addCollider*(this: CollisionTraverser, collider: NodePath, handler: CollisionHandler) {.importcpp: "#.add_collider(#, #)".} ## \
## Adds a new CollisionNode, representing an object that will be tested for
## collisions into other objects, along with the handler that will serve each
## detected collision.  Each CollisionNode may be served by only one handler
## at a time, but a given handler may serve many CollisionNodes.
##
## The handler that serves a particular node may be changed from time to time
## by calling add_collider() again on the same node.

proc removeCollider*(this: CollisionTraverser, collider: NodePath): bool {.importcpp: "#.remove_collider(#)".} ## \
## Removes the collider (and its associated handler) from the set of
## CollisionNodes that will be tested each frame for collisions into other
## objects.  Returns true if the definition was found and removed, false if it
## wasn't present to begin with.

proc hasCollider*(this: CollisionTraverser, collider: NodePath): bool {.importcpp: "#.has_collider(#)".} ## \
## Returns true if the indicated node is current in the set of nodes that will
## be tested each frame for collisions into other objects.

proc getNumColliders*(this: CollisionTraverser): int {.importcpp: "#.get_num_colliders()".} ## \
## Returns the number of CollisionNodes that have been added to the traverser
## via add_collider().

proc getCollider*(this: CollisionTraverser, n: int): NodePath {.importcpp: "#.get_collider(#)".} ## \
## Returns the nth CollisionNode that has been added to the traverser via
## add_collider().

proc getHandler*(this: CollisionTraverser, collider: NodePath): CollisionHandler {.importcpp: "#.get_handler(#)".} ## \
## Returns the handler that is currently assigned to serve the indicated
## collision node, or NULL if the node is not on the traverser's set of active
## nodes.

proc clearColliders*(this: CollisionTraverser) {.importcpp: "#.clear_colliders()".} ## \
## Completely empties the set of collision nodes and their associated
## handlers.

proc traverse*(this: CollisionTraverser, root: NodePath) {.importcpp: "#.traverse(#)".} ## \
## Perform the traversal. Begins at the indicated root and detects all
## collisions with any of its collider objects against nodes at or below the
## indicated root, calling the appropriate CollisionHandler for each detected
## collision.

proc setRecorder*(this: CollisionTraverser, recorder: CollisionRecorder) {.importcpp: "#.set_recorder(#)".} ## \
## Uses the indicated CollisionRecorder object to start recording the
## intersection tests made by each subsequent call to traverse() on this
## object.  A particular CollisionRecorder object can only record one
## traverser at a time; if this object has already been assigned to another
## traverser, that assignment is broken.
##
## This is intended to be used in a debugging mode to try to determine what
## work is being performed by the collision traversal.  Usually, attaching a
## recorder will impose significant runtime overhead.
##
## This does not transfer ownership of the CollisionRecorder pointer;
## maintenance of that remains the caller's responsibility.  If the
## CollisionRecorder is destructed, it will cleanly remove itself from the
## traverser.

proc hasRecorder*(this: CollisionTraverser): bool {.importcpp: "#.has_recorder()".} ## \
## Returns true if the CollisionTraverser has a CollisionRecorder object
## currently assigned, false otherwise.

proc getRecorder*(this: CollisionTraverser): CollisionRecorder {.importcpp: "#.get_recorder()".} ## \
## Returns the CollisionRecorder currently assigned, or NULL if no recorder is
## assigned.

proc clearRecorder*(this: CollisionTraverser) {.importcpp: "#.clear_recorder()".} ## \
## Removes the CollisionRecorder from the traverser and restores normal low-
## overhead operation.

proc output*(this: CollisionRecorder, `out`: ostream) {.importcpp: "#.output(#)".}

converter getClassType*(_: typedesc[CollisionRecorder]): TypeHandle {.importcpp: "CollisionRecorder::get_class_type()", header: "collisionRecorder.h".}

proc showCollisions*(this: CollisionTraverser, root: NodePath): CollisionVisualizer {.importcpp: "#.show_collisions(#)".} ## \
## This is a high-level function to create a CollisionVisualizer object to
## render the collision tests performed by this traverser.  The supplied root
## should be any node in the scene graph; typically, the top node (e.g.
## render).  The CollisionVisualizer will be attached to this node.

proc hideCollisions*(this: CollisionTraverser) {.importcpp: "#.hide_collisions()".} ## \
## Undoes the effect of a previous call to show_collisions().

proc output*(this: CollisionTraverser, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: CollisionTraverser, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

converter getClassType*(_: typedesc[CollisionTraverser]): TypeHandle {.importcpp: "CollisionTraverser::get_class_type()", header: "collisionTraverser.h".}

proc getFrom*(this: CollisionEntry): CollisionSolid {.importcpp: "deconstify(#->get_from())", header: deconstifyCode.} ## \
## Returns the CollisionSolid pointer for the particular solid that triggered
## this collision.

proc hasInto*(this: CollisionEntry): bool {.importcpp: "#->has_into()".} ## \
## Returns true if the "into" solid is, in fact, a CollisionSolid, and its
## pointer is known (in which case get_into() may be called to retrieve it).
## If this returns false, the collision was detected into a GeomNode, and
## there is no CollisionSolid pointer to be retrieved.

proc getInto*(this: CollisionEntry): CollisionSolid {.importcpp: "deconstify(#->get_into())", header: deconstifyCode.} ## \
## Returns the CollisionSolid pointer for the particular solid was collided
## into.  This pointer might be NULL if the collision was into a piece of
## visible geometry, instead of a normal CollisionSolid collision; see
## has_into().

proc getFromNode*(this: CollisionEntry): CollisionNode {.importcpp: "#->get_from_node()".} ## \
## Returns the node that contains the CollisionSolid that triggered this
## collision.  This will be a node that has been added to a CollisionTraverser
## via add_collider().

proc getIntoNode*(this: CollisionEntry): PandaNode {.importcpp: "#->get_into_node()".} ## \
## Returns the node that contains the CollisionSolid that was collided into.
## This returns a PandaNode pointer instead of something more specific,
## because it might be either a CollisionNode or a GeomNode.
##
## Also see get_into_node_path().

proc getFromNodePath*(this: CollisionEntry): NodePath {.importcpp: "#->get_from_node_path()".} ## \
## Returns the NodePath that represents the CollisionNode that contains the
## CollisionSolid that triggered this collision.  This will be a NodePath that
## has been added to a CollisionTraverser via add_collider().

proc getIntoNodePath*(this: CollisionEntry): NodePath {.importcpp: "#->get_into_node_path()".} ## \
## Returns the NodePath that represents the specific CollisionNode or GeomNode
## instance that was collided into.  This is the same node returned by
## get_into_node(), represented as a NodePath; however, it may be more useful
## because the NodePath can resolve the particular instance of the node, if
## there is more than one.

proc setT*(this: CollisionEntry, t: float32) {.importcpp: "#->set_t(#)".} ## \
## Sets a time value for this collision relative to other CollisionEntries

proc getT*(this: CollisionEntry): float32 {.importcpp: "#->get_t()".} ## \
## returns time value for this collision relative to other CollisionEntries

proc collided*(this: CollisionEntry): bool {.importcpp: "#->collided()".} ## \
## returns true if this represents an actual collision as opposed to a
## potential collision, needed for iterative collision resolution where path
## of collider changes mid-frame

proc resetCollided*(this: CollisionEntry) {.importcpp: "#->reset_collided()".} ## \
## prepare for another collision test

proc getRespectPrevTransform*(this: CollisionEntry): bool {.importcpp: "#->get_respect_prev_transform()".} ## \
## Returns true if the collision was detected by a CollisionTraverser whose
## respect_prev_transform flag was set true, meaning we should consider motion
## significant in evaluating collisions.

proc setSurfacePoint*(this: CollisionEntry, point: LPoint3) {.importcpp: "#->set_surface_point(#)".} ## \
## Stores the point, on the surface of the "into" object, at which a collision
## is detected.
##
## This point is specified in the coordinate space of the "into" object.

proc setSurfaceNormal*(this: CollisionEntry, normal: LVector3) {.importcpp: "#->set_surface_normal(#)".} ## \
## Stores the surface normal of the "into" object at the point of the
## intersection.
##
## This normal is specified in the coordinate space of the "into" object.

proc setInteriorPoint*(this: CollisionEntry, point: LPoint3) {.importcpp: "#->set_interior_point(#)".} ## \
## Stores the point, within the interior of the "into" object, which
## represents the depth to which the "from" object has penetrated.  This can
## also be described as the intersection point on the surface of the "from"
## object (which is inside the "into" object).
##
## This point is specified in the coordinate space of the "into" object.

proc hasSurfacePoint*(this: CollisionEntry): bool {.importcpp: "#->has_surface_point()".} ## \
## Returns true if the surface point has been specified, false otherwise.  See
## get_surface_point().  Some types of collisions may not compute the surface
## point.

proc hasSurfaceNormal*(this: CollisionEntry): bool {.importcpp: "#->has_surface_normal()".} ## \
## Returns true if the surface normal has been specified, false otherwise.
## See get_surface_normal().  Some types of collisions may not compute the
## surface normal.

proc hasInteriorPoint*(this: CollisionEntry): bool {.importcpp: "#->has_interior_point()".} ## \
## Returns true if the interior point has been specified, false otherwise.
## See get_interior_point().  Some types of collisions may not compute the
## interior point.

proc setContactPos*(this: CollisionEntry, pos: LPoint3) {.importcpp: "#->set_contact_pos(#)".} ## \
## Stores the position of the "from" object at the instant at which the
## collision is first detected.
##
## This position is specified in the coordinate space of the "into" object.

proc setContactNormal*(this: CollisionEntry, normal: LVector3) {.importcpp: "#->set_contact_normal(#)".} ## \
## Stores the surface normal of the "into" object at the contact pos.
##
## This normal is specified in the coordinate space of the "into" object.

proc hasContactPos*(this: CollisionEntry): bool {.importcpp: "#->has_contact_pos()".} ## \
## Returns true if the contact position has been specified, false otherwise.
## See get_contact_pos().  Some types of collisions may not compute the
## contact pos.

proc hasContactNormal*(this: CollisionEntry): bool {.importcpp: "#->has_contact_normal()".} ## \
## Returns true if the contact normal has been specified, false otherwise.
## See get_contact_normal().  Some types of collisions may not compute the
## contact normal.

proc getSurfacePoint*(this: CollisionEntry, space: NodePath): LPoint3 {.importcpp: "#->get_surface_point(#)".} ## \
## Returns the point, on the surface of the "into" object, at which a
## collision is detected.  This can be thought of as the first point of
## intersection.  However the contact point is the actual first point of
## intersection.
##
## The point will be converted into whichever coordinate space the caller
## specifies.

proc getSurfaceNormal*(this: CollisionEntry, space: NodePath): LVector3 {.importcpp: "#->get_surface_normal(#)".} ## \
## Returns the surface normal of the "into" object at the point at which a
## collision is detected.
##
## The normal will be converted into whichever coordinate space the caller
## specifies.

proc getInteriorPoint*(this: CollisionEntry, space: NodePath): LPoint3 {.importcpp: "#->get_interior_point(#)".} ## \
## Returns the point, within the interior of the "into" object, which
## represents the depth to which the "from" object has penetrated.  This can
## also be described as the intersection point on the surface of the "from"
## object (which is inside the "into" object).  It can be thought of as the
## deepest point of intersection.
##
## The point will be converted into whichever coordinate space the caller
## specifies.

proc getAll*(this: CollisionEntry, space: NodePath, surface_point: LPoint3, surface_normal: LVector3, interior_point: LPoint3): bool {.importcpp: "#->get_all(#, #, #, #)".} ## \
## Simultaneously transforms the surface point, surface normal, and interior
## point of the collision into the indicated coordinate space.
##
## Returns true if all three properties are available, or false if any one of
## them is not.

proc getContactPos*(this: CollisionEntry, space: NodePath): LPoint3 {.importcpp: "#->get_contact_pos(#)".} ## \
## Returns the position of the "from" object at the instant that a collision
## is first detected.
##
## The position will be converted into whichever coordinate space the caller
## specifies.

proc getContactNormal*(this: CollisionEntry, space: NodePath): LVector3 {.importcpp: "#->get_contact_normal(#)".} ## \
## Returns the surface normal of the "into" object at the contact position.
##
## The normal will be converted into whichever coordinate space the caller
## specifies.

proc getAllContactInfo*(this: CollisionEntry, space: NodePath, contact_pos: LPoint3, contact_normal: LVector3): bool {.importcpp: "#->get_all_contact_info(#, #, #)".} ## \
## Simultaneously transforms the contact position and contact normal of the
## collision into the indicated coordinate space.
##
## Returns true if all three properties are available, or false if any one of
## them is not.

proc output*(this: CollisionEntry, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: CollisionEntry, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: CollisionEntry, `out`: ostream) {.importcpp: "#->write(#)".}

converter getClassType*(_: typedesc[CollisionEntry]): TypeHandle {.importcpp: "CollisionEntry::get_class_type()", header: "collisionEntry.h".}

proc newCollisionPlane*(copy: CollisionPlane): CollisionPlane {.importcpp: "new CollisionPlane(#)".}

proc newCollisionPlane*(plane: LPlane): CollisionPlane {.importcpp: "new CollisionPlane(#)".}

proc getNormal*(this: CollisionPlane): LVector3 {.importcpp: "#->get_normal()".}

proc distToPlane*(this: CollisionPlane, point: LPoint3): float32 {.importcpp: "#->dist_to_plane(#)".}

proc setPlane*(this: CollisionPlane, plane: LPlane) {.importcpp: "#->set_plane(#)".}

proc getPlane*(this: CollisionPlane): LPlane {.importcpp: "#->get_plane()".}

proc flip*(this: CollisionPlane) {.importcpp: "#->flip()".} ## \
## Convenience method to flip the plane in-place.

converter getClassType*(_: typedesc[CollisionPlane]): TypeHandle {.importcpp: "CollisionPlane::get_class_type()", header: "collisionPlane.h".}

proc newCollisionFloorMesh*(): CollisionFloorMesh {.importcpp: "new CollisionFloorMesh()".} ## \
## This is only for the convenience of CollisionPolygon.  Normally, you should
## not attempt to create an uninitialized CollisionPlane.

proc addVertex*(this: CollisionFloorMesh, vert: LPoint3) {.importcpp: "#->add_vertex(#)".} ## \
## store away a vertex to index against

proc addTriangle*(this: CollisionFloorMesh, pointA: int, pointB: int, pointC: int) {.importcpp: "#->add_triangle(#, #, #)".} ## \
## store a triangle for processing

proc getNumVertices*(this: CollisionFloorMesh): int {.importcpp: "#->get_num_vertices()".}

proc getVertex*(this: CollisionFloorMesh, index: int): LPoint3 {.importcpp: "#->get_vertex(#)".}

proc getNumTriangles*(this: CollisionFloorMesh): int {.importcpp: "#->get_num_triangles()".}

proc getTriangle*(this: CollisionFloorMesh, index: int): LPoint3i {.importcpp: "#->get_triangle(#)".}

converter getClassType*(_: typedesc[CollisionFloorMesh]): TypeHandle {.importcpp: "CollisionFloorMesh::get_class_type()", header: "collisionFloorMesh.h".}

proc newCollisionPolygon*(a: LVecBase3, b: LVecBase3, c: LVecBase3): CollisionPolygon {.importcpp: "new CollisionPolygon(#, #, #)".}

proc newCollisionPolygon*(a: LVecBase3, b: LVecBase3, c: LVecBase3, d: LVecBase3): CollisionPolygon {.importcpp: "new CollisionPolygon(#, #, #, #)".}

proc getNumPoints*(this: CollisionPolygon): clonglong {.importcpp: "#->get_num_points()".} ## \
## Returns the number of vertices of the CollisionPolygon.

proc getPoint*(this: CollisionPolygon, n: clonglong): LPoint3 {.importcpp: "#->get_point(#)".} ## \
## Returns the nth vertex of the CollisionPolygon, expressed in 3-D space.

proc verifyPoints*(_: typedesc[CollisionPolygon], a: LPoint3, b: LPoint3, c: LPoint3): bool {.importcpp: "#CollisionPolygon::verify_points(#, #, #)", header: "collisionPolygon.h".} ## \
## Verifies that the indicated set of points will define a valid
## CollisionPolygon: that is, at least three non-collinear points, with no
## points repeated.

proc verifyPoints*(_: typedesc[CollisionPolygon], a: LPoint3, b: LPoint3, c: LPoint3, d: LPoint3): bool {.importcpp: "#CollisionPolygon::verify_points(#, #, #, #)", header: "collisionPolygon.h".} ## \
## Verifies that the indicated set of points will define a valid
## CollisionPolygon: that is, at least three non-collinear points, with no
## points repeated.

proc isValid*(this: CollisionPolygon): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the CollisionPolygon is valid (that is, it has at least
## three vertices), or false otherwise.

proc isConcave*(this: CollisionPolygon): bool {.importcpp: "#->is_concave()".} ## \
## Returns true if the CollisionPolygon appears to be concave, or false if it
## is safely convex.

converter getClassType*(_: typedesc[CollisionPolygon]): TypeHandle {.importcpp: "CollisionPolygon::get_class_type()", header: "collisionPolygon.h".}

proc newCollisionHandlerEvent*(): CollisionHandlerEvent {.importcpp: "new CollisionHandlerEvent()".} ## \
## The default CollisionHandlerEvent will throw no events.  Its pattern
## strings must first be set via a call to add_in_pattern() and/or
## add_out_pattern().

proc newCollisionHandlerEvent*(param0: CollisionHandlerEvent): CollisionHandlerEvent {.importcpp: "new CollisionHandlerEvent(#)".}

proc clearInPatterns*(this: CollisionHandlerEvent) {.importcpp: "#->clear_in_patterns()".} ## \
## Removes all of the previously-added in patterns.  See add_in_pattern.

proc addInPattern*(this: CollisionHandlerEvent, in_pattern: string) {.importcpp: "#->add_in_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a pattern string to the list of events that will be generated in
## response to a collision.  The pattern string describes how the event name
## will be composed.  It is a string that may contain any of the following:
##
## %fn  - the name of the "from" object's node %in  - the name of the "into"
## object's node %fs  - 't' if "from" is tangible, 'i' if intangible %is  -
## 't' if "into" is tangible, 'i' if intangible %ig  - 'c' if the collision is
## into a CollisionNode, 'g' if it is a geom.
##
## %(tag)fh - generate event only if "from" node has the indicated net tag.
## %(tag)fx - generate event only if "from" node does not have the indicated
## net tag.  %(tag)ih - generate event only if "into" node has the indicated
## net tag.  %(tag)ix - generate event only if "into" node does not have the
## indicated net tag.  %(tag)ft - the indicated net tag value of the "from"
## node.  %(tag)it - the indicated net tag value of the "into" node.
##
## Parentheses in the above are literal and should be included in the actual
## pattern.
##
## The event name will be based on the in_pattern string specified here, with
## all occurrences of the above strings replaced with the corresponding
## values.
##
## In general, the in_pattern event is thrown on the first detection of a
## collision between two particular nodes.  In subsequent passes, as long as a
## collision between those two nodes continues to be detected each frame, the
## again_pattern is thrown.  The first frame in which the collision is no
## longer detected, the out_pattern event is thrown.

proc setInPattern*(this: CollisionHandlerEvent, in_pattern: string) {.importcpp: "#->set_in_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## This method is deprecated; it completely replaces all the in patterns that
## have previously been set with the indicated pattern.
##
## @deprecated Use add_in_pattern() instead.

proc getNumInPatterns*(this: CollisionHandlerEvent): int {.importcpp: "#->get_num_in_patterns()".} ## \
## Returns the number of in pattern strings that have been added.

proc getInPattern*(this: CollisionHandlerEvent, n: int): string {.importcpp: "nimStringFromStdString(#->get_in_pattern(#))", header: stringConversionCode.} ## \
## Returns the nth pattern string that indicates how the event names are
## generated for each collision detected.  See add_in_pattern().

proc clearAgainPatterns*(this: CollisionHandlerEvent) {.importcpp: "#->clear_again_patterns()".} ## \
## Removes all of the previously-added in patterns.  See add_again_pattern.

proc addAgainPattern*(this: CollisionHandlerEvent, again_pattern: string) {.importcpp: "#->add_again_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds the pattern string that indicates how the event names are generated
## when a collision between two particular nodes is \*still\* detected.  This
## event is thrown each consecutive time a collision between two particular
## nodes is detected, starting with the second time.
##
## In general, the in_pattern event is thrown on the first detection of a
## collision between two particular nodes.  In subsequent passes, as long as a
## collision between those two nodes continues to be detected each frame, the
## again_pattern is thrown.  The first frame in which the collision is no
## longer detected, the out_pattern event is thrown.

proc setAgainPattern*(this: CollisionHandlerEvent, again_pattern: string) {.importcpp: "#->set_again_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## This method is deprecated; it completely replaces all the in patterns that
## have previously been set with the indicated pattern.
##
## @deprecated Use add_again_pattern() instead.

proc getNumAgainPatterns*(this: CollisionHandlerEvent): int {.importcpp: "#->get_num_again_patterns()".} ## \
## Returns the number of in pattern strings that have been added.

proc getAgainPattern*(this: CollisionHandlerEvent, n: int): string {.importcpp: "nimStringFromStdString(#->get_again_pattern(#))", header: stringConversionCode.} ## \
## Returns the nth pattern string that indicates how the event names are
## generated for each collision detected.  See add_again_pattern().

proc clearOutPatterns*(this: CollisionHandlerEvent) {.importcpp: "#->clear_out_patterns()".} ## \
## Removes all of the previously-added in patterns.  See add_out_pattern.

proc addOutPattern*(this: CollisionHandlerEvent, out_pattern: string) {.importcpp: "#->add_out_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds the pattern string that indicates how the event names are generated
## when a collision between two particular nodes is \*no longer\* detected.
##
## In general, the in_pattern event is thrown on the first detection of a
## collision between two particular nodes.  In subsequent passes, as long as a
## collision between those two nodes continues to be detected each frame, the
## again_pattern is thrown.  The first frame in which the collision is no
## longer detected, the out_pattern event is thrown.

proc setOutPattern*(this: CollisionHandlerEvent, out_pattern: string) {.importcpp: "#->set_out_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## This method is deprecated; it completely replaces all the in patterns that
## have previously been set with the indicated pattern.
##
## @deprecated Use add_out_pattern() instead.

proc getNumOutPatterns*(this: CollisionHandlerEvent): int {.importcpp: "#->get_num_out_patterns()".} ## \
## Returns the number of in pattern strings that have been added.

proc getOutPattern*(this: CollisionHandlerEvent, n: int): string {.importcpp: "nimStringFromStdString(#->get_out_pattern(#))", header: stringConversionCode.} ## \
## Returns the nth pattern string that indicates how the event names are
## generated for each collision detected.  See add_out_pattern().

proc clear*(this: CollisionHandlerEvent) {.importcpp: "#->clear()".} ## \
## Empties the list of elements that all colliders are known to be colliding
## with.  No "out" events will be thrown; if the same collision is detected
## next frame, a new "in" event will be thrown for each collision.
##
## This can be called each frame to defeat the persistent "in" event
## mechanism, which prevents the same "in" event from being thrown repeatedly.
## However, also see add_again_pattern(), which can be used to set the event
## that is thrown when a collision is detected for two or more consecutive
## frames.

proc flush*(this: CollisionHandlerEvent) {.importcpp: "#->flush()".} ## \
## Same as clear() except "out" events are thrown.

proc writeDatagram*(this: CollisionHandlerEvent, destination: Datagram) {.importcpp: "#->write_datagram(#)".} ## \
## Serializes this object, to implement pickle support.

proc readDatagram*(this: CollisionHandlerEvent, source: DatagramIterator) {.importcpp: "#->read_datagram(#)".} ## \
## Restores the object state from the given datagram, previously obtained using
## __getstate__.

converter getClassType*(_: typedesc[CollisionHandlerEvent]): TypeHandle {.importcpp: "CollisionHandlerEvent::get_class_type()", header: "collisionHandlerEvent.h".}

proc addCollider*(this: CollisionHandlerPhysical, collider: NodePath, target: NodePath) {.importcpp: "#->add_collider(#, #)".} ## \
## Adds a new collider to the list with a NodePath that will be updated with
## the collider's new position, or updates the existing collider with a new
## NodePath object.

proc addCollider*(this: CollisionHandlerPhysical, collider: NodePath, target: NodePath, drive_interface: DriveInterface) {.importcpp: "#->add_collider(#, #, #)".} ## \
## Adds a new collider to the list with a NodePath that will be updated with
## the collider's new position, or updates the existing collider with a new
## NodePath object.
##
## The indicated DriveInterface will also be updated with the target's new
## transform each frame.  This method should be used when the target is
## directly controlled by a DriveInterface.

proc removeCollider*(this: CollisionHandlerPhysical, collider: NodePath): bool {.importcpp: "#->remove_collider(#)".} ## \
## Removes the collider from the list of colliders that this handler knows
## about.

proc hasCollider*(this: CollisionHandlerPhysical, collider: NodePath): bool {.importcpp: "#->has_collider(#)".} ## \
## Returns true if the handler knows about the indicated collider, false
## otherwise.

proc clearColliders*(this: CollisionHandlerPhysical) {.importcpp: "#->clear_colliders()".} ## \
## Completely empties the list of colliders this handler knows about.

proc setCenter*(this: CollisionHandlerPhysical, center: NodePath) {.importcpp: "#->set_center(#)".} ## \
## Specifies an arbitrary NodePath that the handler is always considered to be
## facing.  It does not detect collisions with surfaces that appear to be
## facing away from this NodePath.  This works best when the collision
## surfaces in question are polygons.

proc clearCenter*(this: CollisionHandlerPhysical) {.importcpp: "#->clear_center()".} ## \
## Clears the center NodePath specified with set_center.

proc getCenter*(this: CollisionHandlerPhysical): NodePath {.importcpp: "#->get_center()".} ## \
## Returns the NodePath specified with set_center, or the empty NodePath if
## nothing has been specified.

proc hasCenter*(this: CollisionHandlerPhysical): bool {.importcpp: "#->has_center()".} ## \
## Returns true if a NodePath has been specified with set_center(), false
## otherwise.

proc hasContact*(this: CollisionHandlerPhysical): bool {.importcpp: "#->has_contact()".} ## \
## Did the handler make any contacts with anything on the last collision pass?
## Depending on how your world is setup, this can be used to tell if the
## handler is out of the world (i.e.  out of bounds). That is the original use
## of this call.

converter getClassType*(_: typedesc[CollisionHandlerPhysical]): TypeHandle {.importcpp: "CollisionHandlerPhysical::get_class_type()", header: "collisionHandlerPhysical.h".}

proc newCollisionHandlerFloor*(): CollisionHandlerFloor {.importcpp: "new CollisionHandlerFloor()".}

proc setOffset*(this: CollisionHandlerFloor, offset: float32) {.importcpp: "#->set_offset(#)".} ## \
## Sets the linear offset to add to (or subtract from) the highest detected
## collision point to determine the actual height at which to set the
## collider.

proc getOffset*(this: CollisionHandlerFloor): float32 {.importcpp: "#->get_offset()".} ## \
## Returns the linear offset to add to (or subtract from) the highest detected
## collision point to determine the actual height at which to set the
## collider.

proc setReach*(this: CollisionHandlerFloor, reach: float32) {.importcpp: "#->set_reach(#)".} ## \
## Sets the reach to add to (or subtract from) the highest collision point

proc getReach*(this: CollisionHandlerFloor): float32 {.importcpp: "#->get_reach()".} ## \
## Returns the reach to add to (or subtract from) the highest collision point

proc setMaxVelocity*(this: CollisionHandlerFloor, max_vel: float32) {.importcpp: "#->set_max_velocity(#)".} ## \
## Sets the maximum speed at which the object will be allowed to descend
## towards a floor below it, in units per second.  Set this to zero to allow
## it to instantly teleport any distance.

proc getMaxVelocity*(this: CollisionHandlerFloor): float32 {.importcpp: "#->get_max_velocity()".} ## \
## Retrieves the maximum speed at which the object will be allowed to descend
## towards a floor below it, in units per second.  See set_max_velocity().

proc writeDatagram*(this: CollisionHandlerFloor, destination: Datagram) {.importcpp: "#->write_datagram(#)".} ## \
## Serializes this object, to implement pickle support.

proc readDatagram*(this: CollisionHandlerFloor, source: DatagramIterator) {.importcpp: "#->read_datagram(#)".} ## \
## Restores the object state from the given datagram, previously obtained using
## __getstate__.

converter getClassType*(_: typedesc[CollisionHandlerFloor]): TypeHandle {.importcpp: "CollisionHandlerFloor::get_class_type()", header: "collisionHandlerFloor.h".}

proc newCollisionHandlerPusher*(): CollisionHandlerPusher {.importcpp: "new CollisionHandlerPusher()".}

proc setHorizontal*(this: CollisionHandlerPusher, flag: bool) {.importcpp: "#->set_horizontal(#)".}

proc getHorizontal*(this: CollisionHandlerPusher): bool {.importcpp: "#->get_horizontal()".}

proc writeDatagram*(this: CollisionHandlerPusher, destination: Datagram) {.importcpp: "#->write_datagram(#)".} ## \
## Serializes this object, to implement pickle support.

proc readDatagram*(this: CollisionHandlerPusher, source: DatagramIterator) {.importcpp: "#->read_datagram(#)".} ## \
## Restores the object state from the given datagram, previously obtained using
## __getstate__.

converter getClassType*(_: typedesc[CollisionHandlerPusher]): TypeHandle {.importcpp: "CollisionHandlerPusher::get_class_type()", header: "collisionHandlerPusher.h".}

proc newCollisionHandlerFluidPusher*(): CollisionHandlerFluidPusher {.importcpp: "new CollisionHandlerFluidPusher()".}

converter getClassType*(_: typedesc[CollisionHandlerFluidPusher]): TypeHandle {.importcpp: "CollisionHandlerFluidPusher::get_class_type()", header: "collisionHandlerFluidPusher.h".}

proc newCollisionHandlerGravity*(): CollisionHandlerGravity {.importcpp: "new CollisionHandlerGravity()".}

proc setOffset*(this: CollisionHandlerGravity, offset: float32) {.importcpp: "#->set_offset(#)".} ## \
## Sets the linear offset to add to (or subtract from) the highest detected
## collision point to determine the actual height at which to set the
## collider.

proc getOffset*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_offset()".} ## \
## Returns the linear offset to add to (or subtract from) the highest detected
## collision point to determine the actual height at which to set the
## collider.

proc setReach*(this: CollisionHandlerGravity, reach: float32) {.importcpp: "#->set_reach(#)".} ## \
## Sets the reach to add to (or subtract from) the highest collision point

proc getReach*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_reach()".} ## \
## Returns the reach to add to (or subtract from) the highest collision point

proc getAirborneHeight*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_airborne_height()".} ## \
## Return the height of the object from the ground.
##
## The object might not necessarily be at rest.  Use is_on_ground() if you
## want to know whether the object is on the ground and at rest.

proc isOnGround*(this: CollisionHandlerGravity): bool {.importcpp: "#->is_on_ground()".} ## \
## Is the object at rest?

proc getImpactVelocity*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_impact_velocity()".} ## \
## How hard did the object hit the ground.  This value is set on impact with
## the ground.  You may want to watch (poll) on is_on_ground() and when that is
## true, call get_impact_velocity(). Normally I avoid polling, but we are
## calling is_on_ground() frequently anyway.

proc getContactNormal*(this: CollisionHandlerGravity): LVector3 {.importcpp: "#->get_contact_normal()".}

proc addVelocity*(this: CollisionHandlerGravity, velocity: float32) {.importcpp: "#->add_velocity(#)".} ## \
## Adds the sepcified amount to the current velocity.  This is mostly here
## allow this common operation to be faster for scripting, but it's also more
## concise even in cpp.

proc setVelocity*(this: CollisionHandlerGravity, velocity: float32) {.importcpp: "#->set_velocity(#)".} ## \
## Sets the current vertical velocity.

proc getVelocity*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_velocity()".} ## \
## Gets the current vertical velocity.
##
## Generally, negative values mean the object is in free fall; while postive
## values mean the object has vertical thrust.
##
## A zero value does not necessarily mean the object on the ground, it may
## also be weightless and/or at the apex of its jump.
##
## See Also: is_on_ground() and get_gravity()

proc setGravity*(this: CollisionHandlerGravity, gravity: float32) {.importcpp: "#->set_gravity(#)".} ## \
## Sets the linear gravity force (always plumb).

proc getGravity*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_gravity()".} ## \
## Gets the linear gravity force (always plumb).

proc setMaxVelocity*(this: CollisionHandlerGravity, max_vel: float32) {.importcpp: "#->set_max_velocity(#)".} ## \
## Sets the maximum speed at which the object will be allowed to descend
## towards a floor below it, in units per second.  Set this to zero to allow
## it to instantly teleport any distance.

proc getMaxVelocity*(this: CollisionHandlerGravity): float32 {.importcpp: "#->get_max_velocity()".} ## \
## Retrieves the maximum speed at which the object will be allowed to descend
## towards a floor below it, in units per second.  See set_max_velocity().

proc setLegacyMode*(this: CollisionHandlerGravity, legacy_mode: bool) {.importcpp: "#->set_legacy_mode(#)".} ## \
## Enables old behavior required by Toontown (Sellbot Factory lava room is
## good test case, lava and conveyor belt specifically). Behavior is to throw
## enter/exit events only for floor that the toon is in contact with

proc getLegacyMode*(this: CollisionHandlerGravity): bool {.importcpp: "#->get_legacy_mode()".} ## \
## returns true if legacy mode is enabled

proc writeDatagram*(this: CollisionHandlerGravity, destination: Datagram) {.importcpp: "#->write_datagram(#)".} ## \
## Serializes this object, to implement pickle support.

proc readDatagram*(this: CollisionHandlerGravity, source: DatagramIterator) {.importcpp: "#->read_datagram(#)".} ## \
## Restores the object state from the given datagram, previously obtained using
## __getstate__.

converter getClassType*(_: typedesc[CollisionHandlerGravity]): TypeHandle {.importcpp: "CollisionHandlerGravity::get_class_type()", header: "collisionHandlerGravity.h".}

proc newCollisionHandlerHighestEvent*(): CollisionHandlerHighestEvent {.importcpp: "new CollisionHandlerHighestEvent()".} ## \
## The default CollisionHandlerEvent will throw no events.  Its pattern
## strings must first be set via a call to add_in_pattern() and/or
## add_out_pattern().

proc newCollisionHandlerHighestEvent*(param0: CollisionHandlerHighestEvent): CollisionHandlerHighestEvent {.importcpp: "new CollisionHandlerHighestEvent(#)".}

converter getClassType*(_: typedesc[CollisionHandlerHighestEvent]): TypeHandle {.importcpp: "CollisionHandlerHighestEvent::get_class_type()", header: "collisionHandlerHighestEvent.h".}

proc newCollisionHandlerQueue*(): CollisionHandlerQueue {.importcpp: "new CollisionHandlerQueue()".}

proc newCollisionHandlerQueue*(param0: CollisionHandlerQueue): CollisionHandlerQueue {.importcpp: "new CollisionHandlerQueue(#)".}

proc sortEntries*(this: CollisionHandlerQueue) {.importcpp: "#->sort_entries()".} ## \
## Sorts all the detected collisions front-to-back by
## from_intersection_point() so that those intersection points closest to the
## collider's origin (e.g., the center of the CollisionSphere, or the point_a
## of a CollisionSegment) appear first.

proc clearEntries*(this: CollisionHandlerQueue) {.importcpp: "#->clear_entries()".} ## \
## Removes all the entries from the queue.

proc getNumEntries*(this: CollisionHandlerQueue): int {.importcpp: "#->get_num_entries()".} ## \
## Returns the number of CollisionEntries detected last pass.

proc getEntry*(this: CollisionHandlerQueue, n: int): CollisionEntry {.importcpp: "#->get_entry(#)".} ## \
## Returns the nth CollisionEntry detected last pass.

proc output*(this: CollisionHandlerQueue, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: CollisionHandlerQueue, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: CollisionHandlerQueue, `out`: ostream) {.importcpp: "#->write(#)".}

converter getClassType*(_: typedesc[CollisionHandlerQueue]): TypeHandle {.importcpp: "CollisionHandlerQueue::get_class_type()", header: "collisionHandlerQueue.h".}

proc newCollisionSphere*(center: LPoint3, radius: float32): CollisionSphere {.importcpp: "new CollisionSphere(#, #)".}

proc newCollisionSphere*(cx: float32, cy: float32, cz: float32, radius: float32): CollisionSphere {.importcpp: "new CollisionSphere(#, #, #, #)".}

proc setCenter*(this: CollisionSphere, center: LPoint3) {.importcpp: "#->set_center(#)".}

proc setCenter*(this: CollisionSphere, x: float32, y: float32, z: float32) {.importcpp: "#->set_center(#, #, #)".}

proc getCenter*(this: CollisionSphere): LPoint3 {.importcpp: "#->get_center()".}

proc setRadius*(this: CollisionSphere, radius: float32) {.importcpp: "#->set_radius(#)".}

proc getRadius*(this: CollisionSphere): float32 {.importcpp: "#->get_radius()".}

converter getClassType*(_: typedesc[CollisionSphere]): TypeHandle {.importcpp: "CollisionSphere::get_class_type()", header: "collisionSphere.h".}

proc newCollisionInvSphere*(center: LPoint3, radius: float32): CollisionInvSphere {.importcpp: "new CollisionInvSphere(#, #)".}

proc newCollisionInvSphere*(cx: float32, cy: float32, cz: float32, radius: float32): CollisionInvSphere {.importcpp: "new CollisionInvSphere(#, #, #, #)".}

converter getClassType*(_: typedesc[CollisionInvSphere]): TypeHandle {.importcpp: "CollisionInvSphere::get_class_type()", header: "collisionInvSphere.h".}

proc newCollisionRay*(): CollisionRay {.importcpp: "new CollisionRay()".} ## \
## Creates an invalid ray.  This isn't terribly useful; it's expected that the
## user will subsequently adjust the ray via set_origin()/set_direction() or
## set_from_lens().

proc newCollisionRay*(origin: LPoint3, direction: LVector3): CollisionRay {.importcpp: "new CollisionRay(#, #)".}

proc newCollisionRay*(ox: float32, oy: float32, oz: float32, dx: float32, dy: float32, dz: float32): CollisionRay {.importcpp: "new CollisionRay(#, #, #, #, #, #)".}

proc setOrigin*(this: CollisionRay, origin: LPoint3) {.importcpp: "#->set_origin(#)".}

proc setOrigin*(this: CollisionRay, x: float32, y: float32, z: float32) {.importcpp: "#->set_origin(#, #, #)".}

proc getOrigin*(this: CollisionRay): LPoint3 {.importcpp: "#->get_origin()".}

proc setDirection*(this: CollisionRay, direction: LVector3) {.importcpp: "#->set_direction(#)".}

proc setDirection*(this: CollisionRay, x: float32, y: float32, z: float32) {.importcpp: "#->set_direction(#, #, #)".}

proc getDirection*(this: CollisionRay): LVector3 {.importcpp: "#->get_direction()".}

proc setFromLens*(this: CollisionRay, camera: LensNode, point: LPoint2): bool {.importcpp: "#->set_from_lens(#, #)".} ## \
## Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
## CollisionRay so that it begins at the LensNode's near plane and extends to
## infinity, making it suitable for picking objects from the screen given a
## camera and a mouse location.
##
## Returns true if the point was acceptable, false otherwise.

proc setFromLens*(this: CollisionRay, camera: LensNode, px: float32, py: float32): bool {.importcpp: "#->set_from_lens(#, #, #)".} ## \
## Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
## CollisionRay so that it begins at the LensNode's near plane and extends to
## infinity, making it suitable for picking objects from the screen given a
## camera and a mouse location.

converter getClassType*(_: typedesc[CollisionRay]): TypeHandle {.importcpp: "CollisionRay::get_class_type()", header: "collisionRay.h".}

proc newCollisionLine*(): CollisionLine {.importcpp: "new CollisionLine()".} ## \
## Creates an invalid line.  This isn't terribly useful; it's expected that
## the user will subsequently adjust the line via set_origin()/set_direction()
## or set_from_lens().

proc newCollisionLine*(origin: LPoint3, direction: LVector3): CollisionLine {.importcpp: "new CollisionLine(#, #)".}

proc newCollisionLine*(ox: float32, oy: float32, oz: float32, dx: float32, dy: float32, dz: float32): CollisionLine {.importcpp: "new CollisionLine(#, #, #, #, #, #)".}

converter getClassType*(_: typedesc[CollisionLine]): TypeHandle {.importcpp: "CollisionLine::get_class_type()", header: "collisionLine.h".}

proc newCollisionParabola*(): CollisionParabola {.importcpp: "new CollisionParabola()".} ## \
## Creates an invalid parabola.

proc newCollisionParabola*(parabola: LParabola, t1: float32, t2: float32): CollisionParabola {.importcpp: "new CollisionParabola(#, #, #)".} ## \
## Creates a parabola with the endpoints between t1 and t2 in the parametric
## space of the parabola.

proc setParabola*(this: CollisionParabola, parabola: LParabola) {.importcpp: "#->set_parabola(#)".} ## \
## Replaces the parabola specified by this solid.

proc getParabola*(this: CollisionParabola): LParabola {.importcpp: "#->get_parabola()".} ## \
## Returns the parabola specified by this solid.

proc setT1*(this: CollisionParabola, t1: float32) {.importcpp: "#->set_t1(#)".} ## \
## Changes the starting point on the parabola.

proc getT1*(this: CollisionParabola): float32 {.importcpp: "#->get_t1()".} ## \
## Returns the starting point on the parabola.

proc setT2*(this: CollisionParabola, t2: float32) {.importcpp: "#->set_t2(#)".} ## \
## Changes the ending point on the parabola.

proc getT2*(this: CollisionParabola): float32 {.importcpp: "#->get_t2()".} ## \
## Returns the ending point on the parabola.

converter getClassType*(_: typedesc[CollisionParabola]): TypeHandle {.importcpp: "CollisionParabola::get_class_type()", header: "collisionParabola.h".}

proc newCollisionSegment*(): CollisionSegment {.importcpp: "new CollisionSegment()".} ## \
## Creates an invalid segment.  This isn't terribly useful; it's expected that
## the user will subsequently adjust the segment via
## set_origin()/set_direction() or set_from_lens().

proc newCollisionSegment*(a: LPoint3, db: LPoint3): CollisionSegment {.importcpp: "new CollisionSegment(#, #)".}

proc newCollisionSegment*(ax: float32, ay: float32, az: float32, bx: float32, by: float32, bz: float32): CollisionSegment {.importcpp: "new CollisionSegment(#, #, #, #, #, #)".}

proc setPointA*(this: CollisionSegment, a: LPoint3) {.importcpp: "#->set_point_a(#)".}

proc setPointA*(this: CollisionSegment, x: float32, y: float32, z: float32) {.importcpp: "#->set_point_a(#, #, #)".}

proc getPointA*(this: CollisionSegment): LPoint3 {.importcpp: "#->get_point_a()".}

proc setPointB*(this: CollisionSegment, b: LPoint3) {.importcpp: "#->set_point_b(#)".}

proc setPointB*(this: CollisionSegment, x: float32, y: float32, z: float32) {.importcpp: "#->set_point_b(#, #, #)".}

proc getPointB*(this: CollisionSegment): LPoint3 {.importcpp: "#->get_point_b()".}

proc setFromLens*(this: CollisionSegment, camera: LensNode, point: LPoint2): bool {.importcpp: "#->set_from_lens(#, #)".} ## \
## Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
## CollisionSegment so that it begins at the LensNode's near plane and extends
## to the far plane, making it suitable for picking objects from the screen
## given a camera and a mouse location.
##
## Returns true if the point was acceptable, false otherwise.

proc setFromLens*(this: CollisionSegment, camera: LensNode, px: float32, py: float32): bool {.importcpp: "#->set_from_lens(#, #, #)".} ## \
## Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
## CollisionSegment so that it begins at the LensNode's near plane and extends
## to the far plane, making it suitable for picking objects from the screen
## given a camera and a mouse location.

converter getClassType*(_: typedesc[CollisionSegment]): TypeHandle {.importcpp: "CollisionSegment::get_class_type()", header: "collisionSegment.h".}

converter upcastToPandaNode*(this: CollisionVisualizer): PandaNode {.importcpp: "(PT(PandaNode)(#))".}

converter upcastToCollisionRecorder*(this: CollisionVisualizer): CollisionRecorder {.importcpp: "((CollisionRecorder *)(CollisionVisualizer *)(#))".}

proc newCollisionVisualizer*(copy: CollisionVisualizer): CollisionVisualizer {.importcpp: "new CollisionVisualizer(#)".} ## \
## Copy constructor.

proc newCollisionVisualizer*(name: string): CollisionVisualizer {.importcpp: "new CollisionVisualizer(nimStringToStdString(#))", header: stringConversionCode.}

proc setPointScale*(this: CollisionVisualizer, point_scale: float32) {.importcpp: "#->set_point_scale(#)".} ## \
## Scales the points that are drawn to represent the surface and interior
## intersection points of the collisions.  By default, these objects are drawn
## at an arbitrary scale which is appropriate if the window units are the
## default range -1 .. 1.  Change this scale accordinatly if the window units
## are measured on some other scale or if you need to observe these objects in
## a smaller window.

proc getPointScale*(this: CollisionVisualizer): float32 {.importcpp: "#->get_point_scale()".} ## \
## Returns the value last set by set_point_scale().

proc setNormalScale*(this: CollisionVisualizer, normal_scale: float32) {.importcpp: "#->set_normal_scale(#)".} ## \
## Scales the line segments that are drawn to represent the normals of the
## collisions.  By default, these objects are drawn at an arbitrary scale
## which is appropriate if the scene units are measured in feet.  Change this
## scale accordinatly if the scene units are measured on some other scale or
## if you need to observe these normals from farther away.

proc getNormalScale*(this: CollisionVisualizer): float32 {.importcpp: "#->get_normal_scale()".} ## \
## Returns the value last set by set_normal_scale().

proc clear*(this: CollisionVisualizer) {.importcpp: "#->clear()".} ## \
## Removes all the visualization data from a previous traversal and resets the
## visualizer to empty.

converter getClassType*(_: typedesc[CollisionVisualizer]): TypeHandle {.importcpp: "CollisionVisualizer::get_class_type()", header: "collisionVisualizer.h".}

proc hasTracker*(this: InputDevice): bool {.importcpp: "#->has_tracker()".} ## \
## Returns true if the device features a tracker that can track position and/or
## orientation in 3D space.

proc hasBattery*(this: InputDevice): bool {.importcpp: "#->has_battery()".} ## \
## Returns true if the device may be able to provide information about its
## battery life.

proc getNumButtons*(this: InputDevice): clonglong {.importcpp: "#->get_num_buttons()".} ## \
## Returns the number of buttons known to the device.  This includes those
## buttons whose state has been seen, as well as buttons that have been
## associated with a ButtonHandle even if their state is unknown.  This number
## may change as more buttons are discovered.

proc getNumAxes*(this: InputDevice): clonglong {.importcpp: "#->get_num_axes()".} ## \
## Returns the number of analog axes known to the InputDevice.  This number
## may change as more axes are discovered.

proc mapButton*(this: InputDevice, index: clonglong, handle: ButtonHandle) {.importcpp: "#->map_button(#, #)".} ## \
## Associates the indicated ButtonHandle with the button of the indicated index
## number.  When the given button index changes state, a corresponding
## ButtonEvent will be generated with the given ButtonHandle.  Pass
## ButtonHandle::none() to turn off any association.
##
## It is not necessary to call this if you simply want to query the state of
## the various buttons by index number; this is only necessary in order to
## generate ButtonEvents when the buttons change state.

proc setVibration*(this: InputDevice, strong: float64, weak: float64) {.importcpp: "#->set_vibration(#, #)".} ## \
## Sets the strength of the vibration effect, if supported.  The values are
## clamped to 0-1 range. The first value axes the low-frequency rumble
## motor, whereas the second axes the high-frequency motor, if present.

proc enablePointerEvents*(this: InputDevice) {.importcpp: "#->enable_pointer_events()".} ## \
## Enables the generation of mouse-movement events.

proc disablePointerEvents*(this: InputDevice) {.importcpp: "#->disable_pointer_events()".} ## \
## Disables the generation of mouse-movement events.

proc poll*(this: InputDevice) {.importcpp: "#->poll()".} ## \
## Polls the input device for new activity, to ensure it contains the latest
## events.  This will only have any effect for some types of input devices;
## others may be updated automatically, and this method will be a no-op.

proc hasButtonEvent*(this: InputDevice): bool {.importcpp: "#->has_button_event()".} ## \
## Returns true if this device has a pending button event (a mouse button or
## keyboard button down/up), false otherwise.  If this returns true, the
## particular event may be extracted via get_button_event().

proc getButtonEvents*(this: InputDevice): ButtonEventList {.importcpp: "#->get_button_events()".} ## \
## Returns the list of recently-generated ButtonEvents.
## The list is also cleared.

proc hasPointerEvent*(this: InputDevice): bool {.importcpp: "#->has_pointer_event()".} ## \
## Returns true if this device has a pending pointer event (a mouse movement),
## or false otherwise.  If this returns true, the particular event may be
## extracted via get_pointer_event().

proc getPointerEvents*(this: InputDevice): PointerEventList {.importcpp: "#->get_pointer_events()".} ## \
## Returns a PointerEventList containing all the recent pointer events.
## Clears the list.

proc output*(this: InputDevice, `out`: ostream) {.importcpp: "#->output(#)".} ## \
## Writes a one-line string describing the device.

converter getClassType*(_: typedesc[InputDevice]): TypeHandle {.importcpp: "InputDevice::get_class_type()", header: "inputDevice.h".}

proc forkAsynchronousThread*(this: ClientBase, poll_time: float64): bool {.importcpp: "#->fork_asynchronous_thread(#)".} ## \
## Forks a separate thread to do all the polling of connected devices.  The
## forked thread will poll after every poll_time seconds has elapsed.  Returns
## true if the fork was successful, or false otherwise (for instance, because
## we were already forked, or because asynchronous threads are disabled).

proc isForked*(this: ClientBase): bool {.importcpp: "#->is_forked()".} ## \
## Returns true if the ClientBase has been forked (and, therefore, poll() does
## not need to be called), false otherwise.

proc poll*(this: ClientBase): bool {.importcpp: "#->poll()".} ## \
## Initiates a poll of the client devices, if we are not forked and if we have
## not already polled this frame.  Returns true if the poll occurred, or false
## if it did not.

proc getLastPollTime*(this: ClientBase): float64 {.importcpp: "#->get_last_poll_time()".} ## \
## Returns the time (according to the global ClockObject's get_real_time()
## method) of the last device poll.

proc setCoordinateSystem*(this: ClientBase, cs: CoordinateSystem) {.importcpp: "#->set_coordinate_system(#)".} ## \
## Specifies the coordinate system that all devices associated with this
## client will operate in.  Normally, this is CS_default.

proc getCoordinateSystem*(this: ClientBase): CoordinateSystem {.importcpp: "#->get_coordinate_system()".} ## \
## Returns the coordinate system that all devices associated with this client
## will operate in.  Normally, this is CS_default.

converter getClassType*(_: typedesc[ClientBase]): TypeHandle {.importcpp: "ClientBase::get_class_type()", header: "clientBase.h".}

proc newAnalogNode*(param0: AnalogNode): AnalogNode {.importcpp: "new AnalogNode(#)".}

proc newAnalogNode*(client: ClientBase, device_name: string): AnalogNode {.importcpp: "new AnalogNode(#, nimStringToStdString(#))", header: stringConversionCode.}

proc newAnalogNode*(device: InputDevice): AnalogNode {.importcpp: "new AnalogNode(#)".}

proc isValid*(this: AnalogNode): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the AnalogNode is valid and connected to a server, false
## otherwise.

proc getNumControls*(this: AnalogNode): int {.importcpp: "#->get_num_controls()".} ## \
## Returns the number of analog controls known to the AnalogNode.  This number
## may change as more controls are discovered.

proc getControlState*(this: AnalogNode, index: int): float64 {.importcpp: "#->get_control_state(#)".} ## \
## Returns the current position of indicated analog control identified by its
## index number, or 0.0 if the control is unknown.  The normal range of a
## single control is -1.0 to 1.0.

proc isControlKnown*(this: AnalogNode, index: int): bool {.importcpp: "#->is_control_known(#)".} ## \
## Returns true if the state of the indicated analog control is known, or
## false if we have never heard anything about this particular control.

proc setOutput*(this: AnalogNode, channel: int, index: int, flip: bool) {.importcpp: "#->set_output(#, #, #)".} ## \
## Causes a particular analog control to be placed in the data graph for the
## indicated channel.  Normally, a mouse uses channels 0 and 1 for the X and Y
## information, respectively; channels 0, 1, and 2 are available.  If flip is
## true, the analog control value will be reversed before outputting it.

proc clearOutput*(this: AnalogNode, channel: int) {.importcpp: "#->clear_output(#)".} ## \
## Removes the output to the data graph associated with the indicated channel.
## See set_output().

proc getOutput*(this: AnalogNode, channel: int): int {.importcpp: "#->get_output(#)".} ## \
## Returns the analog control index that is output to the data graph on the
## indicated channel, or -1 if no control is output on that channel.  See
## set_output().

proc isOutputFlipped*(this: AnalogNode, channel: int): bool {.importcpp: "#->is_output_flipped(#)".} ## \
## Returns true if the analog control index that is output to the data graph
## on the indicated channel is flipped.  See set_output().

converter getClassType*(_: typedesc[AnalogNode]): TypeHandle {.importcpp: "AnalogNode::get_class_type()", header: "analogNode.h".}

proc newButtonNode*(param0: ButtonNode): ButtonNode {.importcpp: "new ButtonNode(#)".}

proc newButtonNode*(client: ClientBase, device_name: string): ButtonNode {.importcpp: "new ButtonNode(#, nimStringToStdString(#))", header: stringConversionCode.}

proc newButtonNode*(device: InputDevice): ButtonNode {.importcpp: "new ButtonNode(#)".}

proc isValid*(this: ButtonNode): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the ButtonNode is valid and connected to a server, false
## otherwise.

proc getNumButtons*(this: ButtonNode): int {.importcpp: "#->get_num_buttons()".} ## \
## Returns the number of buttons known to the ButtonNode.  This includes those
## buttons whose state has been seen, as well as buttons that have been
## associated with a ButtonHandle even if their state is unknown.  This number
## may change as more buttons are discovered.

proc setButtonMap*(this: ButtonNode, index: int, button: ButtonHandle) {.importcpp: "#->set_button_map(#, #)".} ## \
## Associates the indicated ButtonHandle with the button of the indicated
## index number.  When the given button index changes state, a corresponding
## ButtonEvent will be generated with the given ButtonHandle.  Pass
## ButtonHandle::none() to turn off any association.
##
## It is not necessary to call this if you simply want to query the state of
## the various buttons by index number; this is only necessary in order to
## generate ButtonEvents when the buttons change state.

proc getButtonMap*(this: ButtonNode, index: int): ButtonHandle {.importcpp: "#->get_button_map(#)".} ## \
## Returns the ButtonHandle that was previously associated with the given
## index number by a call to set_button_map(), or ButtonHandle::none() if no
## button was associated.

proc getButtonState*(this: ButtonNode, index: int): bool {.importcpp: "#->get_button_state(#)".} ## \
## Returns true if the indicated button (identified by its index number) is
## currently known to be down, or false if it is up or unknown.

proc isButtonKnown*(this: ButtonNode, index: int): bool {.importcpp: "#->is_button_known(#)".} ## \
## Returns true if the state of the indicated button is known, or false if we
## have never heard anything about this particular button.

converter getClassType*(_: typedesc[ButtonNode]): TypeHandle {.importcpp: "ButtonNode::get_class_type()", header: "buttonNode.h".}

proc newDialNode*(client: ClientBase, device_name: string): DialNode {.importcpp: "new DialNode(#, nimStringToStdString(#))", header: stringConversionCode.}

proc newDialNode*(param0: DialNode): DialNode {.importcpp: "new DialNode(#)".}

proc isValid*(this: DialNode): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the DialNode is valid and connected to a server, false
## otherwise.

proc getNumDials*(this: DialNode): int {.importcpp: "#->get_num_dials()".} ## \
## Returns the number of dial dials known to the DialNode.  This number may
## change as more dials are discovered.

proc readDial*(this: DialNode, index: int): float64 {.importcpp: "#->read_dial(#)".} ## \
## Returns the number of complete revolutions of the dial since the last time
## read_dial() was called.  This is a destructive operation; it is not
## possible to read the dial without resetting the counter.

proc isDialKnown*(this: DialNode, index: int): bool {.importcpp: "#->is_dial_known(#)".} ## \
## Returns true if the state of the indicated dial dial is known, or false if
## we have never heard anything about this particular dial.

converter getClassType*(_: typedesc[DialNode]): TypeHandle {.importcpp: "DialNode::get_class_type()", header: "dialNode.h".}

proc initInputDeviceSet*(): InputDeviceSet {.importcpp: "InputDeviceSet()".}

proc initInputDeviceSet*(copy: InputDeviceSet): InputDeviceSet {.importcpp: "InputDeviceSet(#)".}

proc clear*(this: InputDeviceSet) {.importcpp: "#.clear()".} ## \
## Removes all InputDevices from the collection.

proc reserve*(this: InputDeviceSet, num: clonglong) {.importcpp: "#.reserve(#)".} ## \
## This is a hint to Panda to allocate enough memory to hold the given number
## of InputDevices, if you know ahead of time how many you will be adding.

proc `[]`*(this: InputDeviceSet, index: clonglong): InputDevice {.importcpp: "#.operator [](#)".} ## \
## Returns the nth InputDevice in the collection.

proc size*(this: InputDeviceSet): clonglong {.importcpp: "#.size()".} ## \
## Returns the number of devices in the collection.

proc output*(this: InputDeviceSet, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Writes a brief one-line description of the InputDeviceSet to the indicated
## output stream.

proc write*(this: InputDeviceSet, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Writes a complete multi-line description of the InputDeviceSet to the
## indicated output stream.

proc write*(this: InputDeviceSet, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes a complete multi-line description of the InputDeviceSet to the
## indicated output stream.

proc getDevices*(this: InputDeviceManager): InputDeviceSet {.importcpp: "#.get_devices()".} ## \
## Description: Returns all currently connected devices.

proc addDevice*(this: InputDeviceManager, device: InputDevice) {.importcpp: "#.add_device(#)".} ## \
## Called when a new device has been discovered.  This may also be used to
## register virtual devices.
##
## This causes a connect-device event to be thrown.

proc removeDevice*(this: InputDeviceManager, device: InputDevice) {.importcpp: "#.remove_device(#)".} ## \
## Called when a device has been removed, or when a device should otherwise no
## longer be tracked.
##
## This causes a disconnect-device event to be thrown.

proc update*(this: InputDeviceManager) {.importcpp: "#.update()".} ## \
## Polls the system to see if there are any new devices.  In some
## implementations this is a no-op.

proc getGlobalPtr*(_: typedesc[InputDeviceManager]): InputDeviceManager {.importcpp: "InputDeviceManager::get_global_ptr()", header: "inputDeviceManager.h".} ## \
## Returns the singleton InputDeviceManager instance.

proc newInputDeviceNode*(device: InputDevice, name: string): InputDeviceNode {.importcpp: "new InputDeviceNode(#, nimStringToStdString(#))", header: stringConversionCode.}

proc newInputDeviceNode*(param0: InputDeviceNode): InputDeviceNode {.importcpp: "new InputDeviceNode(#)".}

converter getClassType*(_: typedesc[InputDeviceNode]): TypeHandle {.importcpp: "InputDeviceNode::get_class_type()", header: "inputDeviceNode.h".}

proc newTrackerNode*(client: ClientBase, device_name: string): TrackerNode {.importcpp: "new TrackerNode(#, nimStringToStdString(#))", header: stringConversionCode.}

proc newTrackerNode*(device: InputDevice): TrackerNode {.importcpp: "new TrackerNode(#)".}

proc newTrackerNode*(param0: TrackerNode): TrackerNode {.importcpp: "new TrackerNode(#)".}

proc isValid*(this: TrackerNode): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the TrackerNode is valid and connected to a server, false
## otherwise.

proc getPos*(this: TrackerNode): LPoint3 {.importcpp: "#->get_pos()".} ## \
## Returns the current position of the tracker, if it is available.

proc getOrient*(this: TrackerNode): LOrientation {.importcpp: "#->get_orient()".} ## \
## Returns the current orientation of the tracker, if it is available.

proc getTransform*(this: TrackerNode): LMatrix4 {.importcpp: "#->get_transform()".} ## \
## Returns the current position and orientation of the tracker, as a combined
## matrix.

proc getTime*(this: TrackerNode): float64 {.importcpp: "#->get_time()".} ## \
## Returns the time of the tracker's last update.

proc hasTime*(this: TrackerNode): bool {.importcpp: "#->has_time()".} ## \
## True if this data comes with timestamps.

proc setTrackerCoordinateSystem*(this: TrackerNode, cs: CoordinateSystem) {.importcpp: "#->set_tracker_coordinate_system(#)".} ## \
## Specifies the coordinate system that the tracker associated with this node
## will operate in.  Normally, this is set from the ClientBase that's used to
## create the TrackerNode, so it should not need to be set on an individual
## tracker basis.

proc getTrackerCoordinateSystem*(this: TrackerNode): CoordinateSystem {.importcpp: "#->get_tracker_coordinate_system()".} ## \
## Returns the coordinate system that the tracker associated with this node
## will operate in.

proc setGraphCoordinateSystem*(this: TrackerNode, cs: CoordinateSystem) {.importcpp: "#->set_graph_coordinate_system(#)".} ## \
## Specifies the coordinate system that the TrackerNode will convert its
## transform into for passing down the data graph.  Normally, this is
## CS_default.

proc getGraphCoordinateSystem*(this: TrackerNode): CoordinateSystem {.importcpp: "#->get_graph_coordinate_system()".} ## \
## Returns the coordinate system that the TrackerNode will convert its
## transform into for passing down the data graph.  Normally, this is
## CS_default.

converter getClassType*(_: typedesc[TrackerNode]): TypeHandle {.importcpp: "TrackerNode::get_class_type()", header: "trackerNode.h".}

proc newVirtualMouse*(param0: VirtualMouse): VirtualMouse {.importcpp: "new VirtualMouse(#)".}

proc newVirtualMouse*(name: string): VirtualMouse {.importcpp: "new VirtualMouse(nimStringToStdString(#))", header: stringConversionCode.}

proc setMousePos*(this: VirtualMouse, x: int, y: int) {.importcpp: "#->set_mouse_pos(#, #)".} ## \
## Sets the current mouse pixel location, where (0,0) is the upper left, and
## (width-1, height-1) is the lower right pixel of the virtual window.

proc setWindowSize*(this: VirtualMouse, width: int, height: int) {.importcpp: "#->set_window_size(#, #)".} ## \
## Sets the size of the "window" in which the mouse rolls.  This changes the
## meaning of the values passed to set_mouse_pos().

proc setMouseOn*(this: VirtualMouse, flag: bool) {.importcpp: "#->set_mouse_on(#)".} ## \
## Sets whether the mouse should appear to be within the window or not.  If
## this is true, the mouse is within the window; if false, the mouse is not
## within the window (and set_mouse_pos() means nothing).

proc pressButton*(this: VirtualMouse, button: ButtonHandle) {.importcpp: "#->press_button(#)".} ## \
## Simulates a mouse or keyboard button being depressed.  This should be
## followed up by a call to release_button() sometime later (possibly
## immediately).

proc releaseButton*(this: VirtualMouse, button: ButtonHandle) {.importcpp: "#->release_button(#)".} ## \
## Simulates the button being released.  This should follow a previous call to
## press_button().

converter getClassType*(_: typedesc[VirtualMouse]): TypeHandle {.importcpp: "VirtualMouse::get_class_type()", header: "virtualMouse.h".}

proc initDataGraphTraverser*(param0: DataGraphTraverser): DataGraphTraverser {.importcpp: "DataGraphTraverser(#)".}

proc initDataGraphTraverser*(current_thread: Thread): DataGraphTraverser {.importcpp: "DataGraphTraverser(#)".}

proc initDataGraphTraverser*(): DataGraphTraverser {.importcpp: "DataGraphTraverser()".}

proc getCurrentThread*(this: DataGraphTraverser): Thread {.importcpp: "#.get_current_thread()".} ## \
## Returns the currently-executing thread object, as passed to the
## DataGraphTraverser constructor.

proc traverse*(this: DataGraphTraverser, node: PandaNode) {.importcpp: "#.traverse(#)".} ## \
## Starts the traversal of the data graph at the indicated root node.

proc collectLeftovers*(this: DataGraphTraverser) {.importcpp: "#.collect_leftovers()".} ## \
## Pick up any nodes that didn't get completely traversed.  These must be
## nodes that have multiple parents, with at least one parent completely
## outside of the data graph.

proc newDataNode*(name: string): DataNode {.importcpp: "new DataNode(nimStringToStdString(#))", header: stringConversionCode.}

proc writeInputs*(this: DataNode, `out`: ostream) {.importcpp: "#->write_inputs(#)".} ## \
## Writes to the indicated ostream a list of all the inputs this DataNode
## might expect to receive.

proc writeOutputs*(this: DataNode, `out`: ostream) {.importcpp: "#->write_outputs(#)".} ## \
## Writes to the indicated ostream a list of all the outputs this DataNode
## might generate.

proc writeConnections*(this: DataNode, `out`: ostream) {.importcpp: "#->write_connections(#)".} ## \
## Writes to the indicated ostream a list of all the connections currently
## showing between this DataNode and its parent(s).

converter getClassType*(_: typedesc[DataNode]): TypeHandle {.importcpp: "DataNode::get_class_type()", header: "dataNode.h".}

proc getPipe*(this: GraphicsDevice): GraphicsPipe {.importcpp: "#->get_pipe()".} ## \
## Returns the GraphicsPipe that this device is associated with.

converter getClassType*(_: typedesc[GraphicsDevice]): TypeHandle {.importcpp: "GraphicsDevice::get_class_type()", header: "graphicsDevice.h".}

proc isValid*(this: GraphicsPipe): bool {.importcpp: "#->is_valid()".} ## \
## Returns false if this pipe is known to be invalid, meaning that an attempt
## to create a GraphicsWindow with the pipe will certainly fail.  Returns true
## if the pipe is probably valid (is this case, an attempt to create a
## GraphicsWindow should succeed, but might still fail).
##
## Use the GraphicsEngine class to create a GraphicsWindow on a particular
## pipe.

proc getSupportedTypes*(this: GraphicsPipe): int {.importcpp: "#->get_supported_types()".} ## \
## Returns the mask of bits that represents the kinds of GraphicsOutput
## objects this pipe might be able to successfully create.  The return value
## is the union of bits in GraphicsPipe::OutputTypes that represents the set
## of GraphicsOutput types.
##
## A 1 bit in a particular position is not a guarantee of success, but a 0 bit
## is a guarantee of failure.

proc supportsType*(this: GraphicsPipe, flags: int): bool {.importcpp: "#->supports_type(#)".} ## \
## A convenience function to ask if a particular type or types of
## GraphicsObjects are supported.  The parameter is a union of one or more
## bits defined in GrpahicsPipe::OutputTypes.
##
## Returns true if all of the requested types are listed in the
## supported_types mask, false if any one of them is not.  This is not a
## guarantee that the indicated output type will successfully be created when
## it is attempted.

proc getDisplayWidth*(this: GraphicsPipe): int {.importcpp: "#->get_display_width()".} ## \
## Returns the width of the entire display, if it is known.  This may return
## 0.  This is not a guarantee that windows (particularly fullscreen windows)
## may not be created larger than this width, but it is intended to provide a
## hint to the application.

proc getDisplayHeight*(this: GraphicsPipe): int {.importcpp: "#->get_display_height()".} ## \
## Returns the height of the entire display, if it is known.  This may return
## 0.  See the caveats for get_display_width().

proc getDisplayZoom*(this: GraphicsPipe): float32 {.importcpp: "#->get_display_zoom()".} ## \
## Returns the display zoom factor configured in the operating system.  If the
## operating system automatically scales windows to match the DPI (such as when
## dpi-aware is set to false), this will be 1.0.  Otherwise, this will be set to
## a value approximating the density of the monitor divided by the standard
## density of the operating system (usually 96), yielding a value like 1.5 or
## 2.0.
##
## @since 1.10.8

proc getDisplayInformation*(this: GraphicsPipe): DisplayInformation {.importcpp: "#->get_display_information()".} ## \
## Gets the pipe's DisplayInformation.

proc initDisplayInformation*(): DisplayInformation {.importcpp: "DisplayInformation()".}

proc initDisplayInformation*(param0: DisplayInformation): DisplayInformation {.importcpp: "DisplayInformation(#)".}

proc getDisplayState*(this: DisplayInformation): int {.importcpp: "#.get_display_state()".}

proc getMaximumWindowWidth*(this: DisplayInformation): int {.importcpp: "#.get_maximum_window_width()".}

proc getMaximumWindowHeight*(this: DisplayInformation): int {.importcpp: "#.get_maximum_window_height()".}

proc getWindowBitsPerPixel*(this: DisplayInformation): int {.importcpp: "#.get_window_bits_per_pixel()".}

proc getTotalDisplayModes*(this: DisplayInformation): int {.importcpp: "#.get_total_display_modes()".}

proc getDisplayMode*(this: DisplayInformation, display_index: int): DisplayMode {.importcpp: "#.get_display_mode(#)".}

proc getDisplayModeWidth*(this: DisplayInformation, display_index: int): int {.importcpp: "#.get_display_mode_width(#)".} ## \
## Older interface for display modes.

proc getDisplayModeHeight*(this: DisplayInformation, display_index: int): int {.importcpp: "#.get_display_mode_height(#)".}

proc getDisplayModeBitsPerPixel*(this: DisplayInformation, display_index: int): int {.importcpp: "#.get_display_mode_bits_per_pixel(#)".}

proc getDisplayModeRefreshRate*(this: DisplayInformation, display_index: int): int {.importcpp: "#.get_display_mode_refresh_rate(#)".}

proc getDisplayModeFullscreenOnly*(this: DisplayInformation, display_index: int): int {.importcpp: "#.get_display_mode_fullscreen_only(#)".}

proc getVideoMemory*(this: DisplayInformation): int {.importcpp: "#.get_video_memory()".}

proc getTextureMemory*(this: DisplayInformation): int {.importcpp: "#.get_texture_memory()".}

proc updateMemoryInformation*(this: DisplayInformation) {.importcpp: "#.update_memory_information()".}

proc getPhysicalMemory*(this: DisplayInformation): clonglong {.importcpp: "#.get_physical_memory()".}

proc getAvailablePhysicalMemory*(this: DisplayInformation): clonglong {.importcpp: "#.get_available_physical_memory()".}

proc getPageFileSize*(this: DisplayInformation): clonglong {.importcpp: "#.get_page_file_size()".}

proc getAvailablePageFileSize*(this: DisplayInformation): clonglong {.importcpp: "#.get_available_page_file_size()".}

proc getProcessVirtualMemory*(this: DisplayInformation): clonglong {.importcpp: "#.get_process_virtual_memory()".}

proc getAvailableProcessVirtualMemory*(this: DisplayInformation): clonglong {.importcpp: "#.get_available_process_virtual_memory()".}

proc getMemoryLoad*(this: DisplayInformation): int {.importcpp: "#.get_memory_load()".}

proc getPageFaultCount*(this: DisplayInformation): clonglong {.importcpp: "#.get_page_fault_count()".}

proc getProcessMemory*(this: DisplayInformation): clonglong {.importcpp: "#.get_process_memory()".}

proc getPeakProcessMemory*(this: DisplayInformation): clonglong {.importcpp: "#.get_peak_process_memory()".}

proc getPageFileUsage*(this: DisplayInformation): clonglong {.importcpp: "#.get_page_file_usage()".}

proc getPeakPageFileUsage*(this: DisplayInformation): clonglong {.importcpp: "#.get_peak_page_file_usage()".}

proc getVendorId*(this: DisplayInformation): int {.importcpp: "#.get_vendor_id()".}

proc getDeviceId*(this: DisplayInformation): int {.importcpp: "#.get_device_id()".}

proc getDriverProduct*(this: DisplayInformation): int {.importcpp: "#.get_driver_product()".}

proc getDriverVersion*(this: DisplayInformation): int {.importcpp: "#.get_driver_version()".}

proc getDriverSubVersion*(this: DisplayInformation): int {.importcpp: "#.get_driver_sub_version()".}

proc getDriverBuild*(this: DisplayInformation): int {.importcpp: "#.get_driver_build()".}

proc getDriverDateMonth*(this: DisplayInformation): int {.importcpp: "#.get_driver_date_month()".}

proc getDriverDateDay*(this: DisplayInformation): int {.importcpp: "#.get_driver_date_day()".}

proc getDriverDateYear*(this: DisplayInformation): int {.importcpp: "#.get_driver_date_year()".}

proc getCpuVendorString*(this: DisplayInformation): string {.importcpp: "nimStringFromStdString(#.get_cpu_vendor_string())", header: stringConversionCode.}

proc getCpuBrandString*(this: DisplayInformation): string {.importcpp: "nimStringFromStdString(#.get_cpu_brand_string())", header: stringConversionCode.}

proc getCpuVersionInformation*(this: DisplayInformation): int {.importcpp: "#.get_cpu_version_information()".}

proc getCpuBrandIndex*(this: DisplayInformation): int {.importcpp: "#.get_cpu_brand_index()".}

proc getCpuFrequency*(this: DisplayInformation): clonglong {.importcpp: "#.get_cpu_frequency()".}

proc getCpuTime*(_: typedesc[DisplayInformation]): clonglong {.importcpp: "DisplayInformation::get_cpu_time()", header: "displayInformation.h".} ## \
## Equivalent to the rdtsc processor instruction.

proc getMaximumCpuFrequency*(this: DisplayInformation): clonglong {.importcpp: "#.get_maximum_cpu_frequency()".}

proc getCurrentCpuFrequency*(this: DisplayInformation): clonglong {.importcpp: "#.get_current_cpu_frequency()".}

proc updateCpuFrequency*(this: DisplayInformation, processor_number: int) {.importcpp: "#.update_cpu_frequency(#)".}

proc getNumCpuCores*(this: DisplayInformation): int {.importcpp: "#.get_num_cpu_cores()".} ## \
## Returns the number of individual CPU cores in the system, or 0 if this
## number is not available.  A hyperthreaded CPU counts once here.

proc getNumLogicalCpus*(this: DisplayInformation): int {.importcpp: "#.get_num_logical_cpus()".} ## \
## Returns the number of logical CPU's in the system, or 0 if this number is
## not available.  A hyperthreaded CPU counts as two or more here.

proc getOsVersionMajor*(this: DisplayInformation): int {.importcpp: "#.get_os_version_major()".} ## \
## Returns -1 if not set.

proc getOsVersionMinor*(this: DisplayInformation): int {.importcpp: "#.get_os_version_minor()".} ## \
## Returns -1 if not set.

proc getOsVersionBuild*(this: DisplayInformation): int {.importcpp: "#.get_os_version_build()".} ## \
## Returns -1 if not set.

proc getOsPlatformId*(this: DisplayInformation): int {.importcpp: "#.get_os_platform_id()".} ## \
## Returns -1 if not set.

proc lookupCpuData*(this: GraphicsPipe) {.importcpp: "#->lookup_cpu_data()".} ## \
## Looks up the detailed CPU information and stores it in
## _display_information, if supported by the OS. This may take a second or
## two.

proc getInterfaceName*(this: GraphicsPipe): string {.importcpp: "nimStringFromStdString(#->get_interface_name())", header: stringConversionCode.}

converter getClassType*(_: typedesc[GraphicsPipe]): TypeHandle {.importcpp: "GraphicsPipe::get_class_type()", header: "graphicsPipe.h".}

proc setClearColorActive*(this: DrawableRegion, clear_color_active: bool) {.importcpp: "#->set_clear_color_active(#)".} ## \
## Toggles the flag that indicates whether the color buffer should be cleared
## every frame.  If this is true, the color buffer will be cleared to the
## color indicated by set_clear_color(); otherwise, it will be left alone.

proc getClearColorActive*(this: DrawableRegion): bool {.importcpp: "#->get_clear_color_active()".} ## \
## Returns the current setting of the flag that indicates whether the color
## buffer should be cleared every frame.  See set_clear_color_active().

proc setClearDepthActive*(this: DrawableRegion, clear_depth_active: bool) {.importcpp: "#->set_clear_depth_active(#)".} ## \
## Toggles the flag that indicates whether the depth buffer should be cleared
## every frame.  If this is true, the depth buffer will be cleared to the
## depth value indicated by set_clear_depth(); otherwise, it will be left
## alone.

proc getClearDepthActive*(this: DrawableRegion): bool {.importcpp: "#->get_clear_depth_active()".} ## \
## Returns the current setting of the flag that indicates whether the depth
## buffer should be cleared every frame.  See set_clear_depth_active().

proc setClearStencilActive*(this: DrawableRegion, clear_stencil_active: bool) {.importcpp: "#->set_clear_stencil_active(#)".} ## \
## Toggles the flag that indicates whether the stencil buffer should be
## cleared every frame.  If this is true, the stencil buffer will be cleared
## to the value indicated by set_clear_stencil(); otherwise, it will be left
## alone.

proc getClearStencilActive*(this: DrawableRegion): bool {.importcpp: "#->get_clear_stencil_active()".} ## \
## Returns the current setting of the flag that indicates whether the color
## buffer should be cleared every frame.  See set_clear_stencil_active().

proc setClearColor*(this: DrawableRegion, color: LColor) {.importcpp: "#->set_clear_color(#)".} ## \
## Sets the clear color to the indicated value.  This is the value that will
## be used to clear the color buffer every frame, but only if
## get_clear_color_active() returns true.  If get_clear_color_active() returns
## false, this is meaningless.

proc getClearColor*(this: DrawableRegion): LColor {.importcpp: "#->get_clear_color()".} ## \
## Returns the current clear color value.  This is the value that will be used
## to clear the color buffer every frame, but only if get_clear_color_active()
## returns true.  If get_clear_color_active() returns false, this is
## meaningless.

proc setClearDepth*(this: DrawableRegion, depth: float32) {.importcpp: "#->set_clear_depth(#)".} ## \
## Sets the clear depth to the indicated value.  This is the value that will
## be used to clear the depth buffer every frame, but only if
## get_clear_depth_active() returns true.  If get_clear_depth_active() returns
## false, this is meaningless.

proc getClearDepth*(this: DrawableRegion): float32 {.importcpp: "#->get_clear_depth()".} ## \
## Returns the current clear depth value.  This is the value that will be used
## to clear the depth buffer every frame, but only if get_clear_depth_active()
## returns true.  If get_clear_depth_active() returns false, this is
## meaningless.

proc setClearStencil*(this: DrawableRegion, stencil: int) {.importcpp: "#->set_clear_stencil(#)".}

proc getClearStencil*(this: DrawableRegion): int {.importcpp: "#->get_clear_stencil()".} ## \
## Returns the current clear stencil value.  This is the value that will be
## used to clear the stencil buffer every frame, but only if
## get_clear_stencil_active() returns true.  If get_clear_stencil_active()
## returns false, this is meaningless.

proc setClearActive*(this: DrawableRegion, n: int, clear_aux_active: bool) {.importcpp: "#->set_clear_active(#, #)".} ## \
## Sets the clear-active flag for any bitplane.

proc getClearActive*(this: DrawableRegion, n: int): bool {.importcpp: "#->get_clear_active(#)".} ## \
## Gets the clear-active flag for any bitplane.

proc setClearValue*(this: DrawableRegion, n: int, clear_value: LColor) {.importcpp: "#->set_clear_value(#, #)".} ## \
## Sets the clear value for any bitplane.

proc getClearValue*(this: DrawableRegion, n: int): LColor {.importcpp: "#->get_clear_value(#)".} ## \
## Returns the clear value for any bitplane.

proc disableClears*(this: DrawableRegion) {.importcpp: "#->disable_clears()".} ## \
## Disables both the color and depth clear.  See set_clear_color_active and
## set_clear_depth_active.

proc isAnyClearActive*(this: DrawableRegion): bool {.importcpp: "#->is_any_clear_active()".} ## \
## Returns true if any of the clear types (so far there are just color or
## depth) have been set active, or false if none of them are active and there
## is no need to clear.

proc setPixelZoom*(this: DrawableRegion, pixel_zoom: float32) {.importcpp: "#->set_pixel_zoom(#)".} ## \
## Sets the amount by which the pixels of the region are scaled internally
## when filling the image interally.  Setting this number larger makes the
## pixels blockier, but may make the rendering faster, particularly for
## software renderers.  Setting this number to 2.0 reduces the number of
## pixels that have to be filled by the renderer by a factor of 2.0.  It
## doesn't make sense to set this lower than 1.0.
##
## It is possible to set this on either individual DisplayRegions or on
## overall GraphicsWindows, but you will get better performance for setting it
## on the window rather than its individual DisplayRegions.  Also, you may not
## set it on a DisplayRegion that doesn't have both clear_color() and
## clear_depth() enabled.
##
## This property is only supported on renderers for which it is particularly
## useful--currently, this is the tinydisplay software renderer.  Other kinds
## of renderers allow you to set this property, but ignore it.

proc getPixelZoom*(this: DrawableRegion): float32 {.importcpp: "#->get_pixel_zoom()".} ## \
## Returns the value set by set_pixel_zoom(), regardless of whether it is
## being respected or not.  Also see get_pixel_factor().

proc getPixelFactor*(this: DrawableRegion): float32 {.importcpp: "#->get_pixel_factor()".} ## \
## Returns the amount by which the height and width of the region will be
## scaled internally, based on the zoom factor set by set_pixel_zoom().  This
## will return 1.0 if the pixel_zoom was not set or if it is not being
## respected (for instance, because the underlying renderer doesn't support it
## --see supports_pixel_zoom).

proc supportsPixelZoom*(this: DrawableRegion): bool {.importcpp: "#->supports_pixel_zoom()".} ## \
## Returns true if a call to set_pixel_zoom() will be respected, false if it
## will be ignored.  If this returns false, then get_pixel_factor() will
## always return 1.0, regardless of what value you specify for
## set_pixel_zoom().
##
## This may return false if the underlying renderer doesn't support pixel
## zooming, or if you have called this on a DisplayRegion that doesn't have
## both set_clear_color() and set_clear_depth() enabled.

proc getRenderbufferType*(_: typedesc[DrawableRegion], plane: int): int {.importcpp: "#DrawableRegion::get_renderbuffer_type(#)", header: "drawableRegion.h".} ## \
## Returns the RenderBuffer::Type that corresponds to a RenderTexturePlane.

proc newWindowHandle*(copy: WindowHandle): WindowHandle {.importcpp: "new WindowHandle(#)".}

proc sendWindowsMessage*(this: WindowHandle, msg: int, wparam: int, lparam: int) {.importcpp: "#->send_windows_message(#, #, #)".} ## \
## Call this method on a parent WindowHandle to deliver a Windows message to
## the current child window, if any.  This is used in the web plugin system to
## deliver button events detected directly by the browser system into Panda,
## which is particularly necessary on Vista.

proc getIntHandle*(this: WindowHandle): clonglong {.importcpp: "#->get_int_handle()".} ## \
## Returns the OS-specific handle converted to an integer, if this is possible
## for the particular representation.  Returns 0 if it is not.

proc output*(this: WindowHandle, `out`: ostream) {.importcpp: "#->output(#)".}

converter getClassType*(_: typedesc[WindowHandle]): TypeHandle {.importcpp: "WindowHandle::get_class_type()", header: "windowHandle.h".}

proc getConfigProperties*(_: typedesc[WindowProperties]): WindowProperties {.importcpp: "WindowProperties::get_config_properties()", header: "windowProperties.h".} ## \
## Returns a WindowProperties structure with all of the default values filled
## in according to the user's config file.

proc getDefault*(_: typedesc[WindowProperties]): WindowProperties {.importcpp: "WindowProperties::get_default()", header: "windowProperties.h".} ## \
## Returns the "default" WindowProperties.  If set_default() has been called,
## this returns that WindowProperties structure; otherwise, this returns
## get_config_properties().

proc setDefault*(_: typedesc[WindowProperties], default_properties: WindowProperties) {.importcpp: "#WindowProperties::set_default(#)", header: "windowProperties.h".} ## \
## Replaces the "default" WindowProperties with the specified structure.  The
## specified WindowProperties will be returned by future calls to
## get_default(), until clear_default() is called.
##
## Note that this completely replaces the default properties; it is not
## additive.

proc clearDefault*(_: typedesc[WindowProperties]) {.importcpp: "WindowProperties::clear_default()", header: "windowProperties.h".} ## \
## Returns the "default" WindowProperties to whatever is specified in the
## user's config file.

proc size*(_: typedesc[WindowProperties], size: LVecBase2i): WindowProperties {.importcpp: "#WindowProperties::size(#)", header: "windowProperties.h".} ## \
## Returns a WindowProperties structure with only the size specified.  The
## size is the only property that matters to buffers.
##
## @deprecated in the Python API, use WindowProperties(size=(x, y)) instead.

proc size*(_: typedesc[WindowProperties], x_size: int, y_size: int): WindowProperties {.importcpp: "#WindowProperties::size(#, #)", header: "windowProperties.h".}

proc `==`*(this: WindowProperties, other: WindowProperties): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: WindowProperties, other: WindowProperties): bool {.importcpp: "#.operator !=(#)".}

proc clear*(this: WindowProperties) {.importcpp: "#.clear()".} ## \
## Unsets all properties that have been specified so far, and resets the
## WindowProperties structure to its initial empty state.

proc isAnySpecified*(this: WindowProperties): bool {.importcpp: "#.is_any_specified()".} ## \
## Returns true if any properties have been specified, false otherwise.

proc setOrigin*(this: WindowProperties, origin: LPoint2i) {.importcpp: "#.set_origin(#)".} ## \
## Specifies the origin on the screen (in pixels, relative to the top-left
## corner) at which the window should appear.  This is the origin of the top-
## left corner of the useful part of the window, not including decorations.

proc setOrigin*(this: WindowProperties, x_origin: int, y_origin: int) {.importcpp: "#.set_origin(#, #)".} ## \
## Specifies the origin on the screen (in pixels, relative to the top-left
## corner) at which the window should appear.  This is the origin of the top-
## left corner of the useful part of the window, not including decorations.

proc getOrigin*(this: WindowProperties): LPoint2i {.importcpp: "#.get_origin()".} ## \
## Returns the coordinates of the window's top-left corner, not including
## decorations.

proc getXOrigin*(this: WindowProperties): int {.importcpp: "#.get_x_origin()".} ## \
## Returns the x coordinate of the window's top-left corner, not including
## decorations.

proc getYOrigin*(this: WindowProperties): int {.importcpp: "#.get_y_origin()".} ## \
## Returns the y coordinate of the window's top-left corner, not including
## decorations.

proc hasOrigin*(this: WindowProperties): bool {.importcpp: "#.has_origin()".} ## \
## Returns true if the window origin has been specified, false otherwise.

proc clearOrigin*(this: WindowProperties) {.importcpp: "#.clear_origin()".} ## \
## Removes the origin specification from the properties.

proc setSize*(this: WindowProperties, size: LVector2i) {.importcpp: "#.set_size(#)".} ## \
## Specifies the requested size of the window, in pixels.  This is the size of
## the useful part of the window, not including decorations.

proc setSize*(this: WindowProperties, x_size: int, y_size: int) {.importcpp: "#.set_size(#, #)".} ## \
## Specifies the requested size of the window, in pixels.  This is the size of
## the useful part of the window, not including decorations.

proc getSize*(this: WindowProperties): LVector2i {.importcpp: "#.get_size()".} ## \
## Returns size in pixels of the useful part of the window, not including
## decorations.

proc getXSize*(this: WindowProperties): int {.importcpp: "#.get_x_size()".} ## \
## Returns size in pixels in the x dimension of the useful part of the window,
## not including decorations.  That is, this is the window's width.

proc getYSize*(this: WindowProperties): int {.importcpp: "#.get_y_size()".} ## \
## Returns size in pixels in the y dimension of the useful part of the window,
## not including decorations.  That is, this is the window's height.

proc hasSize*(this: WindowProperties): bool {.importcpp: "#.has_size()".} ## \
## Returns true if the window size has been specified, false otherwise.

proc clearSize*(this: WindowProperties) {.importcpp: "#.clear_size()".} ## \
## Removes the size specification from the properties.

proc hasMouseMode*(this: WindowProperties): bool {.importcpp: "#.has_mouse_mode()".}

proc clearMouseMode*(this: WindowProperties) {.importcpp: "#.clear_mouse_mode()".} ## \
## Removes the mouse_mode specification from the properties.

proc setTitle*(this: WindowProperties, title: string) {.importcpp: "#.set_title(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the title that should be assigned to the window.

proc getTitle*(this: WindowProperties): string {.importcpp: "nimStringFromStdString(#.get_title())", header: stringConversionCode.} ## \
## Returns the window's title.

proc hasTitle*(this: WindowProperties): bool {.importcpp: "#.has_title()".} ## \
## Returns true if the window title has been specified, false otherwise.

proc clearTitle*(this: WindowProperties) {.importcpp: "#.clear_title()".} ## \
## Removes the title specification from the properties.

proc setUndecorated*(this: WindowProperties, undecorated: bool) {.importcpp: "#.set_undecorated(#)".} ## \
## Specifies whether the window should be created with a visible title and
## border (false, the default) or not (true).

proc getUndecorated*(this: WindowProperties): bool {.importcpp: "#.get_undecorated()".} ## \
## Returns true if the window has no border.

proc hasUndecorated*(this: WindowProperties): bool {.importcpp: "#.has_undecorated()".} ## \
## Returns true if set_undecorated() has been specified.

proc clearUndecorated*(this: WindowProperties) {.importcpp: "#.clear_undecorated()".} ## \
## Removes the undecorated specification from the properties.

proc setFixedSize*(this: WindowProperties, fixed_size: bool) {.importcpp: "#.set_fixed_size(#)".} ## \
## Specifies whether the window should be resizable by the user.

proc getFixedSize*(this: WindowProperties): bool {.importcpp: "#.get_fixed_size()".} ## \
## Returns true if the window cannot be resized by the user, false otherwise.

proc hasFixedSize*(this: WindowProperties): bool {.importcpp: "#.has_fixed_size()".} ## \
## Returns true if set_fixed_size() has been specified.

proc clearFixedSize*(this: WindowProperties) {.importcpp: "#.clear_fixed_size()".} ## \
## Removes the fixed_size specification from the properties.

proc setFullscreen*(this: WindowProperties, fullscreen: bool) {.importcpp: "#.set_fullscreen(#)".} ## \
## Specifies whether the window should be opened in fullscreen mode (true) or
## normal windowed mode (false, the default).

proc getFullscreen*(this: WindowProperties): bool {.importcpp: "#.get_fullscreen()".} ## \
## Returns true if the window is in fullscreen mode.

proc hasFullscreen*(this: WindowProperties): bool {.importcpp: "#.has_fullscreen()".} ## \
## Returns true if set_fullscreen() has been specified.

proc clearFullscreen*(this: WindowProperties) {.importcpp: "#.clear_fullscreen()".} ## \
## Removes the fullscreen specification from the properties.

proc setForeground*(this: WindowProperties, foreground: bool) {.importcpp: "#.set_foreground(#)".} ## \
## Specifies whether the window should be opened in the foreground (true), or
## left in the background (false).

proc getForeground*(this: WindowProperties): bool {.importcpp: "#.get_foreground()".} ## \
## Returns true if the window is in the foreground.

proc hasForeground*(this: WindowProperties): bool {.importcpp: "#.has_foreground()".} ## \
## Returns true if set_foreground() has been specified.

proc clearForeground*(this: WindowProperties) {.importcpp: "#.clear_foreground()".} ## \
## Removes the foreground specification from the properties.

proc setMinimized*(this: WindowProperties, minimized: bool) {.importcpp: "#.set_minimized(#)".} ## \
## Specifies whether the window should be created minimized (true), or normal
## (false).

proc getMinimized*(this: WindowProperties): bool {.importcpp: "#.get_minimized()".} ## \
## Returns true if the window is minimized.

proc hasMinimized*(this: WindowProperties): bool {.importcpp: "#.has_minimized()".} ## \
## Returns true if set_minimized() has been specified.

proc clearMinimized*(this: WindowProperties) {.importcpp: "#.clear_minimized()".} ## \
## Removes the minimized specification from the properties.

proc setRawMice*(this: WindowProperties, raw_mice: bool) {.importcpp: "#.set_raw_mice(#)".} ## \
## Specifies whether the window should read the raw mouse devices.

proc getRawMice*(this: WindowProperties): bool {.importcpp: "#.get_raw_mice()".} ## \
## Returns true if the window reads the raw mice.

proc hasRawMice*(this: WindowProperties): bool {.importcpp: "#.has_raw_mice()".} ## \
## Returns true if set_raw_mice() has been specified.

proc clearRawMice*(this: WindowProperties) {.importcpp: "#.clear_raw_mice()".} ## \
## Removes the raw_mice specification from the properties.

proc setOpen*(this: WindowProperties, open: bool) {.importcpp: "#.set_open(#)".} ## \
## Specifies whether the window should be open.  It is legal to create a
## GraphicsWindow in the closed state, and later request it to open by
## changing this flag.

proc getOpen*(this: WindowProperties): bool {.importcpp: "#.get_open()".} ## \
## Returns true if the window is open.

proc hasOpen*(this: WindowProperties): bool {.importcpp: "#.has_open()".} ## \
## Returns true if set_open() has been specified.

proc clearOpen*(this: WindowProperties) {.importcpp: "#.clear_open()".} ## \
## Removes the open specification from the properties.

proc setCursorHidden*(this: WindowProperties, cursor_hidden: bool) {.importcpp: "#.set_cursor_hidden(#)".} ## \
## Specifies whether the mouse cursor should be visible.

proc getCursorHidden*(this: WindowProperties): bool {.importcpp: "#.get_cursor_hidden()".} ## \
## Returns true if the mouse cursor is invisible.

proc hasCursorHidden*(this: WindowProperties): bool {.importcpp: "#.has_cursor_hidden()".} ## \
## Returns true if set_cursor_hidden() has been specified.

proc clearCursorHidden*(this: WindowProperties) {.importcpp: "#.clear_cursor_hidden()".} ## \
## Removes the cursor_hidden specification from the properties.

proc setIconFilename*(this: WindowProperties, icon_filename: Filename) {.importcpp: "#.set_icon_filename(#)".} ## \
## Specifies the file that contains the icon to associate with the window when
## it is minimized.

proc getIconFilename*(this: WindowProperties): Filename {.importcpp: "#.get_icon_filename()".} ## \
## Returns the icon filename associated with the window.

proc hasIconFilename*(this: WindowProperties): bool {.importcpp: "#.has_icon_filename()".} ## \
## Returns true if set_icon_filename() has been specified.

proc clearIconFilename*(this: WindowProperties) {.importcpp: "#.clear_icon_filename()".} ## \
## Removes the icon_filename specification from the properties.

proc setCursorFilename*(this: WindowProperties, cursor_filename: Filename) {.importcpp: "#.set_cursor_filename(#)".} ## \
## Specifies the file that contains the icon to associate with the mouse
## cursor when it is within the window (and visible).

proc getCursorFilename*(this: WindowProperties): Filename {.importcpp: "#.get_cursor_filename()".} ## \
## Returns the icon filename associated with the mouse cursor.

proc hasCursorFilename*(this: WindowProperties): bool {.importcpp: "#.has_cursor_filename()".} ## \
## Returns true if set_cursor_filename() has been specified.

proc clearCursorFilename*(this: WindowProperties) {.importcpp: "#.clear_cursor_filename()".} ## \
## Removes the cursor_filename specification from the properties.

proc hasZOrder*(this: WindowProperties): bool {.importcpp: "#.has_z_order()".} ## \
## Returns true if the window z_order has been specified, false otherwise.

proc clearZOrder*(this: WindowProperties) {.importcpp: "#.clear_z_order()".} ## \
## Removes the z_order specification from the properties.

proc setParentWindow*(this: WindowProperties, parent_window: WindowHandle) {.importcpp: "#.set_parent_window(#)".} ## \
## Specifies the window that this window should be attached to.  If this is
## NULL or unspecified, the window will be created as a toplevel window on the
## desktop; if this is non-NULL, the window will be bound as a child window to
## the indicated parent window.
##
## You should use GraphicsPipe::make_window_handle() to create an instance of
## a WindowHandle object given an appropriate OS-specific window handle
## representation.  Each OS-specific GraphicsPipe class defines a
## make_window_handle() method that returns an appropriate WindowHandle object
## to wrap the particular OS-specific representation.

proc setParentWindow*(this: WindowProperties) {.importcpp: "#.set_parent_window()".} ## \
## Specifies the window that this window should be attached to.  If this is
## NULL or unspecified, the window will be created as a toplevel window on the
## desktop; if this is non-NULL, the window will be bound as a child window to
## the indicated parent window.
##
## You should use GraphicsPipe::make_window_handle() to create an instance of
## a WindowHandle object given an appropriate OS-specific window handle
## representation.  Each OS-specific GraphicsPipe class defines a
## make_window_handle() method that returns an appropriate WindowHandle object
## to wrap the particular OS-specific representation.

proc setParentWindow*(this: WindowProperties, parent: clonglong) {.importcpp: "#.set_parent_window(#)".} ## \
## Specifies the window that this window should be attached to.
##
## This is a deprecated variant on this method, and exists only for backward
## compatibility.  Future code should use the version of set_parent_window()
## below that receives a WindowHandle object; that interface is much more
## robust.
##
## In this deprecated variant, the actual value for "parent" is platform-
## specific.  On Windows, it is the HWND of the parent window, cast to an
## unsigned integer.  On X11, it is the Window pointer of the parent window,
## similarly cast.  On OSX, this is the NSWindow pointer, which doesn't appear
## to work at all.

proc getParentWindow*(this: WindowProperties): WindowHandle {.importcpp: "#.get_parent_window()".} ## \
## Returns the parent window specification, or NULL if there is no parent
## window specified.

proc hasParentWindow*(this: WindowProperties): bool {.importcpp: "#.has_parent_window()".} ## \
## Checks the S_parent_window specification from the properties.

proc clearParentWindow*(this: WindowProperties) {.importcpp: "#.clear_parent_window()".} ## \
## Removes the S_parent_window specification from the properties.

proc addProperties*(this: WindowProperties, other: WindowProperties) {.importcpp: "#.add_properties(#)".} ## \
## Sets any properties that are explicitly specified in other on this object.
## Leaves other properties unchanged.

proc output*(this: WindowProperties, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Sets any properties that are explicitly specified in other on this object.
## Leaves other properties unchanged.

converter upcastToTypedReferenceCount*(this: DisplayRegion): TypedReferenceCount {.importcpp: "(PT(TypedReferenceCount)(#))".}

converter upcastToDrawableRegion*(this: DisplayRegion): DrawableRegion {.importcpp: "((DrawableRegion *)(DisplayRegion *)(#))".}

proc getNumRegions*(this: DisplayRegion): int {.importcpp: "#->get_num_regions()".} ## \
## Returns the number of regions, see set_num_regions.

proc setNumRegions*(this: DisplayRegion, i: int) {.importcpp: "#->set_num_regions(#)".} ## \
## Sets the number of regions that this DisplayRegion indicates.  Usually,
## this number is 1 (and it is always at least 1), and only the first is used
## for rendering.  However, if more than one is provided, you may select which
## one to render into using a geometry shader (gl_ViewportIndex in GLSL).

proc getDimensions*(this: DisplayRegion, i: int): LVecBase4 {.importcpp: "#->get_dimensions(#)".} ## \
## Retrieves the coordinates of the DisplayRegion's rectangle within its
## GraphicsOutput.  These numbers will be in the range [0..1].

proc getDimensions*(this: DisplayRegion): LVecBase4 {.importcpp: "#->get_dimensions()".} ## \
## Retrieves the coordinates of the DisplayRegion's rectangle within its
## GraphicsOutput.  These numbers will be in the range [0..1].

proc getLeft*(this: DisplayRegion, i: int): float32 {.importcpp: "#->get_left(#)".} ## \
## Retrieves the x coordinate of the left edge of the rectangle within its
## GraphicsOutput.  This number will be in the range [0..1].

proc getLeft*(this: DisplayRegion): float32 {.importcpp: "#->get_left()".} ## \
## Retrieves the x coordinate of the left edge of the rectangle within its
## GraphicsOutput.  This number will be in the range [0..1].

proc getRight*(this: DisplayRegion, i: int): float32 {.importcpp: "#->get_right(#)".} ## \
## Retrieves the x coordinate of the right edge of the rectangle within its
## GraphicsOutput.  This number will be in the range [0..1].

proc getRight*(this: DisplayRegion): float32 {.importcpp: "#->get_right()".} ## \
## Retrieves the x coordinate of the right edge of the rectangle within its
## GraphicsOutput.  This number will be in the range [0..1].

proc getBottom*(this: DisplayRegion, i: int): float32 {.importcpp: "#->get_bottom(#)".} ## \
## Retrieves the y coordinate of the bottom edge of the rectangle within its
## GraphicsOutput.  This number will be in the range [0..1].

proc getBottom*(this: DisplayRegion): float32 {.importcpp: "#->get_bottom()".} ## \
## Retrieves the y coordinate of the bottom edge of the rectangle within its
## GraphicsOutput.  This number will be in the range [0..1].

proc getTop*(this: DisplayRegion, i: int): float32 {.importcpp: "#->get_top(#)".} ## \
## Retrieves the y coordinate of the top edge of the rectangle within its
## GraphicsOutput.  This number will be in the range [0..1].

proc getTop*(this: DisplayRegion): float32 {.importcpp: "#->get_top()".} ## \
## Retrieves the y coordinate of the top edge of the rectangle within its
## GraphicsOutput.  This number will be in the range [0..1].

proc setDimensions*(this: DisplayRegion, dimensions: LVecBase4) {.importcpp: "#->set_dimensions(#)".} ## \
## Changes the portion of the framebuffer this DisplayRegion corresponds to.
## The parameters range from 0 to 1, where 0,0 is the lower left corner and
## 1,1 is the upper right; (0, 1, 0, 1) represents the whole screen.

proc setDimensions*(this: DisplayRegion, l: float32, r: float32, b: float32, t: float32) {.importcpp: "#->set_dimensions(#, #, #, #)".} ## \
## Changes the portion of the framebuffer this DisplayRegion corresponds to.
## The parameters range from 0 to 1, where 0,0 is the lower left corner and
## 1,1 is the upper right; (0, 1, 0, 1) represents the whole screen.

proc setDimensions*(this: DisplayRegion, i: int, dimensions: LVecBase4) {.importcpp: "#->set_dimensions(#, #)".} ## \
## Changes the portion of the framebuffer this DisplayRegion corresponds to.
## The parameters range from 0 to 1, where 0,0 is the lower left corner and
## 1,1 is the upper right; (0, 1, 0, 1) represents the whole screen.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc setDimensions*(this: DisplayRegion, i: int, l: float32, r: float32, b: float32, t: float32) {.importcpp: "#->set_dimensions(#, #, #, #, #)".} ## \
## Changes the portion of the framebuffer this DisplayRegion corresponds to.
## The parameters range from 0 to 1, where 0,0 is the lower left corner and
## 1,1 is the upper right; (0, 1, 0, 1) represents the whole screen.

proc getWindow*(this: DisplayRegion): GraphicsOutput {.importcpp: "#->get_window()".} ## \
## Returns the GraphicsOutput that this DisplayRegion is ultimately associated
## with, or NULL if no window is associated.

proc getPipe*(this: DisplayRegion): GraphicsPipe {.importcpp: "#->get_pipe()".} ## \
## Returns the GraphicsPipe that this DisplayRegion is ultimately associated
## with, or NULL if no pipe is associated.

proc isStereo*(this: DisplayRegion): bool {.importcpp: "#->is_stereo()".} ## \
## Returns true if this is a StereoDisplayRegion, false otherwise.

converter upcastToGraphicsOutputBase*(this: GraphicsOutput): GraphicsOutputBase {.importcpp: "(PT(GraphicsOutputBase)(#))".}

converter upcastToDrawableRegion*(this: GraphicsOutput): DrawableRegion {.importcpp: "((DrawableRegion *)(GraphicsOutput *)(#))".}

proc getGsg*(this: GraphicsOutput): GraphicsStateGuardian {.importcpp: "#->get_gsg()".} ## \
## Returns the GSG that is associated with this window.  There is a one-to-one
## association between windows and GSG's.
##
## This may return NULL if the graphics context has not yet been created for
## the window, e.g.  before the first frame has rendered; or after the window
## has been closed.

proc getPipe*(this: GraphicsOutput): GraphicsPipe {.importcpp: "#->get_pipe()".} ## \
## Returns the GraphicsPipe that this window is associated with.  It is
## possible that the GraphicsPipe might have been deleted while an outstanding
## PT(GraphicsOutput) prevented all of its children windows from also being
## deleted; in this unlikely case, get_pipe() may return NULL.

proc getEngine*(this: GraphicsOutput): GraphicsEngine {.importcpp: "#->get_engine()".} ## \
## Returns the graphics engine that created this output.  Since there is
## normally only one GraphicsEngine object in an application, this is usually
## the same as the global GraphicsEngine.

proc getName*(this: GraphicsOutput): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Returns the name that was passed to the GraphicsOutput constructor.

proc releaseAll*(this: GraphicsStateGuardian) {.importcpp: "#->release_all()".} ## \
## Releases all prepared objects.

proc releaseAllTextures*(this: GraphicsStateGuardian): int {.importcpp: "#->release_all_textures()".} ## \
## Frees the resources for all textures associated with this GSG.

proc releaseAllSamplers*(this: GraphicsStateGuardian): int {.importcpp: "#->release_all_samplers()".} ## \
## Frees the resources for all samplers associated with this GSG.

proc releaseAllGeoms*(this: GraphicsStateGuardian): int {.importcpp: "#->release_all_geoms()".} ## \
## Frees the resources for all geoms associated with this GSG.

proc releaseAllVertexBuffers*(this: GraphicsStateGuardian): int {.importcpp: "#->release_all_vertex_buffers()".} ## \
## Frees the resources for all vertex buffers associated with this GSG.

proc releaseAllIndexBuffers*(this: GraphicsStateGuardian): int {.importcpp: "#->release_all_index_buffers()".} ## \
## Frees the resources for all index buffers associated with this GSG.

proc releaseAllShaderBuffers*(this: GraphicsStateGuardian): int {.importcpp: "#->release_all_shader_buffers()".} ## \
## Frees the resources for all index buffers associated with this GSG.

proc setActive*(this: GraphicsStateGuardian, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets the active flag associated with the GraphicsStateGuardian.  If the
## GraphicsStateGuardian is marked inactive, nothing is rendered.  This is not
## normally turned off unless there is a problem with the rendering detected
## at a low level.

proc isActive*(this: GraphicsStateGuardian): bool {.importcpp: "#->is_active()".} ## \
## Returns the active flag associated with the GraphicsStateGuardian.

proc isValid*(this: GraphicsStateGuardian): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the GSG has been correctly initialized within a graphics
## context, false if there has been some problem or it hasn't been initialized
## yet.

proc needsReset*(this: GraphicsStateGuardian): bool {.importcpp: "#->needs_reset()".} ## \
## Returns true if the gsg is marked as needing a reset.

proc setIncompleteRender*(this: GraphicsStateGuardian, incomplete_render: bool) {.importcpp: "#->set_incomplete_render(#)".} ## \
## Sets the incomplete_render flag.  When this is true, the frame will be
## rendered even if some of the geometry or textures in the scene are not
## available (e.g.  they have been temporarily paged out).  When this is
## false, the frame will be held up while this data is reloaded.
##
## Setting this true allows for a smoother frame rate, but occasionally parts
## of the frame will be invisible or missing (they will generally come in
## within a second or two).  Setting this false guarantees that every frame
## will be complete, but may cause more chugs as things are loaded up at
## runtime.
##
## You may want to set this false during loading screens, to guarantee that
## all of your assets are available by the time you take the loading screen
## down.
##
## This flag may also be set individually on each DisplayRegion.  It will be
## considered true for a given DisplayRegion only if it is true on both the
## GSG and on the DisplayRegion.

proc setLoader*(this: GraphicsStateGuardian, loader: Loader) {.importcpp: "#->set_loader(#)".} ## \
## Sets the Loader object that will be used by this GSG to load textures when
## necessary, if get_incomplete_render() is true.

proc getLoader*(this: GraphicsStateGuardian): Loader {.importcpp: "#->get_loader()".} ## \
## Returns the Loader object that will be used by this GSG to load textures
## when necessary, if get_incomplete_render() is true.

proc setShaderGenerator*(this: GraphicsStateGuardian, shader_generator: ShaderGenerator) {.importcpp: "#->set_shader_generator(#)".} ## \
## Sets the ShaderGenerator object that will be used by this GSG to generate
## shaders when necessary.

proc getShaderGenerator*(this: GraphicsStateGuardian): ShaderGenerator {.importcpp: "#->get_shader_generator()".} ## \
## Returns the ShaderGenerator object that will be used by this GSG to
## generate shaders when necessary.

proc getPipe*(this: GraphicsStateGuardian): GraphicsPipe {.importcpp: "#->get_pipe()".} ## \
## Returns the graphics pipe on which this GSG was created.

proc getEngine*(this: GraphicsStateGuardian): GraphicsEngine {.importcpp: "#->get_engine()".}

proc getThreadingModel*(this: GraphicsStateGuardian): GraphicsThreadingModel {.importcpp: "#->get_threading_model()".} ## \
## Returns the threading model that was used to create this GSG.

proc isHardware*(this: GraphicsStateGuardian): bool {.importcpp: "#->is_hardware()".} ## \
## Returns true if this GSG appears to be hardware-accelerated, or false if it
## is known to be software only.

proc getMaxTextureStages*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_texture_stages()".} ## \
## Returns the maximum number of simultaneous textures that may be applied to
## geometry with multitexturing, as supported by this particular GSG.  If you
## exceed this number, the lowest-priority texture stages will not be applied.
## Use TextureStage::set_priority() to adjust the relative importance of the
## different texture stages.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

proc getMax3dTextureDimension*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_3d_texture_dimension()".} ## \
## Returns the largest possible texture size in any one dimension for a 3-d
## texture, or -1 if there is no particular limit.  Returns 0 if 3-d textures
## are not supported.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

proc getMax2dTextureArrayLayers*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_2d_texture_array_layers()".} ## \
## Returns the largest possible number of pages, or -1 if there is no
## particular limit.  Returns 0 if 2-d texture arrays not supported.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

proc getMaxCubeMapDimension*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_cube_map_dimension()".} ## \
## Returns the largest possible texture size in any one dimension for a cube
## map texture, or -1 if there is no particular limit.  Returns 0 if cube map
## textures are not supported.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

proc getMaxBufferTextureSize*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_buffer_texture_size()".} ## \
## Returns the largest possible buffer texture size, or -1 if there is no
## particular limit.  Returns 0 if cube map textures are not supported.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

proc getSupportsTextureCombine*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_texture_combine()".} ## \
## Returns true if this particular GSG can use the TextureStage::M_combine
## mode, which includes all of the texture blend modes specified by
## set_combine_rgb() and/or set_combine_alpha().  If this is false, you must
## limit yourself to using the simpler blend modes.

proc getSupportsTextureSavedResult*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_texture_saved_result()".} ## \
## Returns true if this GSG can use the TextureStage::CS_last_saved_result
## source, which allows you to save the result of a TextureStage and re-use it
## for multiple inputs.

proc getSupportsTextureDot3*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_texture_dot3()".} ## \
## Returns true if this GSG can use the TextureStage::CM_dot3_rgb or
## CM_dot3_rgba combine modes.

proc getSupports3dTexture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_3d_texture()".} ## \
## Returns true if this GSG can render 3-d (volumetric) textures.

proc getSupports2dTextureArray*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_2d_texture_array()".} ## \
## Returns true if this GSG can render 2-d textures array.

proc getSupportsCubeMap*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_cube_map()".} ## \
## Returns true if this GSG can render cube map textures.

proc getSupportsBufferTexture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_buffer_texture()".} ## \
## Returns true if this GSG can render buffer textures.

proc getSupportsCubeMapArray*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_cube_map_array()".} ## \
## Returns true if this GSG can render cube map arrays.

proc getSupportsTexNonPow2*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_tex_non_pow2()".} ## \
## Returns true if this GSG can handle non power of two sized textures.

proc getSupportsCompressedTexture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_compressed_texture()".} ## \
## Returns true if this GSG can compress textures as it loads them into
## texture memory, and/or accept pre-compressed textures for storing.

proc getMaxLights*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_lights()".} ## \
## Returns the maximum number of simultaneous lights that may be rendered on
## geometry, or -1 if there is no particular limit.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

proc getMaxClipPlanes*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_clip_planes()".} ## \
## Returns the maximum number of simultaneous clip planes that may be applied
## to geometry, or -1 if there is no particular limit.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

proc getMaxVertexTransforms*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_vertex_transforms()".} ## \
## Returns the maximum number of transform matrices that may be simultaneously
## used to transform any one vertex by the graphics hardware.  If this number
## is 0, then the hardware (or the graphics backend) doesn't support soft-
## skinned vertices (in which case Panda will animate the vertices in
## software).
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

proc getMaxVertexTransformIndices*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_vertex_transform_indices()".} ## \
## Returns the maximum number of transforms there may be in a single
## TransformTable for this graphics hardware.  If this number is 0 (but
## get_max_transforms() is nonzero), then the graphics hardware (or API)
## doesn't support indexed transforms, but can support direct transform
## references.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

proc getCopyTextureInverted*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_copy_texture_inverted()".} ## \
## Returns true if this particular GSG has the property that any framebuffer-
## to-texture copy results in a texture that is upside-down and backwards from
## Panda's usual convention; that is, it copies into a texture from the bottom
## up instead of from the top down.
##
## If this is true, then on offscreen GraphicsBuffer created for the purposes
## of rendering into a texture should be created with the invert flag set
## true, to compensate.  Panda will do this automatically if you create an
## offscreen buffer using GraphicsOutput::make_texture_buffer().

proc getSupportsGenerateMipmap*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_generate_mipmap()".} ## \
## Returns true if this particular GSG can generate mipmaps for a texture
## automatically, or if they must be generated in software.  If this is true,
## then mipmaps can safely be enabled for rendered textures (e.g.  using the
## MultitexReducer).

proc getSupportsDepthTexture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_depth_texture()".} ## \
## Returns true if this particular GSG supports textures whose format is
## F_depth_stencil.  This returns true if the GSG supports GL_DEPTH_COMPONENT
## textures, which are considered a limited but still valid case of
## F_depth_stencil.

proc getSupportsDepthStencil*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_depth_stencil()".} ## \
## Returns true if this particular GSG supports textures whose format is
## F_depth_stencil.  This only returns true if the GSG supports the full
## packed depth-stencil functionality.

proc getSupportsLuminanceTexture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_luminance_texture()".} ## \
## Returns true if this particular GSG supports luminance textures.

proc getSupportsSamplerObjects*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_sampler_objects()".} ## \
## Returns true if this particular GSG supports the use of sampler objects to
## record texture sampling parameters separately from the texture objects.
## This doesn't really affect functionality, but if this is false, it may mean
## that using the same texture with different SamplerState objects will result
## in reduced performance.

proc getSupportsBasicShaders*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_basic_shaders()".} ## \
## Returns true if this particular GSG supports arbfp1+arbvp1 or above.

proc getSupportsGeometryShaders*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_geometry_shaders()".} ## \
## Returns true if this particular GSG supports geometry shaders.

proc getSupportsTessellationShaders*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_tessellation_shaders()".} ## \
## Returns true if this particular GSG supports tesselation shaders.

proc getSupportsComputeShaders*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_compute_shaders()".} ## \
## Returns true if this particular GSG supports compute shaders.

proc getSupportsGlsl*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_glsl()".} ## \
## Returns true if this particular GSG supports GLSL shaders.

proc getSupportsStencil*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_stencil()".} ## \
## Returns true if this particular GSG supports stencil buffers at all.

proc getSupportsTwoSidedStencil*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_two_sided_stencil()".} ## \
## Returns true if this particular GSG supports two sided stencil: different
## stencil settings for the front and back side of the same polygon.

proc getSupportsGeometryInstancing*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_geometry_instancing()".} ## \
## Returns true if this particular GSG supports hardware geometry instancing:
## the ability to render multiple copies of a model.  In OpenGL, this is done
## using the EXT_draw_instanced extension.

proc getSupportsIndirectDraw*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_indirect_draw()".} ## \
## Returns true if this particular GSG supports draw calls for which the
## information comes from a buffer.

proc getSupportsOcclusionQuery*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_occlusion_query()".} ## \
## Returns true if this GSG supports an occlusion query.  If this is true,
## then begin_occlusion_query() and end_occlusion_query() may be called to
## bracket a sequence of draw_triangles() (or whatever) calls to measure
## pixels that pass the depth test.

proc getSupportsTimerQuery*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_timer_query()".} ## \
## Returns true if this GSG supports a timer query.

proc getTimerQueriesActive*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_timer_queries_active()".} ## \
## Returns true if timer queries are currently enabled on this GSG.

proc getMaxColorTargets*(this: GraphicsStateGuardian): int {.importcpp: "#->get_max_color_targets()".} ## \
## Returns the maximum number of simultaneous color textures that may be
## attached for render-to-texture, as supported by this particular GSG.  If
## you exceed this number, the lowest-priority render targets will not be
## applied.  Use RenderTarget::set_priority() to adjust the relative
## importance of the different render targets.
##
## The value returned may not be meaningful until after the graphics context
## has been fully created (e.g.  the window has been opened).

proc getMaximumSimultaneousRenderTargets*(this: GraphicsStateGuardian): int {.importcpp: "#->get_maximum_simultaneous_render_targets()".} ## \
## Deprecated.  Use get_max_color_targets() instead, which returns the exact
## same value.

proc getSupportsDualSourceBlending*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_supports_dual_source_blending()".} ## \
## Returns true if dual source (incoming1_color and incoming1_alpha) blend
## operands are supported by this GSG.

proc getSupportsCgProfile*(this: GraphicsStateGuardian, name: string): bool {.importcpp: "#->get_supports_cg_profile(nimStringToStdString(#))", header: stringConversionCode.}

proc getColorScaleViaLighting*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_color_scale_via_lighting()".} ## \
## Returns true if this particular GSG can implement (or would prefer to
## implement) set color and/or color scale using materials and/or ambient
## lights, or false if we need to actually munge the color.

proc getAlphaScaleViaTexture*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_alpha_scale_via_texture()".} ## \
## Returns true if this particular GSG can implement (or would prefer to
## implement) an alpha scale via an additional Texture layer, or false if we
## need to actually munge the alpha.

proc getAlphaScaleViaTexture*(this: GraphicsStateGuardian, tex_attrib: TextureAttrib): bool {.importcpp: "#->get_alpha_scale_via_texture(#)".} ## \
## This variant of get_alpha_scale_via_texture() answers the question of
## whether the GSG can implement an alpha scale via an additional Texture
## layer, considering the current TextureAttrib that will be in effect.  This
## considers whether there is at least one additional texture slot available
## on the GSG.

proc getRuntimeColorScale*(this: GraphicsStateGuardian): bool {.importcpp: "#->get_runtime_color_scale()".} ## \
## Returns true if this particular GSG can implement (or would prefer to
## implement) set color and/or color scale directly, without requiring any
## munging of vertices or tricks with lighting.

proc getAlphaScaleTextureStage*(_: typedesc[GraphicsStateGuardian]): TextureStage {.importcpp: "GraphicsStateGuardian::get_alpha_scale_texture_stage()", header: "graphicsStateGuardian.h".} ## \
## Returns the TextureStage that will be used to apply an alpha scale, if
## get_alpha_scale_via_texture() returns true.

proc setCoordinateSystem*(this: GraphicsStateGuardian, cs: CoordinateSystem) {.importcpp: "#->set_coordinate_system(#)".}

proc getCoordinateSystem*(this: GraphicsStateGuardian): CoordinateSystem {.importcpp: "#->get_coordinate_system()".} ## \
## Returns the coordinate system in effect on this particular gsg.  Normally,
## this will be the default coordinate system, but it might be set differently
## at runtime.

proc getInternalCoordinateSystem*(this: GraphicsStateGuardian): CoordinateSystem {.importcpp: "#->get_internal_coordinate_system()".}

proc getPreparedObjects*(this: GraphicsStateGuardian): PreparedGraphicsObjects {.importcpp: "#->get_prepared_objects()".}

proc setGamma*(this: GraphicsStateGuardian, gamma: float32): bool {.importcpp: "#->set_gamma(#)".}

proc getGamma*(this: GraphicsStateGuardian): float32 {.importcpp: "#->get_gamma()".}

proc restoreGamma*(this: GraphicsStateGuardian) {.importcpp: "#->restore_gamma()".}

proc setFlashTexture*(this: GraphicsStateGuardian, tex: Texture) {.importcpp: "#->set_flash_texture(#)".}

proc clearFlashTexture*(this: GraphicsStateGuardian) {.importcpp: "#->clear_flash_texture()".}

proc getFlashTexture*(this: GraphicsStateGuardian): Texture {.importcpp: "#->get_flash_texture()".}

proc hasExtension*(this: GraphicsStateGuardian, extension: string): bool {.importcpp: "#->has_extension(nimStringToStdString(#))", header: stringConversionCode.}

proc getDriverVendor*(this: GraphicsStateGuardian): string {.importcpp: "nimStringFromStdString(#->get_driver_vendor())", header: stringConversionCode.}

proc getDriverRenderer*(this: GraphicsStateGuardian): string {.importcpp: "nimStringFromStdString(#->get_driver_renderer())", header: stringConversionCode.}

proc getDriverVersion*(this: GraphicsStateGuardian): string {.importcpp: "nimStringFromStdString(#->get_driver_version())", header: stringConversionCode.}

proc getDriverVersionMajor*(this: GraphicsStateGuardian): int {.importcpp: "#->get_driver_version_major()".}

proc getDriverVersionMinor*(this: GraphicsStateGuardian): int {.importcpp: "#->get_driver_version_minor()".}

proc getDriverShaderVersionMajor*(this: GraphicsStateGuardian): int {.importcpp: "#->get_driver_shader_version_major()".}

proc getDriverShaderVersionMinor*(this: GraphicsStateGuardian): int {.importcpp: "#->get_driver_shader_version_minor()".}

proc setScene*(this: GraphicsStateGuardian, scene_setup: SceneSetup): bool {.importcpp: "#->set_scene(#)".}

proc getScene*(this: GraphicsStateGuardian): SceneSetup {.importcpp: "#->get_scene()".}

proc beginScene*(this: GraphicsStateGuardian): bool {.importcpp: "#->begin_scene()".}

proc endScene*(this: GraphicsStateGuardian) {.importcpp: "#->end_scene()".}

converter getClassType*(_: typedesc[GraphicsStateGuardian]): TypeHandle {.importcpp: "GraphicsStateGuardian::get_class_type()", header: "graphicsStateGuardian.h".}

proc newGraphicsEngine*(): GraphicsEngine {.importcpp: "new GraphicsEngine()".} ## \
## Creates a new GraphicsEngine object.  The Pipeline is normally left to
## default to NULL, which indicates the global render pipeline, but it may be
## any Pipeline you choose.

proc setThreadingModel*(this: GraphicsEngine, threading_model: GraphicsThreadingModel) {.importcpp: "#->set_threading_model(#)".} ## \
## Specifies how future objects created via make_gsg(), make_buffer(), and
## make_output() will be threaded.  This does not affect any already-created
## objects.

proc getThreadingModel*(this: GraphicsEngine): GraphicsThreadingModel {.importcpp: "#->get_threading_model()".} ## \
## Returns the threading model that will be applied to future objects.  See
## set_threading_model().

proc initGraphicsThreadingModel*(copy: GraphicsThreadingModel): GraphicsThreadingModel {.importcpp: "GraphicsThreadingModel(#)".}

converter initGraphicsThreadingModel*(model: string): GraphicsThreadingModel {.importcpp: "GraphicsThreadingModel(nimStringToStdString(#))", header: stringConversionCode.} ## \
## The threading model accepts a string representing the names of the two
## threads that will process cull and draw for the given window, separated by
## a slash.  The names are completely arbitrary and are used only to
## differentiate threads.  The two names may be the same, meaning the same
## thread, or each may be the empty string, which represents the previous
## thread.
##
## Thus, for example, "cull/draw" indicates that the window will be culled in
## a thread called "cull", and drawn in a separate thread called "draw".
## "draw/draw" or simply "draw" indicates the window will be culled and drawn
## in the same thread, "draw". On the other hand, "/draw" indicates the thread
## will be culled in the main, or app thread, and drawn in a separate thread
## named "draw".  The empty string, "" or "/", indicates the thread will be
## culled and drawn in the main thread; that is to say, a single-process
## model.
##
## Finally, if the threading model begins with a "-" character, then cull and
## draw are run simultaneously, in the same thread, with no binning or state
## sorting.  It simplifies the cull process but it forces the scene to render
## in scene graph order; state sorting and alpha sorting is lost.

proc initGraphicsThreadingModel*(): GraphicsThreadingModel {.importcpp: "GraphicsThreadingModel()".} ## \
## The threading model accepts a string representing the names of the two
## threads that will process cull and draw for the given window, separated by
## a slash.  The names are completely arbitrary and are used only to
## differentiate threads.  The two names may be the same, meaning the same
## thread, or each may be the empty string, which represents the previous
## thread.
##
## Thus, for example, "cull/draw" indicates that the window will be culled in
## a thread called "cull", and drawn in a separate thread called "draw".
## "draw/draw" or simply "draw" indicates the window will be culled and drawn
## in the same thread, "draw". On the other hand, "/draw" indicates the thread
## will be culled in the main, or app thread, and drawn in a separate thread
## named "draw".  The empty string, "" or "/", indicates the thread will be
## culled and drawn in the main thread; that is to say, a single-process
## model.
##
## Finally, if the threading model begins with a "-" character, then cull and
## draw are run simultaneously, in the same thread, with no binning or state
## sorting.  It simplifies the cull process but it forces the scene to render
## in scene graph order; state sorting and alpha sorting is lost.

proc getModel*(this: GraphicsThreadingModel): string {.importcpp: "nimStringFromStdString(#.get_model())", header: stringConversionCode.} ## \
## Returns the string that describes the threading model.  See the
## constructor.

proc getCullName*(this: GraphicsThreadingModel): string {.importcpp: "nimStringFromStdString(#.get_cull_name())", header: stringConversionCode.} ## \
## Returns the name of the thread that will handle culling in this model.

proc setCullName*(this: GraphicsThreadingModel, cull_name: string) {.importcpp: "#.set_cull_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name of the thread that will handle culling in this model.
## This won't change any windows that were already created with this model;
## this only has an effect on newly-opened windows.

proc getCullStage*(this: GraphicsThreadingModel): int {.importcpp: "#.get_cull_stage()".} ## \
## Returns the pipeline stage from which the cull thread should access data.
## This will be 0 if the cull is run in the same thread as app, or 1 if it is
## its own thread.

proc getDrawName*(this: GraphicsThreadingModel): string {.importcpp: "nimStringFromStdString(#.get_draw_name())", header: stringConversionCode.} ## \
## Returns the name of the thread that will handle sending the actual graphics
## primitives to the graphics API in this model.

proc setDrawName*(this: GraphicsThreadingModel, cull_name: string) {.importcpp: "#.set_draw_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name of the thread that will handle drawing in this model.
## This won't change any windows that were already created with this model;
## this only has an effect on newly-opened windows.

proc getDrawStage*(this: GraphicsThreadingModel): int {.importcpp: "#.get_draw_stage()".} ## \
## Returns the pipeline stage from which the draw thread should access data.
## This will be the same value as get_cull_stage() if cull and draw are run in
## the same thread, or one more than that value if draw should be in its own
## thread.

proc getCullSorting*(this: GraphicsThreadingModel): bool {.importcpp: "#.get_cull_sorting()".} ## \
## Returns true if the model involves a separate cull pass, or false if
## culling happens implicitly, at the same time as draw.

proc setCullSorting*(this: GraphicsThreadingModel, cull_sorting: bool) {.importcpp: "#.set_cull_sorting(#)".} ## \
## Changes the flag that indicates whether the threading model involves a
## separate cull pass.  This won't change any windows that were already
## created with this model; this only has an effect on newly-opened windows.

proc isSingleThreaded*(this: GraphicsThreadingModel): bool {.importcpp: "#.is_single_threaded()".} ## \
## Returns true if the threading model is a single-threaded model, or false if
## it involves threads.

proc isDefault*(this: GraphicsThreadingModel): bool {.importcpp: "#.is_default()".} ## \
## Returns true if the threading model is the default, cull-then-draw single-
## threaded model, or false otherwise.

proc output*(this: GraphicsThreadingModel, `out`: ostream) {.importcpp: "#.output(#)".}

proc getRenderLock*(this: GraphicsEngine): ReMutex {.importcpp: "#->get_render_lock()".} ## \
## Returns a ReMutex object that is held by the GraphicsEngine during the
## entire call to render_frame().  While you hold this lock you can be
## confident that no part of the frame will be rendered (at least by the app
## thread).

proc setAutoFlip*(this: GraphicsEngine, auto_flip: bool) {.importcpp: "#->set_auto_flip(#)".} ## \
## Set this flag true to indicate the GraphicsEngine should automatically
## cause windows to sync and flip as soon as they have finished drawing,
## rather than waiting for all of the windows to finish drawing first so they
## can flip together.
##
## This only affects the timing of when the flip occurs.  If this is true (the
## default), the flip occurs before render_frame() returns.  If this is false,
## the flip occurs whenever flip_frame() is called, or at the beginning of the
## next call to render_frame(), if flip_frame() is never called.

proc getAutoFlip*(this: GraphicsEngine): bool {.importcpp: "#->get_auto_flip()".} ## \
## Returns the current setting for the auto-flip flag.  See set_auto_flip.

proc setPortalCull*(this: GraphicsEngine, value: bool) {.importcpp: "#->set_portal_cull(#)".} ## \
## Set this flag true to indicate the GraphicsEngine should start portal
## culling

proc getPortalCull*(this: GraphicsEngine): bool {.importcpp: "#->get_portal_cull()".} ## \
## Returns the current setting for the portal culling flag.

proc setDefaultLoader*(this: GraphicsEngine, loader: Loader) {.importcpp: "#->set_default_loader(#)".} ## \
## Sets the Loader object that will be assigned to every GSG created with this
## GraphicsEngine.  See GraphicsStateGuardian::set_loader().

proc getDefaultLoader*(this: GraphicsEngine): Loader {.importcpp: "#->get_default_loader()".} ## \
## Returns the Loader object that will be assigned to every GSG created with
## this GraphicsEngine.  See GraphicsStateGuardian::set_loader().

proc makeOutput*(this: GraphicsEngine, pipe: GraphicsPipe, name: string, sort: int, fb_prop: FrameBufferProperties, win_prop: WindowProperties, flags: int, gsg: GraphicsStateGuardian, host: GraphicsOutput): GraphicsOutput {.importcpp: "#->make_output(#, nimStringToStdString(#), #, #, #, #, #, #)", header: stringConversionCode.}

proc makeOutput*(this: GraphicsEngine, pipe: GraphicsPipe, name: string, sort: int, fb_prop: FrameBufferProperties, win_prop: WindowProperties, flags: int, gsg: GraphicsStateGuardian): GraphicsOutput {.importcpp: "#->make_output(#, nimStringToStdString(#), #, #, #, #, #)", header: stringConversionCode.}

proc makeOutput*(this: GraphicsEngine, pipe: GraphicsPipe, name: string, sort: int, fb_prop: FrameBufferProperties, win_prop: WindowProperties, flags: int): GraphicsOutput {.importcpp: "#->make_output(#, nimStringToStdString(#), #, #, #, #)", header: stringConversionCode.}

proc makeBuffer*(this: GraphicsEngine, host: GraphicsOutput, name: string, sort: int, x_size: int, y_size: int): GraphicsOutput {.importcpp: "#->make_buffer(#, nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## Syntactic shorthand for make_output.  This is the preferred way to create
## an offscreen buffer, when you already have an onscreen window or another
## buffer to start with.  For the first parameter, pass an existing
## GraphicsOutput object, e.g.  the main window; this allows the buffer to
## adapt itself to that window's framebuffer properties, and allows maximum
## sharing of resources.

proc makeBuffer*(this: GraphicsEngine, gsg: GraphicsStateGuardian, name: string, sort: int, x_size: int, y_size: int): GraphicsOutput {.importcpp: "#->make_buffer(#, nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## Syntactic shorthand for make_output.  This flavor accepts a GSG rather than
## a GraphicsOutput as the first parameter, which is too limiting and
## disallows the possibility of creating a ParasiteBuffer if the user's
## graphics hardware prefers that.  It also attempts to request specific
## framebuffer properties and may therefore do a poorer job of sharing the GSG
## between the old buffer and the new.
##
## For these reasons, this variant is a poor choice unless you are creating an
## offscreen buffer for the first time, without an onscreen window already in
## existence.  If you already have an onscreen window, you should use the
## other flavor of make_buffer() instead, which accepts a GraphicsOutput as
## the first parameter.

proc makeParasite*(this: GraphicsEngine, host: GraphicsOutput, name: string, sort: int, x_size: int, y_size: int): GraphicsOutput {.importcpp: "#->make_parasite(#, nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## Syntactic shorthand for make_buffer.

proc addWindow*(this: GraphicsEngine, window: GraphicsOutput, sort: int): bool {.importcpp: "#->add_window(#, #)".} ## \
## This can be used to add a newly-created GraphicsOutput object (and its GSG)
## to the engine's list of windows, and requests that it be opened.  This
## shouldn't be called by user code as make_output normally does this under
## the hood; it may be useful in esoteric cases in which a custom window
## object is used.
##
## This can be called during the rendering loop, unlike make_output(); the
## window will be opened before the next frame begins rendering.  Because it
## doesn't call open_windows(), however, it's not guaranteed that the window
## will succeed opening even if it returns true.

proc removeWindow*(this: GraphicsEngine, window: GraphicsOutput): bool {.importcpp: "#->remove_window(#)".} ## \
## Removes the indicated window or offscreen buffer from the set of windows
## that will be processed when render_frame() is called.  This also closes the
## window if it is open, and removes the window from its GraphicsPipe,
## allowing the window to be destructed if there are no other references to
## it.  (However, the window may not be actually closed until next frame, if
## it is controlled by a sub-thread.)
##
## The return value is true if the window was removed, false if it was not
## found.
##
## Unlike remove_all_windows(), this function does not terminate any of the
## threads that may have been started to service this window; they are left
## running (since you might open a new window later on these threads).  If
## your intention is to clean up before shutting down, it is better to call
## remove_all_windows() then to call remove_window() one at a time.

proc removeAllWindows*(this: GraphicsEngine) {.importcpp: "#->remove_all_windows()".} ## \
## Removes and closes all windows from the engine.  This also cleans up and
## terminates any threads that have been started to service those windows.

proc resetAllWindows*(this: GraphicsEngine, swapchain: bool) {.importcpp: "#->reset_all_windows(#)".} ## \
## Resets the framebuffer of the current window.  This is currently used by
## DirectX 8 only.  It calls a reset_window function on each active window to
## release/create old/new framebuffer

proc isEmpty*(this: GraphicsEngine): bool {.importcpp: "#->is_empty()".} ## \
## Returns true if there are no windows or buffers managed by the engine,
## false if there is at least one.

proc getNumWindows*(this: GraphicsEngine): int {.importcpp: "#->get_num_windows()".} ## \
## Returns the number of windows (or buffers) managed by the engine.

proc getWindow*(this: GraphicsEngine, n: int): GraphicsOutput {.importcpp: "#->get_window(#)".} ## \
## Returns the nth window or buffers managed by the engine, in sorted order.

proc renderFrame*(this: GraphicsEngine) {.importcpp: "#->render_frame()".} ## \
## Renders the next frame in all the registered windows, and flips all of the
## frame buffers.

proc openWindows*(this: GraphicsEngine) {.importcpp: "#->open_windows()".} ## \
## Fully opens (or closes) any windows that have recently been requested open
## or closed, without rendering any frames.  It is not necessary to call this
## explicitly, since windows will be automatically opened or closed when the
## next frame is rendered, but you may call this if you want your windows now
## without seeing a frame go by.

proc syncFrame*(this: GraphicsEngine) {.importcpp: "#->sync_frame()".} ## \
## Waits for all the threads that started drawing their last frame to finish
## drawing.  The windows are not yet flipped when this returns; see also
## flip_frame(). It is not usually necessary to call this explicitly, unless
## you need to see the previous frame right away.

proc readyFlip*(this: GraphicsEngine) {.importcpp: "#->ready_flip()".} ## \
## Waits for all the threads that started drawing their last frame to finish
## drawing.  Returns when all threads have actually finished drawing, as
## opposed to 'sync_frame' we seems to return once all draw calls have been
## submitted.  Calling 'flip_frame' after this function should immediately
## cause a buffer flip.  This function will only work in opengl right now, for
## all other graphics pipelines it will simply return immediately.  In opengl
## it's a bit of a hack: it will attempt to read a single pixel from the frame
## buffer to force the graphics card to finish drawing before it returns

proc flipFrame*(this: GraphicsEngine) {.importcpp: "#->flip_frame()".} ## \
## Waits for all the threads that started drawing their last frame to finish
## drawing, and then flips all the windows.  It is not usually necessary to
## call this explicitly, unless you need to see the previous frame right away.

proc extractTextureData*(this: GraphicsEngine, tex: Texture, gsg: GraphicsStateGuardian): bool {.importcpp: "#->extract_texture_data(#, #)".} ## \
## Asks the indicated GraphicsStateGuardian to retrieve the texture memory
## image of the indicated texture and store it in the texture's ram_image
## field.  The image can then be written to disk via Texture::write(), or
## otherwise manipulated on the CPU.
##
## This is useful for retrieving the contents of a texture that has been
## somehow generated on the graphics card, instead of having been loaded the
## normal way via Texture::read() or Texture::load(). It is particularly
## useful for getting the data associated with a compressed texture image.
##
## Since this requires a round-trip to the draw thread, it may require waiting
## for the current thread to finish rendering if it is called in a
## multithreaded environment.  However, you can call this several consecutive
## times on different textures for little additional cost.
##
## If the texture has not yet been loaded to the GSG in question, it will be
## loaded immediately.
##
## The return value is true if the operation is successful, false otherwise.

proc dispatchCompute*(this: GraphicsEngine, work_groups: LVecBase3i, sattr: ShaderAttrib, gsg: GraphicsStateGuardian) {.importcpp: "#->dispatch_compute(#, #, #)".} ## \
## Asks the indicated GraphicsStateGuardian to dispatch the compute shader in
## the given ShaderAttrib using the given work group counts.  This can act as
## an interface for running a one-off compute shader, without having to store
## it in the scene graph using a ComputeNode.
##
## Since this requires a round-trip to the draw thread, it may require waiting
## for the current thread to finish rendering if it is called in a
## multithreaded environment.  However, you can call this several consecutive
## times on different textures for little additional cost.
##
## The return value is true if the operation is successful, false otherwise.

proc getGlobalPtr*(_: typedesc[GraphicsEngine]): GraphicsEngine {.importcpp: "GraphicsEngine::get_global_ptr()", header: "graphicsEngine.h".}

proc countTextures*(this: GraphicsOutput): int {.importcpp: "#->count_textures()".} ## \
## If the GraphicsOutput is set to render into a texture, returns the number
## of textures that are being rendered into.  Normally, the textures would be
## associated with different buffers - a color texture, a depth texture, and a
## stencil texture.

proc hasTexture*(this: GraphicsOutput): bool {.importcpp: "#->has_texture()".} ## \
## Returns true if the GraphicsOutput is rendering into any textures at all.

proc getTexture*(this: GraphicsOutput, i: int): Texture {.importcpp: "#->get_texture(#)".} ## \
## Returns the nth texture into which the GraphicsOutput renders.  Returns
## NULL if there is no such texture.
##
## If the texture is non-NULL, it may be applied to geometry to be rendered
## for any other windows or outputs that share the same GSG as this
## GraphicsOutput.  The effect is undefined for windows that share a different
## GSG; usually in these cases the texture will be invalid.

proc getTexture*(this: GraphicsOutput): Texture {.importcpp: "#->get_texture()".} ## \
## Returns the nth texture into which the GraphicsOutput renders.  Returns
## NULL if there is no such texture.
##
## If the texture is non-NULL, it may be applied to geometry to be rendered
## for any other windows or outputs that share the same GSG as this
## GraphicsOutput.  The effect is undefined for windows that share a different
## GSG; usually in these cases the texture will be invalid.

proc clearRenderTextures*(this: GraphicsOutput) {.importcpp: "#->clear_render_textures()".} ## \
## If the GraphicsOutput is currently rendering to a texture, then all
## textures are dissociated from the GraphicsOuput.

proc setupRenderTexture*(this: GraphicsOutput, tex: Texture, allow_bind: bool, to_ram: bool) {.importcpp: "#->setup_render_texture(#, #, #)".} ## \
## This is a deprecated interface that made sense back when GraphicsOutputs
## could only render into one texture at a time.  From now on, use
## clear_render_textures and add_render_texture instead.
##
## @deprecated Use add_render_texture() instead.

proc getSize*(this: GraphicsOutput): LVecBase2i {.importcpp: "#->get_size()".} ## \
## Returns the visible size of the window or buffer, if it is known.  In
## certain cases (e.g.  fullscreen windows), the size may not be known until
## after the object has been fully created.  Check has_size() first.
##
## Certain objects (like windows) may change size spontaneously; this method
## is not thread-safe.  To get the size of a window in a thread-safe manner,
## query get_properties().

proc getXSize*(this: GraphicsOutput): int {.importcpp: "#->get_x_size()".} ## \
## Returns the visible width of the window or buffer, if it is known.  In
## certain cases (e.g.  fullscreen windows), the size may not be known until
## after the object has been fully created.  Check has_size() first.
##
## Certain objects (like windows) may change size spontaneously; this method
## is not thread-safe.  To get the size of a window in a thread-safe manner,
## query get_properties().

proc getYSize*(this: GraphicsOutput): int {.importcpp: "#->get_y_size()".} ## \
## Returns the visible height of the window or buffer, if it is known.  In
## certain cases (e.g.  fullscreen windows), the size may not be known until
## after the object has been fully created.  Check has_size() first.
##
## Certain objects (like windows) may change size spontaneously; this method
## is not thread-safe.  To get the size of a window in a thread-safe manner,
## query get_properties().

proc getFbSize*(this: GraphicsOutput): LVecBase2i {.importcpp: "#->get_fb_size()".} ## \
## Returns the internal size of the window or buffer.  This is almost always
## the same as get_size(), except when a pixel_zoom is in effect--see
## set_pixel_zoom().

proc getFbXSize*(this: GraphicsOutput): int {.importcpp: "#->get_fb_x_size()".} ## \
## Returns the internal width of the window or buffer.  This is almost always
## the same as get_x_size(), except when a pixel_zoom is in effect--see
## set_pixel_zoom().

proc getFbYSize*(this: GraphicsOutput): int {.importcpp: "#->get_fb_y_size()".} ## \
## Returns the internal height of the window or buffer.  This is almost always
## the same as get_y_size(), except when a pixel_zoom is in effect--see
## set_pixel_zoom().

proc getSbsLeftSize*(this: GraphicsOutput): LVecBase2i {.importcpp: "#->get_sbs_left_size()".} ## \
## If side-by-side stereo is enabled, this returns the pixel size of the left
## eye, based on scaling get_size() by get_sbs_left_dimensions().  If side-by-
## side stereo is not enabled, this returns the same as get_size().

proc getSbsLeftXSize*(this: GraphicsOutput): int {.importcpp: "#->get_sbs_left_x_size()".} ## \
## If side-by-side stereo is enabled, this returns the pixel width of the left
## eye, based on scaling get_x_size() by get_sbs_left_dimensions().  If side-
## by-side stereo is not enabled, this returns the same as get_x_size().

proc getSbsLeftYSize*(this: GraphicsOutput): int {.importcpp: "#->get_sbs_left_y_size()".} ## \
## If side-by-side stereo is enabled, this returns the pixel height of the
## left eye, based on scaling get_y_size() by get_sbs_left_dimensions().  If
## side-by-side stereo is not enabled, this returns the same as get_y_size().

proc getSbsRightSize*(this: GraphicsOutput): LVecBase2i {.importcpp: "#->get_sbs_right_size()".} ## \
## If side-by-side stereo is enabled, this returns the pixel size of the right
## eye, based on scaling get_size() by get_sbs_right_dimensions().  If side-
## by-side stereo is not enabled, this returns the same as get_size().

proc getSbsRightXSize*(this: GraphicsOutput): int {.importcpp: "#->get_sbs_right_x_size()".} ## \
## If side-by-side stereo is enabled, this returns the pixel width of the
## right eye, based on scaling get_x_size() by get_sbs_right_dimensions().  If
## side-by-side stereo is not enabled, this returns the same as get_x_size().

proc getSbsRightYSize*(this: GraphicsOutput): int {.importcpp: "#->get_sbs_right_y_size()".} ## \
## If side-by-side stereo is enabled, this returns the pixel height of the
## right eye, based on scaling get_y_size() by get_sbs_right_dimensions().  If
## side-by-side stereo is not enabled, this returns the same as get_y_size().

proc hasSize*(this: GraphicsOutput): bool {.importcpp: "#->has_size()".} ## \
## Returns true if the size of the window/frame buffer is known, false
## otherwise.  In certain cases the size may not be known until after the
## object has been fully created.  Also, certain objects (like windows) may
## change size spontaneously.

proc isValid*(this: GraphicsOutput): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the output is fully created and ready for rendering, false
## otherwise.

proc isNonzeroSize*(this: GraphicsOutput): bool {.importcpp: "#->is_nonzero_size()".} ## \
## Returns true if the output has a nonzero size in both X and Y, or false if
## it is zero (and therefore invalid).

proc setActive*(this: GraphicsOutput, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets the active flag associated with the GraphicsOutput.  If the
## GraphicsOutput is marked inactive, nothing is rendered.

proc isActive*(this: GraphicsOutput): bool {.importcpp: "#->is_active()".} ## \
## Returns true if the window is ready to be rendered into, false otherwise.

proc setOneShot*(this: GraphicsOutput, one_shot: bool) {.importcpp: "#->set_one_shot(#)".} ## \
## Changes the current setting of the one-shot flag.  When this is true, the
## GraphicsOutput will render the current frame and then automatically set
## itself inactive.  This is particularly useful for buffers that are created
## for the purposes of render-to-texture, for static textures that don't need
## to be continually re-rendered once they have been rendered the first time.
##
## Setting the buffer inactive is not the same thing as destroying it.  You
## are still responsible for passing this buffer to
## GraphicsEngine::remove_window() when you no longer need the texture, in
## order to clean up fully.  (However, you should not call remove_window() on
## this buffer while the texture is still needed, because depending on the
## render-to-texture mechanism in use, this may invalidate the texture
## contents.)

proc getOneShot*(this: GraphicsOutput): bool {.importcpp: "#->get_one_shot()".} ## \
## Returns the current setting of the one-shot flag.  When this is true, the
## GraphicsOutput will automatically set itself inactive after the next frame.

proc setInverted*(this: GraphicsOutput, inverted: bool) {.importcpp: "#->set_inverted(#)".} ## \
## Changes the current setting of the inverted flag.  When this is true, the
## scene is rendered into the window upside-down and backwards, that is,
## inverted as if viewed through a mirror placed on the floor.
##
## This is primarily intended to support DirectX (and a few buggy OpenGL
## graphics drivers) that perform a framebuffer-to-texture copy upside-down
## from the usual OpenGL (and Panda) convention.  Panda will automatically set
## this flag for offscreen buffers on hardware that is known to do this, to
## compensate when rendering offscreen into a texture.

proc getInverted*(this: GraphicsOutput): bool {.importcpp: "#->get_inverted()".} ## \
## Returns the current setting of the inverted flag.  When this is true, the
## scene is rendered into the window upside-down, flipped like a mirror along
## the X axis.  See set_inverted().

proc setSwapEyes*(this: GraphicsOutput, swap_eyes: bool) {.importcpp: "#->set_swap_eyes(#)".} ## \
## Changes the "swap eyes" flag.  This flag is normally false.  When it is
## true, the left and right channels of a stereo DisplayRegion are sent to the
## opposite channels in the rendering backend.  This is meant to work around
## hardware that inadvertently swaps the output channels, or hardware for
## which it cannot be determined which channel is which until runtime.

proc getSwapEyes*(this: GraphicsOutput): bool {.importcpp: "#->get_swap_eyes()".} ## \
## Returns the current setting of the "swap eyes" flag.  See set_swap_eyes().

proc setRedBlueStereo*(this: GraphicsOutput, red_blue_stereo: bool, left_eye_color_mask: int, right_eye_color_mask: int) {.importcpp: "#->set_red_blue_stereo(#, #, #)".} ## \
## Enables red-blue stereo mode on this particular window.  When red-blue
## stereo mode is in effect, DisplayRegions that have the "left" channel set
## will render in the red (or specified) channel only, while DisplayRegions
## that have the "right" channel set will render in the blue (or specified)
## channel only.
##
## The remaining two parameters specify the particular color channel(s) to
## associate with each eye.  Use the bits defined in
## ColorWriteAttrib::Channels.
##
## This can be used to achieve a cheesy stereo mode in the absence of
## hardware-supported stereo.

proc getRedBlueStereo*(this: GraphicsOutput): bool {.importcpp: "#->get_red_blue_stereo()".} ## \
## Returns whether red-blue stereo mode is in effect for this particular
## window.  See set_red_blue_stereo().

proc getLeftEyeColorMask*(this: GraphicsOutput): int {.importcpp: "#->get_left_eye_color_mask()".} ## \
## Returns the color mask in effect when rendering a left-eye view in red_blue
## stereo mode.  This is one or more bits defined in
## ColorWriteAttrib::Channels.  See set_red_blue_stereo().

proc getRightEyeColorMask*(this: GraphicsOutput): int {.importcpp: "#->get_right_eye_color_mask()".} ## \
## Returns the color mask in effect when rendering a right-eye view in
## red_blue stereo mode.  This is one or more bits defined in
## ColorWriteAttrib::Channels.  See set_red_blue_stereo().

proc setSideBySideStereo*(this: GraphicsOutput, side_by_side_stereo: bool) {.importcpp: "#->set_side_by_side_stereo(#)".} ## \
## Enables side-by-side stereo mode on this particular window.  When side-by-
## side stereo mode is in effect, DisplayRegions that have the "left" channel
## set will render on the part of the window specified by sbs_left_dimensions
## (typically the left half: (0, 0.5, 0, 1)), while DisplayRegions that have
## the "right" channel set will render on the part of the window specified by
## sbs_right_dimensions (typically the right half: (0.5, 1, 0, 1)).
##
## This is commonly used in a dual-monitor mode, where a window is opened that
## spans two monitors, and each monitor represents a different eye.

proc setSideBySideStereo*(this: GraphicsOutput, side_by_side_stereo: bool, sbs_left_dimensions: LVecBase4, sbs_right_dimensions: LVecBase4) {.importcpp: "#->set_side_by_side_stereo(#, #, #)".} ## \
## Enables side-by-side stereo mode on this particular window.  When side-by-
## side stereo mode is in effect, DisplayRegions that have the "left" channel
## set will render on the part of the window specified by sbs_left_dimensions
## (typically the left half: (0, 0.5, 0, 1)), while DisplayRegions that have
## the "right" channel set will render on the part of the window specified by
## sbs_right_dimensions (typically the right half: (0.5, 1, 0, 1)).
##
## This is commonly used in a dual-monitor mode, where a window is opened that
## spans two monitors, and each monitor represents a different eye.

proc getSideBySideStereo*(this: GraphicsOutput): bool {.importcpp: "#->get_side_by_side_stereo()".} ## \
## Returns whether side-by-side stereo mode is in effect for this particular
## window.  See set_side_by_side_stereo().

proc getSbsLeftDimensions*(this: GraphicsOutput): LVecBase4 {.importcpp: "#->get_sbs_left_dimensions()".} ## \
## Returns the effective sub-region of the window for displaying the left
## channel, if side-by-side stereo mode is in effect for the window.  See
## set_side_by_side_stereo().

proc getSbsRightDimensions*(this: GraphicsOutput): LVecBase4 {.importcpp: "#->get_sbs_right_dimensions()".} ## \
## Returns the effective sub-region of the window for displaying the right
## channel, if side-by-side stereo mode is in effect for the window.  See
## set_side_by_side_stereo().

proc getFbProperties*(this: GraphicsOutput): FrameBufferProperties {.importcpp: "#->get_fb_properties()".} ## \
## Returns the framebuffer properties of the window.

proc isStereo*(this: GraphicsOutput): bool {.importcpp: "#->is_stereo()".} ## \
## Returns Returns true if this window can render stereo DisplayRegions,
## either through red-blue stereo (see set_red_blue_stereo()) or through true
## hardware stereo rendering.

proc clearDeleteFlag*(this: GraphicsOutput) {.importcpp: "#->clear_delete_flag()".} ## \
## Resets the delete flag, so the GraphicsOutput will not be automatically
## deleted before the beginning of the next frame.

proc getDeleteFlag*(this: GraphicsOutput): bool {.importcpp: "#->get_delete_flag()".} ## \
## Returns the current setting of the delete flag.  When this is true, the
## GraphicsOutput will automatically be removed before the beginning of the
## next frame by the GraphicsEngine.

proc setSort*(this: GraphicsOutput, sort: int) {.importcpp: "#->set_sort(#)".} ## \
## Adjusts the sorting order of this particular GraphicsOutput, relative to
## other GraphicsOutputs.

proc getSort*(this: GraphicsOutput): int {.importcpp: "#->get_sort()".} ## \
## Returns the sorting order of this particular GraphicsOutput.  The various
## GraphicsOutputs within a particular thread will be rendered in the
## indicated order.

proc setChildSort*(this: GraphicsOutput, child_sort: int) {.importcpp: "#->set_child_sort(#)".} ## \
## Specifies the sort value of future offscreen buffers created by
## make_texture_sort().
##
## The purpose of this method is to allow the user to limit the sort value
## chosen for a buffer created via make_texture_buffer().  Normally, this
## buffer will be assigned a value of get_sort() - 1, so that it will be
## rendered before this window is rendered; but sometimes this isn't
## sufficiently early, especially if other buffers also have a view into the
## same scene.
##
## If you specify a value here, then new buffers created via
## make_texture_buffer() will be given that sort value instead of get_sort() -
## 1.

proc clearChildSort*(this: GraphicsOutput) {.importcpp: "#->clear_child_sort()".} ## \
## Resets the sort value of future offscreen buffers created by
## make_texture_sort() to the default value.  See set_child_sort().

proc getChildSort*(this: GraphicsOutput): int {.importcpp: "#->get_child_sort()".} ## \
## Returns the sort value of future offscreen buffers created by
## make_texture_sort(). See set_child_sort().

proc triggerCopy*(this: GraphicsOutput): AsyncFuture {.importcpp: "#->trigger_copy()".} ## \
## When the GraphicsOutput is in triggered copy mode, this function triggers
## the copy (at the end of the next frame).
## @returns a future that can be awaited.

proc makeDisplayRegion*(this: GraphicsOutput): DisplayRegion {.importcpp: "#->make_display_region()".} ## \
## Creates a new DisplayRegion that covers the entire window.
##
## If is_stereo() is true for this window, and default-stereo-camera is
## configured true, this actually makes a StereoDisplayRegion.  Call
## make_mono_display_region() or make_stereo_display_region() if you want to
## insist on one or the other.

proc makeDisplayRegion*(this: GraphicsOutput, dimensions: LVecBase4): DisplayRegion {.importcpp: "#->make_display_region(#)".} ## \
## Creates a new DisplayRegion that covers the indicated sub-rectangle within
## the window.  The range on all parameters is 0..1.
##
## If is_stereo() is true for this window, and default-stereo-camera is
## configured true, this actually makes a StereoDisplayRegion.  Call
## make_mono_display_region() or make_stereo_display_region() if you want to
## insist on one or the other.

proc makeDisplayRegion*(this: GraphicsOutput, l: float32, r: float32, b: float32, t: float32): DisplayRegion {.importcpp: "#->make_display_region(#, #, #, #)".} ## \
## Creates a new DisplayRegion that covers the indicated sub-rectangle within
## the window.  The range on all parameters is 0..1.
##
## If is_stereo() is true for this window, and default-stereo-camera is
## configured true, this actually makes a StereoDisplayRegion.  Call
## make_mono_display_region() or make_stereo_display_region() if you want to
## insist on one or the other.

proc makeMonoDisplayRegion*(this: GraphicsOutput): DisplayRegion {.importcpp: "#->make_mono_display_region()".} ## \
## Creates a new DisplayRegion that covers the entire window.
##
## This generally returns a mono DisplayRegion, even if is_stereo() is true.
## However, if side-by-side stereo is enabled, this will return a
## StereoDisplayRegion whose two eyes are both set to SC_mono.  (This is
## necessary because in side-by-side stereo mode, it is necessary to draw even
## mono DisplayRegions twice).

proc makeMonoDisplayRegion*(this: GraphicsOutput, dimensions: LVecBase4): DisplayRegion {.importcpp: "#->make_mono_display_region(#)".} ## \
## Creates a new DisplayRegion that covers the indicated sub-rectangle within
## the window.  The range on all parameters is 0..1.
##
## This generally returns a mono DisplayRegion, even if is_stereo() is true.
## However, if side-by-side stereo is enabled, this will return a
## StereoDisplayRegion whose two eyes are both set to SC_mono.  (This is
## necessary because in side-by-side stereo mode, it is necessary to draw even
## mono DisplayRegions twice).

proc makeMonoDisplayRegion*(this: GraphicsOutput, l: float32, r: float32, b: float32, t: float32): DisplayRegion {.importcpp: "#->make_mono_display_region(#, #, #, #)".} ## \
## Creates a new DisplayRegion that covers the entire window.
##
## This generally returns a mono DisplayRegion, even if is_stereo() is true.
## However, if side-by-side stereo is enabled, this will return a
## StereoDisplayRegion whose two eyes are both set to SC_mono.  (This is
## necessary because in side-by-side stereo mode, it is necessary to draw even
## mono DisplayRegions twice).

proc makeStereoDisplayRegion*(this: GraphicsOutput): StereoDisplayRegion {.importcpp: "#->make_stereo_display_region()".} ## \
## Creates a new DisplayRegion that covers the entire window.
##
## This always returns a stereo DisplayRegion, even if is_stereo() is false.

proc makeStereoDisplayRegion*(this: GraphicsOutput, dimensions: LVecBase4): StereoDisplayRegion {.importcpp: "#->make_stereo_display_region(#)".} ## \
## Creates a new DisplayRegion that covers the indicated sub-rectangle within
## the window.  The range on all parameters is 0..1.
##
## This always returns a stereo DisplayRegion, even if is_stereo() is false.

proc makeStereoDisplayRegion*(this: GraphicsOutput, l: float32, r: float32, b: float32, t: float32): StereoDisplayRegion {.importcpp: "#->make_stereo_display_region(#, #, #, #)".} ## \
## Creates a new DisplayRegion that covers the entire window.
##
## This always returns a stereo DisplayRegion, even if is_stereo() is false.

proc removeDisplayRegion*(this: GraphicsOutput, display_region: DisplayRegion): bool {.importcpp: "#->remove_display_region(#)".} ## \
## Removes the indicated DisplayRegion from the window, and destructs it if
## there are no other references.
##
## Returns true if the DisplayRegion is found and removed, false if it was not
## a part of the window.

proc removeAllDisplayRegions*(this: GraphicsOutput) {.importcpp: "#->remove_all_display_regions()".} ## \
## Removes all display regions from the window, except the default one that is
## created with the window.

proc getOverlayDisplayRegion*(this: GraphicsOutput): DisplayRegion {.importcpp: "#->get_overlay_display_region()".} ## \
## Returns the special "overlay" DisplayRegion that is created for each window
## or buffer.  This DisplayRegion covers the entire window, but cannot be used
## for rendering.  It is a placeholder only, to indicate the dimensions of the
## window, and is usually used internally for purposes such as clearing the
## window, or grabbing a screenshot of the window.
##
## There are very few applications that require access to this DisplayRegion.
## Normally, you should create your own DisplayRegion that covers the window,
## if you want to render to the window.

proc setOverlayDisplayRegion*(this: GraphicsOutput, display_region: DisplayRegion) {.importcpp: "#->set_overlay_display_region(#)".} ## \
## Replaces the special "overlay" DisplayRegion that is created for each
## window or buffer.  See get_overlay_display_region().  This must be a new
## DisplayRegion that has already been created for this window, for instance
## via a call to make_mono_display_region().  You are responsible for ensuring
## that the new DisplayRegion covers the entire window.  The previous overlay
## display region is not automatically removed; you must explicitly call
## remove_display_region() on it after replacing it with this method, if you
## wish it to be removed.
##
## Normally, there is no reason to change the overlay DisplayRegion, so this
## method should be used only in very unusual circumstances.

proc getNumDisplayRegions*(this: GraphicsOutput): int {.importcpp: "#->get_num_display_regions()".} ## \
## Returns the number of DisplayRegions that have been created within the
## window, active or otherwise.

proc getDisplayRegion*(this: GraphicsOutput, n: int): DisplayRegion {.importcpp: "#->get_display_region(#)".} ## \
## Returns the nth DisplayRegion of those that have been created within the
## window.  This may return NULL if n is out of bounds; particularly likely if
## the number of display regions has changed since the last call to
## get_num_display_regions().

proc getNumActiveDisplayRegions*(this: GraphicsOutput): int {.importcpp: "#->get_num_active_display_regions()".} ## \
## Returns the number of active DisplayRegions that have been created within
## the window.

proc getActiveDisplayRegion*(this: GraphicsOutput, n: int): DisplayRegion {.importcpp: "#->get_active_display_region(#)".} ## \
## Returns the nth active DisplayRegion of those that have been created within
## the window.  This may return NULL if n is out of bounds; particularly
## likely if the number of display regions has changed since the last call to
## get_num_active_display_regions().

proc makeTextureBuffer*(this: GraphicsOutput, name: string, x_size: int, y_size: int, tex: Texture, to_ram: bool, fbp: FrameBufferProperties): GraphicsOutput {.importcpp: "#->make_texture_buffer(nimStringToStdString(#), #, #, #, #, #)", header: stringConversionCode.} ## \
## Creates and returns an offscreen buffer for rendering into, the result of
## which will be a texture suitable for applying to geometry within the scene
## rendered into this window.
##
## If you pass zero as the buffer size, the buffer will have the same size as
## the host window, and will automatically be resized when the host window is.
##
## If tex is not NULL, it is the texture that will be set up for rendering
## into; otherwise, a new Texture object will be created.  In either case, the
## target texture can be retrieved from the return value with
## buffer->get_texture() (assuming the return value is not NULL).
##
## If to_ram is true, the buffer will be set up to download its contents to
## the system RAM memory associated with the Texture object, instead of
## keeping it strictly within texture memory; this is much slower, but it
## allows using the texture with any GSG.
##
## This will attempt to be smart about maximizing render performance while
## minimizing framebuffer waste.  It might return a GraphicsBuffer set to
## render directly into a texture, if possible; or it might return a
## ParasiteBuffer that renders into this window.  The return value is NULL if
## the buffer could not be created for some reason.
##
## When you are done using the buffer, you should remove it with a call to
## GraphicsEngine::remove_window().

proc makeTextureBuffer*(this: GraphicsOutput, name: string, x_size: int, y_size: int, tex: Texture, to_ram: bool): GraphicsOutput {.importcpp: "#->make_texture_buffer(nimStringToStdString(#), #, #, #, #)", header: stringConversionCode.} ## \
## Creates and returns an offscreen buffer for rendering into, the result of
## which will be a texture suitable for applying to geometry within the scene
## rendered into this window.
##
## If you pass zero as the buffer size, the buffer will have the same size as
## the host window, and will automatically be resized when the host window is.
##
## If tex is not NULL, it is the texture that will be set up for rendering
## into; otherwise, a new Texture object will be created.  In either case, the
## target texture can be retrieved from the return value with
## buffer->get_texture() (assuming the return value is not NULL).
##
## If to_ram is true, the buffer will be set up to download its contents to
## the system RAM memory associated with the Texture object, instead of
## keeping it strictly within texture memory; this is much slower, but it
## allows using the texture with any GSG.
##
## This will attempt to be smart about maximizing render performance while
## minimizing framebuffer waste.  It might return a GraphicsBuffer set to
## render directly into a texture, if possible; or it might return a
## ParasiteBuffer that renders into this window.  The return value is NULL if
## the buffer could not be created for some reason.
##
## When you are done using the buffer, you should remove it with a call to
## GraphicsEngine::remove_window().

proc makeTextureBuffer*(this: GraphicsOutput, name: string, x_size: int, y_size: int, tex: Texture): GraphicsOutput {.importcpp: "#->make_texture_buffer(nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## Creates and returns an offscreen buffer for rendering into, the result of
## which will be a texture suitable for applying to geometry within the scene
## rendered into this window.
##
## If you pass zero as the buffer size, the buffer will have the same size as
## the host window, and will automatically be resized when the host window is.
##
## If tex is not NULL, it is the texture that will be set up for rendering
## into; otherwise, a new Texture object will be created.  In either case, the
## target texture can be retrieved from the return value with
## buffer->get_texture() (assuming the return value is not NULL).
##
## If to_ram is true, the buffer will be set up to download its contents to
## the system RAM memory associated with the Texture object, instead of
## keeping it strictly within texture memory; this is much slower, but it
## allows using the texture with any GSG.
##
## This will attempt to be smart about maximizing render performance while
## minimizing framebuffer waste.  It might return a GraphicsBuffer set to
## render directly into a texture, if possible; or it might return a
## ParasiteBuffer that renders into this window.  The return value is NULL if
## the buffer could not be created for some reason.
##
## When you are done using the buffer, you should remove it with a call to
## GraphicsEngine::remove_window().

proc makeTextureBuffer*(this: GraphicsOutput, name: string, x_size: int, y_size: int): GraphicsOutput {.importcpp: "#->make_texture_buffer(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Creates and returns an offscreen buffer for rendering into, the result of
## which will be a texture suitable for applying to geometry within the scene
## rendered into this window.
##
## If you pass zero as the buffer size, the buffer will have the same size as
## the host window, and will automatically be resized when the host window is.
##
## If tex is not NULL, it is the texture that will be set up for rendering
## into; otherwise, a new Texture object will be created.  In either case, the
## target texture can be retrieved from the return value with
## buffer->get_texture() (assuming the return value is not NULL).
##
## If to_ram is true, the buffer will be set up to download its contents to
## the system RAM memory associated with the Texture object, instead of
## keeping it strictly within texture memory; this is much slower, but it
## allows using the texture with any GSG.
##
## This will attempt to be smart about maximizing render performance while
## minimizing framebuffer waste.  It might return a GraphicsBuffer set to
## render directly into a texture, if possible; or it might return a
## ParasiteBuffer that renders into this window.  The return value is NULL if
## the buffer could not be created for some reason.
##
## When you are done using the buffer, you should remove it with a call to
## GraphicsEngine::remove_window().

proc makeCubeMap*(this: GraphicsOutput, name: string, size: int, camera_rig: NodePath, camera_mask: DrawMask, to_ram: bool, fbp: FrameBufferProperties): GraphicsOutput {.importcpp: "#->make_cube_map(nimStringToStdString(#), #, #, #, #, #)", header: stringConversionCode.} ## \
## This is similar to make_texture_buffer() in that it allocates a separate
## buffer suitable for rendering to a texture that can be assigned to geometry
## in this window, but in this case, the buffer is set up to render the six
## faces of a cube map.
##
## The buffer is automatically set up with six display regions and six
## cameras, each of which are assigned the indicated draw_mask and parented to
## the given camera_rig node (which you should then put in your scene to
## render the cube map from the appropriate point of view).
##
## You may take the texture associated with the buffer and apply it to
## geometry, particularly with TexGenAttrib::M_world_cube_map also in effect,
## to apply a reflection of everything seen by the camera rig.

proc makeCubeMap*(this: GraphicsOutput, name: string, size: int, camera_rig: NodePath, camera_mask: DrawMask, to_ram: bool): GraphicsOutput {.importcpp: "#->make_cube_map(nimStringToStdString(#), #, #, #, #)", header: stringConversionCode.} ## \
## This is similar to make_texture_buffer() in that it allocates a separate
## buffer suitable for rendering to a texture that can be assigned to geometry
## in this window, but in this case, the buffer is set up to render the six
## faces of a cube map.
##
## The buffer is automatically set up with six display regions and six
## cameras, each of which are assigned the indicated draw_mask and parented to
## the given camera_rig node (which you should then put in your scene to
## render the cube map from the appropriate point of view).
##
## You may take the texture associated with the buffer and apply it to
## geometry, particularly with TexGenAttrib::M_world_cube_map also in effect,
## to apply a reflection of everything seen by the camera rig.

proc makeCubeMap*(this: GraphicsOutput, name: string, size: int, camera_rig: NodePath, camera_mask: DrawMask): GraphicsOutput {.importcpp: "#->make_cube_map(nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## This is similar to make_texture_buffer() in that it allocates a separate
## buffer suitable for rendering to a texture that can be assigned to geometry
## in this window, but in this case, the buffer is set up to render the six
## faces of a cube map.
##
## The buffer is automatically set up with six display regions and six
## cameras, each of which are assigned the indicated draw_mask and parented to
## the given camera_rig node (which you should then put in your scene to
## render the cube map from the appropriate point of view).
##
## You may take the texture associated with the buffer and apply it to
## geometry, particularly with TexGenAttrib::M_world_cube_map also in effect,
## to apply a reflection of everything seen by the camera rig.

proc makeCubeMap*(this: GraphicsOutput, name: string, size: int, camera_rig: NodePath): GraphicsOutput {.importcpp: "#->make_cube_map(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## This is similar to make_texture_buffer() in that it allocates a separate
## buffer suitable for rendering to a texture that can be assigned to geometry
## in this window, but in this case, the buffer is set up to render the six
## faces of a cube map.
##
## The buffer is automatically set up with six display regions and six
## cameras, each of which are assigned the indicated draw_mask and parented to
## the given camera_rig node (which you should then put in your scene to
## render the cube map from the appropriate point of view).
##
## You may take the texture associated with the buffer and apply it to
## geometry, particularly with TexGenAttrib::M_world_cube_map also in effect,
## to apply a reflection of everything seen by the camera rig.

proc makeScreenshotFilename*(_: typedesc[GraphicsOutput], prefix: string): Filename {.importcpp: "#GraphicsOutput::make_screenshot_filename(nimStringToStdString(#))", header: "graphicsOutput.h".} ## \
## Saves a screenshot of the region to a default filename, and returns the
## filename, or empty string if the screenshot failed.  The default filename
## is generated from the supplied prefix and from the Config variable
## screenshot-filename, which contains the following strings:
##
## %~p - the supplied prefix %~f - the frame count %~e - the value of
## screenshot-extension All other % strings in strftime().

proc makeScreenshotFilename*(_: typedesc[GraphicsOutput]): Filename {.importcpp: "GraphicsOutput::make_screenshot_filename()", header: "graphicsOutput.h".} ## \
## Saves a screenshot of the region to a default filename, and returns the
## filename, or empty string if the screenshot failed.  The default filename
## is generated from the supplied prefix and from the Config variable
## screenshot-filename, which contains the following strings:
##
## %~p - the supplied prefix %~f - the frame count %~e - the value of
## screenshot-extension All other % strings in strftime().

proc saveScreenshotDefault*(this: GraphicsOutput, prefix: string): Filename {.importcpp: "#->save_screenshot_default(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Saves a screenshot of the region to a default filename, and returns the
## filename, or empty string if the screenshot failed.  The filename is
## generated by make_screenshot_filename().

proc saveScreenshotDefault*(this: GraphicsOutput): Filename {.importcpp: "#->save_screenshot_default()".} ## \
## Saves a screenshot of the region to a default filename, and returns the
## filename, or empty string if the screenshot failed.  The filename is
## generated by make_screenshot_filename().

proc saveScreenshot*(this: GraphicsOutput, filename: Filename, image_comment: string): bool {.importcpp: "#->save_screenshot(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Saves a screenshot of the region to the indicated filename.  The image
## comment is an optional user readable string that will be saved with the
## header of the image (if the file format supports embedded data; for example
## jpg allows comments).  Returns true on success, false on failure.

proc saveScreenshot*(this: GraphicsOutput, filename: Filename): bool {.importcpp: "#->save_screenshot(#)".} ## \
## Saves a screenshot of the region to the indicated filename.  The image
## comment is an optional user readable string that will be saved with the
## header of the image (if the file format supports embedded data; for example
## jpg allows comments).  Returns true on success, false on failure.

proc getScreenshot*(this: GraphicsOutput): Texture {.importcpp: "#->get_screenshot()".} ## \
## Captures the most-recently rendered image from the framebuffer and returns
## it as Texture, or NULL on failure.

proc getScreenshot*(this: GraphicsOutput, image: PNMImage): bool {.importcpp: "#->get_screenshot(#)".} ## \
## Captures the most-recently rendered image from the framebuffer into the
## indicated PNMImage.  Returns true on success, false on failure.

proc getTextureCard*(this: GraphicsOutput): NodePath {.importcpp: "#->get_texture_card()".} ## \
## Returns a PandaNode containing a square polygon.  The dimensions are
## (-1,0,-1) to (1,0,1). The texture coordinates are such that the texture of
## this GraphicsOutput is aligned properly to the polygon.  The GraphicsOutput
## promises to surgically update the Geom inside the PandaNode if necessary to
## maintain this invariant.
##
## Each invocation of this function returns a freshly- allocated PandaNode.
## You can therefore safely modify the RenderAttribs of the PandaNode.  The
## PandaNode is initially textured with the texture of this GraphicOutput.

proc shareDepthBuffer*(this: GraphicsOutput, graphics_output: GraphicsOutput): bool {.importcpp: "#->share_depth_buffer(#)".} ## \
## Will attempt to use the depth buffer of the input graphics_output.  The
## buffer sizes must be exactly the same.

proc unshareDepthBuffer*(this: GraphicsOutput) {.importcpp: "#->unshare_depth_buffer()".} ## \
## Discontinue sharing the depth buffer.

proc getSupportsRenderTexture*(this: GraphicsOutput): bool {.importcpp: "#->get_supports_render_texture()".} ## \
## Returns true if this particular GraphicsOutput can render directly into a
## texture, or false if it must always copy-to-texture at the end of each
## frame to achieve this effect.

proc flipReady*(this: GraphicsOutput): bool {.importcpp: "#->flip_ready()".} ## \
## These are not intended to be called directly by the user, but they're
## published anyway since they might occasionally be useful for low-level
## debugging.

proc getHost*(this: GraphicsOutput): GraphicsOutput {.importcpp: "#->get_host()".} ## \
## This is normally called only from within make_texture_buffer().  When
## called on a ParasiteBuffer, it returns the host of that buffer; but when
## called on some other buffer, it returns the buffer itself.

converter getClassType*(_: typedesc[GraphicsOutput]): TypeHandle {.importcpp: "GraphicsOutput::get_class_type()", header: "graphicsOutput.h".}

proc setCamera*(this: DisplayRegion, camera: NodePath) {.importcpp: "#->set_camera(#)".} ## \
## Sets the camera that is associated with this DisplayRegion.  There is a
## one-to-many association between cameras and DisplayRegions; one camera may
## be shared by multiple DisplayRegions.
##
## The camera is actually set via a NodePath, which clarifies which instance
## of the camera (if there happen to be multiple instances) we should use.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc getCamera*(this: DisplayRegion, current_thread: Thread): NodePath {.importcpp: "#->get_camera(#)".} ## \
## Returns the camera associated with this DisplayRegion, or an empty NodePath
## if no camera is associated.

proc getCamera*(this: DisplayRegion): NodePath {.importcpp: "#->get_camera()".} ## \
## Returns the camera associated with this DisplayRegion, or an empty NodePath
## if no camera is associated.

proc setActive*(this: DisplayRegion, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets the active flag associated with the DisplayRegion.  If the
## DisplayRegion is marked inactive, nothing is rendered.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc isActive*(this: DisplayRegion): bool {.importcpp: "#->is_active()".} ## \
## Returns the active flag associated with the DisplayRegion.

proc setSort*(this: DisplayRegion, sort: int) {.importcpp: "#->set_sort(#)".} ## \
## Sets the sort value associated with the DisplayRegion.  Within a window,
## DisplayRegions will be rendered in order from the lowest sort value to the
## highest.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc getSort*(this: DisplayRegion): int {.importcpp: "#->get_sort()".} ## \
## Returns the sort value associated with the DisplayRegion.

proc setTexViewOffset*(this: DisplayRegion, tex_view_offset: int) {.importcpp: "#->set_tex_view_offset(#)".} ## \
## Sets the current texture view offset for this DisplayRegion.  This is
## normally set to zero.  If nonzero, it is used to select a particular view
## of any multiview textures that are rendered within this DisplayRegion.
##
## For a StereoDisplayRegion, this is normally 0 for the left eye, and 1 for
## the right eye, to support stereo textures.  This is set automatically when
## you call set_stereo_channel().

proc getTexViewOffset*(this: DisplayRegion): int {.importcpp: "#->get_tex_view_offset()".} ## \
## Returns the current texture view offset for this DisplayRegion.  This is
## normally set to zero.  If nonzero, it is used to select a particular view
## of any multiview textures that are rendered within this DisplayRegion.
##
## For a StereoDisplayRegion, this is normally 0 for the left eye, and 1 for
## the right eye, to support stereo textures.

proc setIncompleteRender*(this: DisplayRegion, incomplete_render: bool) {.importcpp: "#->set_incomplete_render(#)".} ## \
## Sets the incomplete_render flag.  When this is true, the frame will be
## rendered even if some of the geometry or textures in the scene are not
## available (e.g.  they have been temporarily paged out).  When this is
## false, the frame will be held up while this data is reloaded.
##
## This flag may also be set on the GraphicsStateGuardian.  It will be
## considered true for a given DisplayRegion only if it is true on both the
## GSG and on the DisplayRegion.
##
## See GraphicsStateGuardian::set_incomplete_render() for more detail.

proc getIncompleteRender*(this: DisplayRegion): bool {.importcpp: "#->get_incomplete_render()".} ## \
## Returns the incomplete_render flag.  See set_incomplete_render().

proc setTextureReloadPriority*(this: DisplayRegion, texture_reload_priority: int) {.importcpp: "#->set_texture_reload_priority(#)".} ## \
## Specifies an integer priority which is assigned to any asynchronous texture
## reload requests spawned while processing this DisplayRegion.  This controls
## which textures are loaded first when multiple textures need to be reloaded
## at once; it also controls the relative priority between asynchronous
## texture loads and asynchronous model or animation loads.
##
## Specifying a larger number here makes the textures rendered by this
## DisplayRegion load up first.  This may be particularly useful to do, for
## instance, for the DisplayRegion that renders the gui.

proc getTextureReloadPriority*(this: DisplayRegion): int {.importcpp: "#->get_texture_reload_priority()".} ## \
## Returns the priority which is assigned to asynchronous texture reload
## requests.  See set_texture_reload_priority().

proc setLensIndex*(this: DisplayRegion, index: int) {.importcpp: "#->set_lens_index(#)".} ## \
## Sets the lens index, allows for multiple lenses to be attached to a camera.
## This is useful for a variety of setups, such as fish eye rendering.  The
## default is 0.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc getLensIndex*(this: DisplayRegion): int {.importcpp: "#->get_lens_index()".} ## \
## Returns the specific lens of the associated Camera that will be used for
## rendering this scene.  Most Cameras hold only one lens, but for multiple
## lenses this method may be used to selected between them.

proc setCullTraverser*(this: DisplayRegion, trav: CullTraverser) {.importcpp: "#->set_cull_traverser(#)".} ## \
## Specifies the CullTraverser that will be used to draw the contents of this
## DisplayRegion.  Normally the default CullTraverser is sufficient, but this
## may be changed to change the default cull behavior.

proc getCullTraverser*(this: DisplayRegion): CullTraverser {.importcpp: "#->get_cull_traverser()".} ## \
## Returns the CullTraverser that will be used to draw the contents of this
## DisplayRegion.

proc setCubeMapIndex*(this: DisplayRegion, cube_map_index: int) {.importcpp: "#->set_cube_map_index(#)".} ## \
## Deprecated; replaced by set_target_tex_page().

proc setTargetTexPage*(this: DisplayRegion, page: int) {.importcpp: "#->set_target_tex_page(#)".} ## \
## This is a special parameter that is only used when rendering the faces of a
## cube map or multipage and/or multiview texture.
##
## This sets up the DisplayRegion to render to the ith page and jth view of
## its associated texture(s); the value must be consistent with the range of
## values availble to the texture.  A normal DisplayRegion that is not
## associated with any particular page should be set to page -1 and view 0.
##
## This is particularly useful when rendering cube maps and/or stereo
## textures.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc getTargetTexPage*(this: DisplayRegion): int {.importcpp: "#->get_target_tex_page()".} ## \
## Returns the target page number associated with this particular
## DisplayRegion, or -1 if it is not associated with a page.  See
## set_target_tex_page().

proc setScissorEnabled*(this: DisplayRegion, scissor_enabled: bool) {.importcpp: "#->set_scissor_enabled(#)".} ## \
## Sets whether or not scissor testing is enabled for this region.  The
## default is true, except for the overlay display region.

proc getScissorEnabled*(this: DisplayRegion): bool {.importcpp: "#->get_scissor_enabled()".} ## \
## Returns whether or not scissor testing is enabled for this region.  The
## default is true, except for the overlay display region.

proc setCullCallback*(this: DisplayRegion, `object`: CallbackObject) {.importcpp: "#->set_cull_callback(#)".} ## \
## Sets the CallbackObject that will be notified when the DisplayRegion is
## visited during the cull traversal.  This callback will be made during the
## cull thread.
##
## The cull traversal is responsible for determining which nodes are visible
## and within the view frustum, and for accumulating state and transform, and
## generally building up the list of CullableObjects that are to be eventually
## passed to the draw traversal for rendering.
##
## At the time the cull traversal callback is made, the traversal for this
## DisplayRegion has not yet started.
##
## The callback is passed an instance of a DisplayRegionCullCallbackData,
## which contains pointers to the current scene information, as well as the
## current DisplayRegion and GSG.  The callback \*replaces\* the normal cull
## behavior, so if your callback does nothing, the scene graph will not be
## traversed and therefore nothing will be drawn.  If you wish the normal cull
## traversal to be performed for this DisplayRegion, you must call
## cbdata->upcall() from your callback.

proc clearCullCallback*(this: DisplayRegion) {.importcpp: "#->clear_cull_callback()".} ## \
## Removes the callback set by an earlier call to set_cull_callback().

proc getCullCallback*(this: DisplayRegion): CallbackObject {.importcpp: "#->get_cull_callback()".} ## \
## Returns the CallbackObject set by set_cull_callback().

proc setDrawCallback*(this: DisplayRegion, `object`: CallbackObject) {.importcpp: "#->set_draw_callback(#)".} ## \
## Sets the CallbackObject that will be notified when the contents of
## DisplayRegion is drawn during the draw traversal.  This callback will be
## made during the draw thread.
##
## The draw traversal is responsible for actually issuing the commands to the
## graphics engine to draw primitives.  Its job is to walk through the list of
## CullableObjects build up by the cull traversal, as quickly as possible,
## issuing the appropriate commands to draw each one.
##
## At the time the draw traversal callback is made, the graphics state is in
## the initial state, and no projection matrix or modelview matrix is in
## effect.  begin_scene() has not yet been called, and no objects have yet
## been drawn.  However, the viewport has already been set to the appropriate
## part of the window, and the clear commands for this DisplayRegion (if any)
## have been issued.
##
## The callback is passed an instance of a DisplayRegionDrawCallbackData,
## which contains pointers to the current scene information, as well as the
## current DisplayRegion and GSG.  The callback \*replaces\* the normal draw
## behavior, so if your callback does nothing, nothing in the DisplayRegion
## will be drawn.  If you wish the draw traversal to continue to draw the
## contents of this DisplayRegion, you must call cbdata->upcall() from your
## callback.

proc clearDrawCallback*(this: DisplayRegion) {.importcpp: "#->clear_draw_callback()".} ## \
## Removes the callback set by an earlier call to set_draw_callback().

proc getDrawCallback*(this: DisplayRegion): CallbackObject {.importcpp: "#->get_draw_callback()".} ## \
## Returns the CallbackObject set by set_draw_callback().

proc getPixelWidth*(this: DisplayRegion, i: int): int {.importcpp: "#->get_pixel_width(#)".} ## \
## Returns the width of the DisplayRegion in pixels.

proc getPixelWidth*(this: DisplayRegion): int {.importcpp: "#->get_pixel_width()".} ## \
## Returns the width of the DisplayRegion in pixels.

proc getPixelHeight*(this: DisplayRegion, i: int): int {.importcpp: "#->get_pixel_height(#)".} ## \
## Returns the height of the DisplayRegion in pixels.

proc getPixelHeight*(this: DisplayRegion): int {.importcpp: "#->get_pixel_height()".} ## \
## Returns the height of the DisplayRegion in pixels.

proc getPixelSize*(this: DisplayRegion, i: int): LVecBase2i {.importcpp: "#->get_pixel_size(#)".} ## \
## Returns the size of the DisplayRegion in pixels.

proc getPixelSize*(this: DisplayRegion): LVecBase2i {.importcpp: "#->get_pixel_size()".} ## \
## Returns the size of the DisplayRegion in pixels.

proc output*(this: DisplayRegion, `out`: ostream) {.importcpp: "#->output(#)".}

proc makeScreenshotFilename*(_: typedesc[DisplayRegion], prefix: string): Filename {.importcpp: "#DisplayRegion::make_screenshot_filename(nimStringToStdString(#))", header: "displayRegion.h".} ## \
## Synthesizes a suitable default filename for passing to save_screenshot().
##
## The default filename is generated from the supplied prefix and from the
## Config variable screenshot-filename, which contains the following strings:
##
## %~p - the supplied prefix %~f - the frame count %~e - the value of
## screenshot-extension All other % strings in strftime().

proc makeScreenshotFilename*(_: typedesc[DisplayRegion]): Filename {.importcpp: "DisplayRegion::make_screenshot_filename()", header: "displayRegion.h".} ## \
## Synthesizes a suitable default filename for passing to save_screenshot().
##
## The default filename is generated from the supplied prefix and from the
## Config variable screenshot-filename, which contains the following strings:
##
## %~p - the supplied prefix %~f - the frame count %~e - the value of
## screenshot-extension All other % strings in strftime().

proc saveScreenshotDefault*(this: DisplayRegion, prefix: string): Filename {.importcpp: "#->save_screenshot_default(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Saves a screenshot of the region to a default filename, and returns the
## filename, or empty string if the screenshot failed.  The filename is
## generated by make_screenshot_filename().

proc saveScreenshotDefault*(this: DisplayRegion): Filename {.importcpp: "#->save_screenshot_default()".} ## \
## Saves a screenshot of the region to a default filename, and returns the
## filename, or empty string if the screenshot failed.  The filename is
## generated by make_screenshot_filename().

proc saveScreenshot*(this: DisplayRegion, filename: Filename, image_comment: string): bool {.importcpp: "#->save_screenshot(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Saves a screenshot of the region to the indicated filename.  Returns true
## on success, false on failure.

proc saveScreenshot*(this: DisplayRegion, filename: Filename): bool {.importcpp: "#->save_screenshot(#)".} ## \
## Saves a screenshot of the region to the indicated filename.  Returns true
## on success, false on failure.

proc getScreenshot*(this: DisplayRegion): Texture {.importcpp: "#->get_screenshot()".} ## \
## Captures the most-recently rendered image from the framebuffer and returns
## it as a Texture, or NULL on failure.

proc getScreenshot*(this: DisplayRegion, image: PNMImage): bool {.importcpp: "#->get_screenshot(#)".} ## \
## Captures the most-recently rendered image from the framebuffer into the
## indicated PNMImage.  Returns true on success, false on failure.

proc clearCullResult*(this: DisplayRegion) {.importcpp: "#->clear_cull_result()".}

proc makeCullResultGraph*(this: DisplayRegion): PandaNode {.importcpp: "#->make_cull_result_graph()".} ## \
## Returns a special scene graph constructed to represent the results of the
## last frame's cull operation.
##
## This will be a hierarchy of nodes, one node for each bin, each of which
## will in term be a parent of a number of GeomNodes, representing the
## geometry drawn in each bin.
##
## This is useful mainly for high-level debugging and abstraction tools; it
## should not be mistaken for the low-level cull result itself, which is
## constructed and maintained internally.  No such scene graph is normally
## constructed during the rendering of a frame; this is an artificial
## construct created for the purpose of making it easy to analyze the results
## of the cull operation.

converter getClassType*(_: typedesc[DisplayRegion]): TypeHandle {.importcpp: "DisplayRegion::get_class_type()", header: "displayRegion.h".}

proc getLeftEye*(this: StereoDisplayRegion): DisplayRegion {.importcpp: "#->get_left_eye()".} ## \
## Returns a pointer to the left DisplayRegion managed by this stereo object.

proc getRightEye*(this: StereoDisplayRegion): DisplayRegion {.importcpp: "#->get_right_eye()".} ## \
## Returns a pointer to the right DisplayRegion managed by this stereo object.

converter getClassType*(_: typedesc[StereoDisplayRegion]): TypeHandle {.importcpp: "StereoDisplayRegion::get_class_type()", header: "stereoDisplayRegion.h".}

proc getDepthBits*(this: FrameBufferProperties): int {.importcpp: "#.get_depth_bits()".} ## \
## Individual queries.

proc getColorBits*(this: FrameBufferProperties): int {.importcpp: "#.get_color_bits()".}

proc getRedBits*(this: FrameBufferProperties): int {.importcpp: "#.get_red_bits()".}

proc getGreenBits*(this: FrameBufferProperties): int {.importcpp: "#.get_green_bits()".}

proc getBlueBits*(this: FrameBufferProperties): int {.importcpp: "#.get_blue_bits()".}

proc getAlphaBits*(this: FrameBufferProperties): int {.importcpp: "#.get_alpha_bits()".}

proc getStencilBits*(this: FrameBufferProperties): int {.importcpp: "#.get_stencil_bits()".}

proc getAccumBits*(this: FrameBufferProperties): int {.importcpp: "#.get_accum_bits()".}

proc getAuxRgba*(this: FrameBufferProperties): int {.importcpp: "#.get_aux_rgba()".}

proc getAuxHrgba*(this: FrameBufferProperties): int {.importcpp: "#.get_aux_hrgba()".}

proc getAuxFloat*(this: FrameBufferProperties): int {.importcpp: "#.get_aux_float()".}

proc getMultisamples*(this: FrameBufferProperties): int {.importcpp: "#.get_multisamples()".}

proc getCoverageSamples*(this: FrameBufferProperties): int {.importcpp: "#.get_coverage_samples()".} ## \
## If coverage samples are specified, and there is hardware support, we use
## coverage multisampling.

proc getBackBuffers*(this: FrameBufferProperties): int {.importcpp: "#.get_back_buffers()".}

proc getIndexedColor*(this: FrameBufferProperties): bool {.importcpp: "#.get_indexed_color()".}

proc getRgbColor*(this: FrameBufferProperties): bool {.importcpp: "#.get_rgb_color()".}

proc getStereo*(this: FrameBufferProperties): bool {.importcpp: "#.get_stereo()".}

proc getForceHardware*(this: FrameBufferProperties): bool {.importcpp: "#.get_force_hardware()".}

proc getForceSoftware*(this: FrameBufferProperties): bool {.importcpp: "#.get_force_software()".}

proc getSrgbColor*(this: FrameBufferProperties): bool {.importcpp: "#.get_srgb_color()".}

proc getFloatColor*(this: FrameBufferProperties): bool {.importcpp: "#.get_float_color()".}

proc getFloatDepth*(this: FrameBufferProperties): bool {.importcpp: "#.get_float_depth()".}

proc setDepthBits*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_depth_bits(#)".} ## \
## Individual assigners.

proc setColorBits*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_color_bits(#)".} ## \
## Sets the number of requested color bits as a single number that represents
## the sum of the individual numbers of red, green and blue bits.  Panda won't
## care how the individual bits are divided up.
##
## See also set_rgba_bits, which allows you to specify requirements for the
## individual components.

proc setRgbaBits*(this: FrameBufferProperties, r: int, g: int, b: int, a: int) {.importcpp: "#.set_rgba_bits(#, #, #, #)".} ## \
## Convenience method for setting the red, green, blue and alpha bits in one
## go.

proc setRedBits*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_red_bits(#)".}

proc setGreenBits*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_green_bits(#)".}

proc setBlueBits*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_blue_bits(#)".}

proc setAlphaBits*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_alpha_bits(#)".}

proc setStencilBits*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_stencil_bits(#)".}

proc setAccumBits*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_accum_bits(#)".}

proc setAuxRgba*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_aux_rgba(#)".}

proc setAuxHrgba*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_aux_hrgba(#)".}

proc setAuxFloat*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_aux_float(#)".}

proc setMultisamples*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_multisamples(#)".}

proc setCoverageSamples*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_coverage_samples(#)".} ## \
## If coverage samples are specified, and there is hardware support, we use
## coverage multisampling

proc setBackBuffers*(this: FrameBufferProperties, n: int) {.importcpp: "#.set_back_buffers(#)".}

proc setIndexedColor*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_indexed_color(#)".}

proc setRgbColor*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_rgb_color(#)".}

proc setStereo*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_stereo(#)".}

proc setForceHardware*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_force_hardware(#)".}

proc setForceSoftware*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_force_software(#)".}

proc setSrgbColor*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_srgb_color(#)".}

proc setFloatColor*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_float_color(#)".}

proc setFloatDepth*(this: FrameBufferProperties, n: bool) {.importcpp: "#.set_float_depth(#)".}

proc initFrameBufferProperties*(): FrameBufferProperties {.importcpp: "FrameBufferProperties()".}

proc initFrameBufferProperties*(param0: FrameBufferProperties): FrameBufferProperties {.importcpp: "FrameBufferProperties(#)".}

proc getDefault*(_: typedesc[FrameBufferProperties]): FrameBufferProperties {.importcpp: "FrameBufferProperties::get_default()", header: "frameBufferProperties.h".} ## \
## Returns a FrameBufferProperties structure with all of the default values
## filled in according to the user's config file.

proc `==`*(this: FrameBufferProperties, other: FrameBufferProperties): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: FrameBufferProperties, other: FrameBufferProperties): bool {.importcpp: "#.operator !=(#)".}

proc clear*(this: FrameBufferProperties) {.importcpp: "#.clear()".} ## \
## Unsets all properties that have been specified so far, and resets the
## FrameBufferProperties structure to its initial empty state.

proc setAllSpecified*(this: FrameBufferProperties) {.importcpp: "#.set_all_specified()".} ## \
## Marks all bits as having been specified.

proc subsumes*(this: FrameBufferProperties, other: FrameBufferProperties): bool {.importcpp: "#.subsumes(#)".} ## \
## Returns true if this set of properties makes strictly greater or equal
## demands of the framebuffer than the other set of framebuffer properties.

proc addProperties*(this: FrameBufferProperties, other: FrameBufferProperties) {.importcpp: "#.add_properties(#)".} ## \
## Sets any properties that are explicitly specified in other on this object.
## Leaves other properties unchanged.

proc output*(this: FrameBufferProperties, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Generates a string representation.

proc setOneBitPerChannel*(this: FrameBufferProperties) {.importcpp: "#.set_one_bit_per_channel()".} ## \
## If any of the depth, color, alpha, accum, or stencil properties is set to
## more than one, then they are reduced to one.

proc isStereo*(this: FrameBufferProperties): bool {.importcpp: "#.is_stereo()".}

proc isSingleBuffered*(this: FrameBufferProperties): bool {.importcpp: "#.is_single_buffered()".}

proc getQuality*(this: FrameBufferProperties, reqs: FrameBufferProperties): int {.importcpp: "#.get_quality(#)".} ## \
## Assumes that these properties are a description of a window.
##
## Measures how well this window satisfies a specified set of requirements.  A
## higher quality number means that more requirements were satisfied.  A
## quality of zero means that the window is unsuitable.
##
## The routine deducts a lot if the window fails to provide a requested
## feature.  It deducts less if the window provides a feature, but at a
## degraded level of functionality (ie, the user asks for rgba8, color, but
## the window only provides rgba4).  The routine also deducts a small amount
## for unnecessary features.  For example, if the window has an accumulation
## buffer when one is not requested will reduce quality slightly.  Maximum
## quality is obtained when the window exactly matches the request.
##
## If you want to know whether the window satisfies all of the requirements,
## use the "subsumes" function.

proc isAnySpecified*(this: FrameBufferProperties): bool {.importcpp: "#.is_any_specified()".} ## \
## Returns true if any properties have been specified, false otherwise.

proc isBasic*(this: FrameBufferProperties): bool {.importcpp: "#.is_basic()".} ## \
## Returns true if the properties are extremely basic.  The following count as
## basic: rgb or rgba, depth.  If anything else is specified, the properties
## are non-basic.

proc getAuxMask*(this: FrameBufferProperties): int {.importcpp: "#.get_aux_mask()".} ## \
## Converts the aux bitplanes of the framebuffer into a RenderBuffer::Type.

proc getBufferMask*(this: FrameBufferProperties): int {.importcpp: "#.get_buffer_mask()".} ## \
## Converts the non-aux bitplanes of the framebuffer into a
## RenderBuffer::Type.

proc verifyHardwareSoftware*(this: FrameBufferProperties, props: FrameBufferProperties, renderer: string): bool {.importcpp: "#.verify_hardware_software(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Validates that the properties represent the desired kind of renderer
## (hardware or software).  If not, prints out an error message and returns
## false.

proc setupColorTexture*(this: FrameBufferProperties, tex: Texture): bool {.importcpp: "#.setup_color_texture(#)".} ## \
## Sets the texture up for render-to-texture matching these framebuffer
## properties.
##
## Returns true if there was a format that had enough bits, false otherwise.
## Of course, this is no guarantee that a particular graphics back-end
## supports rendering to textures of that format.

proc setupDepthTexture*(this: FrameBufferProperties, tex: Texture): bool {.importcpp: "#.setup_depth_texture(#)".} ## \
## Sets the texture up for render-to-texture matching these framebuffer
## properties.
##
## Returns true if there was a format that had enough bits, false otherwise.
## Of course, this is no guarantee that a particular graphics back-end
## supports rendering to textures of that format.

proc buttonDown*(this: GraphicsWindowInputDevice, button: ButtonHandle, time: float64) {.importcpp: "#->button_down(#, #)".} ## \
## The following interface is for the various kinds of GraphicsWindows to
## record the data incoming on the device.

proc buttonDown*(this: GraphicsWindowInputDevice, button: ButtonHandle) {.importcpp: "#->button_down(#)".} ## \
## The following interface is for the various kinds of GraphicsWindows to
## record the data incoming on the device.

proc buttonResumeDown*(this: GraphicsWindowInputDevice, button: ButtonHandle, time: float64) {.importcpp: "#->button_resume_down(#, #)".} ## \
## Records that the indicated button was depressed earlier, and we only just
## detected the event after the fact.  This is mainly useful for tracking the
## state of modifier keys.

proc buttonResumeDown*(this: GraphicsWindowInputDevice, button: ButtonHandle) {.importcpp: "#->button_resume_down(#)".} ## \
## Records that the indicated button was depressed earlier, and we only just
## detected the event after the fact.  This is mainly useful for tracking the
## state of modifier keys.

proc buttonUp*(this: GraphicsWindowInputDevice, button: ButtonHandle, time: float64) {.importcpp: "#->button_up(#, #)".} ## \
## Records that the indicated button has been released.

proc buttonUp*(this: GraphicsWindowInputDevice, button: ButtonHandle) {.importcpp: "#->button_up(#)".} ## \
## Records that the indicated button has been released.

proc keystroke*(this: GraphicsWindowInputDevice, keycode: int, time: float64) {.importcpp: "#->keystroke(#, #)".} ## \
## Records that the indicated keystroke has been generated.

proc keystroke*(this: GraphicsWindowInputDevice, keycode: int) {.importcpp: "#->keystroke(#)".} ## \
## Records that the indicated keystroke has been generated.

proc candidate*(this: GraphicsWindowInputDevice, candidate_string: string, highlight_start: clonglong, highlight_end: clonglong, cursor_pos: clonglong) {.importcpp: "#->candidate(nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## Records that the indicated candidate string has been highlighted.  This is
## used to implement IME support for typing in international languages,
## especially Chinese/Japanese/Korean.

proc focusLost*(this: GraphicsWindowInputDevice, time: float64) {.importcpp: "#->focus_lost(#)".} ## \
## This should be called when the window focus is lost, so that we may miss
## upcoming button events (especially "up" events) for the next period of
## time.  It generates keyboard and mouse "up" events for those buttons that
## we previously sent unpaired "down" events, so that the Panda application
## will believe all buttons are now released.

proc focusLost*(this: GraphicsWindowInputDevice) {.importcpp: "#->focus_lost()".} ## \
## This should be called when the window focus is lost, so that we may miss
## upcoming button events (especially "up" events) for the next period of
## time.  It generates keyboard and mouse "up" events for those buttons that
## we previously sent unpaired "down" events, so that the Panda application
## will believe all buttons are now released.

proc rawButtonDown*(this: GraphicsWindowInputDevice, button: ButtonHandle, time: float64) {.importcpp: "#->raw_button_down(#, #)".} ## \
## Records that the indicated button has been depressed.

proc rawButtonDown*(this: GraphicsWindowInputDevice, button: ButtonHandle) {.importcpp: "#->raw_button_down(#)".} ## \
## Records that the indicated button has been depressed.

proc rawButtonUp*(this: GraphicsWindowInputDevice, button: ButtonHandle, time: float64) {.importcpp: "#->raw_button_up(#, #)".} ## \
## Records that the indicated button has been released.

proc rawButtonUp*(this: GraphicsWindowInputDevice, button: ButtonHandle) {.importcpp: "#->raw_button_up(#)".} ## \
## Records that the indicated button has been released.

proc getPointer*(this: GraphicsWindowInputDevice): PointerData {.importcpp: "#->get_pointer()".} ## \
## Returns the PointerData associated with the input device's pointer.  This
## only makes sense if has_pointer() also returns true.

proc setPointerInWindow*(this: GraphicsWindowInputDevice, x: float64, y: float64, time: float64) {.importcpp: "#->set_pointer_in_window(#, #, #)".} ## \
## To be called by a particular kind of GraphicsWindow to indicate that the
## pointer is within the window, at the given pixel coordinates.

proc setPointerInWindow*(this: GraphicsWindowInputDevice, x: float64, y: float64) {.importcpp: "#->set_pointer_in_window(#, #)".} ## \
## To be called by a particular kind of GraphicsWindow to indicate that the
## pointer is within the window, at the given pixel coordinates.

proc setPointerOutOfWindow*(this: GraphicsWindowInputDevice, time: float64) {.importcpp: "#->set_pointer_out_of_window(#)".} ## \
## To be called by a particular kind of GraphicsWindow to indicate that the
## pointer is no longer within the window.

proc setPointerOutOfWindow*(this: GraphicsWindowInputDevice) {.importcpp: "#->set_pointer_out_of_window()".} ## \
## To be called by a particular kind of GraphicsWindow to indicate that the
## pointer is no longer within the window.

proc updatePointer*(this: GraphicsWindowInputDevice, data: PointerData, time: float64) {.importcpp: "#->update_pointer(#, #)".} ## \
## To be called by a particular kind of GraphicsWindow to indicate that the
## pointer data has changed.

proc updatePointer*(this: GraphicsWindowInputDevice, data: PointerData) {.importcpp: "#->update_pointer(#)".} ## \
## To be called by a particular kind of GraphicsWindow to indicate that the
## pointer data has changed.

proc pointerMoved*(this: GraphicsWindowInputDevice, x: float64, y: float64, time: float64) {.importcpp: "#->pointer_moved(#, #, #)".} ## \
## To be called by a particular kind of GraphicsWindow to indicate that the
## pointer has moved by the given relative amount.

proc pointerMoved*(this: GraphicsWindowInputDevice, x: float64, y: float64) {.importcpp: "#->pointer_moved(#, #)".} ## \
## To be called by a particular kind of GraphicsWindow to indicate that the
## pointer has moved by the given relative amount.

proc removePointer*(this: GraphicsWindowInputDevice, id: int) {.importcpp: "#->remove_pointer(#)".} ## \
## To be called by a particular kind of GraphicsWindow to indicate that the
## pointer no longer exists.

converter getClassType*(_: typedesc[GraphicsWindowInputDevice]): TypeHandle {.importcpp: "GraphicsWindowInputDevice::get_class_type()", header: "graphicsWindowInputDevice.h".}

proc getX*(this: TouchInfo): int {.importcpp: "#.get_x()".}

proc getY*(this: TouchInfo): int {.importcpp: "#.get_y()".}

proc getId*(this: TouchInfo): int {.importcpp: "#.get_id()".}

proc getFlags*(this: TouchInfo): int {.importcpp: "#.get_flags()".}

proc initTouchInfo*(param0: TouchInfo): TouchInfo {.importcpp: "TouchInfo(#)".}

proc getHwnd*(this: GraphicsWindowProcCallbackData): clonglong {.importcpp: "#.get_hwnd()".} ## \
## Returns the Windows proc hwnd parameter.

proc getMsg*(this: GraphicsWindowProcCallbackData): int {.importcpp: "#.get_msg()".} ## \
## Returns the Windows proc msg parameter.

proc getWparam*(this: GraphicsWindowProcCallbackData): int {.importcpp: "#.get_wparam()".} ## \
## Returns the Windows proc wparam parameter.

proc getLparam*(this: GraphicsWindowProcCallbackData): int {.importcpp: "#.get_lparam()".} ## \
## Returns the Windows proc lparam parameter.

proc isTouchEvent*(this: GraphicsWindowProcCallbackData): bool {.importcpp: "#.is_touch_event()".} ## \
## Returns whether the event is a touch event.

proc getNumTouches*(this: GraphicsWindowProcCallbackData): int {.importcpp: "#.get_num_touches()".} ## \
## Returns the current number of touches on the window.

proc getTouchInfo*(this: GraphicsWindowProcCallbackData, index: int): TouchInfo {.importcpp: "#.get_touch_info(#)".} ## \
## Returns the TouchInfo object describing the specified touch.

converter getClassType*(_: typedesc[GraphicsWindowProcCallbackData]): TypeHandle {.importcpp: "GraphicsWindowProcCallbackData::get_class_type()", header: "graphicsWindowProcCallbackData.h".}

proc getProperties*(this: GraphicsWindow): WindowProperties {.importcpp: "#->get_properties()".} ## \
## Returns the current properties of the window.

proc getRequestedProperties*(this: GraphicsWindow): WindowProperties {.importcpp: "#->get_requested_properties()".} ## \
## Returns the properties of the window that are currently requested.  These
## properties will be applied to the window (if valid) at the next execution
## of process_events().

proc clearRejectedProperties*(this: GraphicsWindow) {.importcpp: "#->clear_rejected_properties()".} ## \
## Empties the set of failed properties that will be returned by
## get_rejected_properties().

proc getRejectedProperties*(this: GraphicsWindow): WindowProperties {.importcpp: "#->get_rejected_properties()".} ## \
## Returns the set of properties that have recently been requested, but could
## not be applied to the window for some reason.  This set of properties will
## remain unchanged until they are changed by a new failed request, or
## clear_rejected_properties() is called.

proc requestProperties*(this: GraphicsWindow, requested_properties: WindowProperties) {.importcpp: "#->request_properties(#)".} ## \
## Requests a property change on the window.  For example, use this method to
## request a window change size or minimize or something.
##
## The change is not made immediately; rather, the request is saved and will
## be applied the next time the window task is run (probably at the next
## frame).

proc isClosed*(this: GraphicsWindow): bool {.importcpp: "#->is_closed()".} ## \
## Returns true if the window has not yet been opened, or has been fully
## closed, false if it is open.  The window is not opened immediately after
## GraphicsEngine::make_output() is called; nor is it closed immediately after
## GraphicsEngine::remove_window() is called.  Either operation may take a
## frame or two.

proc isFullscreen*(this: GraphicsWindow): bool {.importcpp: "#->is_fullscreen()".} ## \
## Returns true if the window has been opened as a fullscreen window, false
## otherwise.

proc setWindowEvent*(this: GraphicsWindow, window_event: string) {.importcpp: "#->set_window_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name of the event that is generated when this window is
## modified externally, e.g.  to be resized or closed by the user.
##
## By default, all windows have the same window event unless they are
## explicitly changed.  When the event is generated, it includes one
## parameter: the window itself.

proc getWindowEvent*(this: GraphicsWindow): string {.importcpp: "nimStringFromStdString(#->get_window_event())", header: stringConversionCode.} ## \
## Returns the name of the event that is generated when this window is
## modified externally, e.g.  to be resized or closed by the user.  See
## set_window_event().

proc setCloseRequestEvent*(this: GraphicsWindow, close_request_event: string) {.importcpp: "#->set_close_request_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the event that is triggered when the user requests to close the
## window, e.g.  via alt-F4, or clicking on the close box.
##
## The default for each window is for this event to be the empty string, which
## means the window-close request is handled immediately by Panda (and the
## window will be closed without the app getting a chance to intervene).  If
## you set this to a nonempty string, then the window is not closed, but
## instead the event is thrown.  It is then up to the app to respond
## appropriately, for instance by presenting an "are you sure?"  dialog box,
## and eventually calling close_window() when the user is sure.
##
## It is considered poor form to set this string and then not handle the
## event.  This can frustrate the user by making it difficult for him to
## cleanly shut down the application (and may force the user to hard-kill the
## app, or reboot the machine).

proc getCloseRequestEvent*(this: GraphicsWindow): string {.importcpp: "nimStringFromStdString(#->get_close_request_event())", header: stringConversionCode.} ## \
## Returns the name of the event set via set_close_request_event().  If this
## string is nonempty, then when the user requests to close window, this event
## will be generated instead.  See set_close_request_event().

proc setUnexposedDraw*(this: GraphicsWindow, unexposed_draw: bool) {.importcpp: "#->set_unexposed_draw(#)".} ## \
## If this flag is false, the window is redrawn only after it has received a
## recent "unexpose" or "draw" event from the underlying windowing system.  If
## this flag is true, the window is redrawn every frame regardless.  Setting
## this false may prevent the window from redrawing unnecessarily when it is
## hidden, and may play nicer with other windows on the desktop, but may
## adversely affect frame rate even when the window is fully visible; setting
## it true will ensure that the window contents are always current.

proc getUnexposedDraw*(this: GraphicsWindow): bool {.importcpp: "#->get_unexposed_draw()".} ## \
## See set_unexposed_draw().

proc getWindowHandle*(this: GraphicsWindow): WindowHandle {.importcpp: "#->get_window_handle()".} ## \
## Returns the WindowHandle corresponding to this window on the desktop.  This
## is mainly useful for communicating with external libraries.  Use
## window_handle->get_os_handle()->get_handle(), or
## window_handle->get_string_handle(), to get the actual OS-specific window
## handle object, whatever type that might be.

proc getNumInputDevices*(this: GraphicsWindow): int {.importcpp: "#->get_num_input_devices()".} ## \
## Returns the number of separate input devices associated with the window.
## Typically, a window will have exactly one input device: the keyboard/mouse
## pair.  However, some windows may have no input devices, and others may add
## additional devices, for instance for a joystick.

proc getInputDevice*(this: GraphicsWindow, i: int): InputDevice {.importcpp: "#->get_input_device(#)".} ## \
## Returns the nth input device associated with the window.  Typically, a
## window will have exactly one input device: the keyboard/mouse pair.

proc getInputDeviceName*(this: GraphicsWindow, device: int): string {.importcpp: "nimStringFromStdString(#->get_input_device_name(#))", header: stringConversionCode.} ## \
## Returns the name of the nth input device.

proc hasPointer*(this: GraphicsWindow, device: int): bool {.importcpp: "#->has_pointer(#)".} ## \
## Returns true if the nth input device has a screen-space pointer (for
## instance, a mouse), false otherwise.

proc hasKeyboard*(this: GraphicsWindow, device: int): bool {.importcpp: "#->has_keyboard(#)".} ## \
## Returns true if the nth input device has a keyboard, false otherwise.

proc getKeyboardMap*(this: GraphicsWindow): ButtonMap {.importcpp: "#->get_keyboard_map()".} ## \
## Returns a ButtonMap containing the association between raw buttons and
## virtual buttons.

proc enablePointerEvents*(this: GraphicsWindow, device: int) {.importcpp: "#->enable_pointer_events(#)".} ## \
## Turn on the generation of pointer events.

proc disablePointerEvents*(this: GraphicsWindow, device: int) {.importcpp: "#->disable_pointer_events(#)".} ## \
## Turn off the generation of pointer events.

proc getPointer*(this: GraphicsWindow, device: int): MouseData {.importcpp: "#->get_pointer(#)".} ## \
## Returns the MouseData associated with the nth input device's pointer.
## Using this to access raw mice (with an index other than 0) is deprecated,
## see the InputDeviceManager interface instead.

proc movePointer*(this: GraphicsWindow, device: int, x: int, y: int): bool {.importcpp: "#->move_pointer(#, #, #)".} ## \
## Forces the pointer to the indicated position within the window, if
## possible.
##
## Returns true if successful, false on failure.  This may fail if the mouse
## is not currently within the window, or if the API doesn't support this
## operation.

proc closeIme*(this: GraphicsWindow) {.importcpp: "#->close_ime()".} ## \
## Forces the ime window to close if any

converter getClassType*(_: typedesc[GraphicsWindow]): TypeHandle {.importcpp: "GraphicsWindow::get_class_type()", header: "graphicsWindow.h".}

proc setEventsCallback*(this: CallbackGraphicsWindow, `object`: CallbackObject) {.importcpp: "#->set_events_callback(#)".} ## \
## Sets the CallbackObject that will be notified when this window is polled
## for window events, including mouse and keyboard events, as well as window
## resize events and other system-generated events.
##
## This callback will receive a CallbackGraphicsWindow::EventsCallbackData.
##
## This callback should process any system-generated events, and call
## data->upcall() to process requested property change requests made via
## request_properties().

proc clearEventsCallback*(this: CallbackGraphicsWindow) {.importcpp: "#->clear_events_callback()".} ## \
## Removes the callback set by an earlier call to set_events_callback().

proc getEventsCallback*(this: CallbackGraphicsWindow): CallbackObject {.importcpp: "#->get_events_callback()".} ## \
## Returns the CallbackObject set by set_events_callback().

proc setPropertiesCallback*(this: CallbackGraphicsWindow, `object`: CallbackObject) {.importcpp: "#->set_properties_callback(#)".} ## \
## Sets the CallbackObject that will be notified when this window receives a
## property change request from user code (e.g.  via request_properties).
##
## This callback will receive a
## CallbackGraphicsWindow::PropertiesCallbackData, which provides a
## get_properties() method that returns a modifiable reference to a
## WindowsProperties object.  This object will contain only those properties
## requested by user code.  The callback should handle any of the requests it
## finds, including and especially set_open(), and remove them from the object
## when it has handled them.  Any unhandled properties should be left
## unchanged in the properties object.

proc clearPropertiesCallback*(this: CallbackGraphicsWindow) {.importcpp: "#->clear_properties_callback()".} ## \
## Removes the callback set by an earlier call to set_properties_callback().

proc getPropertiesCallback*(this: CallbackGraphicsWindow): CallbackObject {.importcpp: "#->get_properties_callback()".} ## \
## Returns the CallbackObject set by set_properties_callback().

proc setRenderCallback*(this: CallbackGraphicsWindow, `object`: CallbackObject) {.importcpp: "#->set_render_callback(#)".} ## \
## Sets the CallbackObject that will be notified when this window is invoked
## (in the draw thread) to render its contents, and/or flip the graphics
## buffers.
##
## This callback will actually serve several different functions.  It
## receivces a RenderCallbackData, and you can query data->get_callback_type()
## to return the actual function of each particular callback.

proc clearRenderCallback*(this: CallbackGraphicsWindow) {.importcpp: "#->clear_render_callback()".} ## \
## Removes the callback set by an earlier call to set_render_callback().

proc getRenderCallback*(this: CallbackGraphicsWindow): CallbackObject {.importcpp: "#->get_render_callback()".} ## \
## Returns the CallbackObject set by set_render_callback().

proc createInputDevice*(this: CallbackGraphicsWindow, name: string): int {.importcpp: "#->create_input_device(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Adds a new input device (mouse) to the window with the indicated name.
## Returns the index of the new device.

converter getClassType*(_: typedesc[CallbackGraphicsWindow]): TypeHandle {.importcpp: "CallbackGraphicsWindow::get_class_type()", header: "callbackGraphicsWindow.h".}

proc `==`*(this: DisplayMode, other: DisplayMode): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: DisplayMode, other: DisplayMode): bool {.importcpp: "#.operator !=(#)".}

proc output*(this: DisplayMode, `out`: ostream) {.importcpp: "#.output(#)".}

proc initDisplayMode*(): DisplayMode {.importcpp: "DisplayMode()".}

proc initDisplayMode*(param0: DisplayMode): DisplayMode {.importcpp: "DisplayMode(#)".}

proc getSceneSetup*(this: DisplayRegionCullCallbackData): SceneSetup {.importcpp: "#.get_scene_setup()".} ## \
## Returns a pointer to the SceneSetup object, which contains information
## about the camera and such.

converter getClassType*(_: typedesc[DisplayRegionCullCallbackData]): TypeHandle {.importcpp: "DisplayRegionCullCallbackData::get_class_type()", header: "displayRegionCullCallbackData.h".}

proc getCullResult*(this: DisplayRegionDrawCallbackData): CullResult {.importcpp: "#.get_cull_result()".} ## \
## Returns a pointer to the CullResult, the list of CullableObjects that
## should be drawn in this DisplayRegion.

proc getSceneSetup*(this: DisplayRegionDrawCallbackData): SceneSetup {.importcpp: "#.get_scene_setup()".} ## \
## Returns a pointer to the SceneSetup object, which contains information
## about the camera and such.

converter getClassType*(_: typedesc[DisplayRegionDrawCallbackData]): TypeHandle {.importcpp: "DisplayRegionDrawCallbackData::get_class_type()", header: "displayRegionDrawCallbackData.h".}

proc initDisplaySearchParameters*(): DisplaySearchParameters {.importcpp: "DisplaySearchParameters()".}

proc initDisplaySearchParameters*(param0: DisplaySearchParameters): DisplaySearchParameters {.importcpp: "DisplaySearchParameters(#)".}

proc setMinimumWidth*(this: DisplaySearchParameters, minimum_width: int) {.importcpp: "#.set_minimum_width(#)".}

proc setMaximumWidth*(this: DisplaySearchParameters, maximum_width: int) {.importcpp: "#.set_maximum_width(#)".}

proc setMinimumHeight*(this: DisplaySearchParameters, minimum_height: int) {.importcpp: "#.set_minimum_height(#)".}

proc setMaximumHeight*(this: DisplaySearchParameters, maximum_height: int) {.importcpp: "#.set_maximum_height(#)".}

proc setMinimumBitsPerPixel*(this: DisplaySearchParameters, minimum_bits_per_pixel: int) {.importcpp: "#.set_minimum_bits_per_pixel(#)".}

proc setMaximumBitsPerPixel*(this: DisplaySearchParameters, maximum_bits_per_pixel: int) {.importcpp: "#.set_maximum_bits_per_pixel(#)".}

proc setSize*(this: GraphicsBuffer, x: int, y: int) {.importcpp: "#->set_size(#, #)".} ## \
## This is called by the GraphicsEngine to request that the buffer resize
## itself.  Although calls to get the size will return the new value, much of
## the actual resizing work doesn't take place until the next begin_frame.
## Not all buffers are resizeable.

converter getClassType*(_: typedesc[GraphicsBuffer]): TypeHandle {.importcpp: "GraphicsBuffer::get_class_type()", header: "graphicsBuffer.h".}

proc getNumPipeTypes*(this: GraphicsPipeSelection): int {.importcpp: "#->get_num_pipe_types()".} ## \
## Returns the number of different types of GraphicsPipes that are available
## to create through this interface.

proc getPipeType*(this: GraphicsPipeSelection, n: int): TypeHandle {.importcpp: "#->get_pipe_type(#)".} ## \
## Returns the nth type of GraphicsPipe available through this interface.

proc printPipeTypes*(this: GraphicsPipeSelection) {.importcpp: "#->print_pipe_types()".} ## \
## Writes a list of the currently known GraphicsPipe types to nout, for the
## user's information.

proc makePipe*(this: GraphicsPipeSelection, `type`: TypeHandle): GraphicsPipe {.importcpp: "#->make_pipe(#)".} ## \
## Creates a new GraphicsPipe of the indicated type (or a type more specific
## than the indicated type, if necessary) and returns it.  Returns NULL if the
## type cannot be matched.

proc makePipe*(this: GraphicsPipeSelection, type_name: string, module_name: string): GraphicsPipe {.importcpp: "#->make_pipe(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates a new GraphicsPipe of the indicated type (or a type more specific
## than the indicated type, if necessary) and returns it.  Returns NULL if the
## type cannot be matched.
##
## If the type is not already defined, this will implicitly load the named
## module, or if module_name is empty, it will call load_aux_modules().

proc makePipe*(this: GraphicsPipeSelection, type_name: string): GraphicsPipe {.importcpp: "#->make_pipe(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates a new GraphicsPipe of the indicated type (or a type more specific
## than the indicated type, if necessary) and returns it.  Returns NULL if the
## type cannot be matched.
##
## If the type is not already defined, this will implicitly load the named
## module, or if module_name is empty, it will call load_aux_modules().

proc makeModulePipe*(this: GraphicsPipeSelection, module_name: string): GraphicsPipe {.importcpp: "#->make_module_pipe(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a new GraphicsPipe of a type defined by the indicated module.
## Returns NULL if the module is not found or does not properly recommend a
## GraphicsPipe.

proc makeDefaultPipe*(this: GraphicsPipeSelection): GraphicsPipe {.importcpp: "#->make_default_pipe()".} ## \
## Creates a new GraphicsPipe of some arbitrary type.  The user may specify a
## preference using the Configrc file; otherwise, one will be chosen
## arbitrarily.

proc getNumAuxModules*(this: GraphicsPipeSelection): int {.importcpp: "#->get_num_aux_modules()".} ## \
## Returns the number of display modules that are still to be loaded.  If this
## is nonzero, then calling load_aux_modules() will likely increase the number
## of GraphicsPipes available.

proc loadAuxModules*(this: GraphicsPipeSelection) {.importcpp: "#->load_aux_modules()".} ## \
## Loads all the modules named in the aux-display Configrc variable, making as
## many graphics pipes as possible available.

proc getGlobalPtr*(_: typedesc[GraphicsPipeSelection]): GraphicsPipeSelection {.importcpp: "GraphicsPipeSelection::get_global_ptr()", header: "graphicsPipeSelection.h".} ## \
## Returns a pointer to the one global GraphicsPipeSelection object.

proc newMouseAndKeyboard*(window: GraphicsWindow, device: int, name: string): MouseAndKeyboard {.importcpp: "new MouseAndKeyboard(#, #, nimStringToStdString(#))", header: stringConversionCode.}

proc newMouseAndKeyboard*(param0: MouseAndKeyboard): MouseAndKeyboard {.importcpp: "new MouseAndKeyboard(#)".}

proc setSource*(this: MouseAndKeyboard, window: GraphicsWindow, device: int) {.importcpp: "#->set_source(#, #)".} ## \
## Redirects the class to get the data from the mouse and keyboard associated
## with a different window and/or device number.

converter getClassType*(_: typedesc[MouseAndKeyboard]): TypeHandle {.importcpp: "MouseAndKeyboard::get_class_type()", header: "mouseAndKeyboard.h".}

proc makeInt*(_: typedesc[NativeWindowHandle], window: clonglong): WindowHandle {.importcpp: "#NativeWindowHandle::make_int(#)", header: "nativeWindowHandle.h".} ## \
## Constructs a new WindowHandle with an int value, which is understood to be
## either an HWND or a Window, cast to int.  This method exists for the
## convenience of Python, which likes to deal with ints; C++ code should use
## one of the more specific make_x11() or make_win32() methods instead.

proc makeSubprocess*(_: typedesc[NativeWindowHandle], filename: Filename): WindowHandle {.importcpp: "#NativeWindowHandle::make_subprocess(#)", header: "nativeWindowHandle.h".} ## \
## Constructs a new WindowHandle that references a SubprocessWindowBuffer read
## in another process, with the named pipe filename that it uses for
## communication.
##
## This is (at present, and maybe always) useful only on the OS X platform,
## where parenting child windows is particularly problematic.

converter getClassType*(_: typedesc[NativeWindowHandle]): TypeHandle {.importcpp: "NativeWindowHandle::get_class_type()", header: "nativeWindowHandle.h".}

proc setSize*(this: ParasiteBuffer, x: int, y: int) {.importcpp: "#->set_size(#, #)".} ## \
## This is called by the GraphicsEngine to request that the buffer resize
## itself.  Although calls to get the size will return the new value, much of
## the actual resizing work doesn't take place until the next begin_frame.
## Not all buffers are resizeable.

converter getClassType*(_: typedesc[ParasiteBuffer]): TypeHandle {.importcpp: "ParasiteBuffer::get_class_type()", header: "parasiteBuffer.h".}

converter upcastToTypedReferenceCount*(this: Thread): TypedReferenceCount {.importcpp: "(PT(TypedReferenceCount)(#))".}

converter upcastToNamable*(this: Thread): Namable {.importcpp: "((Namable *)(Thread *)(#))".}

proc bindThread*(_: typedesc[Thread], name: string, sync_name: string): Thread {.importcpp: "#Thread::bind_thread(nimStringToStdString(#), nimStringToStdString(#))", header: "thread.h".} ## \
## Returns a new Panda Thread object associated with the current thread (which
## has been created externally). This can be used to bind a unique Panda
## Thread object with an external thread, such as a new Python thread.
##
## It is particularly useful to bind a Panda Thread object to an external
## thread for the purposes of PStats monitoring.  Without this call, each
## external thread will be assigned the same global ExternalThread object,
## which means they will all appear in the same PStats graph.
##
## It is the caller's responsibility to save the returned Thread pointer for
## the lifetime of the external thread.  It is an error for the Thread pointer
## to destruct while the external thread is still in the system.
##
## It is also an error to call this method from the main thread, or twice
## within a given thread, unless it is given the same name each time (in which
## case the same pointer will be returned each time).

proc getSyncName*(this: Thread): string {.importcpp: "nimStringFromStdString(#->get_sync_name())", header: stringConversionCode.} ## \
## Returns the sync name of the thread.  This name collects threads into "sync
## groups", which are expected to run synchronously.  This is mainly used for
## the benefit of PStats; threads with the same sync name can be ticked all at
## once via the thread_tick() call.

proc getPstatsIndex*(this: Thread): int {.importcpp: "#->get_pstats_index()".} ## \
## Returns the PStats index associated with this thread, or -1 if no index has
## yet been associated with this thread.  This is used internally by the
## PStatClient; you should not need to call this directly.

proc getPythonIndex*(this: Thread): int {.importcpp: "#->get_python_index()".} ## \
## Returns the Python index associated with this thread, or -1 if no index has
## yet been associated with this thread.  This is used internally by the
## direct.stdpy.thread module; you should not need to call this directly.

proc getUniqueId*(this: Thread): string {.importcpp: "nimStringFromStdString(#->get_unique_id())", header: stringConversionCode.} ## \
## Returns a string that is guaranteed to be unique to this thread, across all
## processes on the machine, during at least the lifetime of this process.

proc getPipelineStage*(this: Thread): int {.importcpp: "#->get_pipeline_stage()".} ## \
## Returns the Pipeline stage number associated with this thread.  The default
## stage is 0 if no stage is specified otherwise.  See set_pipeline_stage().

proc setPipelineStage*(this: Thread, pipeline_stage: int) {.importcpp: "#->set_pipeline_stage(#)".} ## \
## Specifies the Pipeline stage number associated with this thread.  The
## default stage is 0 if no stage is specified otherwise.
##
## This must be a value in the range [0 .. pipeline->get_num_stages() - 1].
## It specifies the values that this thread observes for all pipelined data.
## Typically, an application thread will leave this at 0, but a render thread
## may set it to 1 or 2 (to operate on the previous frame's data, or the
## second previous frame's data).

proc setMinPipelineStage*(this: Thread, min_pipeline_stage: int) {.importcpp: "#->set_min_pipeline_stage(#)".} ## \
## Sets this thread's pipeline stage number to at least the indicated value,
## unless it is already larger.  See set_pipeline_stage().

proc getMainThread*(_: typedesc[Thread]): Thread {.importcpp: "Thread::get_main_thread()", header: "thread.h".} ## \
## Returns a pointer to the "main" Thread object--this is the Thread that
## started the whole process.

proc getExternalThread*(_: typedesc[Thread]): Thread {.importcpp: "Thread::get_external_thread()", header: "thread.h".} ## \
## Returns a pointer to the "external" Thread object--this is a special Thread
## object that corresponds to any thread spawned outside of Panda's threading
## interface.  Note that multiple different threads may share this same
## pointer.

proc getCurrentThread*(_: typedesc[Thread]): Thread {.importcpp: "Thread::get_current_thread()", header: "thread.h".} ## \
## Returns a pointer to the currently-executing Thread object.  If this is
## called from the main thread, this will return the same value as
## get_main_thread().
##
## This will always return some valid Thread pointer.  It will never return
## NULL, even if the current thread was spawned outside of Panda's threading
## system, although all non-Panda threads will return the exact same Thread
## pointer.

proc getCurrentPipelineStage*(_: typedesc[Thread]): int {.importcpp: "Thread::get_current_pipeline_stage()", header: "thread.h".} ## \
## Returns the integer pipeline stage associated with the current thread.
## This is the same thing as get_current_thread()->get_pipeline_stage(), but
## it may be faster to retrieve in some contexts.

proc isThreadingSupported*(_: typedesc[Thread]): bool {.importcpp: "Thread::is_threading_supported()", header: "thread.h".} ## \
## Returns true if threading support has been compiled in and enabled, or
## false if no threading is available (and Thread::start() will always fail).

proc isTrueThreads*(_: typedesc[Thread]): bool {.importcpp: "Thread::is_true_threads()", header: "thread.h".} ## \
## Returns true if a real threading library is available that supports actual
## OS-implemented threads, or false if the only threading we can provide is
## simulated user-space threading.

proc isSimpleThreads*(_: typedesc[Thread]): bool {.importcpp: "Thread::is_simple_threads()", header: "thread.h".} ## \
## Returns true if Panda is currently compiled for "simple threads", which is
## to say, cooperative context switching only, reducing the need for quite so
## many critical section protections.  This is not necessarily the opposite of
## "true threads", since one possible implementation of simple threads is via
## true threads with mutex protection to ensure only one runs at a time.

proc sleep*(_: typedesc[Thread], seconds: float64) {.importcpp: "#Thread::sleep(#)", header: "thread.h".} ## \
## Suspends the current thread for at least the indicated amount of time.  It
## might be suspended for longer.

proc forceYield*(_: typedesc[Thread]) {.importcpp: "Thread::force_yield()", header: "thread.h".} ## \
## Suspends the current thread for the rest of the current epoch.

proc considerYield*(_: typedesc[Thread]) {.importcpp: "Thread::consider_yield()", header: "thread.h".} ## \
## Possibly suspends the current thread for the rest of the current epoch, if
## it has run for enough this epoch.  This is especially important for the
## simple thread implementation, which relies on cooperative yields like this.

proc output*(this: Thread, `out`: ostream) {.importcpp: "#->output(#)".}

proc outputBlocker*(this: Thread, `out`: ostream) {.importcpp: "#->output_blocker(#)".} ## \
## Writes a description of the mutex or condition variable that this thread is
## blocked on.  Writes nothing if there is no blocker, or if we are not in
## DEBUG_THREADS mode.

proc writeStatus*(_: typedesc[Thread], `out`: ostream) {.importcpp: "#Thread::write_status(#)", header: "thread.h".}

proc isStarted*(this: Thread): bool {.importcpp: "#->is_started()".} ## \
## Returns true if the thread has been started, false if it has not, or if
## join() has already been called.

proc isJoinable*(this: Thread): bool {.importcpp: "#->is_joinable()".} ## \
## Returns the value of joinable that was passed to the start() call.

proc start*(this: Thread, priority: ThreadPriority, joinable: bool): bool {.importcpp: "#->start(#, #)".} ## \
## Starts the thread executing.  It is only valid to call this once.
##
## The thread will begin executing its thread_main() function, and will
## terminate when thread_main() returns.
##
## priority is intended as a hint to the relative importance of this thread.
## This may be ignored by the thread implementation.
##
## joinable should be set true if you intend to call join() to wait for the
## thread to terminate, or false if you don't care and you will never call
## join(). Note that the reference count on the Thread object is incremented
## while the thread itself is running, so if you just want to fire and forget
## a thread, you may pass joinable = false, and never store the Thread object.
## It will automatically destruct itself when it finishes.
##
## The return value is true if the thread is successfully started, false
## otherwise.

proc join*(this: Thread) {.importcpp: "#->join()".} ## \
## Blocks the calling process until the thread terminates.  If the thread has
## already terminated, this returns immediately.

proc preempt*(this: Thread) {.importcpp: "#->preempt()".} ## \
## Indicates that this thread should run as soon as possible, preemptying any
## other threads that may be scheduled to run.  This may not be implemented on
## every platform.

proc getCurrentTask*(this: Thread): TypedReferenceCount {.importcpp: "#->get_current_task()".} ## \
## Returns the task currently executing on this thread (via the
## AsyncTaskManager), if any, or NULL if the thread is not currently servicing
## a task.

proc setPythonIndex*(this: Thread, index: int) {.importcpp: "#->set_python_index(#)".} ## \
## Stores a Python index to be associated with this thread.  This is used
## internally by the thread module; you should not need to call this directly.

proc prepareForExit*(_: typedesc[Thread]) {.importcpp: "Thread::prepare_for_exit()", header: "thread.h".} ## \
## Should be called by the main thread just before exiting the program, this
## blocks until any remaining thread cleanup has finished.

converter getClassType*(_: typedesc[Thread]): TypeHandle {.importcpp: "Thread::get_class_type()", header: "thread.h".}

proc acquire*(this: MutexDirect) {.importcpp: "#.acquire()".} ## \
## Grabs the mutex if it is available.  If it is not available, blocks until
## it becomes available, then grabs it.  In either case, the function does not
## return until the mutex is held; you should then call unlock().
##
## This method is considered const so that you can lock and unlock const
## mutexes, mainly to allow thread-safe access to otherwise const data.
##
## Also see MutexHolder.

proc tryAcquire*(this: MutexDirect): bool {.importcpp: "#.try_acquire()".} ## \
## Returns immediately, with a true value indicating the mutex has been
## acquired, and false indicating it has not.

proc release*(this: MutexDirect) {.importcpp: "#.release()".} ## \
## Releases the mutex.  It is an error to call this if the mutex was not
## already locked.
##
## This method is considered const so that you can lock and unlock const
## mutexes, mainly to allow thread-safe access to otherwise const data.

proc debugIsLocked*(this: MutexDirect): bool {.importcpp: "#.debug_is_locked()".} ## \
## Returns true if the current thread has locked the Mutex, false otherwise.
## This method is only intended for use in debugging, hence the method name;
## in the MutexDirect case, it always returns true, since there's not a
## reliable way to determine this otherwise.

proc setName*(this: MutexDirect, name: string) {.importcpp: "#.set_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc clearName*(this: MutexDirect) {.importcpp: "#.clear_name()".} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc hasName*(this: MutexDirect): bool {.importcpp: "#.has_name()".} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc getName*(this: MutexDirect): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc output*(this: MutexDirect, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## This method is declared virtual in MutexDebug, but non-virtual in
## MutexDirect.

proc initMutex*(): Mutex {.importcpp: "Mutex()".}

proc initMutex*(name: string): Mutex {.importcpp: "Mutex(nimStringToStdString(#))", header: stringConversionCode.}

proc getMutex*(this: ConditionVarDirect): MutexDirect {.importcpp: "#.get_mutex()".} ## \
## Returns the mutex associated with this condition variable.

proc wait*(this: ConditionVarDirect) {.importcpp: "#.wait()".} ## \
## Waits on the condition.  The caller must already be holding the lock
## associated with the condition variable before calling this function.
##
## wait() will release the lock, then go to sleep until some other thread
## calls notify() on this condition variable.  At that time at least one
## thread waiting on the same ConditionVarDirect will grab the lock again, and
## then return from wait().
##
## It is possible that wait() will return even if no one has called notify().
## It is the responsibility of the calling process to verify the condition on
## return from wait, and possibly loop back to wait again if necessary.
##
## Note the semantics of a condition variable: the mutex must be held before
## wait() is called, and it will still be held when wait() returns.  However,
## it will be temporarily released during the wait() call itself.

proc wait*(this: ConditionVarDirect, timeout: float64) {.importcpp: "#.wait(#)".} ## \
## Waits on the condition, with a timeout.  The function will return when the
## condition variable is notified, or the timeout occurs.  There is no way to
## directly tell which happened, and it is possible that neither in fact
## happened (spurious wakeups are possible).
##
## See wait() with no parameters for more.

proc notify*(this: ConditionVarDirect) {.importcpp: "#.notify()".} ## \
## Informs one of the other threads who are currently blocked on wait() that
## the relevant condition has changed.  If multiple threads are currently
## waiting, at least one of them will be woken up, although there is no way to
## predict which one.  It is possible that more than one thread will be woken
## up.
##
## The caller must be holding the mutex associated with the condition variable
## before making this call, which will not release the mutex.
##
## If no threads are waiting, this is a no-op: the notify event is lost.

proc output*(this: ConditionVarDirect, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## This method is declared virtual in ConditionVarDebug, but non-virtual in
## ConditionVarDirect.

proc initConditionVar*(mutex: Mutex): ConditionVar {.importcpp: "ConditionVar(#)".} ## \
## You must pass in a Mutex to the condition variable constructor.  This mutex
## may be shared by other condition variables, if desired.  It is the caller's
## responsibility to ensure the Mutex object does not destruct during the
## lifetime of the condition variable.

proc getMutex*(this: ConditionVar): Mutex {.importcpp: "#.get_mutex()".} ## \
## Returns the mutex associated with this condition variable.

proc getMutex*(this: ConditionVarFullDirect): MutexDirect {.importcpp: "#.get_mutex()".} ## \
## Returns the mutex associated with this condition variable.

proc wait*(this: ConditionVarFullDirect) {.importcpp: "#.wait()".} ## \
## Waits on the condition.  The caller must already be holding the lock
## associated with the condition variable before calling this function.
##
## wait() will release the lock, then go to sleep until some other thread
## calls notify() on this condition variable.  At that time at least one
## thread waiting on the same ConditionVarFullDirect will grab the lock again,
## and then return from wait().
##
## It is possible that wait() will return even if no one has called notify().
## It is the responsibility of the calling process to verify the condition on
## return from wait, and possibly loop back to wait again if necessary.
##
## Note the semantics of a condition variable: the mutex must be held before
## wait() is called, and it will still be held when wait() returns.  However,
## it will be temporarily released during the wait() call itself.

proc wait*(this: ConditionVarFullDirect, timeout: float64) {.importcpp: "#.wait(#)".} ## \
## Waits on the condition, with a timeout.  The function will return when the
## condition variable is notified, or the timeout occurs.  There is no way to
## directly tell which happened, and it is possible that neither in fact
## happened (spurious wakeups are possible).
##
## See wait() with no parameters for more.

proc notify*(this: ConditionVarFullDirect) {.importcpp: "#.notify()".} ## \
## Informs one of the other threads who are currently blocked on wait() that
## the relevant condition has changed.  If multiple threads are currently
## waiting, at least one of them will be woken up, although there is no way to
## predict which one.  It is possible that more than one thread will be woken
## up.
##
## The caller must be holding the mutex associated with the condition variable
## before making this call, which will not release the mutex.
##
## If no threads are waiting, this is a no-op: the notify is lost.

proc notifyAll*(this: ConditionVarFullDirect) {.importcpp: "#.notify_all()".} ## \
## Informs all of the other threads who are currently blocked on wait() that
## the relevant condition has changed.
##
## The caller must be holding the mutex associated with the condition variable
## before making this call, which will not release the mutex.
##
## If no threads are waiting, this is a no-op: the notify event is lost.

proc output*(this: ConditionVarFullDirect, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## This method is declared virtual in ConditionVarFullDebug, but non-virtual
## in ConditionVarFullDirect.

proc initConditionVarFull*(mutex: Mutex): ConditionVarFull {.importcpp: "ConditionVarFull(#)".} ## \
## You must pass in a Mutex to the condition variable constructor.  This mutex
## may be shared by other condition variables, if desired.  It is the caller's
## responsibility to ensure the Mutex object does not destruct during the
## lifetime of the condition variable.

proc getMutex*(this: ConditionVarFull): Mutex {.importcpp: "#.get_mutex()".} ## \
## Returns the mutex associated with this condition variable.

proc acquire*(this: ReMutexDirect) {.importcpp: "#.acquire()".} ## \
## Grabs the reMutex if it is available.  If it is not available, blocks until
## it becomes available, then grabs it.  In either case, the function does not
## return until the reMutex is held; you should then call unlock().
##
## This method is considered const so that you can lock and unlock const
## reMutexes, mainly to allow thread-safe access to otherwise const data.
##
## Also see ReMutexHolder.

proc acquire*(this: ReMutexDirect, current_thread: Thread) {.importcpp: "#.acquire(#)".} ## \
## This variant on acquire() accepts the current thread as a parameter, if it
## is already known, as an optimization.

proc tryAcquire*(this: ReMutexDirect): bool {.importcpp: "#.try_acquire()".} ## \
## Returns immediately, with a true value indicating the mutex has been
## acquired, and false indicating it has not.

proc tryAcquire*(this: ReMutexDirect, current_thread: Thread): bool {.importcpp: "#.try_acquire(#)".} ## \
## Returns immediately, with a true value indicating the mutex has been
## acquired, and false indicating it has not.

proc elevateLock*(this: ReMutexDirect) {.importcpp: "#.elevate_lock()".} ## \
## This method increments the lock count, assuming the calling thread already
## holds the lock.  After this call, release() will need to be called one
## additional time to release the lock.
##
## This method really performs the same function as acquire(), but it offers a
## potential (slight) performance benefit when the calling thread knows that
## it already holds the lock.  It is an error to call this when the calling
## thread does not hold the lock.

proc release*(this: ReMutexDirect) {.importcpp: "#.release()".} ## \
## Releases the reMutex.  It is an error to call this if the reMutex was not
## already locked.
##
## This method is considered const so that you can lock and unlock const
## reMutexes, mainly to allow thread-safe access to otherwise const data.

proc debugIsLocked*(this: ReMutexDirect): bool {.importcpp: "#.debug_is_locked()".} ## \
## Returns true if the current thread has locked the ReMutex, false otherwise.
## This method is only intended for use in debugging, hence the method name;
## in the ReMutexDirect case, it always returns true, since there's not a
## reliable way to determine this otherwise.

proc setName*(this: ReMutexDirect, name: string) {.importcpp: "#.set_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc clearName*(this: ReMutexDirect) {.importcpp: "#.clear_name()".} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc hasName*(this: ReMutexDirect): bool {.importcpp: "#.has_name()".} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc getName*(this: ReMutexDirect): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc output*(this: ReMutexDirect, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## This method is declared virtual in MutexDebug, but non-virtual in
## ReMutexDirect.

proc initReMutex*(): ReMutex {.importcpp: "ReMutex()".}

proc initReMutex*(name: string): ReMutex {.importcpp: "ReMutex(nimStringToStdString(#))", header: stringConversionCode.}

converter getClassType*(_: typedesc[ExternalThread]): TypeHandle {.importcpp: "ExternalThread::get_class_type()", header: "externalThread.h".}

proc acquire*(this: LightMutexDirect) {.importcpp: "#.acquire()".} ## \
## Grabs the lightMutex if it is available.  If it is not available, blocks
## until it becomes available, then grabs it.  In either case, the function
## does not return until the lightMutex is held; you should then call
## unlock().
##
## This method is considered const so that you can lock and unlock const
## lightMutexes, mainly to allow thread-safe access to otherwise const data.
##
## Also see LightMutexHolder.

proc release*(this: LightMutexDirect) {.importcpp: "#.release()".} ## \
## Releases the lightMutex.  It is an error to call this if the lightMutex was
## not already locked.
##
## This method is considered const so that you can lock and unlock const
## lightMutexes, mainly to allow thread-safe access to otherwise const data.

proc debugIsLocked*(this: LightMutexDirect): bool {.importcpp: "#.debug_is_locked()".} ## \
## Returns true if the current thread has locked the LightMutex, false
## otherwise.  This method is only intended for use in debugging, hence the
## method name; in the LightMutexDirect case, it always returns true, since
## there's not a reliable way to determine this otherwise.

proc setName*(this: LightMutexDirect, name: string) {.importcpp: "#.set_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## The lightMutex name is only defined when compiling in DEBUG_THREADS mode.

proc clearName*(this: LightMutexDirect) {.importcpp: "#.clear_name()".} ## \
## The lightMutex name is only defined when compiling in DEBUG_THREADS mode.

proc hasName*(this: LightMutexDirect): bool {.importcpp: "#.has_name()".} ## \
## The lightMutex name is only defined when compiling in DEBUG_THREADS mode.

proc getName*(this: LightMutexDirect): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## The lightMutex name is only defined when compiling in DEBUG_THREADS mode.

proc output*(this: LightMutexDirect, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## This method is declared virtual in LightMutexDebug, but non-virtual in
## LightMutexDirect.

proc initLightMutex*(): LightMutex {.importcpp: "LightMutex()".}

proc initLightMutex*(name: string): LightMutex {.importcpp: "LightMutex(nimStringToStdString(#))", header: stringConversionCode.}

proc acquire*(this: LightReMutexDirect) {.importcpp: "#.acquire()".} ## \
## Grabs the lightReMutex if it is available.  If it is not available, blocks
## until it becomes available, then grabs it.  In either case, the function
## does not return until the lightReMutex is held; you should then call
## unlock().
##
## This method is considered const so that you can lock and unlock const
## lightReMutexes, mainly to allow thread-safe access to otherwise const data.
##
## Also see LightReMutexHolder.

proc acquire*(this: LightReMutexDirect, current_thread: Thread) {.importcpp: "#.acquire(#)".} ## \
## This variant on acquire() accepts the current thread as a parameter, if it
## is already known, as an optimization.

proc elevateLock*(this: LightReMutexDirect) {.importcpp: "#.elevate_lock()".} ## \
## This method increments the lock count, assuming the calling thread already
## holds the lock.  After this call, release() will need to be called one
## additional time to release the lock.
##
## This method really performs the same function as acquire(), but it offers a
## potential (slight) performance benefit when the calling thread knows that
## it already holds the lock.  It is an error to call this when the calling
## thread does not hold the lock.

proc release*(this: LightReMutexDirect) {.importcpp: "#.release()".} ## \
## Releases the lightReMutex.  It is an error to call this if the lightReMutex
## was not already locked.
##
## This method is considered const so that you can lock and unlock const
## lightReMutexes, mainly to allow thread-safe access to otherwise const data.

proc debugIsLocked*(this: LightReMutexDirect): bool {.importcpp: "#.debug_is_locked()".} ## \
## Returns true if the current thread has locked the LightReMutex, false
## otherwise.  This method is only intended for use in debugging, hence the
## method name; in the LightReMutexDirect case, it always returns true, since
## there's not a reliable way to determine this otherwise.

proc setName*(this: LightReMutexDirect, name: string) {.importcpp: "#.set_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc clearName*(this: LightReMutexDirect) {.importcpp: "#.clear_name()".} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc hasName*(this: LightReMutexDirect): bool {.importcpp: "#.has_name()".} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc getName*(this: LightReMutexDirect): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## The mutex name is only defined when compiling in DEBUG_THREADS mode.

proc output*(this: LightReMutexDirect, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## This method is declared virtual in MutexDebug, but non-virtual in
## LightReMutexDirect.

proc initLightReMutex*(): LightReMutex {.importcpp: "LightReMutex()".}

proc initLightReMutex*(name: string): LightReMutex {.importcpp: "LightReMutex(nimStringToStdString(#))", header: stringConversionCode.}

converter getClassType*(_: typedesc[MainThread]): TypeHandle {.importcpp: "MainThread::get_class_type()", header: "mainThread.h".}

proc initSemaphore*(initial_count: int): Semaphore {.importcpp: "Semaphore(#)".}

proc initSemaphore*(): Semaphore {.importcpp: "Semaphore()".}

proc acquire*(this: Semaphore) {.importcpp: "#.acquire()".} ## \
## Decrements the internal count.  If the count was already at zero, blocks
## until the count is nonzero, then decrements it.

proc tryAcquire*(this: Semaphore): bool {.importcpp: "#.try_acquire()".} ## \
## If the semaphore can be acquired without blocking, does so and returns
## true.  Otherwise, returns false.

proc release*(this: Semaphore): int {.importcpp: "#.release()".} ## \
## Increments the semaphore's internal count.  This may wake up another thread
## blocked on acquire().
##
## Returns the count of the semaphore upon release.

proc getCount*(this: Semaphore): int {.importcpp: "#.get_count()".} ## \
## Returns the current semaphore count.  Note that this call is not thread-
## safe (the count may change at any time).

proc output*(this: Semaphore, `out`: ostream) {.importcpp: "#.output(#)".}

converter getClassType*(_: typedesc[PythonThread]): TypeHandle {.importcpp: "PythonThread::get_class_type()", header: "pythonThread.h".}

proc initEventParameter*(): EventParameter {.importcpp: "EventParameter()".}

proc initEventParameter*(copy: EventParameter): EventParameter {.importcpp: "EventParameter(#)".}

converter initEventParameter*(`ptr`: TypedReferenceCount): EventParameter {.importcpp: "EventParameter(#)".} ## \
## Defines an EventParameter that stores a pointer to a TypedReferenceCount
## object.  Note that a TypedReferenceCount is not the same kind of pointer as
## a TypedWritableReferenceCount, hence we require both constructors.
##
## This accepts a const pointer, even though it stores (and eventually
## returns) a non-const pointer.  This is just the simplest way to allow both
## const and non-const pointers to be stored, but it does lose the constness.
## Be careful.

converter initEventParameter*(`ptr`: TypedWritableReferenceCount): EventParameter {.importcpp: "EventParameter(#)".} ## \
## Defines an EventParameter that stores a pointer to any kind of
## TypedWritableReferenceCount object.  This is the most general constructor.
##
## This accepts a const pointer, even though it stores (and eventually
## returns) a non-const pointer.  This is just the simplest way to allow both
## const and non-const pointers to be stored, but it does lose the constness.
## Be careful.

converter initEventParameter*(value: float64): EventParameter {.importcpp: "EventParameter(#)".} ## \
## Defines an EventParameter that stores a floating-point value.

converter initEventParameter*(value: int): EventParameter {.importcpp: "EventParameter(#)".} ## \
## Defines an EventParameter that stores an integer value.

converter initEventParameter*(param0: type(nil)): EventParameter {.importcpp: "EventParameter(#)".}

converter initEventParameter*(value: string): EventParameter {.importcpp: "EventParameter(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Defines an EventParameter that stores a string value.

proc isEmpty*(this: EventParameter): bool {.importcpp: "#.is_empty()".} ## \
## These functions are conveniences to easily determine if the
## EventParameter is one of the predefined parameter types, and retrieve the
## corresponding value.  Of course, it is possible that the EventParameter
## is some user-defined type, and is none of these.

proc isInt*(this: EventParameter): bool {.importcpp: "#.is_int()".} ## \
## Returns true if the EventParameter stores an integer value, false
## otherwise.

proc getIntValue*(this: EventParameter): int {.importcpp: "#.get_int_value()".} ## \
## Retrieves the value stored in the EventParameter.  It is only valid to call
## this if is_int() has already returned true.

proc isDouble*(this: EventParameter): bool {.importcpp: "#.is_double()".} ## \
## Returns true if the EventParameter stores a double floating-point value,
## false otherwise.

proc getDoubleValue*(this: EventParameter): float64 {.importcpp: "#.get_double_value()".} ## \
## Retrieves the value stored in the EventParameter.  It is only valid to call
## this if is_double() has already returned true.

proc isString*(this: EventParameter): bool {.importcpp: "#.is_string()".} ## \
## Returns true if the EventParameter stores a string value, false otherwise.

proc getStringValue*(this: EventParameter): string {.importcpp: "nimStringFromStdString(#.get_string_value())", header: stringConversionCode.} ## \
## Retrieves the value stored in the EventParameter.  It is only valid to call
## this if is_string() has already returned true.

proc isWstring*(this: EventParameter): bool {.importcpp: "#.is_wstring()".} ## \
## Returns true if the EventParameter stores a wstring value, false otherwise.

proc getWstringValue*(this: EventParameter): string {.importcpp: "nimStringFromStdString(#.get_wstring_value())", header: stringConversionCode.} ## \
## Retrieves the value stored in the EventParameter.  It is only valid to call
## this if is_wstring() has already returned true.

proc isTypedRefCount*(this: EventParameter): bool {.importcpp: "#.is_typed_ref_count()".} ## \
## Returns true if the EventParameter stores a TypedReferenceCount pointer,
## false otherwise.  Note that a TypedReferenceCount is not exactly the same
## kind of pointer as a TypedWritableReferenceCount, hence the need for this
## separate call.

proc getTypedRefCountValue*(this: EventParameter): TypedReferenceCount {.importcpp: "#.get_typed_ref_count_value()".} ## \
## Retrieves the value stored in the EventParameter.  It is only valid to call
## this if is_typed_ref_count() has already returned true.

proc getPtr*(this: EventParameter): TypedWritableReferenceCount {.importcpp: "#.get_ptr()".} ## \
## Retrieves a pointer to the actual value stored in the parameter.  The
## TypeHandle of this pointer may be examined to determine the actual type of
## parameter it contains.  This is the only way to retrieve the value when it
## is not one of the above predefined types.

proc output*(this: EventParameter, `out`: ostream) {.importcpp: "#.output(#)".}

proc newAsyncFuture*(): AsyncFuture {.importcpp: "new AsyncFuture()".} ## \
## Initializes the future in the pending state.

proc newAsyncFuture*(param0: AsyncFuture): AsyncFuture {.importcpp: "new AsyncFuture(#)".}

proc done*(this: AsyncFuture): bool {.importcpp: "#->done()".} ## \
## Returns true if the future is done or has been cancelled.  It is always
## safe to call this.

proc cancelled*(this: AsyncFuture): bool {.importcpp: "#->cancelled()".} ## \
## Returns true if the future was cancelled.  It is always safe to call this.

proc cancel*(this: AsyncFuture): bool {.importcpp: "#->cancel()".} ## \
## Cancels the future.  Returns true if it was cancelled, or false if the
## future was already done.  Either way, done() will return true after this
## call returns.
##
## In the case of a task, this is equivalent to remove().

proc setDoneEvent*(this: AsyncFuture, done_event: string) {.importcpp: "#->set_done_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the event name that will be triggered when the future finishes.  Will
## not be triggered if the future is cancelled, but it will be triggered for
## a coroutine task that exits with an exception.

proc getDoneEvent*(this: AsyncFuture): string {.importcpp: "nimStringFromStdString(#->get_done_event())", header: stringConversionCode.} ## \
## Returns the event name that will be triggered when the future finishes.
## See set_done_event().

proc output*(this: AsyncFuture, `out`: ostream) {.importcpp: "#->output(#)".}

proc wait*(this: AsyncFuture) {.importcpp: "#->wait()".} ## \
## Waits until the future is done.

proc wait*(this: AsyncFuture, timeout: float64) {.importcpp: "#->wait(#)".} ## \
## Waits until the future is done, or until the timeout is reached.

converter getClassType*(_: typedesc[AsyncFuture]): TypeHandle {.importcpp: "AsyncFuture::get_class_type()", header: "asyncFuture.h".}

converter upcastToAsyncFuture*(this: AsyncTask): AsyncFuture {.importcpp: "(PT(AsyncFuture)(#))".}

converter upcastToNamable*(this: AsyncTask): Namable {.importcpp: "((Namable *)(AsyncTask *)(#))".}

proc isAlive*(this: AsyncTask): bool {.importcpp: "#->is_alive()".} ## \
## Returns true if the task is currently active or sleeping on some task
## chain, meaning that it will be executed in its turn, or false if it is not
## active.  If the task has recently been removed while it is in the middle of
## execution, this will return false, because the task will not run again once
## it finishes.

proc getManager*(this: AsyncTask): AsyncTaskManager {.importcpp: "#->get_manager()".} ## \
## Returns the AsyncTaskManager that this task is active on.  This will be
## NULL if the state is S_inactive.

proc remove*(this: AsyncTask): bool {.importcpp: "#->remove()".} ## \
## Removes the task from its active manager, if any, and makes the state
## S_inactive (or possible S_servicing_removed).  This is a no-op if the state
## is already S_inactive.

proc setDelay*(this: AsyncTask, delay: float64) {.importcpp: "#->set_delay(#)".} ## \
## Specifies the amount of time, in seconds, by which this task will be
## delayed after it has been added to the AsyncTaskManager.  At least the
## specified amount of time (and possibly more) will elapse before the task
## begins.
##
## You may specify a delay of 0.0 to guarantee that the task will run in the
## next epoch following the one in which it is added.
##
## Setting this value after the task has already been added will not affect
## the task's wake time; it will only affect the task if it is re-added to the
## queue in the future, for instance if the task returns DS_again.  However,
## see recalc_wake_time() if you wish to apply the delay effect immediately.

proc clearDelay*(this: AsyncTask) {.importcpp: "#->clear_delay()".} ## \
## Removes any delay specified for the task.  The next time the task is added
## to the queue, it will run immediately.  This does not affect the task's
## wake time if it has already been added to the queue.

proc hasDelay*(this: AsyncTask): bool {.importcpp: "#->has_delay()".} ## \
## Returns true if a delay has been set for this task via set_delay(), or
## false otherwise.

proc getDelay*(this: AsyncTask): float64 {.importcpp: "#->get_delay()".} ## \
## Returns the delay value that has been set via set_delay, if any.

proc getWakeTime*(this: AsyncTask): float64 {.importcpp: "#->get_wake_time()".} ## \
## If this task has been added to an AsyncTaskManager with a delay in effect,
## this returns the time at which the task is expected to awaken.  It has no
## meaning if the task has not yet been added to a queue, or if there was no
## delay in effect at the time the task was added.
##
## If the task's status is not S_sleeping, this returns 0.0.

proc recalcWakeTime*(this: AsyncTask) {.importcpp: "#->recalc_wake_time()".} ## \
## If the task is currently sleeping on a task chain, this resets its wake
## time to the current time + get_delay().  It is as if the task had suddenly
## returned DS_again.  The task will sleep for its current delay seconds
## before running again.  This method may therefore be used to make the task
## wake up sooner or later than it would have otherwise.
##
## If the task is not already sleeping, this method has no effect.

proc getStartTime*(this: AsyncTask): float64 {.importcpp: "#->get_start_time()".} ## \
## Returns the time at which the task was started, according to the task
## manager's clock.
##
## It is only valid to call this if the task's status is not S_inactive.

proc getElapsedTime*(this: AsyncTask): float64 {.importcpp: "#->get_elapsed_time()".} ## \
## Returns the amount of time that has elapsed since the task was started,
## according to the task manager's clock.
##
## It is only valid to call this if the task's status is not S_inactive.

proc getStartFrame*(this: AsyncTask): int {.importcpp: "#->get_start_frame()".} ## \
## Returns the frame number at which the task was started, according to the
## task manager's clock.
##
## It is only valid to call this if the task's status is not S_inactive.

proc getElapsedFrames*(this: AsyncTask): int {.importcpp: "#->get_elapsed_frames()".} ## \
## Returns the number of frames that have elapsed since the task was started,
## according to the task manager's clock.
##
## It is only valid to call this if the task's status is not S_inactive.

proc setName*(this: AsyncTask, name: string) {.importcpp: "#->set_name(nimStringToStdString(#))", header: stringConversionCode.}

proc clearName*(this: AsyncTask) {.importcpp: "#->clear_name()".} ## \
## Resets the task's name to empty.

proc getNamePrefix*(this: AsyncTask): string {.importcpp: "nimStringFromStdString(#->get_name_prefix())", header: stringConversionCode.} ## \
## Returns the initial part of the name, up to but not including any trailing
## digits following a hyphen or underscore.

proc getTaskId*(this: AsyncTask): int {.importcpp: "#->get_task_id()".} ## \
## Returns a number guaranteed to be unique for each different AsyncTask
## object in the universe.

proc setTaskChain*(this: AsyncTask, chain_name: string) {.importcpp: "#->set_task_chain(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the AsyncTaskChain on which this task will be running.  Each task
## chain runs tasks independently of the others.

proc getTaskChain*(this: AsyncTask): string {.importcpp: "nimStringFromStdString(#->get_task_chain())", header: stringConversionCode.} ## \
## Returns the AsyncTaskChain on which this task will be running.  Each task
## chain runs tasks independently of the others.

proc setSort*(this: AsyncTask, sort: int) {.importcpp: "#->set_sort(#)".} ## \
## Specifies a sort value for this task.  Within a given AsyncTaskManager, all
## of the tasks with a given sort value are guaranteed to be completed before
## any tasks with a higher sort value are begun.
##
## To put it another way, two tasks might execute in parallel with each other
## only if they both have the same sort value.  Tasks with a lower sort value
## are executed first.
##
## This is different from the priority, which makes no such exclusion
## guarantees.

proc getSort*(this: AsyncTask): int {.importcpp: "#->get_sort()".} ## \
## Returns the task's current sort value.  See set_sort().

proc setPriority*(this: AsyncTask, priority: int) {.importcpp: "#->set_priority(#)".} ## \
## Specifies a priority value for this task.  In general, tasks with a higher
## priority value are executed before tasks with a lower priority value (but
## only for tasks with the same sort value).
##
## Unlike the sort value, tasks with different priorities may execute at the
## same time, if the AsyncTaskManager has more than one thread servicing
## tasks.
##
## Also see AsyncTaskChain::set_timeslice_priority(), which changes the
## meaning of this value.  In the default mode, when the timeslice_priority
## flag is false, all tasks always run once per epoch, regardless of their
## priority values (that is, the priority controls the order of the task
## execution only, not the number of times it runs).  On the other hand, if
## you set the timeslice_priority flag to true, then changing a task's
## priority has an effect on the number of times it runs.

proc getPriority*(this: AsyncTask): int {.importcpp: "#->get_priority()".} ## \
## Returns the task's current priority value.  See set_priority().

proc setDoneEvent*(this: AsyncTask, done_event: string) {.importcpp: "#->set_done_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the event name that will be triggered when the task finishes.  This
## should only be called before the task has been started, or after it has
## finished and before it is about to be restarted (i.e.  when get_state()
## returns S_inactive).

proc getDt*(this: AsyncTask): float64 {.importcpp: "#->get_dt()".} ## \
## Returns the amount of time elapsed during the task's previous run cycle, in
## seconds.

proc getMaxDt*(this: AsyncTask): float64 {.importcpp: "#->get_max_dt()".} ## \
## Returns the maximum amount of time elapsed during any one of the task's
## previous run cycles, in seconds.

proc getAverageDt*(this: AsyncTask): float64 {.importcpp: "#->get_average_dt()".} ## \
## Returns the average amount of time elapsed during each of the task's
## previous run cycles, in seconds.

proc output*(this: AsyncTask, `out`: ostream) {.importcpp: "#->output(#)".}

converter upcastToTypedReferenceCount*(this: AsyncTaskManager): TypedReferenceCount {.importcpp: "(PT(TypedReferenceCount)(#))".}

converter upcastToNamable*(this: AsyncTaskManager): Namable {.importcpp: "((Namable *)(AsyncTaskManager *)(#))".}

proc newAsyncTaskManager*(name: string): AsyncTaskManager {.importcpp: "new AsyncTaskManager(nimStringToStdString(#))", header: stringConversionCode.}

proc cleanup*(this: AsyncTaskManager) {.importcpp: "#->cleanup()".} ## \
## Stops all threads and messily empties the task list.  This is intended to
## be called on destruction only.

proc setClock*(this: AsyncTaskManager, clock: ClockObject) {.importcpp: "#->set_clock(#)".} ## \
## Replaces the clock pointer used within the AsyncTaskManager.  This is used
## to control when tasks with a set_delay() specified will be scheduled.  It
## can also be ticked automatically each epoch, if set_tick_clock() is true.
##
## The default is the global clock pointer.

proc getClock*(this: AsyncTaskManager): ClockObject {.importcpp: "#->get_clock()".} ## \
## Returns the clock pointer used within the AsyncTaskManager.  See
## set_clock().

proc getNumTaskChains*(this: AsyncTaskManager): int {.importcpp: "#->get_num_task_chains()".} ## \
## Returns the number of different task chains.

proc getTaskChain*(this: AsyncTaskManager, n: int): AsyncTaskChain {.importcpp: "#->get_task_chain(#)".} ## \
## Returns the nth task chain.

proc makeTaskChain*(this: AsyncTaskManager, name: string): AsyncTaskChain {.importcpp: "#->make_task_chain(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates a new AsyncTaskChain of the indicated name and stores it within the
## AsyncTaskManager.  If a task chain with this name already exists, returns
## it instead.

proc findTaskChain*(this: AsyncTaskManager, name: string): AsyncTaskChain {.importcpp: "#->find_task_chain(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Searches a new AsyncTaskChain of the indicated name and returns it if it
## exists, or NULL otherwise.

proc removeTaskChain*(this: AsyncTaskManager, name: string): bool {.importcpp: "#->remove_task_chain(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes the AsyncTaskChain of the indicated name.  If the chain still has
## tasks, this will block until all tasks are finished.
##
## Returns true if successful, or false if the chain did not exist.

proc add*(this: AsyncTaskManager, task: AsyncTask) {.importcpp: "#->add(#)".} ## \
## Adds the indicated task to the active queue.  It is an error if the task is
## already added to this or any other active queue.

proc hasTask*(this: AsyncTaskManager, task: AsyncTask): bool {.importcpp: "#->has_task(#)".} ## \
## Returns true if the indicated task has been added to this AsyncTaskManager,
## false otherwise.

proc findTask*(this: AsyncTaskManager, name: string): AsyncTask {.importcpp: "#->find_task(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the first task found with the indicated name, or NULL if there is
## no task with the indicated name.
##
## If there are multiple tasks with the same name, returns one of them
## arbitrarily.

proc findTasks*(this: AsyncTaskManager, name: string): AsyncTaskCollection {.importcpp: "#->find_tasks(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the list of tasks found with the indicated name.

proc findTasksMatching*(this: AsyncTaskManager, pattern: GlobPattern): AsyncTaskCollection {.importcpp: "#->find_tasks_matching(#)".} ## \
## Returns the list of tasks found whose name matches the indicated glob
## pattern, e.g.  "my_task_\*".

proc remove*(this: AsyncTaskManager, task: AsyncTask): bool {.importcpp: "#->remove(#)".} ## \
## Removes the indicated task from the active queue.  Returns true if the task
## is successfully removed, or false if it wasn't there.

proc remove*(this: AsyncTaskManager, tasks: AsyncTaskCollection): clonglong {.importcpp: "#->remove(#)".} ## \
## Removes all of the tasks in the AsyncTaskCollection.  Returns the number of
## tasks removed.

proc waitForTasks*(this: AsyncTaskManager) {.importcpp: "#->wait_for_tasks()".} ## \
## Blocks until the task list is empty.

proc stopThreads*(this: AsyncTaskManager) {.importcpp: "#->stop_threads()".} ## \
## Stops any threads that are currently running.  If any tasks are still
## pending and have not yet been picked up by a thread, they will not be
## serviced unless poll() or start_threads() is later called.

proc startThreads*(this: AsyncTaskManager) {.importcpp: "#->start_threads()".} ## \
## Starts any requested threads to service the tasks on the queue.  This is
## normally not necessary, since adding a task will start the threads
## automatically.

proc getNumTasks*(this: AsyncTaskManager): clonglong {.importcpp: "#->get_num_tasks()".} ## \
## Returns the number of tasks that are currently active or sleeping within
## the task manager.

proc getTasks*(this: AsyncTaskManager): AsyncTaskCollection {.importcpp: "#->get_tasks()".} ## \
## Returns the set of tasks that are active or sleeping on the task manager,
## at the time of the call.

proc getActiveTasks*(this: AsyncTaskManager): AsyncTaskCollection {.importcpp: "#->get_active_tasks()".} ## \
## Returns the set of tasks that are active (and not sleeping) on the task
## manager, at the time of the call.

proc getSleepingTasks*(this: AsyncTaskManager): AsyncTaskCollection {.importcpp: "#->get_sleeping_tasks()".} ## \
## Returns the set of tasks that are sleeping (and not active) on the task
## manager, at the time of the call.

proc initAsyncTaskCollection*(): AsyncTaskCollection {.importcpp: "AsyncTaskCollection()".}

proc initAsyncTaskCollection*(copy: AsyncTaskCollection): AsyncTaskCollection {.importcpp: "AsyncTaskCollection(#)".}

proc addTask*(this: AsyncTaskCollection, task: AsyncTask) {.importcpp: "#.add_task(#)".} ## \
## Adds a new AsyncTask to the collection.

proc removeTask*(this: AsyncTaskCollection, task: AsyncTask): bool {.importcpp: "#.remove_task(#)".} ## \
## Removes the indicated AsyncTask from the collection.  Returns true if the
## task was removed, false if it was not a member of the collection.

proc removeTask*(this: AsyncTaskCollection, index: clonglong) {.importcpp: "#.remove_task(#)".} ## \
## Removes the nth AsyncTask from the collection.

proc addTasksFrom*(this: AsyncTaskCollection, other: AsyncTaskCollection) {.importcpp: "#.add_tasks_from(#)".} ## \
## Adds all the AsyncTasks indicated in the other collection to this task.
## The other tasks are simply appended to the end of the tasks in this list;
## duplicates are not automatically removed.

proc removeTasksFrom*(this: AsyncTaskCollection, other: AsyncTaskCollection) {.importcpp: "#.remove_tasks_from(#)".} ## \
## Removes from this collection all of the AsyncTasks listed in the other
## collection.

proc removeDuplicateTasks*(this: AsyncTaskCollection) {.importcpp: "#.remove_duplicate_tasks()".} ## \
## Removes any duplicate entries of the same AsyncTasks on this collection.
## If a AsyncTask appears multiple times, the first appearance is retained;
## subsequent appearances are removed.

proc hasTask*(this: AsyncTaskCollection, task: AsyncTask): bool {.importcpp: "#.has_task(#)".} ## \
## Returns true if the indicated AsyncTask appears in this collection, false
## otherwise.

proc clear*(this: AsyncTaskCollection) {.importcpp: "#.clear()".} ## \
## Removes all AsyncTasks from the collection.

proc findTask*(this: AsyncTaskCollection, name: string): AsyncTask {.importcpp: "#.find_task(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the task in the collection with the indicated name, if any, or NULL
## if no task has that name.

proc getNumTasks*(this: AsyncTaskCollection): clonglong {.importcpp: "#.get_num_tasks()".} ## \
## Returns the number of AsyncTasks in the collection.

proc getTask*(this: AsyncTaskCollection, index: clonglong): AsyncTask {.importcpp: "#.get_task(#)".} ## \
## Returns the nth AsyncTask in the collection.

proc `[]`*(this: AsyncTaskCollection, index: clonglong): AsyncTask {.importcpp: "#.operator [](#)".} ## \
## Returns the nth AsyncTask in the collection.  This is the same as
## get_task(), but it may be a more convenient way to access it.

proc size*(this: AsyncTaskCollection): clonglong {.importcpp: "#.size()".} ## \
## Returns the number of tasks in the collection.  This is the same thing as
## get_num_tasks().

proc `+=`*(this: var AsyncTaskCollection, other: AsyncTaskCollection): AsyncTaskCollection {.importcpp: "#.operator +=(#)".}

proc `+`*(this: AsyncTaskCollection, other: AsyncTaskCollection): AsyncTaskCollection {.importcpp: "#.operator +(#)".}

proc output*(this: AsyncTaskCollection, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Writes a brief one-line description of the AsyncTaskCollection to the
## indicated output stream.

proc write*(this: AsyncTaskCollection, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Writes a complete multi-line description of the AsyncTaskCollection to the
## indicated output stream.

proc write*(this: AsyncTaskCollection, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes a complete multi-line description of the AsyncTaskCollection to the
## indicated output stream.

proc poll*(this: AsyncTaskManager) {.importcpp: "#->poll()".} ## \
## Runs through all the tasks in the task list, once, if the task manager is
## running in single-threaded mode (no threads available).  This method does
## nothing in threaded mode, so it may safely be called in either case.

proc getNextWakeTime*(this: AsyncTaskManager): float64 {.importcpp: "#->get_next_wake_time()".} ## \
## Returns the scheduled time (on the manager's clock) of the next sleeping
## task, on any task chain, to awaken.  Returns -1 if there are no sleeping
## tasks.

proc output*(this: AsyncTaskManager, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: AsyncTaskManager, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: AsyncTaskManager, `out`: ostream) {.importcpp: "#->write(#)".}

proc getGlobalPtr*(_: typedesc[AsyncTaskManager]): AsyncTaskManager {.importcpp: "AsyncTaskManager::get_global_ptr()", header: "asyncTaskManager.h".} ## \
## Returns a pointer to the global AsyncTaskManager.  This is the
## AsyncTaskManager that most code should use for queueing tasks and suchlike.

converter getClassType*(_: typedesc[AsyncTaskManager]): TypeHandle {.importcpp: "AsyncTaskManager::get_class_type()", header: "asyncTaskManager.h".}

converter getClassType*(_: typedesc[AsyncTask]): TypeHandle {.importcpp: "AsyncTask::get_class_type()", header: "asyncTask.h".}

proc newAsyncTask*(param0: AsyncTask): AsyncTask {.importcpp: "new AsyncTask(#)".}

converter upcastToTypedReferenceCount*(this: AsyncTaskChain): TypedReferenceCount {.importcpp: "(PT(TypedReferenceCount)(#))".}

converter upcastToNamable*(this: AsyncTaskChain): Namable {.importcpp: "((Namable *)(AsyncTaskChain *)(#))".}

proc setTickClock*(this: AsyncTaskChain, tick_clock: bool) {.importcpp: "#->set_tick_clock(#)".} ## \
## Sets the tick_clock flag.  When this is true, get_clock()->tick() will be
## called automatically at each task epoch.  This is false by default.

proc getTickClock*(this: AsyncTaskChain): bool {.importcpp: "#->get_tick_clock()".} ## \
## Returns the tick_clock flag.  See set_tick_clock().

proc setNumThreads*(this: AsyncTaskChain, num_threads: int) {.importcpp: "#->set_num_threads(#)".} ## \
## Changes the number of threads for this task chain.  This may require
## stopping the threads if they are already running.

proc getNumThreads*(this: AsyncTaskChain): int {.importcpp: "#->get_num_threads()".} ## \
## Returns the number of threads that will be servicing tasks for this chain.
## Also see get_num_running_threads().

proc getNumRunningThreads*(this: AsyncTaskChain): int {.importcpp: "#->get_num_running_threads()".} ## \
## Returns the number of threads that have been created and are actively
## running.  This will return 0 before the threads have been started; it will
## also return 0 if thread support is not available.

proc setThreadPriority*(this: AsyncTaskChain, priority: ThreadPriority) {.importcpp: "#->set_thread_priority(#)".} ## \
## Changes the priority associated with threads that serve this task chain.
## This may require stopping the threads if they are already running.

proc getThreadPriority*(this: AsyncTaskChain): ThreadPriority {.importcpp: "#->get_thread_priority()".} ## \
## Returns the priority associated with threads that serve this task chain.

proc setFrameBudget*(this: AsyncTaskChain, frame_budget: float64) {.importcpp: "#->set_frame_budget(#)".} ## \
## Sets the maximum amount of time per frame the tasks on this chain are
## granted for execution.  If this is less than zero, there is no limit; if it
## is >= 0, it represents a maximum amount of time (in seconds) that will be
## used to execute tasks.  If this time is exceeded in any one frame, the task
## chain will stop executing tasks until the next frame, as defined by the
## TaskManager's clock.

proc getFrameBudget*(this: AsyncTaskChain): float64 {.importcpp: "#->get_frame_budget()".} ## \
## Returns the maximum amount of time per frame the tasks on this chain are
## granted for execution.  See set_frame_budget().

proc setFrameSync*(this: AsyncTaskChain, frame_sync: bool) {.importcpp: "#->set_frame_sync(#)".} ## \
## Sets the frame_sync flag.  When this flag is true, this task chain will be
## forced to sync with the TaskManager's clock.  It will run no faster than
## one epoch per clock frame.
##
## When this flag is false, the default, the task chain will finish all of its
## tasks and then immediately start from the first task again, regardless of
## the clock frame.  When it is true, the task chain will finish all of its
## tasks and then wait for the clock to tick to the next frame before resuming
## the first task.
##
## This only makes sense for threaded task chains.  Non-threaded task chains
## are automatically synchronous.

proc getFrameSync*(this: AsyncTaskChain): bool {.importcpp: "#->get_frame_sync()".} ## \
## Returns the frame_sync flag.  See set_frame_sync().

proc setTimeslicePriority*(this: AsyncTaskChain, timeslice_priority: bool) {.importcpp: "#->set_timeslice_priority(#)".} ## \
## Sets the timeslice_priority flag.  This changes the interpretation of
## priority, and the number of times per epoch each task will run.
##
## When this flag is true, some tasks might not run in any given epoch.
## Instead, tasks with priority higher than 1 will be given precedence, in
## proportion to the amount of time they have already used.  This gives
## higher-priority tasks more runtime than lower-priority tasks.  Each task
## gets the amount of time proportional to its priority value, so a task with
## priority 100 will get five times as much processing time as a task with
## priority 20.  For these purposes, priority values less than 1 are deemed to
## be equal to 1.
##
## When this flag is false (the default), all tasks are run exactly once each
## epoch, round-robin style.  Priority is only used to determine which task
## runs first within tasks of the same sort value.

proc getTimeslicePriority*(this: AsyncTaskChain): bool {.importcpp: "#->get_timeslice_priority()".} ## \
## Returns the timeslice_priority flag.  This changes the interpretation of
## priority, and the number of times per epoch each task will run.  See
## set_timeslice_priority().

proc stopThreads*(this: AsyncTaskChain) {.importcpp: "#->stop_threads()".} ## \
## Stops any threads that are currently running.  If any tasks are still
## pending and have not yet been picked up by a thread, they will not be
## serviced unless poll() or start_threads() is later called.

proc startThreads*(this: AsyncTaskChain) {.importcpp: "#->start_threads()".} ## \
## Starts any requested threads to service the tasks on the queue.  This is
## normally not necessary, since adding a task will start the threads
## automatically.

proc isStarted*(this: AsyncTaskChain): bool {.importcpp: "#->is_started()".} ## \
## Returns true if the thread(s) have been started and are ready to service
## requests, false otherwise.  If this is false, the next call to add() or
## add_and_do() will automatically start the threads.

proc hasTask*(this: AsyncTaskChain, task: AsyncTask): bool {.importcpp: "#->has_task(#)".} ## \
## Returns true if the indicated task has been added to this AsyncTaskChain,
## false otherwise.

proc waitForTasks*(this: AsyncTaskChain) {.importcpp: "#->wait_for_tasks()".} ## \
## Blocks until the task list is empty.

proc getNumTasks*(this: AsyncTaskChain): int {.importcpp: "#->get_num_tasks()".} ## \
## Returns the number of tasks that are currently active or sleeping within
## the task chain.

proc getTasks*(this: AsyncTaskChain): AsyncTaskCollection {.importcpp: "#->get_tasks()".} ## \
## Returns the set of tasks that are active or sleeping on the task chain, at
## the time of the call.

proc getActiveTasks*(this: AsyncTaskChain): AsyncTaskCollection {.importcpp: "#->get_active_tasks()".} ## \
## Returns the set of tasks that are active (and not sleeping) on the task
## chain, at the time of the call.

proc getSleepingTasks*(this: AsyncTaskChain): AsyncTaskCollection {.importcpp: "#->get_sleeping_tasks()".} ## \
## Returns the set of tasks that are sleeping (and not active) on the task
## chain, at the time of the call.

proc poll*(this: AsyncTaskChain) {.importcpp: "#->poll()".} ## \
## Runs through all the tasks in the task list, once, if the task chain is
## running in single-threaded mode (no threads available).  This method does
## nothing in threaded mode, so it may safely be called in either case.
##
## Normally, you would not call this function directly; instead, call
## AsyncTaskManager::poll(), which polls all of the task chains in sequence.

proc getNextWakeTime*(this: AsyncTaskChain): float64 {.importcpp: "#->get_next_wake_time()".} ## \
## Returns the scheduled time (on the manager's clock) of the next sleeping
## task, on any task chain, to awaken.  Returns -1 if there are no sleeping
## tasks.

proc output*(this: AsyncTaskChain, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: AsyncTaskChain, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: AsyncTaskChain, `out`: ostream) {.importcpp: "#->write(#)".}

converter getClassType*(_: typedesc[AsyncTaskChain]): TypeHandle {.importcpp: "AsyncTaskChain::get_class_type()", header: "asyncTaskChain.h".}

proc newAsyncTaskPause*(param0: AsyncTaskPause): AsyncTaskPause {.importcpp: "new AsyncTaskPause(#)".}

proc newAsyncTaskPause*(delay: float64): AsyncTaskPause {.importcpp: "new AsyncTaskPause(#)".}

converter getClassType*(_: typedesc[AsyncTaskPause]): TypeHandle {.importcpp: "AsyncTaskPause::get_class_type()", header: "asyncTaskPause.h".}

converter upcastToAsyncTask*(this: AsyncTaskSequence): AsyncTask {.importcpp: "(PT(AsyncTask)(#))".}

converter upcastToAsyncTaskCollection*(this: AsyncTaskSequence): AsyncTaskCollection {.importcpp: "((AsyncTaskCollection *)(AsyncTaskSequence *)(#))".}

proc newAsyncTaskSequence*(param0: AsyncTaskSequence): AsyncTaskSequence {.importcpp: "new AsyncTaskSequence(#)".}

proc newAsyncTaskSequence*(name: string): AsyncTaskSequence {.importcpp: "new AsyncTaskSequence(nimStringToStdString(#))", header: stringConversionCode.}

proc setRepeatCount*(this: AsyncTaskSequence, repeat_count: int) {.importcpp: "#->set_repeat_count(#)".} ## \
## Sets the repeat count of the sequence.  If the count is 0 or 1, the
## sequence will run exactly once.  If it is greater than 0, it will run that
## number of times.  If it is negative, it will run forever until it is
## explicitly removed.

proc getRepeatCount*(this: AsyncTaskSequence): int {.importcpp: "#->get_repeat_count()".} ## \
## Returns the repeat count of the sequence.  See set_repeat_count().

proc getCurrentTaskIndex*(this: AsyncTaskSequence): clonglong {.importcpp: "#->get_current_task_index()".} ## \
## Returns the index of the task within the sequence that is currently being
## executed (or that will be executed at the next epoch).

converter getClassType*(_: typedesc[AsyncTaskSequence]): TypeHandle {.importcpp: "AsyncTaskSequence::get_class_type()", header: "asyncTaskSequence.h".}

proc `==`*(this: ButtonEvent, other: ButtonEvent): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: ButtonEvent, other: ButtonEvent): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: ButtonEvent, other: ButtonEvent): bool {.importcpp: "#.operator <(#)".}

proc newButtonEventList*(): ButtonEventList {.importcpp: "new ButtonEventList()".}

proc newButtonEventList*(copy: ButtonEventList): ButtonEventList {.importcpp: "new ButtonEventList(#)".}

proc addEvent*(this: ButtonEventList, event: ButtonEvent) {.importcpp: "#->add_event(#)".} ## \
## Adds a new event to the end of the list.

proc getNumEvents*(this: ButtonEventList): int {.importcpp: "#->get_num_events()".} ## \
## Returns the number of events in the list.

proc getEvent*(this: ButtonEventList, n: int): ButtonEvent {.importcpp: "#->get_event(#)".} ## \
## Returns the nth event in the list.  This does not remove the event from the
## list; the only way to remove events is to empty the whole list with
## clear().

proc clear*(this: ButtonEventList) {.importcpp: "#->clear()".} ## \
## Empties all the events from the list.

proc addEvents*(this: ButtonEventList, other: ButtonEventList) {.importcpp: "#->add_events(#)".} ## \
## Appends the events from the other list onto the end of this one.

proc updateMods*(this: ButtonEventList, mods: ModifierButtons) {.importcpp: "#->update_mods(#)".} ## \
## Updates the indicated ModifierButtons object with all of the button up/down
## transitions indicated in the list.

proc write*(this: ButtonEventList, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: ButtonEventList, `out`: ostream) {.importcpp: "#->write(#)".}

converter getClassType*(_: typedesc[ButtonEventList]): TypeHandle {.importcpp: "ButtonEventList::get_class_type()", header: "buttonEventList.h".}

proc newEvent*(copy: Event): Event {.importcpp: "new Event(#)".}

proc newEvent*(event_name: string): Event {.importcpp: "new Event(nimStringToStdString(#))", header: stringConversionCode.}

proc setName*(this: Event, name: string) {.importcpp: "#->set_name(nimStringToStdString(#))", header: stringConversionCode.}

proc clearName*(this: Event) {.importcpp: "#->clear_name()".} ## \
## Resets the Event's name to empty.

proc hasName*(this: Event): bool {.importcpp: "#->has_name()".} ## \
## Returns true if the Event has a nonempty name set, false if the name is
## empty.

proc getName*(this: Event): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.}

proc addParameter*(this: Event, obj: EventParameter) {.importcpp: "#->add_parameter(#)".}

proc getNumParameters*(this: Event): int {.importcpp: "#->get_num_parameters()".}

proc getParameter*(this: Event, n: int): EventParameter {.importcpp: "#->get_parameter(#)".}

proc hasReceiver*(this: Event): bool {.importcpp: "#->has_receiver()".}

proc clearReceiver*(this: Event) {.importcpp: "#->clear_receiver()".}

proc output*(this: Event, `out`: ostream) {.importcpp: "#->output(#)".}

converter getClassType*(_: typedesc[Event]): TypeHandle {.importcpp: "Event::get_class_type()", header: "event.h".}

proc initEventHandler*(ev_queue: EventQueue): EventHandler {.importcpp: "EventHandler(#)".}

proc getFuture*(this: EventHandler, event_name: string): AsyncFuture {.importcpp: "#.get_future(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a pending future that will be marked as done when the event is next
## fired.

proc processEvents*(this: EventHandler) {.importcpp: "#.process_events()".} ## \
## The main processing loop of the EventHandler.  This function must be called
## periodically to service events.  Walks through each pending event and calls
## its assigned hooks.

proc dispatchEvent*(this: EventHandler, event: Event) {.importcpp: "#.dispatch_event(#)".} ## \
## Calls the hooks assigned to the indicated single event.

proc write*(this: EventHandler, `out`: ostream) {.importcpp: "#.write(#)".}

proc getGlobalEventHandler*(_: typedesc[EventHandler], queue: EventQueue): EventHandler {.importcpp: "#EventHandler::get_global_event_handler(#)", header: "eventHandler.h".} ## \
## Returns a pointer to the one global EventHandler object.  If the global
## object has not yet been created, this will create it.

proc getGlobalEventHandler*(_: typedesc[EventHandler]): EventHandler {.importcpp: "EventHandler::get_global_event_handler()", header: "eventHandler.h".} ## \
## Returns a pointer to the one global EventHandler object.  If the global
## object has not yet been created, this will create it.

converter getClassType*(_: typedesc[EventHandler]): TypeHandle {.importcpp: "EventHandler::get_class_type()", header: "eventHandler.h".}

proc newEventQueue*(): EventQueue {.importcpp: "new EventQueue()".}

proc queueEvent*(this: EventQueue, event: Event) {.importcpp: "#->queue_event(#)".}

proc clear*(this: EventQueue) {.importcpp: "#->clear()".} ## \
## Empties all events on the queue, throwing them on the floor.

proc isQueueEmpty*(this: EventQueue): bool {.importcpp: "#->is_queue_empty()".}

proc isQueueFull*(this: EventQueue): bool {.importcpp: "#->is_queue_full()".} ## \
## @deprecated Always returns false; the queue can never be full.

proc dequeueEvent*(this: EventQueue): Event {.importcpp: "deconstify(#->dequeue_event())", header: deconstifyCode.}

proc getGlobalEventQueue*(_: typedesc[EventQueue]): EventQueue {.importcpp: "EventQueue::get_global_event_queue()", header: "eventQueue.h".} ## \
## Returns a pointer to the one global EventQueue object.  If the global
## object has not yet been created, this will create it.

proc newPointerEventList*(): PointerEventList {.importcpp: "new PointerEventList()".}

proc getNumEvents*(this: PointerEventList): clonglong {.importcpp: "#->get_num_events()".} ## \
## Returns the number of events in the list.

proc getInWindow*(this: PointerEventList, n: clonglong): bool {.importcpp: "#->get_in_window(#)".} ## \
## Get the in-window flag of the nth event.

proc getXpos*(this: PointerEventList, n: clonglong): int {.importcpp: "#->get_xpos(#)".} ## \
## Get the x-coordinate of the nth event.

proc getYpos*(this: PointerEventList, n: clonglong): int {.importcpp: "#->get_ypos(#)".} ## \
## Get the y-coordinate of the nth event.

proc getDx*(this: PointerEventList, n: clonglong): float64 {.importcpp: "#->get_dx(#)".} ## \
## Get the x-delta of the nth event.

proc getDy*(this: PointerEventList, n: clonglong): float64 {.importcpp: "#->get_dy(#)".} ## \
## Get the y-delta of the nth event.

proc getSequence*(this: PointerEventList, n: clonglong): int {.importcpp: "#->get_sequence(#)".} ## \
## Get the sequence number of the nth event.

proc getLength*(this: PointerEventList, n: clonglong): float64 {.importcpp: "#->get_length(#)".} ## \
## Get the length of the nth event.

proc getDirection*(this: PointerEventList, n: clonglong): float64 {.importcpp: "#->get_direction(#)".} ## \
## Get the direction of the nth event.

proc getRotation*(this: PointerEventList, n: clonglong): float64 {.importcpp: "#->get_rotation(#)".} ## \
## Get the rotation of the nth event.

proc getTime*(this: PointerEventList, n: clonglong): float64 {.importcpp: "#->get_time(#)".} ## \
## Get the timestamp of the nth event.

proc clear*(this: PointerEventList) {.importcpp: "#->clear()".} ## \
## Empties all the events from the list.

proc popFront*(this: PointerEventList) {.importcpp: "#->pop_front()".} ## \
## Discards the first event on the list.

proc addEvent*(this: PointerEventList, data: PointerData, seq: int, time: float64) {.importcpp: "#->add_event(#, #, #)".} ## \
## Adds a new event from the given PointerData object.

proc addEvent*(this: PointerEventList, in_win: bool, xpos: int, ypos: int, xdelta: float64, ydelta: float64, seq: int, time: float64) {.importcpp: "#->add_event(#, #, #, #, #, #, #)".} ## \
## Adds a new event to the end of the list based on the given mouse movement.

proc addEvent*(this: PointerEventList, in_win: bool, xpos: int, ypos: int, seq: int, time: float64) {.importcpp: "#->add_event(#, #, #, #, #)".} ## \
## Adds a new event to the end of the list.  Automatically calculates the dx,
## dy, length, direction, and rotation for all but the first event.

proc encircles*(this: PointerEventList, x: int, y: int): bool {.importcpp: "#->encircles(#, #)".} ## \
## Returns true if the trail loops around the specified point.

proc totalTurns*(this: PointerEventList, sec: float64): float64 {.importcpp: "#->total_turns(#)".} ## \
## returns the total angular deviation that the trail has made in the
## specified time period.  A small number means that the trail is moving in a
## relatively straight line, a large number means that the trail is zig-
## zagging or spinning.  The result is in degrees.

proc matchPattern*(this: PointerEventList, pattern: string, rot: float64, seglen: float64): float64 {.importcpp: "#->match_pattern(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## This function is not implemented yet.  It is a work in progress.  The
## intent is as follows:
##
## Returns a nonzero value if the mouse movements match the specified pattern.
## The higher the value, the better the match.  The pattern is a sequence of
## compass directions (ie, "E", "NE", etc) separated by spaces.  If rot is
## nonzero, then the pattern is rotated counterclockwise by the specified
## amount before testing.  Seglen is the minimum length a mouse movement needs
## to be in order to be considered significant.

converter getClassType*(_: typedesc[PointerEventList]): TypeHandle {.importcpp: "PointerEventList::get_class_type()", header: "pointerEventList.h".}

proc newPythonTask*(): PythonTask {.importcpp: "new PythonTask()".}

proc newPythonTask*(param0: PythonTask): PythonTask {.importcpp: "new PythonTask(#)".}

proc hasDelay*(this: PythonTask): bool {.importcpp: "#->has_delay()".} ## \
## Returns true if a delay has been set for this task via set_delay(), or
## false otherwise.

proc clearDelay*(this: PythonTask) {.importcpp: "#->clear_delay()".} ## \
## Removes any delay specified for the task.  The next time the task is added
## to the queue, it will run immediately.  This does not affect the task's
## wake time if it has already been added to the queue.

converter getClassType*(_: typedesc[PythonTask]): TypeHandle {.importcpp: "PythonTask::get_class_type()", header: "pythonTask.h".}

proc initAdaptiveLru*(name: string, max_size: clonglong): AdaptiveLru {.importcpp: "AdaptiveLru(nimStringToStdString(#), #)", header: stringConversionCode.}

proc getTotalSize*(this: AdaptiveLru): clonglong {.importcpp: "#.get_total_size()".} ## \
## Returns the total size of all objects currently active on the LRU.

proc getMaxSize*(this: AdaptiveLru): clonglong {.importcpp: "#.get_max_size()".} ## \
## Returns the max size of all objects that are allowed to be active on the
## LRU.

proc setMaxSize*(this: AdaptiveLru, max_size: clonglong) {.importcpp: "#.set_max_size(#)".} ## \
## Changes the max size of all objects that are allowed to be active on the
## LRU.
##
## If the size is (size_t)-1, there is no limit.

proc countActiveSize*(this: AdaptiveLru): clonglong {.importcpp: "#.count_active_size()".} ## \
## Returns the total size of the pages that were enqueued since the last call
## to begin_epoch().

proc considerEvict*(this: AdaptiveLru) {.importcpp: "#.consider_evict()".} ## \
## Evicts a sequence of objects if the queue is full.

proc evictTo*(this: AdaptiveLru, target_size: clonglong) {.importcpp: "#.evict_to(#)".} ## \
## Evicts a sequence of objects until the queue fits within the indicated
## target size, regardless of its normal max size.

proc beginEpoch*(this: AdaptiveLru) {.importcpp: "#.begin_epoch()".} ## \
## Marks the end of the previous epoch and the beginning of the next one.
## This will evict any objects that are pending eviction, and also update any
## internal bookkeeping.

proc validate*(this: AdaptiveLru): bool {.importcpp: "#.validate()".} ## \
## Checks that the LRU is internally self-consistent.  Returns true if
## successful, false if there is some problem.

proc output*(this: AdaptiveLru, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: AdaptiveLru, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc setWeight*(this: AdaptiveLru, weight: float32) {.importcpp: "#.set_weight(#)".} ## \
## The following methods are specific to AdaptiveLru, and do not exist in
## the SimpleLru implementation.  In most cases, the defaults will be
## sufficient, so you do not need to mess with them.

proc getWeight*(this: AdaptiveLru): float32 {.importcpp: "#.get_weight()".} ## \
## Returns the weight value used to compute the exponential moving average.

proc setMaxUpdatesPerFrame*(this: AdaptiveLru, max_updates_per_frame: int) {.importcpp: "#.set_max_updates_per_frame(#)".} ## \
## Specifies the maximum number of pages the AdaptiveLru will update each
## frame.  This is a performance optimization: keeping this number low limits
## the impact of the AdaptiveLru's adaptive algorithm.

proc getMaxUpdatesPerFrame*(this: AdaptiveLru): int {.importcpp: "#.get_max_updates_per_frame()".} ## \
## Returns the maximum number of pages the AdaptiveLru will update each frame.

proc newAdaptiveLruPage*(copy: AdaptiveLruPage): AdaptiveLruPage {.importcpp: "new AdaptiveLruPage(#)".}

proc newAdaptiveLruPage*(lru_size: clonglong): AdaptiveLruPage {.importcpp: "new AdaptiveLruPage(#)".}

proc getLru*(this: AdaptiveLruPage): AdaptiveLru {.importcpp: "#->get_lru()".} ## \
## Returns the LRU that manages this page, or NULL if it is not currently
## managed by any LRU.

proc enqueueLru*(this: AdaptiveLruPage, lru: AdaptiveLru) {.importcpp: "#->enqueue_lru(#)".} ## \
## Adds the page to the LRU for the first time, or marks it recently-accessed
## if it has already been added.
##
## If lru is NULL, it means to remove this page from its LRU.

proc dequeueLru*(this: AdaptiveLruPage) {.importcpp: "#->dequeue_lru()".} ## \
## Removes the page from its AdaptiveLru.

proc markUsedLru*(this: AdaptiveLruPage, lru: AdaptiveLru) {.importcpp: "#->mark_used_lru(#)".} ## \
## To be called when the page is used; this will move it to the tail of the
## specified AdaptiveLru queue.

proc getLruSize*(this: AdaptiveLruPage): clonglong {.importcpp: "#->get_lru_size()".} ## \
## Returns the size of this page as reported to the LRU, presumably in bytes.

proc setLruSize*(this: AdaptiveLruPage, lru_size: clonglong) {.importcpp: "#->set_lru_size(#)".} ## \
## Specifies the size of this page, presumably in bytes, although any unit is
## possible.

proc evictLru*(this: AdaptiveLruPage) {.importcpp: "#->evict_lru()".} ## \
## Evicts the page from the LRU.  Called internally when the LRU determines
## that it is full.  May also be called externally when necessary to
## explicitly evict the page.
##
## It is legal for this method to either evict the page as requested, do
## nothing (in which case the eviction will be requested again at the next
## epoch), or requeue itself on the tail of the queue (in which case the
## eviction will be requested again much later).

proc output*(this: AdaptiveLruPage, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: AdaptiveLruPage, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc getNumFrames*(this: AdaptiveLruPage): int {.importcpp: "#->get_num_frames()".} ## \
## Returns the number of frames since the page was first added to its LRU.
## Returns 0 if it does not have an LRU.

proc getNumInactiveFrames*(this: AdaptiveLruPage): int {.importcpp: "#->get_num_inactive_frames()".} ## \
## Returns the number of frames since the page was last accessed on its LRU.
## Returns 0 if it does not have an LRU.

proc initGeomEnums*(): GeomEnums {.importcpp: "GeomEnums()".}

proc initGeomEnums*(param0: GeomEnums): GeomEnums {.importcpp: "GeomEnums(#)".}

proc initGeomVertexAnimationSpec*(): GeomVertexAnimationSpec {.importcpp: "GeomVertexAnimationSpec()".}

proc initGeomVertexAnimationSpec*(other: GeomVertexAnimationSpec): GeomVertexAnimationSpec {.importcpp: "GeomVertexAnimationSpec(#)".}

proc getNumTransforms*(this: GeomVertexAnimationSpec): int {.importcpp: "#.get_num_transforms()".} ## \
## This is only meaningful for animation_type AT_hardware.  It specifies the
## maximum number of transforms that might be simultaneously applied to any
## one vertex by the data in this format.

proc getIndexedTransforms*(this: GeomVertexAnimationSpec): bool {.importcpp: "#.get_indexed_transforms()".} ## \
## This is only meaningful for animation_type AT_hardware.  If true, it
## indicates that the format uses indexed animation tables.  It is false if
## each vertex will reference the first _num_transforms table entries only.

proc setNone*(this: GeomVertexAnimationSpec) {.importcpp: "#.set_none()".} ## \
## Specifies that no vertex animation is represented by this spec.

proc setPanda*(this: GeomVertexAnimationSpec) {.importcpp: "#.set_panda()".} ## \
## Specifies that vertex animation is to be performed by Panda.  This is the
## most general setting and can handle any kind of vertex animation
## represented.

proc setHardware*(this: GeomVertexAnimationSpec, num_transforms: int, indexed_transforms: bool) {.importcpp: "#.set_hardware(#, #)".} ## \
## Specifies that vertex animation is to be performed by the graphics hardware
## (or at least by the graphics backend API, which is actually still free to
## animate the vertices on the CPU).
##
## This is only legal if the graphics hardware can support the specified
## limits on number of transforms and/or indexed transforms.  Also, no current
## graphics API's support morphing.

proc output*(this: GeomVertexAnimationSpec, `out`: ostream) {.importcpp: "#.output(#)".}

proc make*(_: typedesc[InternalName], name: string, index: int): InternalName {.importcpp: "#InternalName::make(nimStringToStdString(#), #)", header: "internalName.h".} ## \
## Make using a string and an integer.  Concatenates the two.

proc append*(this: InternalName, basename: string): InternalName {.importcpp: "#->append(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Constructs a new InternalName based on this name, with the indicated string
## following it.  This is a cheaper way to construct a hierarchical name than
## InternalName::make(parent->get_name() + ".basename").

proc getParent*(this: InternalName): InternalName {.importcpp: "#->get_parent()".} ## \
## Return the parent of this InternalName.  All names have a parent, except
## the root name.

proc getName*(this: InternalName): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Returns the complete name represented by the InternalName and all of its
## parents.

proc join*(this: InternalName, sep: string): string {.importcpp: "nimStringFromStdString(#->join(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Like get_name, but uses a custom separator instead of ".".

proc getBasename*(this: InternalName): string {.importcpp: "nimStringFromStdString(#->get_basename())", header: stringConversionCode.} ## \
## Return the name represented by just this particular InternalName object,
## ignoring its parents names.  This is everything after the rightmost dot.

proc findAncestor*(this: InternalName, basename: string): int {.importcpp: "#->find_ancestor(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the index of the ancestor with the indicated basename, or -1 if no
## ancestor has that basename.  Returns 0 if this name has the basename.
##
## This index value may be passed to get_ancestor() or get_net_basename() to
## retrieve more information about the indicated name.

proc getAncestor*(this: InternalName, n: int): InternalName {.importcpp: "deconstify(#->get_ancestor(#))", header: deconstifyCode.} ## \
## Returns the ancestor with the indicated index number.  0 is this name
## itself, 1 is the name's parent, 2 is the parent's parent, and so on.  If
## there are not enough ancestors, returns the root InternalName.

proc getTop*(this: InternalName): InternalName {.importcpp: "deconstify(#->get_top())", header: deconstifyCode.} ## \
## Returns the oldest ancestor in the InternalName's chain, not counting the
## root.  This will be the first name in the string, e.g.  "texcoord.foo.bar"
## will return the InternalName "texcoord".

proc getNetBasename*(this: InternalName, n: int): string {.importcpp: "nimStringFromStdString(#->get_net_basename(#))", header: stringConversionCode.} ## \
## Returns the basename of this name prefixed by the indicated number of
## ancestors.  0 is this name's basename, 1 is parent.basename, 2 is
## grandparent.parent.basename, and so on.

proc output*(this: InternalName, `out`: ostream) {.importcpp: "#->output(#)".}

proc getRoot*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_root()", header: "internalName.h".} ## \
## Returns the standard root InternalName.  This is the root of all other
## InternalNames.  It has no name itself, and it is the only InternalName with
## no parent.

proc getError*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_error()", header: "internalName.h".} ## \
## Returns the standard InternalName "error".

proc getVertex*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_vertex()", header: "internalName.h".} ## \
## Returns the standard InternalName "vertex".  This is the column header for
## the 3-d or 4-d vertex position information for each vertex.

proc getNormal*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_normal()", header: "internalName.h".} ## \
## Returns the standard InternalName "normal".  This is the column header for
## the 3-d lighting normal for each vertex.

proc getTangent*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_tangent()", header: "internalName.h".} ## \
## Returns the standard InternalName "tangent".  This is the column header for
## the tangent vector associated with each vertex, which is a unit vector
## usually perpendicular to the normal and in the direction of the U texture
## coordinate change.  It is used for deriving bump maps.

proc getTangentName*(_: typedesc[InternalName], name: string): InternalName {.importcpp: "#InternalName::get_tangent_name(nimStringToStdString(#))", header: "internalName.h".} ## \
## Returns the InternalName "tangent.name", where name is the supplied string.
## This is the column header for the tangent associated with the named texture
## coordinate set.

proc getBinormal*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_binormal()", header: "internalName.h".} ## \
## Returns the standard InternalName "binormal".  This is the column header
## for the tangent vector associated with each vertex, which is a unit vector
## usually perpendicular to both the normal and the tangent, and in the
## direction of the V texture coordinate change.  It is used for deriving bump
## maps.

proc getBinormalName*(_: typedesc[InternalName], name: string): InternalName {.importcpp: "#InternalName::get_binormal_name(nimStringToStdString(#))", header: "internalName.h".} ## \
## Returns the InternalName "binormal.name", where name is the supplied
## string.  This is the column header for the binormal associated with the
## named texture coordinate set.

proc getTexcoord*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_texcoord()", header: "internalName.h".} ## \
## Returns the standard InternalName "texcoord".  This is the column header
## for the default texture coordinate set for each vertex.  It is also used
## for identifying the default texture coordinate set in a TextureStage.

proc getTexcoordName*(_: typedesc[InternalName], name: string): InternalName {.importcpp: "#InternalName::get_texcoord_name(nimStringToStdString(#))", header: "internalName.h".} ## \
## Returns the InternalName "texcoord.name", where name is the supplied
## string.  This is the column header for the named texture coordinate set for
## each vertex.  It is also used for identifying the named texture coordinate
## set in a TextureStage.

proc getColor*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_color()", header: "internalName.h".} ## \
## Returns the standard InternalName "color".  This is the column header for
## the 4-component color value for each vertex.

proc getRotate*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_rotate()", header: "internalName.h".} ## \
## Returns the standard InternalName "rotate".  This is the column header for
## the floating-point rotate value, which represents a number of degrees
## counter-clockwise to rotate each point or point sprite.

proc getSize*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_size()", header: "internalName.h".} ## \
## Returns the standard InternalName "size".  This is the column header for
## the floating-point size value, which overrides the thickness parameter of
## the RenderModeAttrib on a per-vertex (e.g.  per-point) basis.

proc getAspectRatio*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_aspect_ratio()", header: "internalName.h".} ## \
## Returns the standard InternalName "aspect_ratio". This is the column header
## for the floating-point aspect ratio value, which is used to define non-
## square points.  This number is the ratio x / y, where y is the point size
## (above).

proc getTransformBlend*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_transform_blend()", header: "internalName.h".} ## \
## Returns the standard InternalName "transform_blend". This is the column
## header for the integer transform_blend index, which is used to define
## vertex animation on the CPU by indexing to a particular vertex weighting
## from the TransformBlendTable.

proc getTransformWeight*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_transform_weight()", header: "internalName.h".} ## \
## Returns the standard InternalName "transform_weight". This is the column
## header for the n-component transform_weight value, which is used in
## conjuntion with "transform_index" to define vertex animation on the
## graphics card.  The transform_weight value specifies the weight of the nth
## transform.  By convention, there are 1 fewer weight values than transforms,
## since the weights are assumed to sum to 1 (and the last value is therefore
## implicit).

proc getTransformIndex*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_transform_index()", header: "internalName.h".} ## \
## Returns the standard InternalName "transform_index". This is the column
## header for the n-component transform_index value, which is used in
## conjuntion with "transform_weight" to define vertex animation on the
## graphics card.  The transform_index value specifies the nth transform, by
## lookup in the TransformTable.  The transform_index column may be omitted,
## in which case the nth transform is the nth entry in the table.

proc getMorph*(_: typedesc[InternalName], column: InternalName, slider: string): InternalName {.importcpp: "#InternalName::get_morph(#, nimStringToStdString(#))", header: "internalName.h".} ## \
## Returns an InternalName derived from the given base column name and the
## given slider name, which is the column header for the offset vector that
## should be applied to the base column name when the named morph slider is
## engaged.
##
## Each morph slider requires a set of n morph columns, one for each base
## column it applies to.

proc getIndex*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_index()", header: "internalName.h".} ## \
## Returns the standard InternalName "index".  This is the column header for
## the integer vertex index.  It is not used in the vertex data itself, but is
## used in the GeomPrimitive structure to index into the vertex data.

proc getWorld*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_world()", header: "internalName.h".} ## \
## Returns the standard InternalName "world".  This is used as a keyword in
## the shader subsystem.

proc getCamera*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_camera()", header: "internalName.h".} ## \
## Returns the standard InternalName "camera".  This is used as a keyword in
## the shader subsystem.

proc getModel*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_model()", header: "internalName.h".} ## \
## Returns the standard InternalName "model".  This is used as a keyword in
## the shader subsystem.

proc getView*(_: typedesc[InternalName]): InternalName {.importcpp: "InternalName::get_view()", header: "internalName.h".} ## \
## Returns the standard InternalName "view".  This is used as a keyword in the
## shader subsystem.

converter getClassType*(_: typedesc[InternalName]): TypeHandle {.importcpp: "InternalName::get_class_type()", header: "internalName.h".}

proc initGeomVertexColumn*(copy: GeomVertexColumn): GeomVertexColumn {.importcpp: "GeomVertexColumn(#)".}

proc getName*(this: GeomVertexColumn): InternalName {.importcpp: "#.get_name()".} ## \
## Returns the name of this particular data field, e.g.  "vertex" or "normal".
## The name may be a user-defined string, or it may be one of the standard
## system-defined field types.  Only the system-defined field types are used
## for the actual rendering.

proc getNumComponents*(this: GeomVertexColumn): int {.importcpp: "#.get_num_components()".} ## \
## Returns the number of components of the column: the number of instances of
## the NumericType in each element.  This is usually, but not always, the same
## thing as get_num_values().

proc getNumValues*(this: GeomVertexColumn): int {.importcpp: "#.get_num_values()".} ## \
## Returns the number of numeric values of the column: the number of distinct
## numeric values that go into each element.  This is usually, but not always,
## the same thing as get_num_components(); the difference is in the case of a
## composite numeric type like NT_packed_dcba, which has four numeric values
## per component.

proc getNumElements*(this: GeomVertexColumn): int {.importcpp: "#.get_num_elements()".} ## \
## Returns the number of times this column is repeated.  This is usually 1,
## except for matrices.

proc getStart*(this: GeomVertexColumn): int {.importcpp: "#.get_start()".} ## \
## Returns the byte within the array record at which this column starts.  This
## can be set to non-zero to implement interleaved arrays.

proc getColumnAlignment*(this: GeomVertexColumn): int {.importcpp: "#.get_column_alignment()".} ## \
## Returns the alignment requirements for this column.  If this is greater
## than 1, it restricts the column to appear only on memory addresses that are
## integer multiples of this value; this has implications for this column's
## start value, as well as the stride of the resulting array.

proc getElementStride*(this: GeomVertexColumn): int {.importcpp: "#.get_element_stride()".} ## \
## This value is only relevant for matrix types.  Returns the number of bytes
## to add to access the next row of the matrix.

proc getComponentBytes*(this: GeomVertexColumn): int {.importcpp: "#.get_component_bytes()".} ## \
## Returns the number of bytes used by each component (that is, by one element
## of the numeric type).

proc getTotalBytes*(this: GeomVertexColumn): int {.importcpp: "#.get_total_bytes()".} ## \
## Returns the number of bytes used by each element of the column:
## component_bytes \* num_components.

proc hasHomogeneousCoord*(this: GeomVertexColumn): bool {.importcpp: "#.has_homogeneous_coord()".} ## \
## Returns true if this Contents type is one that includes a homogeneous
## coordinate in the fourth component, or false otherwise.  If this is true,
## correct operation on the vertex data may require scaling by the homogeneous
## coordinate from time to time (but in general this is handled automatically
## if you use the 3-component or smaller forms of get_data() and set_data()).

proc overlapsWith*(this: GeomVertexColumn, start_byte: int, num_bytes: int): bool {.importcpp: "#.overlaps_with(#, #)".} ## \
## Returns true if this column overlaps with any of the bytes in the indicated
## range, false if it does not.

proc isBytewiseEquivalent*(this: GeomVertexColumn, other: GeomVertexColumn): bool {.importcpp: "#.is_bytewise_equivalent(#)".} ## \
## Returns true if the data store of this column is exactly the same as that
## of the other, irrespective of name or start position within the record.

proc setName*(this: GeomVertexColumn, name: InternalName) {.importcpp: "#.set_name(#)".} ## \
## Replaces the name of an existing column.  This is only legal on an
## unregistered format (i.e.  when constructing the format initially).

proc setNumComponents*(this: GeomVertexColumn, num_components: int) {.importcpp: "#.set_num_components(#)".} ## \
## Changes the number of components of an existing column.  This is only legal
## on an unregistered format (i.e.  when constructing the format initially).

proc setStart*(this: GeomVertexColumn, start: int) {.importcpp: "#.set_start(#)".} ## \
## Changes the start byte of an existing column.  This is only legal on an
## unregistered format (i.e.  when constructing the format initially).

proc setColumnAlignment*(this: GeomVertexColumn, column_alignment: int) {.importcpp: "#.set_column_alignment(#)".} ## \
## Changes the column alignment of an existing column.  This is only legal on
## an unregistered format (i.e.  when constructing the format initially).

proc output*(this: GeomVertexColumn, `out`: ostream) {.importcpp: "#.output(#)".}

converter upcastToTypedWritableReferenceCount*(this: GeomVertexArrayFormat): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcastToGeomEnums*(this: GeomVertexArrayFormat): GeomEnums {.importcpp: "((GeomEnums *)(GeomVertexArrayFormat *)(#))".}

proc newGeomVertexArrayFormat*(): GeomVertexArrayFormat {.importcpp: "new GeomVertexArrayFormat()".}

proc newGeomVertexArrayFormat*(copy: GeomVertexArrayFormat): GeomVertexArrayFormat {.importcpp: "new GeomVertexArrayFormat(#)".}

proc unref*(this: GeomVertexArrayFormat): bool {.importcpp: "#->unref()".} ## \
## This method overrides ReferenceCount::unref() to unregister the object when
## its reference count goes to zero.

proc isRegistered*(this: GeomVertexArrayFormat): bool {.importcpp: "#->is_registered()".} ## \
## Returns true if this format has been registered, false if it has not.  It
## may not be used for a Geom until it has been registered, but once
## registered, it may no longer be modified.

proc registerFormat*(_: typedesc[GeomVertexArrayFormat], format: GeomVertexArrayFormat): GeomVertexArrayFormat {.importcpp: "deconstify(#GeomVertexArrayFormat::register_format(#))", header: "geomVertexArrayFormat.h".} ## \
## Adds the indicated format to the registry, if there is not an equivalent
## format already there; in either case, returns the pointer to the equivalent
## format now in the registry.
##
## This is similar to GeomVertexFormat::register_format(), except that you
## generally need not call it explicitly.  Calling
## GeomVertexFormat::register_format() automatically registers all of the
## nested array formats.

proc getStride*(this: GeomVertexArrayFormat): int {.importcpp: "#->get_stride()".} ## \
## Returns the total number of bytes reserved in the array for each vertex.

proc setStride*(this: GeomVertexArrayFormat, stride: int) {.importcpp: "#->set_stride(#)".} ## \
## Changes the total number of bytes reserved in the array for each vertex.
## You may not reduce this below get_total_bytes(), but you may increase it
## arbitrarily.

proc getPadTo*(this: GeomVertexArrayFormat): int {.importcpp: "#->get_pad_to()".} ## \
## Returns the byte divisor to which the data record must be padded to meet
## hardware limitations.  For instance, if this is 4, the stride will be
## automatically rounded up to the next multiple of 4 bytes.  This value is
## automatically increased as needed to ensure the individual numeric
## components in the array are word-aligned.

proc setPadTo*(this: GeomVertexArrayFormat, pad_to: int) {.importcpp: "#->set_pad_to(#)".} ## \
## Explicitly sets the byte divisor to which the data record must be padded to
## meet hardware limitations.  See get_pad_to().  Normally it is not necessary
## to call this unless you have some specific requirements for row-to-row data
## alignment.  Note that this value may be automatically increased at each
## subsequent call to add_column().

proc getDivisor*(this: GeomVertexArrayFormat): int {.importcpp: "#->get_divisor()".} ## \
## Returns the divisor attribute for the data in this array.  If 0, it
## contains per-vertex data.  If 1, it contains per-instance data.  If higher
## than 1, the read row is advanced for each n instances.

proc setDivisor*(this: GeomVertexArrayFormat, divisor: int) {.importcpp: "#->set_divisor(#)".} ## \
## Set this to 0 to indicate that this array contains per-vertex data, or to 1
## to indicate that it contains per-instance data.  If higher than 1, the read
## row is advanced for each n instances.

proc getTotalBytes*(this: GeomVertexArrayFormat): int {.importcpp: "#->get_total_bytes()".} ## \
## Returns the total number of bytes used by the data types within the format,
## including gaps between elements.

proc addColumn*(this: GeomVertexArrayFormat, column: GeomVertexColumn): int {.importcpp: "#->add_column(#)".} ## \
## Adds a new column to the specification.  This is a table of per-vertex
## floating-point numbers such as "vertex" or "normal"; you must specify where
## in each record the table starts, and how many components (dimensions) exist
## per vertex.
##
## Adding a column with the same name as a previous type, or that overlaps
## with one or more previous types, quietly removes the previous type(s).
##
## The return value is the index number of the new data type.

proc removeColumn*(this: GeomVertexArrayFormat, name: InternalName) {.importcpp: "#->remove_column(#)".} ## \
## Removes the column with the indicated name, if any.  This leaves a gap in
## the byte structure.

proc clearColumns*(this: GeomVertexArrayFormat) {.importcpp: "#->clear_columns()".} ## \
## Removes all columns previously added, sets the stride to zero, and prepares
## to start over.

proc packColumns*(this: GeomVertexArrayFormat) {.importcpp: "#->pack_columns()".} ## \
## Removes wasted space between columns.

proc alignColumnsForAnimation*(this: GeomVertexArrayFormat) {.importcpp: "#->align_columns_for_animation()".} ## \
## Reprocesses the columns in the format to align the C_point and C_vector
## columns to 16-byte boundaries to allow for the more efficient SSE2
## operations (assuming SSE2 is enabled in the build).
##
## The caller is responsible for testing vertex_animation_align_16 to decide
## whether to call this method.

proc getNumColumns*(this: GeomVertexArrayFormat): int {.importcpp: "#->get_num_columns()".} ## \
## Returns the number of different columns in the array.

proc getColumn*(this: GeomVertexArrayFormat, name: InternalName): GeomVertexColumn {.importcpp: "#->get_column(#)".} ## \
## Returns the specification with the indicated name, or NULL if the name is
## not used.

proc getColumn*(this: GeomVertexArrayFormat, i: int): GeomVertexColumn {.importcpp: "#->get_column(#)".} ## \
## Returns the ith column of the array.

proc getColumn*(this: GeomVertexArrayFormat, start_byte: int, num_bytes: int): GeomVertexColumn {.importcpp: "#->get_column(#, #)".} ## \
## Returns the first specification that overlaps with any of the indicated
## bytes in the range, or NULL if none do.

proc hasColumn*(this: GeomVertexArrayFormat, name: InternalName): bool {.importcpp: "#->has_column(#)".} ## \
## Returns true if the array has the named column, false otherwise.

proc isDataSubsetOf*(this: GeomVertexArrayFormat, other: GeomVertexArrayFormat): bool {.importcpp: "#->is_data_subset_of(#)".} ## \
## Returns true if all of the fields in this array format are also present and
## equivalent in the other array format, and in the same byte positions, and
## the stride is the same.  That is, true if this format can share the same
## data pointer as the other format (with possibly some unused gaps).

proc countUnusedSpace*(this: GeomVertexArrayFormat): int {.importcpp: "#->count_unused_space()".} ## \
## Returns the number of bytes per row that are not assigned to any column.

proc output*(this: GeomVertexArrayFormat, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: GeomVertexArrayFormat, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: GeomVertexArrayFormat, `out`: ostream) {.importcpp: "#->write(#)".}

proc writeWithData*(this: GeomVertexArrayFormat, `out`: ostream, indent_level: int, array_data: GeomVertexArrayData) {.importcpp: "#->write_with_data(#, #, #)".}

proc getFormatString*(this: GeomVertexArrayFormat, pad: bool): string {.importcpp: "nimStringFromStdString(#->get_format_string(#))", header: stringConversionCode.} ## \
## Returns a string with format codes representing the exact memory layout of
## the columns in memory, as understood by Python's struct module.  If pad is
## true, extra padding bytes are added to the end as 'x' characters as needed.

proc getFormatString*(this: GeomVertexArrayFormat): string {.importcpp: "nimStringFromStdString(#->get_format_string())", header: stringConversionCode.} ## \
## Returns a string with format codes representing the exact memory layout of
## the columns in memory, as understood by Python's struct module.  If pad is
## true, extra padding bytes are added to the end as 'x' characters as needed.

converter getClassType*(_: typedesc[GeomVertexArrayFormat]): TypeHandle {.importcpp: "GeomVertexArrayFormat::get_class_type()", header: "geomVertexArrayFormat.h".}

converter upcastToTypedWritableReferenceCount*(this: GeomVertexFormat): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcastToGeomEnums*(this: GeomVertexFormat): GeomEnums {.importcpp: "((GeomEnums *)(GeomVertexFormat *)(#))".}

proc newGeomVertexFormat*(): GeomVertexFormat {.importcpp: "new GeomVertexFormat()".}

proc newGeomVertexFormat*(array_format: GeomVertexArrayFormat): GeomVertexFormat {.importcpp: "new GeomVertexFormat(#)".}

proc newGeomVertexFormat*(copy: GeomVertexFormat): GeomVertexFormat {.importcpp: "new GeomVertexFormat(#)".}

proc unref*(this: GeomVertexFormat): bool {.importcpp: "#->unref()".} ## \
## This method overrides ReferenceCount::unref() to unregister the object when
## its reference count goes to zero.

proc isRegistered*(this: GeomVertexFormat): bool {.importcpp: "#->is_registered()".} ## \
## Returns true if this format has been registered, false if it has not.  It
## may not be used for a Geom until it has been registered, but once
## registered, it may no longer be modified.

proc registerFormat*(_: typedesc[GeomVertexFormat], format: GeomVertexArrayFormat): GeomVertexFormat {.importcpp: "deconstify(#GeomVertexFormat::register_format(#))", header: "geomVertexFormat.h".} ## \
## This flavor of register_format() implicitly creates a one-array vertex
## format from the array definition.

proc registerFormat*(_: typedesc[GeomVertexFormat], format: GeomVertexFormat): GeomVertexFormat {.importcpp: "deconstify(#GeomVertexFormat::register_format(#))", header: "geomVertexFormat.h".} ## \
## Adds the indicated format to the registry, if there is not an equivalent
## format already there; in either case, returns the pointer to the equivalent
## format now in the registry.
##
## This must be called before a format may be used in a Geom.  After this
## call, you should discard the original pointer you passed in (which may or
## may not now be invalid) and let its reference count decrement normally; you
## should use only the returned value from this point on.

proc getAnimation*(this: GeomVertexFormat): GeomVertexAnimationSpec {.importcpp: "#->get_animation()".} ## \
## Returns the GeomVertexAnimationSpec that indicates how this format's
## vertices are set up for animation.

proc setAnimation*(this: GeomVertexFormat, animation: GeomVertexAnimationSpec) {.importcpp: "#->set_animation(#)".} ## \
## Resets the GeomVertexAnimationSpec that indicates how this format's
## vertices are set up for animation.  You should also, of course, change the
## columns in the tables accordingly.
##
## This may not be called once the format has been registered.

proc getPostAnimatedFormat*(this: GeomVertexFormat): GeomVertexFormat {.importcpp: "deconstify(#->get_post_animated_format())", header: deconstifyCode.} ## \
## Returns a suitable vertex format for sending the animated vertices to the
## graphics backend.  This is the same format as the source format, with the
## CPU-animation data elements removed.
##
## This may only be called after the format has been registered.  The return
## value will have been already registered.

proc getUnionFormat*(this: GeomVertexFormat, other: GeomVertexFormat): GeomVertexFormat {.importcpp: "deconstify(#->get_union_format(#))", header: deconstifyCode.} ## \
## Returns a new GeomVertexFormat that includes all of the columns defined in
## either this GeomVertexFormat or the other one.  If any column is defined in
## both formats with different sizes (for instance, texcoord2 vs.  texcoord3),
## the new format will include the larger of the two definitions.
##
## This may only be called after both source formats have been registered.
## The return value will also have been already registered.

proc getNumArrays*(this: GeomVertexFormat): clonglong {.importcpp: "#->get_num_arrays()".} ## \
## Returns the number of individual arrays required by the format.  If the
## array data is completely interleaved, this will be 1; if it is completely
## parallel, this will be the same as the number of data types.

proc getArray*(this: GeomVertexFormat, array: clonglong): GeomVertexArrayFormat {.importcpp: "deconstify(#->get_array(#))", header: deconstifyCode.} ## \
## Returns the description of the nth array used by the format.

proc modifyArray*(this: GeomVertexFormat, array: clonglong): GeomVertexArrayFormat {.importcpp: "#->modify_array(#)".} ## \
## Returns a modifiable pointer to the indicated array.  This means
## duplicating it if it is shared or registered.
##
## This may not be called once the format has been registered.

proc setArray*(this: GeomVertexFormat, array: clonglong, format: GeomVertexArrayFormat) {.importcpp: "#->set_array(#, #)".} ## \
## Replaces the definition of the indicated array.
##
## This may not be called once the format has been registered.

proc removeArray*(this: GeomVertexFormat, array: clonglong) {.importcpp: "#->remove_array(#)".} ## \
## Removes the nth array from the format.
##
## This may not be called once the format has been registered.

proc addArray*(this: GeomVertexFormat, array_format: GeomVertexArrayFormat): clonglong {.importcpp: "#->add_array(#)".} ## \
## Adds the indicated array definition to the list of arrays included within
## this vertex format definition.  The return value is the index number of the
## new array.
##
## This may not be called once the format has been registered.

proc insertArray*(this: GeomVertexFormat, array: clonglong, array_format: GeomVertexArrayFormat) {.importcpp: "#->insert_array(#, #)".} ## \
## Adds the indicated array definition to the list of arrays at the indicated
## position.  This works just like add_array(), except that you can specify
## which array index the new array should have.
##
## This may not be called once the format has been registered.

proc clearArrays*(this: GeomVertexFormat) {.importcpp: "#->clear_arrays()".} ## \
## Removes all of the array definitions from the format and starts over.
##
## This may not be called once the format has been registered.

proc removeEmptyArrays*(this: GeomVertexFormat) {.importcpp: "#->remove_empty_arrays()".} ## \
## Removes the arrays that define no columns.
##
## This may not be called once the format has been registered.

proc getNumColumns*(this: GeomVertexFormat): clonglong {.importcpp: "#->get_num_columns()".} ## \
## Returns the total number of different columns in the specification, across
## all arrays.

proc getArrayWith*(this: GeomVertexFormat, name: InternalName): int {.importcpp: "#->get_array_with(#)".} ## \
## Returns the index number of the array with the indicated column, or -1 if
## no arrays contained that name.
##
## The return value can be passed to get_array_format() to get the format of
## the array.  It may also be passed to GeomVertexData::get_array_data() or
## get_data() or set_data() to manipulate the actual array data.
##
## This may only be called after the format has been registered.

proc getArrayWith*(this: GeomVertexFormat, i: clonglong): int {.importcpp: "#->get_array_with(#)".} ## \
## Returns the index number of the array with the ith column.
##
## The return value can be passed to get_array_format() to get the format of
## the array.  It may also be passed to GeomVertexData::get_array_data() or
## get_data() or set_data() to manipulate the actual array data.

proc getColumn*(this: GeomVertexFormat, name: InternalName): GeomVertexColumn {.importcpp: "#->get_column(#)".} ## \
## Returns the specification with the indicated name, or NULL if the name is
## not used.  Use get_array_with() to determine which array this column is
## associated with.

proc getColumn*(this: GeomVertexFormat, i: clonglong): GeomVertexColumn {.importcpp: "#->get_column(#)".} ## \
## Returns the ith column of the specification, across all arrays.

proc hasColumn*(this: GeomVertexFormat, name: InternalName): bool {.importcpp: "#->has_column(#)".} ## \
## Returns true if the format has the named column, false otherwise.

proc getColumnName*(this: GeomVertexFormat, i: clonglong): InternalName {.importcpp: "deconstify(#->get_column_name(#))", header: deconstifyCode.} ## \
## Returns the name of the ith column, across all arrays.

proc removeColumn*(this: GeomVertexFormat, name: InternalName, keep_empty_array: bool) {.importcpp: "#->remove_column(#, #)".} ## \
## Removes the named column from the format, from whichever array it exists
## in.  If there are other columns remaining in the array, the array is left
## with a gap where the column used to be; if this was the only column in the
## array, the array is removed (unless keep_empty_array is true).
##
## This may not be called once the format has been registered.

proc removeColumn*(this: GeomVertexFormat, name: InternalName) {.importcpp: "#->remove_column(#)".} ## \
## Removes the named column from the format, from whichever array it exists
## in.  If there are other columns remaining in the array, the array is left
## with a gap where the column used to be; if this was the only column in the
## array, the array is removed (unless keep_empty_array is true).
##
## This may not be called once the format has been registered.

proc packColumns*(this: GeomVertexFormat) {.importcpp: "#->pack_columns()".} ## \
## Removes wasted space between columns.

proc alignColumnsForAnimation*(this: GeomVertexFormat) {.importcpp: "#->align_columns_for_animation()".} ## \
## Reprocesses the columns in the format to align the C_point and C_vector
## columns to 16-byte boundaries to allow for the more efficient SSE2
## operations (assuming SSE2 is enabled in the build).
##
## Also see maybe_align_columns_for_animation().

proc maybeAlignColumnsForAnimation*(this: GeomVertexFormat) {.importcpp: "#->maybe_align_columns_for_animation()".} ## \
## Calls align_columns_for_animation() if this format's AnimationSpec
## indicates that it contains animated vertices, and if vertex-animation-
## align-16 is true.

proc getNumPoints*(this: GeomVertexFormat): clonglong {.importcpp: "#->get_num_points()".} ## \
## Returns the number of columns within the format that represent points in
## space.
##
## This may only be called after the format has been registered.

proc getPoint*(this: GeomVertexFormat, n: clonglong): InternalName {.importcpp: "deconstify(#->get_point(#))", header: deconstifyCode.} ## \
## Returns the name of the nth point column.  This represents a point in
## space, which should be transformed by any spatial transform matrix.
##
## This may only be called after the format has been registered.

proc getNumVectors*(this: GeomVertexFormat): clonglong {.importcpp: "#->get_num_vectors()".} ## \
## Returns the number of columns within the format that represent directional
## vectors.
##
## This may only be called after the format has been registered.

proc getVector*(this: GeomVertexFormat, n: clonglong): InternalName {.importcpp: "deconstify(#->get_vector(#))", header: deconstifyCode.} ## \
## Returns the name of the nth vector column.  This represents a directional
## vector, which should be transformed by any spatial transform matrix as a
## vector.
##
## This may only be called after the format has been registered.

proc getNumTexcoords*(this: GeomVertexFormat): clonglong {.importcpp: "#->get_num_texcoords()".} ## \
## Returns the number of columns within the format that represent texture
## coordinates.
##
## This may only be called after the format has been registered.

proc getTexcoord*(this: GeomVertexFormat, n: clonglong): InternalName {.importcpp: "deconstify(#->get_texcoord(#))", header: deconstifyCode.} ## \
## Returns the name of the nth texcoord column.  This represents a texture
## coordinate.
##
## This may only be called after the format has been registered.

proc getNumMorphs*(this: GeomVertexFormat): clonglong {.importcpp: "#->get_num_morphs()".} ## \
## Returns the number of columns within the format that represent morph
## deltas.
##
## This may only be called after the format has been registered.

proc getMorphSlider*(this: GeomVertexFormat, n: clonglong): InternalName {.importcpp: "deconstify(#->get_morph_slider(#))", header: deconstifyCode.} ## \
## Returns the slider name associated with the nth morph column.  This is the
## name of the slider that will control the morph, and should be defined
## within the SliderTable associated with the GeomVertexData.
##
## This may only be called after the format has been registered.

proc getMorphBase*(this: GeomVertexFormat, n: clonglong): InternalName {.importcpp: "deconstify(#->get_morph_base(#))", header: deconstifyCode.} ## \
## Returns the name of the base column that the nth morph modifies.  This
## column will also be defined within the format, and can be retrieved via
## get_array_with() and/or get_column().
##
## This may only be called after the format has been registered.

proc getMorphDelta*(this: GeomVertexFormat, n: clonglong): InternalName {.importcpp: "deconstify(#->get_morph_delta(#))", header: deconstifyCode.} ## \
## Returns the name of the column that defines the nth morph.  This contains
## the delta offsets that are to be applied to the column defined by
## get_morph_base().  This column will be defined within the format, and can
## be retrieved via get_array_with() and/or get_column().
##
## This may only be called after the format has been registered.

proc output*(this: GeomVertexFormat, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: GeomVertexFormat, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: GeomVertexFormat, `out`: ostream) {.importcpp: "#->write(#)".}

proc writeWithData*(this: GeomVertexFormat, `out`: ostream, indent_level: int, data: GeomVertexData) {.importcpp: "#->write_with_data(#, #, #)".}

proc getEmpty*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "deconstify(GeomVertexFormat::get_empty())", header: "geomVertexFormat.h".} ## \
## Returns a standard vertex format containing no arrays at all, useful for
## pull-style vertex rendering.

proc getV3*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "deconstify(GeomVertexFormat::get_v3())", header: "geomVertexFormat.h".} ## \
## Some standard vertex formats.  No particular requirement to use one of
## these, but the DirectX renderers can use these formats directly, whereas
## any other format will have to be converted first.

proc getV3n3*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "deconstify(GeomVertexFormat::get_v3n3())", header: "geomVertexFormat.h".} ## \
## Returns a standard vertex format with a 3-component normal and a
## 3-component vertex position.

proc getV3t2*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "deconstify(GeomVertexFormat::get_v3t2())", header: "geomVertexFormat.h".} ## \
## Returns a standard vertex format with a 2-component texture coordinate pair
## and a 3-component vertex position.

proc getV3n3t2*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "deconstify(GeomVertexFormat::get_v3n3t2())", header: "geomVertexFormat.h".} ## \
## Returns a standard vertex format with a 2-component texture coordinate
## pair, a 3-component normal, and a 3-component vertex position.

proc getV3cp*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "deconstify(GeomVertexFormat::get_v3cp())", header: "geomVertexFormat.h".} ## \
## These formats, with the DirectX-style packed color, may not be supported
## directly by OpenGL.  If you use them and the driver does not support
## them, the GLGraphicsStateGuardian will automatically convert to native
## OpenGL form (with a small runtime overhead).

proc getV3cpt2*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "deconstify(GeomVertexFormat::get_v3cpt2())", header: "geomVertexFormat.h".} ## \
## Returns a standard vertex format with a 2-component texture coordinate
## pair, a packed color, and a 3-component vertex position.

proc getV3n3cp*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "deconstify(GeomVertexFormat::get_v3n3cp())", header: "geomVertexFormat.h".} ## \
## Returns a standard vertex format with a packed color, a 3-component normal,
## and a 3-component vertex position.

proc getV3n3cpt2*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "deconstify(GeomVertexFormat::get_v3n3cpt2())", header: "geomVertexFormat.h".} ## \
## Returns a standard vertex format with a 2-component texture coordinate
## pair, a packed color, a 3-component normal, and a 3-component vertex
## position.

proc getV3c4*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "deconstify(GeomVertexFormat::get_v3c4())", header: "geomVertexFormat.h".} ## \
## These formats, with an OpenGL-style four-byte color, are not supported
## directly by DirectX.  If you use them, the DXGraphicsStateGuardian will
## automatically convert to DirectX form (with a larger runtime overhead,
## since DirectX8, and old DirectX9 drivers, require everything to be
## interleaved together).

proc getV3c4t2*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "deconstify(GeomVertexFormat::get_v3c4t2())", header: "geomVertexFormat.h".} ## \
## Returns a standard vertex format with a 2-component texture coordinate
## pair, a 4-component color, and a 3-component vertex position.

proc getV3n3c4*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "deconstify(GeomVertexFormat::get_v3n3c4())", header: "geomVertexFormat.h".} ## \
## Returns a standard vertex format with a 4-component color, a 3-component
## normal, and a 3-component vertex position.

proc getV3n3c4t2*(_: typedesc[GeomVertexFormat]): GeomVertexFormat {.importcpp: "deconstify(GeomVertexFormat::get_v3n3c4t2())", header: "geomVertexFormat.h".} ## \
## Returns a standard vertex format with a 2-component texture coordinate
## pair, a 4-component color, a 3-component normal, and a 3-component vertex
## position.

converter getClassType*(_: typedesc[GeomVertexFormat]): TypeHandle {.importcpp: "GeomVertexFormat::get_class_type()", header: "geomVertexFormat.h".}

converter upcastToNamable*(this: SimpleLru): Namable {.importcpp: "#.upcast_to_Namable()".}

proc initSimpleLru*(name: string, max_size: clonglong): SimpleLru {.importcpp: "SimpleLru(nimStringToStdString(#), #)", header: stringConversionCode.}

proc getTotalSize*(this: SimpleLru): clonglong {.importcpp: "#.get_total_size()".} ## \
## Returns the total size of all objects currently active on the LRU.

proc getMaxSize*(this: SimpleLru): clonglong {.importcpp: "#.get_max_size()".} ## \
## Returns the max size of all objects that are allowed to be active on the
## LRU.

proc setMaxSize*(this: SimpleLru, max_size: clonglong) {.importcpp: "#.set_max_size(#)".} ## \
## Changes the max size of all objects that are allowed to be active on the
## LRU.
##
## If the size is (size_t)-1, there is no limit.

proc countActiveSize*(this: SimpleLru): clonglong {.importcpp: "#.count_active_size()".} ## \
## Returns the total size of the pages that were enqueued since the last call
## to begin_epoch().

proc considerEvict*(this: SimpleLru) {.importcpp: "#.consider_evict()".} ## \
## Evicts a sequence of objects if the queue is full.

proc evictTo*(this: SimpleLru, target_size: clonglong) {.importcpp: "#.evict_to(#)".} ## \
## Evicts a sequence of objects until the queue fits within the indicated
## target size, regardless of its normal max size.

proc beginEpoch*(this: SimpleLru) {.importcpp: "#.begin_epoch()".} ## \
## Marks the end of the previous epoch and the beginning of the next one.
## This will evict any objects that are pending eviction, and also update any
## internal bookkeeping.

proc validate*(this: SimpleLru): bool {.importcpp: "#.validate()".} ## \
## Checks that the LRU is internally self-consistent.  Returns true if
## successful, false if there is some problem.

proc output*(this: SimpleLru, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: SimpleLru, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc newSimpleLruPage*(copy: SimpleLruPage): SimpleLruPage {.importcpp: "new SimpleLruPage(#)".}

proc newSimpleLruPage*(lru_size: clonglong): SimpleLruPage {.importcpp: "new SimpleLruPage(#)".}

proc getLru*(this: SimpleLruPage): SimpleLru {.importcpp: "#->get_lru()".} ## \
## Returns the LRU that manages this page, or NULL if it is not currently
## managed by any LRU.

proc enqueueLru*(this: SimpleLruPage, lru: SimpleLru) {.importcpp: "#->enqueue_lru(#)".} ## \
## Adds the page to the LRU for the first time, or marks it recently-accessed
## if it has already been added.
##
## If lru is NULL, it means to remove this page from its LRU.

proc dequeueLru*(this: SimpleLruPage) {.importcpp: "#->dequeue_lru()".} ## \
## Removes the page from its SimpleLru.

proc markUsedLru*(this: SimpleLruPage, lru: SimpleLru) {.importcpp: "#->mark_used_lru(#)".} ## \
## To be called when the page is used; this will move it to the tail of the
## specified SimpleLru queue.

proc getLruSize*(this: SimpleLruPage): clonglong {.importcpp: "#->get_lru_size()".} ## \
## Returns the size of this page as reported to the LRU, presumably in bytes.

proc setLruSize*(this: SimpleLruPage, lru_size: clonglong) {.importcpp: "#->set_lru_size(#)".} ## \
## Specifies the size of this page, presumably in bytes, although any unit is
## possible.

proc evictLru*(this: SimpleLruPage) {.importcpp: "#->evict_lru()".} ## \
## Evicts the page from the LRU.  Called internally when the LRU determines
## that it is full.  May also be called externally when necessary to
## explicitly evict the page.
##
## It is legal for this method to either evict the page as requested, do
## nothing (in which case the eviction will be requested again at the next
## epoch), or requeue itself on the tail of the queue (in which case the
## eviction will be requested again much later).

proc output*(this: SimpleLruPage, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: SimpleLruPage, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc newSimpleAllocator*(max_size: clonglong, lock: Mutex): SimpleAllocator {.importcpp: "new SimpleAllocator(#, #)".}

proc alloc*(this: SimpleAllocator, size: clonglong, alignment: clonglong): SimpleAllocatorBlock {.importcpp: "#->alloc(#, #)".} ## \
## Allocates a new block.  Returns NULL if a block of the requested size
## cannot be allocated.
##
## To free the allocated block, call block->free(), or simply delete the block
## pointer.

proc alloc*(this: SimpleAllocator, size: clonglong): SimpleAllocatorBlock {.importcpp: "#->alloc(#)".} ## \
## Allocates a new block.  Returns NULL if a block of the requested size
## cannot be allocated.
##
## To free the allocated block, call block->free(), or simply delete the block
## pointer.

proc isEmpty*(this: SimpleAllocator): bool {.importcpp: "#->is_empty()".} ## \
## Returns true if there are no blocks allocated on this page, or false if
## there is at least one.

proc getTotalSize*(this: SimpleAllocator): clonglong {.importcpp: "#->get_total_size()".} ## \
## Returns the total size of allocated objects.

proc getMaxSize*(this: SimpleAllocator): clonglong {.importcpp: "#->get_max_size()".} ## \
## Returns the available space for allocated objects.

proc setMaxSize*(this: SimpleAllocator, max_size: clonglong) {.importcpp: "#->set_max_size(#)".} ## \
## Changes the available space for allocated objects.  This will not affect
## any already-allocated objects, but will have an effect on future calls to
## alloc().

proc getContiguous*(this: SimpleAllocator): clonglong {.importcpp: "#->get_contiguous()".} ## \
## Returns an upper-bound estimate of the size of the largest contiguous block
## that may be allocated.  It is guaranteed that an attempt to allocate a
## block larger than this will fail, though it is not guaranteed that an
## attempt to allocate a block this size or smaller will succeed.

proc getFirstBlock*(this: SimpleAllocator): SimpleAllocatorBlock {.importcpp: "#->get_first_block()".} ## \
## Returns a pointer to the first allocated block, or NULL if there are no
## allocated blocks.

proc output*(this: SimpleAllocator, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: SimpleAllocator, `out`: ostream) {.importcpp: "#->write(#)".}

proc free*(this: SimpleAllocatorBlock) {.importcpp: "#->free()".} ## \
## Releases the allocated space.

proc getAllocator*(this: SimpleAllocatorBlock): SimpleAllocator {.importcpp: "#->get_allocator()".} ## \
## Returns the SimpleAllocator object that owns this block.  Returns NULL if
## the block has been freed.

proc getStart*(this: SimpleAllocatorBlock): clonglong {.importcpp: "#->get_start()".} ## \
## Returns the starting point of this block.  It is an error to call this if
## the block has been freed.

proc getSize*(this: SimpleAllocatorBlock): clonglong {.importcpp: "#->get_size()".} ## \
## Returns the size of this block.  It is an error to call this if the block
## has been freed.

proc isFree*(this: SimpleAllocatorBlock): bool {.importcpp: "#->is_free()".} ## \
## Returns true if the block has been freed, false if it is still valid.

proc getMaxSize*(this: SimpleAllocatorBlock): clonglong {.importcpp: "#->get_max_size()".} ## \
## Returns the maximum size this block can be reallocated to, as limited by
## the following block.

proc realloc*(this: SimpleAllocatorBlock, size: clonglong): bool {.importcpp: "#->realloc(#)".} ## \
## Changes the size of this block to the specified size.  Returns true if the
## change is accepted, false if there was not enough room.

proc getNextBlock*(this: SimpleAllocatorBlock): SimpleAllocatorBlock {.importcpp: "#->get_next_block()".} ## \
## Returns a pointer to the next allocated block in the chain, or NULL if
## there are no more allocated blocks.

proc output*(this: SimpleAllocatorBlock, `out`: ostream) {.importcpp: "#->output(#)".}

proc isValid*(this: VertexDataSaveFile): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the save file was successfully created and is ready for
## use, false if there was an error.

proc getTotalFileSize*(this: VertexDataSaveFile): clonglong {.importcpp: "#->get_total_file_size()".} ## \
## Returns the amount of space consumed by the save file, including unused
## portions.

proc getUsedFileSize*(this: VertexDataSaveFile): clonglong {.importcpp: "#->get_used_file_size()".} ## \
## Returns the amount of space within the save file that is currently in use.

converter upcastToSimpleAllocator*(this: VertexDataPage): SimpleAllocator {.importcpp: "#.upcast_to_SimpleAllocator()".}

converter upcastToSimpleLruPage*(this: VertexDataPage): SimpleLruPage {.importcpp: "#.upcast_to_SimpleLruPage()".}

proc requestResident*(this: VertexDataPage) {.importcpp: "#.request_resident()".} ## \
## Ensures that the page will become resident soon.  Future calls to
## get_page_data() will eventually return non-NULL.

proc alloc*(this: VertexDataPage, size: clonglong): VertexDataBlock {.importcpp: "#.alloc(#)".} ## \
## Allocates a new block.  Returns NULL if a block of the requested size
## cannot be allocated.
##
## To free the allocated block, call block->free(), or simply delete the block
## pointer.

proc getFirstBlock*(this: VertexDataPage): VertexDataBlock {.importcpp: "#.get_first_block()".} ## \
## Returns a pointer to the first allocated block, or NULL if there are no
## allocated blocks.

proc getBook*(this: VertexDataPage): VertexDataBook {.importcpp: "#.get_book()".} ## \
## Returns a pointer to the book that owns this page.

proc getPendingLru*(_: typedesc[VertexDataPage]): SimpleLru {.importcpp: "VertexDataPage::get_pending_lru()", header: "vertexDataPage.h".} ## \
## Returns a pointer to the global LRU object that manages the
## VertexDataPage's that are pending processing by the thread.

proc getSaveFile*(_: typedesc[VertexDataPage]): VertexDataSaveFile {.importcpp: "VertexDataPage::get_save_file()", header: "vertexDataPage.h".} ## \
## Returns the global VertexDataSaveFile that will be used to save vertex data
## buffers to disk when necessary.

proc saveToDisk*(this: VertexDataPage): bool {.importcpp: "#.save_to_disk()".} ## \
## Writes the page to disk, but does not evict it from memory or affect its
## LRU status.  If it gets evicted later without having been modified, it will
## not need to write itself to disk again.

proc getNumThreads*(_: typedesc[VertexDataPage]): int {.importcpp: "VertexDataPage::get_num_threads()", header: "vertexDataPage.h".} ## \
## Returns the number of threads that have been spawned to service vertex
## paging requests, or 0 if no threads have been spawned (which may mean
## either that all paging requests will be handled by the main thread, or
## simply that no paging requests have yet been issued).

proc getNumPendingReads*(_: typedesc[VertexDataPage]): int {.importcpp: "VertexDataPage::get_num_pending_reads()", header: "vertexDataPage.h".} ## \
## Returns the number of read requests that are waiting to be serviced by a
## thread.

proc getNumPendingWrites*(_: typedesc[VertexDataPage]): int {.importcpp: "VertexDataPage::get_num_pending_writes()", header: "vertexDataPage.h".} ## \
## Returns the number of write requests that are waiting to be serviced by a
## thread.

proc stopThreads*(_: typedesc[VertexDataPage]) {.importcpp: "VertexDataPage::stop_threads()", header: "vertexDataPage.h".} ## \
## Call this to stop the paging threads, if they were started.  This may block
## until all of the pending tasks have been completed.

proc flushThreads*(_: typedesc[VertexDataPage]) {.importcpp: "VertexDataPage::flush_threads()", header: "vertexDataPage.h".} ## \
## Waits for all of the pending thread tasks to finish before returning.

proc output*(this: VertexDataPage, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: VertexDataPage, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

converter getClassType*(_: typedesc[VertexDataPage]): TypeHandle {.importcpp: "VertexDataPage::get_class_type()", header: "vertexDataPage.h".}

proc initVertexDataBook*(block_size: clonglong): VertexDataBook {.importcpp: "VertexDataBook(#)".}

proc alloc*(this: VertexDataBook, size: clonglong): VertexDataBlock {.importcpp: "#.alloc(#)".} ## \
## Allocates and returns a new VertexDataBuffer of the requested size.

proc getNumPages*(this: VertexDataBook): clonglong {.importcpp: "#.get_num_pages()".} ## \
## Returns the number of pages created for the book.

proc countTotalPageSize*(this: VertexDataBook): clonglong {.importcpp: "#.count_total_page_size()".} ## \
## Returns the total size of all bytes owned by all pages owned by this book.

proc countAllocatedSize*(this: VertexDataBook): clonglong {.importcpp: "#.count_allocated_size()".} ## \
## Returns the total size of all bytes allocated within pages owned by this
## book.

proc saveToDisk*(this: VertexDataBook) {.importcpp: "#.save_to_disk()".} ## \
## Writes all pages to disk immediately, just in case they get evicted later.
## It makes sense to make this call just before taking down a loading screen,
## to minimize chugs from saving pages inadvertently later.

converter upcastToSimpleAllocatorBlock*(this: VertexDataBlock): SimpleAllocatorBlock {.importcpp: "((SimpleAllocatorBlock *)(VertexDataBlock *)(#))".}

converter upcastToReferenceCount*(this: VertexDataBlock): ReferenceCount {.importcpp: "(PT(ReferenceCount)(#))".}

proc getPage*(this: VertexDataBlock): VertexDataPage {.importcpp: "#->get_page()".} ## \
## Returns the page from which this buffer was allocated.

proc getNextBlock*(this: VertexDataBlock): VertexDataBlock {.importcpp: "#->get_next_block()".} ## \
## Returns a pointer to the next allocated block in the chain, or NULL if
## there are no more allocated blocks.

converter upcastToCopyOnWriteObject*(this: GeomVertexArrayData): CopyOnWriteObject {.importcpp: "(PT(CopyOnWriteObject)(#))".}

converter upcastToSimpleLruPage*(this: GeomVertexArrayData): SimpleLruPage {.importcpp: "((SimpleLruPage *)(GeomVertexArrayData *)(#))".}

converter upcastToGeomEnums*(this: GeomVertexArrayData): GeomEnums {.importcpp: "((GeomEnums *)(GeomVertexArrayData *)(#))".}

proc newGeomVertexArrayData*(copy: GeomVertexArrayData): GeomVertexArrayData {.importcpp: "new GeomVertexArrayData(#)".}

proc compareTo*(this: GeomVertexArrayData, other: GeomVertexArrayData): int {.importcpp: "#->compare_to(#)".} ## \
## Returns 0 if the two arrays are equivalent, even if they are not the same
## pointer.

proc getArrayFormat*(this: GeomVertexArrayData): GeomVertexArrayFormat {.importcpp: "deconstify(#->get_array_format())", header: deconstifyCode.} ## \
## Returns the format object that describes this array.

proc hasColumn*(this: GeomVertexArrayData, name: InternalName): bool {.importcpp: "#->has_column(#)".} ## \
## Returns true if the array has the named column, false otherwise.  This is
## really just a shortcut for asking the same thing from the format.

proc getNumRows*(this: GeomVertexArrayData): int {.importcpp: "#->get_num_rows()".} ## \
## Returns the number of rows stored in the array, based on the number of
## bytes and the stride.  This should be the same for all arrays within a
## given GeomVertexData object.

proc setNumRows*(this: GeomVertexArrayData, n: int): bool {.importcpp: "#->set_num_rows(#)".} ## \
## Sets the length of the array to n rows.
##
## Normally, you would not call this directly, since all of the arrays in a
## particular GeomVertexData must have the same number of rows; instead, call
## GeomVertexData::set_num_rows().
##
## The return value is true if the number of rows was changed, false if the
## object already contained n rows (or if there was some error).
##
## The new vertex data is initialized to 0, including the "color" column (but
## see GeomVertexData::set_num_rows()).
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc uncleanSetNumRows*(this: GeomVertexArrayData, n: int): bool {.importcpp: "#->unclean_set_num_rows(#)".} ## \
## This method behaves like set_num_rows(), except the new data is not
## initialized.  Furthermore, after this call, \*any\* of the data in the
## GeomVertexArrayData may be uninitialized, including the earlier rows.
##
## Normally, you would not call this directly, since all of the arrays in a
## particular GeomVertexData must have the same number of rows; instead, call
## GeomVertexData::unclean_set_num_rows().

proc reserveNumRows*(this: GeomVertexArrayData, n: int): bool {.importcpp: "#->reserve_num_rows(#)".} ## \
## This ensures that enough memory space for n rows is allocated, so that you
## may increase the number of rows to n without causing a new memory
## allocation.  This is a performance optimization only; it is especially
## useful when you know ahead of time that you will be adding n rows to the
## data.

proc clearRows*(this: GeomVertexArrayData) {.importcpp: "#->clear_rows()".} ## \
## Removes all of the rows in the array.  Functionally equivalent to
## set_num_rows(0).

proc getDataSizeBytes*(this: GeomVertexArrayData): clonglong {.importcpp: "#->get_data_size_bytes()".} ## \
## Returns the number of bytes stored in the array.

proc getModified*(this: GeomVertexArrayData): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the array vertex data is modified.

proc output*(this: GeomVertexArrayData, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: GeomVertexArrayData, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: GeomVertexArrayData, `out`: ostream) {.importcpp: "#->write(#)".}

proc requestResident*(this: GeomVertexArrayData, current_thread: Thread): bool {.importcpp: "#->request_resident(#)".} ## \
## Returns true if the vertex data is currently resident in memory.  If this
## returns true, the next call to get_handle()->get_read_pointer() will
## probably not block.  If this returns false, the vertex data will be brought
## back into memory shortly; try again later.

proc requestResident*(this: GeomVertexArrayData): bool {.importcpp: "#->request_resident()".} ## \
## Returns true if the vertex data is currently resident in memory.  If this
## returns true, the next call to get_handle()->get_read_pointer() will
## probably not block.  If this returns false, the vertex data will be brought
## back into memory shortly; try again later.

proc getHandle*(this: GeomVertexArrayData, current_thread: Thread): GeomVertexArrayDataHandle {.importcpp: "deconstify(#->get_handle(#))", header: deconstifyCode.} ## \
## Returns an object that can be used to read the actual data bytes stored in
## the array.  Calling this method locks the data, and will block any other
## threads attempting to read or write the data, until the returned object
## destructs.

proc getHandle*(this: GeomVertexArrayData): GeomVertexArrayDataHandle {.importcpp: "deconstify(#->get_handle())", header: deconstifyCode.} ## \
## Returns an object that can be used to read the actual data bytes stored in
## the array.  Calling this method locks the data, and will block any other
## threads attempting to read or write the data, until the returned object
## destructs.

proc modifyHandle*(this: GeomVertexArrayData, current_thread: Thread): GeomVertexArrayDataHandle {.importcpp: "#->modify_handle(#)".} ## \
## Returns an object that can be used to read or write the actual data bytes
## stored in the array.  Calling this method locks the data, and will block
## any other threads attempting to read or write the data, until the returned
## object destructs.

proc modifyHandle*(this: GeomVertexArrayData): GeomVertexArrayDataHandle {.importcpp: "#->modify_handle()".} ## \
## Returns an object that can be used to read or write the actual data bytes
## stored in the array.  Calling this method locks the data, and will block
## any other threads attempting to read or write the data, until the returned
## object destructs.

proc prepare*(this: GeomVertexArrayData, prepared_objects: PreparedGraphicsObjects) {.importcpp: "#->prepare(#)".} ## \
## Indicates that the data should be enqueued to be prepared in the indicated
## prepared_objects at the beginning of the next frame.  This will ensure the
## data is already loaded into the GSG if it is expected to be rendered soon.
##
## Use this function instead of prepare_now() to preload datas from a user
## interface standpoint.

proc isPrepared*(this: GeomVertexArrayData, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->is_prepared(#)".} ## \
## Returns true if the data has already been prepared or enqueued for
## preparation on the indicated GSG, false otherwise.

proc prepareNow*(this: GeomVertexArrayData, prepared_objects: PreparedGraphicsObjects, gsg: GraphicsStateGuardianBase): VertexBufferContext {.importcpp: "#->prepare_now(#, #)".} ## \
## Creates a context for the data on the particular GSG, if it does not
## already exist.  Returns the new (or old) VertexBufferContext.  This assumes
## that the GraphicsStateGuardian is the currently active rendering context
## and that it is ready to accept new datas.  If this is not necessarily the
## case, you should use prepare() instead.
##
## Normally, this is not called directly except by the GraphicsStateGuardian;
## a data does not need to be explicitly prepared by the user before it may be
## rendered.

proc release*(this: GeomVertexArrayData, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->release(#)".} ## \
## Frees the data context only on the indicated object, if it exists there.
## Returns true if it was released, false if it had not been prepared.

proc releaseAll*(this: GeomVertexArrayData): int {.importcpp: "#->release_all()".} ## \
## Frees the context allocated on all objects for which the data has been
## declared.  Returns the number of contexts which have been freed.

proc getIndependentLru*(_: typedesc[GeomVertexArrayData]): SimpleLru {.importcpp: "GeomVertexArrayData::get_independent_lru()", header: "geomVertexArrayData.h".} ## \
## Returns a pointer to the global LRU object that manages the
## GeomVertexArrayData's that have not (yet) been paged out.

proc getSmallLru*(_: typedesc[GeomVertexArrayData]): SimpleLru {.importcpp: "GeomVertexArrayData::get_small_lru()", header: "geomVertexArrayData.h".} ## \
## Returns a pointer to the global LRU object that manages the
## GeomVertexArrayData's that are deemed too small to be paged out.

proc lruEpoch*(_: typedesc[GeomVertexArrayData]) {.importcpp: "GeomVertexArrayData::lru_epoch()", header: "geomVertexArrayData.h".} ## \
## Marks that an epoch has passed in each LRU.  Asks the LRU's to consider
## whether they should perform evictions.

proc getBook*(_: typedesc[GeomVertexArrayData]): VertexDataBook {.importcpp: "GeomVertexArrayData::get_book()", header: "geomVertexArrayData.h".} ## \
## Returns the global VertexDataBook that will be used to allocate vertex data
## buffers.

converter getClassType*(_: typedesc[GeomVertexArrayData]): TypeHandle {.importcpp: "GeomVertexArrayData::get_class_type()", header: "geomVertexArrayData.h".}

converter upcastToReferenceCount*(this: GeomVertexArrayDataHandle): ReferenceCount {.importcpp: "(PT(ReferenceCount)(#))".}

converter upcastToGeomEnums*(this: GeomVertexArrayDataHandle): GeomEnums {.importcpp: "((GeomEnums *)(GeomVertexArrayDataHandle *)(#))".}

proc getObject*(this: GeomVertexArrayDataHandle): GeomVertexArrayData {.importcpp: "#->get_object()".}

proc getArrayFormat*(this: GeomVertexArrayDataHandle): GeomVertexArrayFormat {.importcpp: "deconstify(#->get_array_format())", header: deconstifyCode.}

proc getNumRows*(this: GeomVertexArrayDataHandle): int {.importcpp: "#->get_num_rows()".}

proc setNumRows*(this: GeomVertexArrayDataHandle, n: int): bool {.importcpp: "#->set_num_rows(#)".}

proc uncleanSetNumRows*(this: GeomVertexArrayDataHandle, n: int): bool {.importcpp: "#->unclean_set_num_rows(#)".}

proc reserveNumRows*(this: GeomVertexArrayDataHandle, n: int): bool {.importcpp: "#->reserve_num_rows(#)".}

proc clearRows*(this: GeomVertexArrayDataHandle) {.importcpp: "#->clear_rows()".}

proc getDataSizeBytes*(this: GeomVertexArrayDataHandle): clonglong {.importcpp: "#->get_data_size_bytes()".}

proc getModified*(this: GeomVertexArrayDataHandle): UpdateSeq {.importcpp: "#->get_modified()".}

proc requestResident*(this: GeomVertexArrayDataHandle): bool {.importcpp: "#->request_resident()".} ## \
## Returns true if the vertex data is currently resident in memory.  If this
## returns true, the next call to get_handle()->get_read_pointer() will
## probably not block.  If this returns false, the vertex data will be brought
## back into memory shortly; try again later.

proc prepareNow*(this: GeomVertexArrayDataHandle, prepared_objects: PreparedGraphicsObjects, gsg: GraphicsStateGuardianBase): VertexBufferContext {.importcpp: "#->prepare_now(#, #)".} ## \
## Creates a context for the data on the particular GSG, if it does not
## already exist.  Returns the new (or old) VertexBufferContext.  This assumes
## that the GraphicsStateGuardian is the currently active rendering context
## and that it is ready to accept new datas.  If this is not necessarily the
## case, you should use prepare() instead.
##
## Normally, this is not called directly except by the GraphicsStateGuardian;
## a data does not need to be explicitly prepared by the user before it may be
## rendered.

proc copyDataFrom*(this: GeomVertexArrayDataHandle, other: GeomVertexArrayDataHandle) {.importcpp: "#->copy_data_from(#)".} ## \
## Copies the entire data array from the other object.

proc copySubdataFrom*(this: GeomVertexArrayDataHandle, to_start: clonglong, to_size: clonglong, other: GeomVertexArrayDataHandle, from_start: clonglong, from_size: clonglong) {.importcpp: "#->copy_subdata_from(#, #, #, #, #)".} ## \
## Copies a portion of the data array from the other object into a portion of
## the data array of this object.  If to_size != from_size, the size of this
## data array is adjusted accordingly.

proc markUsed*(this: GeomVertexArrayDataHandle) {.importcpp: "#->mark_used()".} ## \
## Marks the array data recently-used.

converter getClassType*(_: typedesc[GeomVertexArrayDataHandle]): TypeHandle {.importcpp: "GeomVertexArrayDataHandle::get_class_type()", header: "geomVertexArrayData.h".}

proc setMaxSize*(this: GeomCacheManager, max_size: int) {.importcpp: "#.set_max_size(#)".} ## \
## Specifies the maximum number of entries in the cache for storing pre-
## processed data for rendering vertices.  This limit is flexible, and may be
## temporarily exceeded if many different Geoms are pre-processed during the
## space of a single frame.
##
## This is not a limit on the actual vertex data, which is what it is; it is
## also not a limit on the amount of memory used by the video driver or the
## system graphics interface, which Panda has no control over.

proc getMaxSize*(this: GeomCacheManager): int {.importcpp: "#.get_max_size()".} ## \
## Returns the maximum number of entries in the cache for storing pre-
## processed data for rendering vertices.  See set_max_size().

proc getTotalSize*(this: GeomCacheManager): int {.importcpp: "#.get_total_size()".} ## \
## Returns the number of entries currently in the cache.

proc flush*(this: GeomCacheManager) {.importcpp: "#.flush()".} ## \
## Immediately empties all elements in the cache.

proc getGlobalPtr*(_: typedesc[GeomCacheManager]): GeomCacheManager {.importcpp: "GeomCacheManager::get_global_ptr()", header: "geomCacheManager.h".} ## \
## Returns the global cache manager pointer.

proc getMatrix*(this: VertexTransform, matrix: LMatrix4) {.importcpp: "#->get_matrix(#)".}

proc multMatrix*(this: VertexTransform, result: LMatrix4, previous: LMatrix4) {.importcpp: "#->mult_matrix(#, #)".} ## \
## Premultiplies this transform's matrix with the indicated previous matrix,
## so that the result is the net composition of the given transform with this
## transform.  The result is stored in the parameter "result", which should
## not be the same matrix as previous.

proc accumulateMatrix*(this: VertexTransform, accum: LMatrix4, weight: float32) {.importcpp: "#->accumulate_matrix(#, #)".} ## \
## Adds the value of this transform's matrix, modified by the indicated
## weight, into the indicated accumulation matrix.  This is used to compute
## the result of several blended transforms.

proc getModified*(this: VertexTransform, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number that's guaranteed to change at least every time
## the value reported by get_matrix() changes.

proc getModified*(this: VertexTransform): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number that's guaranteed to change at least every time
## the value reported by get_matrix() changes.

proc output*(this: VertexTransform, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: VertexTransform, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc getNextModified*(_: typedesc[VertexTransform], current_thread: Thread): UpdateSeq {.importcpp: "#VertexTransform::get_next_modified(#)", header: "vertexTransform.h".} ## \
## Returns a monotonically increasing sequence.  Each time this is called, a
## new sequence number is returned, higher than the previous value.
##
## This is used to ensure that all VertexTransform::get_modified() calls
## return an increasing number in the same space, so that
## TransformBlend::get_modified() is easy to determine.  It is similar to
## Geom::get_modified(), but it is in a different space.

proc getGlobalModified*(_: typedesc[VertexTransform], current_thread: Thread): UpdateSeq {.importcpp: "#VertexTransform::get_global_modified(#)", header: "vertexTransform.h".} ## \
## Returns the currently highest VertexTransform::get_modified() value in the
## world.  This can be used as a quick way to determine if any
## VertexTransforms have changed value recently.

converter getClassType*(_: typedesc[VertexTransform]): TypeHandle {.importcpp: "VertexTransform::get_class_type()", header: "vertexTransform.h".}

proc newTransformTable*(): TransformTable {.importcpp: "new TransformTable()".}

proc newTransformTable*(copy: TransformTable): TransformTable {.importcpp: "new TransformTable(#)".}

proc isRegistered*(this: TransformTable): bool {.importcpp: "#->is_registered()".} ## \
## Returns true if this table has been registered.  Once it has been
## registered, the set of transforms in a TransformTable may not be further
## modified; but it must be registered before it can be assigned to a Geom.

proc registerTable*(_: typedesc[TransformTable], table: TransformTable): TransformTable {.importcpp: "deconstify(#TransformTable::register_table(#))", header: "transformTable.h".} ## \
## Registers a TransformTable for use.  This is similar to
## GeomVertexFormat::register_format().  Once registered, a TransformTable may
## no longer be modified (although the individual VertexTransform objects may
## modify their reported transforms).
##
## This must be called before a table may be used in a Geom.  After this call,
## you should discard the original pointer you passed in (which may or may not
## now be invalid) and let its reference count decrement normally; you should
## use only the returned value from this point on.

proc getNumTransforms*(this: TransformTable): clonglong {.importcpp: "#->get_num_transforms()".} ## \
## Returns the number of transforms in the table.

proc getTransform*(this: TransformTable, n: clonglong): VertexTransform {.importcpp: "deconstify(#->get_transform(#))", header: deconstifyCode.} ## \
## Returns the nth transform in the table.

proc getModified*(this: TransformTable, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number that's guaranteed to change at least when any
## VertexTransforms in the table change.  (However, this is only true for a
## registered table.  An unregistered table may or may not reflect an update
## here when a VertexTransform changes.)

proc getModified*(this: TransformTable): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number that's guaranteed to change at least when any
## VertexTransforms in the table change.  (However, this is only true for a
## registered table.  An unregistered table may or may not reflect an update
## here when a VertexTransform changes.)

proc setTransform*(this: TransformTable, n: clonglong, transform: VertexTransform) {.importcpp: "#->set_transform(#, #)".} ## \
## Replaces the nth transform.  Only valid for unregistered tables.

proc insertTransform*(this: TransformTable, n: clonglong, transform: VertexTransform) {.importcpp: "#->insert_transform(#, #)".} ## \
## Inserts a new transform to the table at the given index position.  If the
## index is beyond the end of the table, appends it to the end.  Only valid
## for unregistered tables.
##
## This does not automatically uniquify the pointer; if the transform is
## already present in the table, it will be added twice.

proc removeTransform*(this: TransformTable, n: clonglong) {.importcpp: "#->remove_transform(#)".} ## \
## Removes the nth transform.  Only valid for unregistered tables.

proc addTransform*(this: TransformTable, transform: VertexTransform): clonglong {.importcpp: "#->add_transform(#)".} ## \
## Adds a new transform to the table and returns the index number of the new
## transform.  Only valid for unregistered tables.
##
## This does not automatically uniquify the pointer; if the transform is
## already present in the table, it will be added twice.

proc write*(this: TransformTable, `out`: ostream) {.importcpp: "#->write(#)".}

converter getClassType*(_: typedesc[TransformTable]): TypeHandle {.importcpp: "TransformTable::get_class_type()", header: "transformTable.h".}

proc initTransformBlend*(): TransformBlend {.importcpp: "TransformBlend()".}

proc initTransformBlend*(copy: TransformBlend): TransformBlend {.importcpp: "TransformBlend(#)".}

proc initTransformBlend*(transform0: VertexTransform, weight0: float32): TransformBlend {.importcpp: "TransformBlend(#, #)".}

proc initTransformBlend*(transform0: VertexTransform, weight0: float32, transform1: VertexTransform, weight1: float32): TransformBlend {.importcpp: "TransformBlend(#, #, #, #)".}

proc initTransformBlend*(transform0: VertexTransform, weight0: float32, transform1: VertexTransform, weight1: float32, transform2: VertexTransform, weight2: float32): TransformBlend {.importcpp: "TransformBlend(#, #, #, #, #, #)".}

proc initTransformBlend*(transform0: VertexTransform, weight0: float32, transform1: VertexTransform, weight1: float32, transform2: VertexTransform, weight2: float32, transform3: VertexTransform, weight3: float32): TransformBlend {.importcpp: "TransformBlend(#, #, #, #, #, #, #, #)".}

proc compareTo*(this: TransformBlend, other: TransformBlend): int {.importcpp: "#.compare_to(#)".} ## \
## Defines an arbitrary ordering for TransformBlend objects.

proc `<`*(this: TransformBlend, other: TransformBlend): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: TransformBlend, other: TransformBlend): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: TransformBlend, other: TransformBlend): bool {.importcpp: "#.operator !=(#)".}

proc addTransform*(this: TransformBlend, transform: VertexTransform, weight: float32) {.importcpp: "#.add_transform(#, #)".} ## \
## Adds a new transform to the blend.  If the transform already existed,
## increases its weight factor.

proc removeTransform*(this: TransformBlend, transform: VertexTransform) {.importcpp: "#.remove_transform(#)".} ## \
## Removes the indicated transform from the blend.

proc removeTransform*(this: TransformBlend, n: clonglong) {.importcpp: "#.remove_transform(#)".} ## \
## Removes the nth transform stored in the blend object.

proc limitTransforms*(this: TransformBlend, max_transforms: int) {.importcpp: "#.limit_transforms(#)".} ## \
## If the total number of transforms in the blend exceeds max_transforms,
## removes the n least-important transforms as needed to reduce the number of
## transforms to max_transforms.

proc normalizeWeights*(this: TransformBlend) {.importcpp: "#.normalize_weights()".} ## \
## Rescales all of the weights on the various transforms so that they sum to
## 1.0.  It is generally a good idea to call this after adding or removing
## transforms from the blend.

proc hasTransform*(this: TransformBlend, transform: VertexTransform): bool {.importcpp: "#.has_transform(#)".} ## \
## Returns true if the blend has the indicated transform, false otherwise.

proc getWeight*(this: TransformBlend, transform: VertexTransform): float32 {.importcpp: "#.get_weight(#)".} ## \
## Returns the weight associated with the indicated transform, or 0 if there
## is no entry for the transform.

proc getWeight*(this: TransformBlend, n: clonglong): float32 {.importcpp: "#.get_weight(#)".} ## \
## Returns the weight associated with the nth transform stored in the blend
## object.

proc getNumTransforms*(this: TransformBlend): clonglong {.importcpp: "#.get_num_transforms()".} ## \
## Returns the number of transforms stored in the blend object.

proc getTransform*(this: TransformBlend, n: clonglong): VertexTransform {.importcpp: "#.get_transform(#)".} ## \
## Returns the nth transform stored in the blend object.

proc setTransform*(this: TransformBlend, n: clonglong, transform: VertexTransform) {.importcpp: "#.set_transform(#, #)".} ## \
## Replaces the nth transform stored in the blend object.

proc setWeight*(this: TransformBlend, n: clonglong, weight: float32) {.importcpp: "#.set_weight(#, #)".} ## \
## Replaces the weight associated with the nth transform stored in the blend
## object.

proc updateBlend*(this: TransformBlend, current_thread: Thread) {.importcpp: "#.update_blend(#)".} ## \
## Recomputes the internal representation of the blend value, if necessary.
## You should call this before calling get_blend() or transform_point().

proc getBlend*(this: TransformBlend, result: LMatrix4, current_thread: Thread) {.importcpp: "#.get_blend(#, #)".} ## \
## Returns the current value of the blend, based on the current value of all
## of the nested transform objects and their associated weights.
##
## You should call update_blend() to ensure that the cache is up-to-date
## before calling this.

proc transformPoint*(this: TransformBlend, point: LPoint3d, current_thread: Thread) {.importcpp: "#.transform_point(#, #)".} ## \
## Transforms the indicated point by the blend matrix.
##
## You should call update_blend() to ensure that the cache is up-to-date
## before calling this.

proc transformPoint*(this: TransformBlend, point: LPoint3f, current_thread: Thread) {.importcpp: "#.transform_point(#, #)".}

proc transformPoint*(this: TransformBlend, point: LPoint4d, current_thread: Thread) {.importcpp: "#.transform_point(#, #)".} ## \
## Transforms the indicated point by the blend matrix.
##
## You should call update_blend() to ensure that the cache is up-to-date
## before calling this.

proc transformPoint*(this: TransformBlend, point: LPoint4f, current_thread: Thread) {.importcpp: "#.transform_point(#, #)".}

proc transformVector*(this: TransformBlend, point: LVector3d, current_thread: Thread) {.importcpp: "#.transform_vector(#, #)".} ## \
## Transforms the indicated vector by the blend matrix.
##
## You should call update_blend() to ensure that the cache is up-to-date
## before calling this.

proc transformVector*(this: TransformBlend, point: LVector3f, current_thread: Thread) {.importcpp: "#.transform_vector(#, #)".}

proc getModified*(this: TransformBlend, current_thread: Thread): UpdateSeq {.importcpp: "#.get_modified(#)".} ## \
## Returns a counter which is guaranteed to increment at least as often as the
## result of get_blend() changes.

proc getModified*(this: TransformBlend): UpdateSeq {.importcpp: "#.get_modified()".} ## \
## Returns a counter which is guaranteed to increment at least as often as the
## result of get_blend() changes.

proc output*(this: TransformBlend, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: TransformBlend, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

converter getClassType*(_: typedesc[TransformBlend]): TypeHandle {.importcpp: "TransformBlend::get_class_type()", header: "transformBlend.h".}

proc newTransformBlendTable*(): TransformBlendTable {.importcpp: "new TransformBlendTable()".}

proc newTransformBlendTable*(copy: TransformBlendTable): TransformBlendTable {.importcpp: "new TransformBlendTable(#)".}

proc getNumBlends*(this: TransformBlendTable): clonglong {.importcpp: "#->get_num_blends()".} ## \
## Returns the total number of different blend combinations in the table.

proc getBlend*(this: TransformBlendTable, n: clonglong): TransformBlend {.importcpp: "#->get_blend(#)".} ## \
## Returns the nth blend in the table.

proc getModified*(this: TransformBlendTable, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a counter which is guaranteed to increment at least when any
## TransformBlends within the table have changed.

proc getModified*(this: TransformBlendTable): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a counter which is guaranteed to increment at least when any
## TransformBlends within the table have changed.

proc setBlend*(this: TransformBlendTable, n: clonglong, blend: TransformBlend) {.importcpp: "#->set_blend(#, #)".} ## \
## Replaces the blend at the nth position with the indicated value.

proc removeBlend*(this: TransformBlendTable, n: clonglong) {.importcpp: "#->remove_blend(#)".} ## \
## Removes the blend at the nth position.

proc addBlend*(this: TransformBlendTable, blend: TransformBlend): clonglong {.importcpp: "#->add_blend(#)".} ## \
## Adds a new blend to the table, and returns its index number.  If there is
## already an identical blend in the table, simply returns that number
## instead.

proc getNumTransforms*(this: TransformBlendTable): int {.importcpp: "#->get_num_transforms()".} ## \
## Returns the number of unique VertexTransform objects represented in the
## table.  This will correspond to the size of the TransformTable object that
## would represent the same table.  This is also the same limit reflected by
## GraphicsStateGuardian::get_max_vertex_transform_indices().

proc getMaxSimultaneousTransforms*(this: TransformBlendTable): int {.importcpp: "#->get_max_simultaneous_transforms()".} ## \
## Returns the maximum number of unique VertexTransform objects that are
## applied to any one vertex simultaneously.  This is the same limit reflected
## by GraphicsStateGuardian::get_max_vertex_transforms().

proc setRows*(this: TransformBlendTable, rows: SparseArray) {.importcpp: "#->set_rows(#)".} ## \
## Specifies the subset of rows (vertices) in the associated GeomVertexData
## that this TransformBlendTable actually affects.

proc getRows*(this: TransformBlendTable): SparseArray {.importcpp: "#->get_rows()".} ## \
## Returns the subset of rows (vertices) in the associated GeomVertexData that
## this TransformBlendTable actually affects.

proc modifyRows*(this: TransformBlendTable): SparseArray {.importcpp: "#->modify_rows()".} ## \
## Returns a modifiable reference to the SparseArray that specifies the subset
## of rows (vertices) in the associated GeomVertexData that this
## TransformBlendTable actually affects.

proc write*(this: TransformBlendTable, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

converter getClassType*(_: typedesc[TransformBlendTable]): TypeHandle {.importcpp: "TransformBlendTable::get_class_type()", header: "transformBlendTable.h".}

proc getName*(this: VertexSlider): InternalName {.importcpp: "deconstify(#->get_name())", header: deconstifyCode.} ## \
## Returns the name of this particular slider.  Every unique blend shape
## within a particular Geom must be identified with a different name, which is
## shared by the slider that controls it.

proc getSlider*(this: VertexSlider): float32 {.importcpp: "#->get_slider()".}

proc getModified*(this: VertexSlider, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number that's guaranteed to change at least every time
## the value reported by get_slider() changes.

proc getModified*(this: VertexSlider): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number that's guaranteed to change at least every time
## the value reported by get_slider() changes.

proc output*(this: VertexSlider, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: VertexSlider, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

converter getClassType*(_: typedesc[VertexSlider]): TypeHandle {.importcpp: "VertexSlider::get_class_type()", header: "vertexSlider.h".}

proc newSliderTable*(): SliderTable {.importcpp: "new SliderTable()".}

proc newSliderTable*(copy: SliderTable): SliderTable {.importcpp: "new SliderTable(#)".}

proc isRegistered*(this: SliderTable): bool {.importcpp: "#->is_registered()".} ## \
## Returns true if this table has been registered.  Once it has been
## registered, the set of sliders in a SliderTable may not be further
## modified; but it must be registered before it can be assigned to a Geom.

proc registerTable*(_: typedesc[SliderTable], table: SliderTable): SliderTable {.importcpp: "deconstify(#SliderTable::register_table(#))", header: "sliderTable.h".} ## \
## Registers a SliderTable for use.  This is similar to
## GeomVertexFormat::register_format().  Once registered, a SliderTable may no
## longer be modified (although the individual VertexSlider objects may modify
## their reported sliders).
##
## This must be called before a table may be used in a Geom.  After this call,
## you should discard the original pointer you passed in (which may or may not
## now be invalid) and let its reference count decrement normally; you should
## use only the returned value from this point on.

proc getNumSliders*(this: SliderTable): clonglong {.importcpp: "#->get_num_sliders()".} ## \
## Returns the number of sliders in the table.

proc getSlider*(this: SliderTable, n: clonglong): VertexSlider {.importcpp: "deconstify(#->get_slider(#))", header: deconstifyCode.} ## \
## Returns the nth slider in the table.

proc getSliderRows*(this: SliderTable, n: clonglong): SparseArray {.importcpp: "#->get_slider_rows(#)".} ## \
## Returns the set of rows (vertices) governed by the nth slider in the table.

proc findSliders*(this: SliderTable, name: InternalName): SparseArray {.importcpp: "#->find_sliders(#)".} ## \
## Returns a list of slider indices that represent the list of sliders with
## the indicated name, or an empty SparseArray if no slider in the table has
## that name.

proc hasSlider*(this: SliderTable, name: InternalName): bool {.importcpp: "#->has_slider(#)".} ## \
## Returns true if the table has at least one slider by the indicated name,
## false otherwise.

proc isEmpty*(this: SliderTable): bool {.importcpp: "#->is_empty()".} ## \
## Returns true if the table has no sliders, false if it has at least one.

proc getModified*(this: SliderTable, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number that's guaranteed to change at least when any
## VertexSliders in the table change.  (However, this is only true for a
## registered table.  An unregistered table may or may not reflect an update
## here when a VertexSlider changes.)

proc getModified*(this: SliderTable): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number that's guaranteed to change at least when any
## VertexSliders in the table change.  (However, this is only true for a
## registered table.  An unregistered table may or may not reflect an update
## here when a VertexSlider changes.)

proc setSlider*(this: SliderTable, n: clonglong, slider: VertexSlider) {.importcpp: "#->set_slider(#, #)".} ## \
## Replaces the nth slider.  Only valid for unregistered tables.

proc setSliderRows*(this: SliderTable, n: clonglong, rows: SparseArray) {.importcpp: "#->set_slider_rows(#, #)".} ## \
## Replaces the rows affected by the nth slider.  Only valid for unregistered
## tables.

proc removeSlider*(this: SliderTable, n: clonglong) {.importcpp: "#->remove_slider(#)".} ## \
## Removes the nth slider.  Only valid for unregistered tables.

proc addSlider*(this: SliderTable, slider: VertexSlider, rows: SparseArray): clonglong {.importcpp: "#->add_slider(#, #)".} ## \
## Adds a new slider to the table, and returns the index number of the new
## slider.  Only valid for unregistered tables.

proc write*(this: SliderTable, `out`: ostream) {.importcpp: "#->write(#)".}

converter getClassType*(_: typedesc[SliderTable]): TypeHandle {.importcpp: "SliderTable::get_class_type()", header: "sliderTable.h".}

converter upcastToCopyOnWriteObject*(this: GeomVertexData): CopyOnWriteObject {.importcpp: "(PT(CopyOnWriteObject)(#))".}

converter upcastToGeomEnums*(this: GeomVertexData): GeomEnums {.importcpp: "((GeomEnums *)(GeomVertexData *)(#))".}

proc newGeomVertexData*(copy: GeomVertexData): GeomVertexData {.importcpp: "new GeomVertexData(#)".}

proc newGeomVertexData*(copy: GeomVertexData, format: GeomVertexFormat): GeomVertexData {.importcpp: "new GeomVertexData(#, #)".} ## \
## This constructor copies all of the basic properties of the source
## VertexData, like usage_hint and animation tables, but does not copy the
## actual data, and it allows you to specify a different format.

proc compareTo*(this: GeomVertexData, other: GeomVertexData): int {.importcpp: "#->compare_to(#)".} ## \
## Returns 0 if the two objects are equivalent, even if they are not the same
## pointer.

proc getName*(this: GeomVertexData): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Returns the name passed to the constructor, if any.  This name is reported
## on the PStats graph for vertex computations.

proc setName*(this: GeomVertexData, name: string) {.importcpp: "#->set_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name of the vertex data.  This name is reported on the PStats
## graph for vertex computations.

proc getFormat*(this: GeomVertexData): GeomVertexFormat {.importcpp: "deconstify(#->get_format())", header: deconstifyCode.} ## \
## Returns a pointer to the GeomVertexFormat structure that defines this data.

proc setFormat*(this: GeomVertexData, format: GeomVertexFormat) {.importcpp: "#->set_format(#)".} ## \
## Changes the format of the vertex data.  If the data is not empty, this will
## implicitly change every row to match the new format.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc uncleanSetFormat*(this: GeomVertexData, format: GeomVertexFormat) {.importcpp: "#->unclean_set_format(#)".} ## \
## Changes the format of the vertex data, without reformatting the data to
## match.  The data is exactly the same after this operation, but will be
## reinterpreted according to the new format.  This assumes that the new
## format is fundamentally compatible with the old format; in particular, it
## must have the same number of arrays with the same stride in each one.  No
## checking is performed that the data remains sensible.

proc hasColumn*(this: GeomVertexData, name: InternalName): bool {.importcpp: "#->has_column(#)".} ## \
## Returns true if the data has the named column, false otherwise.  This is
## really just a shortcut for asking the same thing from the format.

proc getNumRows*(this: GeomVertexData): int {.importcpp: "#->get_num_rows()".} ## \
## Returns the number of rows stored within all the arrays.  All arrays store
## data for the same n rows.

proc setNumRows*(this: GeomVertexData, n: int): bool {.importcpp: "#->set_num_rows(#)".} ## \
## Sets the length of the array to n rows in all of the various arrays
## (presumably by adding rows).
##
## The new vertex data is initialized to 0, except for the "color" column,
## which is initialized to (1, 1, 1, 1).
##
## The return value is true if the number of rows was changed, false if the
## object already contained n rows (or if there was some error).
##
## This can be used when you know exactly how many rows you will be needing.
## It is faster than reserve_num_rows().  Also see unclean_set_num_rows() if
## you are planning to fill in all the data yourself.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc uncleanSetNumRows*(this: GeomVertexData, n: int): bool {.importcpp: "#->unclean_set_num_rows(#)".} ## \
## This method behaves like set_num_rows(), except the new data is not
## initialized.  Furthermore, after this call, \*any\* of the data in the
## GeomVertexData may be uninitialized, including the earlier rows.
##
## This is intended for applications that are about to completely fill the
## GeomVertexData with new data anyway; it provides a tiny performance boost
## over set_num_rows().
##
## This can be used when you know exactly how many rows you will be needing.
## It is faster than reserve_num_rows().

proc reserveNumRows*(this: GeomVertexData, n: int): bool {.importcpp: "#->reserve_num_rows(#)".} ## \
## This ensures that enough memory space for n rows is allocated, so that you
## may increase the number of rows to n without causing a new memory
## allocation.  This is a performance optimization only; it is especially
## useful when you know ahead of time that you will be adding n rows to the
## data.
##
## If you know exactly how many rows you will be needing, it is significantly
## faster to use set_num_rows() or unclean_set_num_rows() instead.

proc clearRows*(this: GeomVertexData) {.importcpp: "#->clear_rows()".} ## \
## Removes all of the rows from the arrays; functionally equivalent to
## set_num_rows(0) (but faster).
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc getNumArrays*(this: GeomVertexData): clonglong {.importcpp: "#->get_num_arrays()".} ## \
## Returns the number of individual arrays stored within the data.  This must
## match get_format()->get_num_arrays().

proc getArray*(this: GeomVertexData, i: clonglong): GeomVertexArrayData {.importcpp: "deconstify(#->get_array(#))", header: deconstifyCode.} ## \
## Returns a const pointer to the vertex data for the indicated array, for
## application code to directly examine (but not modify) the underlying vertex
## data.

proc getArrayHandle*(this: GeomVertexData, i: clonglong): GeomVertexArrayDataHandle {.importcpp: "deconstify(#->get_array_handle(#))", header: deconstifyCode.} ## \
## Equivalent to get_array(i).get_handle().

proc modifyArray*(this: GeomVertexData, i: clonglong): GeomVertexArrayData {.importcpp: "#->modify_array(#)".} ## \
## Returns a modifiable pointer to the indicated vertex array, so that
## application code may directly manipulate the data.  You should avoid
## changing the length of this array, since all of the arrays should be kept
## in sync--use set_num_rows() instead.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc modifyArrayHandle*(this: GeomVertexData, i: clonglong): GeomVertexArrayDataHandle {.importcpp: "#->modify_array_handle(#)".} ## \
## Equivalent to modify_array(i).modify_handle().

proc setArray*(this: GeomVertexData, i: clonglong, array: GeomVertexArrayData) {.importcpp: "#->set_array(#, #)".} ## \
## Replaces the indicated vertex data array with a completely new array.  You
## should be careful that the new array has the same length and format as the
## old one, unless you know what you are doing.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc getTransformTable*(this: GeomVertexData): TransformTable {.importcpp: "deconstify(#->get_transform_table())", header: deconstifyCode.} ## \
## Returns a const pointer to the TransformTable assigned to this data.
## Vertices within the table will index into this table to indicate their
## dynamic skinning information; this table is used when the vertex animation
## is to be performed by the graphics hardware (but also see
## get_transform_blend_table()).
##
## This will return NULL if the vertex data does not have a TransformTable
## assigned (which implies the vertices will not be animated by the graphics
## hardware).

proc setTransformTable*(this: GeomVertexData, table: TransformTable) {.importcpp: "#->set_transform_table(#)".} ## \
## Replaces the TransformTable on this vertex data with the indicated table.
## The length of this table should be consistent with the maximum table index
## assigned to the vertices under the "transform_index" name.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc clearTransformTable*(this: GeomVertexData) {.importcpp: "#->clear_transform_table()".} ## \
## Sets the TransformTable pointer to NULL, removing the table from the vertex
## data.  This disables hardware-driven vertex animation.

proc getTransformBlendTable*(this: GeomVertexData): TransformBlendTable {.importcpp: "deconstify(#->get_transform_blend_table())", header: deconstifyCode.} ## \
## Returns a const pointer to the TransformBlendTable assigned to this data.
## Vertices within the table will index into this table to indicate their
## dynamic skinning information; this table is used when the vertex animation
## is to be performed by the CPU (but also see get_transform_table()).
##
## This will return NULL if the vertex data does not have a
## TransformBlendTable assigned (which implies the vertices will not be
## animated by the CPU).

proc modifyTransformBlendTable*(this: GeomVertexData): TransformBlendTable {.importcpp: "#->modify_transform_blend_table()".} ## \
## Returns a modifiable pointer to the current TransformBlendTable on this
## vertex data, if any, or NULL if there is not a TransformBlendTable.  See
## get_transform_blend_table().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc setTransformBlendTable*(this: GeomVertexData, table: TransformBlendTable) {.importcpp: "#->set_transform_blend_table(#)".} ## \
## Replaces the TransformBlendTable on this vertex data with the indicated
## table.  The length of this table should be consistent with the maximum
## table index assigned to the vertices under the "transform_blend" name.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc clearTransformBlendTable*(this: GeomVertexData) {.importcpp: "#->clear_transform_blend_table()".} ## \
## Sets the TransformBlendTable pointer to NULL, removing the table from the
## vertex data.  This disables CPU-driven vertex animation.

proc getSliderTable*(this: GeomVertexData): SliderTable {.importcpp: "deconstify(#->get_slider_table())", header: deconstifyCode.} ## \
## Returns a const pointer to the SliderTable assigned to this data.  Vertices
## within the vertex data will look up their morph offsets, if any, within
## this table.
##
## This will return NULL if the vertex data does not have a SliderTable
## assigned.

proc setSliderTable*(this: GeomVertexData, table: SliderTable) {.importcpp: "#->set_slider_table(#)".} ## \
## Replaces the SliderTable on this vertex data with the indicated table.
## There should be an entry in this table for each kind of morph offset
## defined in the vertex data.
##
## The SliderTable object must have been registered prior to setting it on the
## GeomVertexData.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc clearSliderTable*(this: GeomVertexData) {.importcpp: "#->clear_slider_table()".} ## \
## Sets the SliderTable pointer to NULL, removing the table from the vertex
## data.  This disables morph (blend shape) animation.

proc getNumBytes*(this: GeomVertexData): int {.importcpp: "#->get_num_bytes()".} ## \
## Returns the total number of bytes consumed by the different arrays of the
## vertex data.

proc getModified*(this: GeomVertexData, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the vertex data is modified.

proc getModified*(this: GeomVertexData): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the vertex data is modified.

proc requestResident*(this: GeomVertexData): bool {.importcpp: "#->request_resident()".} ## \
## Returns true if the vertex data is currently resident in memory.  If this
## returns false, the vertex data will be brought back into memory shortly;
## try again later.

proc copyFrom*(this: GeomVertexData, source: GeomVertexData, keep_data_objects: bool, current_thread: Thread) {.importcpp: "#->copy_from(#, #, #)".} ## \
## Copies all the data from the other array into the corresponding data types
## in this array, by matching data types name-by-name.
##
## keep_data_objects specifies what to do when one or more of the arrays can
## be copied without the need to apply any conversion operation.  If it is
## true, the original GeomVertexArrayData objects in this object are retained,
## and their data arrays are copied byte-by-byte from the source; if it is
## false, then the GeomVertexArrayData objects are copied pointerwise from the
## source.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc copyFrom*(this: GeomVertexData, source: GeomVertexData, keep_data_objects: bool) {.importcpp: "#->copy_from(#, #)".} ## \
## Copies all the data from the other array into the corresponding data types
## in this array, by matching data types name-by-name.
##
## keep_data_objects specifies what to do when one or more of the arrays can
## be copied without the need to apply any conversion operation.  If it is
## true, the original GeomVertexArrayData objects in this object are retained,
## and their data arrays are copied byte-by-byte from the source; if it is
## false, then the GeomVertexArrayData objects are copied pointerwise from the
## source.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc copyRowFrom*(this: GeomVertexData, dest_row: int, source: GeomVertexData, source_row: int, current_thread: Thread) {.importcpp: "#->copy_row_from(#, #, #, #)".} ## \
## Copies a single row of the data from the other array into the indicated row
## of this array.  In this case, the source format must exactly match the
## destination format.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc convertTo*(this: GeomVertexData, new_format: GeomVertexFormat): GeomVertexData {.importcpp: "deconstify(#->convert_to(#))", header: deconstifyCode.} ## \
## Returns a new GeomVertexData that represents the same contents as this one,
## with all data types matched up name-by-name to the indicated new format.

proc scaleColor*(this: GeomVertexData, color_scale: LVecBase4): GeomVertexData {.importcpp: "deconstify(#->scale_color(#))", header: deconstifyCode.} ## \
## Returns a new GeomVertexData object with the color table modified in-place
## to apply the indicated scale.
##
## If the vertex data does not include a color column, a new one will not be
## added.

proc setColor*(this: GeomVertexData, color: LColor): GeomVertexData {.importcpp: "deconstify(#->set_color(#))", header: deconstifyCode.} ## \
## Returns a new GeomVertexData object with the color data modified in-place
## with the new value.
##
## If the vertex data does not include a color column, a new one will not be
## added.

proc reverseNormals*(this: GeomVertexData): GeomVertexData {.importcpp: "deconstify(#->reverse_normals())", header: deconstifyCode.} ## \
## Returns a new GeomVertexData object with the normal data modified in-place,
## so that each lighting normal is now facing in the opposite direction.
##
## If the vertex data does not include a normal column, this returns the
## original GeomVertexData object, unchanged.

proc animateVertices*(this: GeomVertexData, force: bool, current_thread: Thread): GeomVertexData {.importcpp: "deconstify(#->animate_vertices(#, #))", header: deconstifyCode.} ## \
## Returns a GeomVertexData that represents the results of computing the
## vertex animation on the CPU for this GeomVertexData.
##
## If there is no CPU-defined vertex animation on this object, this just
## returns the original object.
##
## If there is vertex animation, but the VertexTransform values have not
## changed since last time, this may return the same pointer it returned
## previously.  Even if the VertexTransform values have changed, it may still
## return the same pointer, but with its contents modified (this is preferred,
## since it allows the graphics backend to update vertex buffers optimally).
##
## If force is false, this method may return immediately with stale data, if
## the vertex data is not completely resident.  If force is true, this method
## will never return stale data, but may block until the data is available.

proc clearAnimatedVertices*(this: GeomVertexData) {.importcpp: "#->clear_animated_vertices()".} ## \
## Removes the cache of animated vertices computed by a previous call to
## animate_vertices() within the same frame.  This will force the next call to
## animate_vertices() to recompute these values from scratch.  Normally it is
## not necessary to call this.

proc transformVertices*(this: GeomVertexData, mat: LMatrix4) {.importcpp: "#->transform_vertices(#)".} ## \
## Applies the indicated transform matrix to all of the vertices in the
## GeomVertexData.  The transform is applied to all "point" and "vector" type
## columns described in the format.

proc transformVertices*(this: GeomVertexData, mat: LMatrix4, rows: SparseArray) {.importcpp: "#->transform_vertices(#, #)".} ## \
## Applies the indicated transform matrix to all of the vertices mentioned in
## the sparse array.  The transform is applied to all "point" and "vector"
## type columns described in the format.

proc transformVertices*(this: GeomVertexData, mat: LMatrix4, begin_row: int, end_row: int) {.importcpp: "#->transform_vertices(#, #, #)".} ## \
## Applies the indicated transform matrix to all of the vertices from
## begin_row up to but not including end_row.  The transform is applied to all
## "point" and "vector" type columns described in the format.

proc output*(this: GeomVertexData, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: GeomVertexData, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: GeomVertexData, `out`: ostream) {.importcpp: "#->write(#)".}

proc describeVertex*(this: GeomVertexData, `out`: ostream, row: int) {.importcpp: "#->describe_vertex(#, #)".} ## \
## Writes a verbose, human-friendly description of the indicated vertex
## number.

proc clearCache*(this: GeomVertexData) {.importcpp: "#->clear_cache()".} ## \
## Removes all of the previously-cached results of convert_to().
##
## This blows away the entire cache, upstream and downstream the pipeline.
## Use clear_cache_stage() instead if you only want to blow away the cache at
## the current stage and upstream.

proc clearCacheStage*(this: GeomVertexData) {.importcpp: "#->clear_cache_stage()".} ## \
## Removes all of the previously-cached results of convert_to(), at the
## current pipeline stage and upstream.  Does not affect the downstream cache.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

converter getClassType*(_: typedesc[GeomVertexData]): TypeHandle {.importcpp: "GeomVertexData::get_class_type()", header: "geomVertexData.h".}

proc newAnimateVerticesRequest*(param0: AnimateVerticesRequest): AnimateVerticesRequest {.importcpp: "new AnimateVerticesRequest(#)".}

proc newAnimateVerticesRequest*(geom_vertex_data: GeomVertexData): AnimateVerticesRequest {.importcpp: "new AnimateVerticesRequest(#)".} ## \
## Create a new AnimateVerticesRequest.

proc isReady*(this: AnimateVerticesRequest): bool {.importcpp: "#->is_ready()".} ## \
## Returns true if this request has completed, false if it is still pending.
## Equivalent to `req.done() and not req.cancelled()`.
## @see done()

converter getClassType*(_: typedesc[AnimateVerticesRequest]): TypeHandle {.importcpp: "AnimateVerticesRequest::get_class_type()", header: "animateVerticesRequest.h".}

converter getClassType*(_: typedesc[SavedContext]): TypeHandle {.importcpp: "SavedContext::get_class_type()", header: "savedContext.h".}

converter upcastToSavedContext*(this: BufferContext): SavedContext {.importcpp: "((SavedContext *)(#))".}

proc getDataSizeBytes*(this: BufferContext): clonglong {.importcpp: "#->get_data_size_bytes()".} ## \
## Returns the number of bytes previously reported for the data object.  This
## is used to track changes in the data object's allocated size; if it changes
## from this, we need to create a new buffer.  This is also used to track
## memory utilization in PStats.

proc getModified*(this: BufferContext): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns the UpdateSeq that was recorded the last time mark_loaded() was
## called.

proc getActive*(this: BufferContext): bool {.importcpp: "#->get_active()".} ## \
## Returns the active flag associated with this object.  An object is
## considered "active" if it was rendered in the current frame.

proc getResident*(this: BufferContext): bool {.importcpp: "#->get_resident()".} ## \
## Returns the resident flag associated with this object.  An object is
## considered "resident" if it appears to be resident in texture memory.

converter getClassType*(_: typedesc[BufferContext]): TypeHandle {.importcpp: "BufferContext::get_class_type()", header: "bufferContext.h".}

converter upcastToCopyOnWriteObject*(this: GeomPrimitive): CopyOnWriteObject {.importcpp: "(PT(CopyOnWriteObject)(#))".}

converter upcastToGeomEnums*(this: GeomPrimitive): GeomEnums {.importcpp: "((GeomEnums *)(GeomPrimitive *)(#))".}

proc makeCopy*(this: GeomPrimitive): GeomPrimitive {.importcpp: "#->make_copy()".}

proc getGeomRendering*(this: GeomPrimitive): int {.importcpp: "#->get_geom_rendering()".} ## \
## Returns the set of GeomRendering bits that represent the rendering
## properties required to properly render this primitive.

proc isComposite*(this: GeomPrimitive): bool {.importcpp: "#->is_composite()".} ## \
## Returns true if the primitive is a composite primitive such as a tristrip
## or trifan, or false if it is a fundamental primitive such as a collection
## of triangles.

proc isIndexed*(this: GeomPrimitive): bool {.importcpp: "#->is_indexed()".} ## \
## Returns true if the primitive is indexed, false otherwise.  An indexed
## primitive stores a table of index numbers into its GeomVertexData, so that
## it can reference the vertices in any order.  A nonindexed primitive, on the
## other hand, stores only the first vertex number and number of vertices
## used, so that it can only reference the vertices consecutively.

proc getFirstVertex*(this: GeomPrimitive): int {.importcpp: "#->get_first_vertex()".} ## \
## Returns the first vertex number referenced by the primitive.  This is
## particularly important in the case of a nonindexed primitive, in which case
## get_first_vertex() and get_num_vertices() completely define the extent of
## the vertex range.

proc getNumVertices*(this: GeomPrimitive): int {.importcpp: "#->get_num_vertices()".} ## \
## Returns the number of indices used by all the primitives in this object.

proc getVertex*(this: GeomPrimitive, i: int): int {.importcpp: "#->get_vertex(#)".} ## \
## Returns the ith vertex index in the table.

proc addVertex*(this: GeomPrimitive, vertex: int) {.importcpp: "#->add_vertex(#)".} ## \
## Adds the indicated vertex to the list of vertex indices used by the
## graphics primitive type.  To define a primitive, you must call add_vertex()
## for each vertex of the new primitive, and then call close_primitive() after
## you have specified the last vertex of each primitive.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc addVertices*(this: GeomPrimitive, v1: int, v2: int) {.importcpp: "#->add_vertices(#, #)".} ## \
## Adds several vertices in a row.

proc addVertices*(this: GeomPrimitive, v1: int, v2: int, v3: int) {.importcpp: "#->add_vertices(#, #, #)".} ## \
## Adds several vertices in a row.

proc addVertices*(this: GeomPrimitive, v1: int, v2: int, v3: int, v4: int) {.importcpp: "#->add_vertices(#, #, #, #)".} ## \
## Adds several vertices in a row.

proc addConsecutiveVertices*(this: GeomPrimitive, start: int, num_vertices: int) {.importcpp: "#->add_consecutive_vertices(#, #)".} ## \
## Adds a consecutive sequence of vertices, beginning at start, to the
## primitive.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc addNextVertices*(this: GeomPrimitive, num_vertices: int) {.importcpp: "#->add_next_vertices(#)".} ## \
## Adds the next n vertices in sequence, beginning from the last vertex added
## to the primitive + 1.
##
## This is most useful when you are building up a primitive and a
## GeomVertexData at the same time, and you just want the primitive to
## reference the first n vertices from the data, then the next n, and so on.

proc reserveNumVertices*(this: GeomPrimitive, num_vertices: int) {.importcpp: "#->reserve_num_vertices(#)".} ## \
## This ensures that enough memory space for n vertices is allocated, so that
## you may increase the number of vertices to n without causing a new memory
## allocation.  This is a performance optimization only; it is especially
## useful when you know ahead of time that you will be adding n vertices to
## the primitive.
##
## Note that the total you specify here should also include implicit vertices
## which may be added at each close_primitive() call, according to
## get_num_unused_vertices_per_primitive().
##
## Note also that making this call will implicitly make the primitive indexed
## if it is not already, which could result in a performance \*penalty\*.  If
## you would prefer not to lose the nonindexed nature of your existing
## GeomPrimitives, check is_indexed() before making this call.

proc closePrimitive*(this: GeomPrimitive): bool {.importcpp: "#->close_primitive()".} ## \
## Indicates that the previous n calls to add_vertex(), since the last call to
## close_primitive(), have fully defined a new primitive.  Returns true if
## successful, false otherwise.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc clearVertices*(this: GeomPrimitive) {.importcpp: "#->clear_vertices()".} ## \
## Removes all of the vertices and primitives from the object, so they can be
## re-added.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc offsetVertices*(this: GeomPrimitive, offset: int) {.importcpp: "#->offset_vertices(#)".} ## \
## Adds the indicated offset to all vertices used by the primitive.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc offsetVertices*(this: GeomPrimitive, offset: int, begin_row: int, end_row: int) {.importcpp: "#->offset_vertices(#, #, #)".} ## \
## Adds the indicated offset to the indicated segment of vertices used by the
## primitive.  Unlike the other version of offset_vertices, this makes the
## geometry indexed if it isn't already.
##
## Note that end_row indicates one past the last row that should be offset.
## In other words, the number of vertices touched is (end_row - begin_row).
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc makeNonindexed*(this: GeomPrimitive, dest: GeomVertexData, source: GeomVertexData) {.importcpp: "#->make_nonindexed(#, #)".} ## \
## Converts the primitive from indexed to nonindexed by duplicating vertices
## as necessary into the indicated dest GeomVertexData.  Note: does not
## support primitives with strip cut indices.

proc packVertices*(this: GeomPrimitive, dest: GeomVertexData, source: GeomVertexData) {.importcpp: "#->pack_vertices(#, #)".} ## \
## Packs the vertices used by the primitive from the indicated source array
## onto the end of the indicated destination array.

proc makeIndexed*(this: GeomPrimitive) {.importcpp: "#->make_indexed()".} ## \
## Converts the primitive from nonindexed form to indexed form.  This will
## simply create an index table that is numbered consecutively from
## get_first_vertex(); it does not automatically collapse together identical
## vertices that may have been split apart by a previous call to
## make_nonindexed().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc getNumPrimitives*(this: GeomPrimitive): int {.importcpp: "#->get_num_primitives()".} ## \
## Returns the number of individual primitives stored within this object.  All
## primitives are the same type.

proc getPrimitiveStart*(this: GeomPrimitive, n: int): int {.importcpp: "#->get_primitive_start(#)".} ## \
## Returns the element within the _vertices list at which the nth primitive
## starts.
##
## If i is one more than the highest valid primitive vertex, the return value
## will be one more than the last valid vertex.  Thus, it is generally true
## that the vertices used by a particular primitive i are the set
## get_primitive_start(n) <= vi < get_primitive_start(n + 1) (although this
## range also includes the unused vertices between primitives).

proc getPrimitiveEnd*(this: GeomPrimitive, n: int): int {.importcpp: "#->get_primitive_end(#)".} ## \
## Returns the element within the _vertices list at which the nth primitive
## ends.  This is one past the last valid element for the nth primitive.

proc getPrimitiveNumVertices*(this: GeomPrimitive, n: int): int {.importcpp: "#->get_primitive_num_vertices(#)".} ## \
## Returns the number of vertices used by the nth primitive.  This is the same
## thing as get_primitive_end(n) - get_primitive_start(n).

proc getNumUsedVertices*(this: GeomPrimitive): int {.importcpp: "#->get_num_used_vertices()".} ## \
## Returns the number of vertices used by all of the primitives.  This is the
## same as summing get_primitive_num_vertices(n) for n in
## get_num_primitives().  It is like get_num_vertices except that it excludes
## all of the degenerate vertices and strip-cut indices.

proc getNumFaces*(this: GeomPrimitive): int {.importcpp: "#->get_num_faces()".} ## \
## Returns the number of triangles or other fundamental type (such as line
## segments) represented by all the primitives in this object.

proc getPrimitiveNumFaces*(this: GeomPrimitive, n: int): int {.importcpp: "#->get_primitive_num_faces(#)".} ## \
## Returns the number of triangles or other fundamental type (such as line
## segments) represented by the nth primitive in this object.

proc getMinVertex*(this: GeomPrimitive): int {.importcpp: "#->get_min_vertex()".} ## \
## Returns the minimum vertex index number used by all the primitives in this
## object.

proc getPrimitiveMinVertex*(this: GeomPrimitive, n: int): int {.importcpp: "#->get_primitive_min_vertex(#)".} ## \
## Returns the minimum vertex index number used by the nth primitive in this
## object.

proc getMaxVertex*(this: GeomPrimitive): int {.importcpp: "#->get_max_vertex()".} ## \
## Returns the maximum vertex index number used by all the primitives in this
## object.

proc getPrimitiveMaxVertex*(this: GeomPrimitive, n: int): int {.importcpp: "#->get_primitive_max_vertex(#)".} ## \
## Returns the maximum vertex index number used by the nth primitive in this
## object.

proc decompose*(this: GeomPrimitive): GeomPrimitive {.importcpp: "deconstify(#->decompose())", header: deconstifyCode.} ## \
## Decomposes a complex primitive type into a simpler primitive type, for
## instance triangle strips to triangles, and returns a pointer to the new
## primitive definition.  If the decomposition cannot be performed, this might
## return the original object.
##
## This method is useful for application code that wants to iterate through
## the set of triangles on the primitive without having to write handlers for
## each possible kind of primitive type.

proc rotate*(this: GeomPrimitive): GeomPrimitive {.importcpp: "deconstify(#->rotate())", header: deconstifyCode.} ## \
## Returns a new primitive with the shade_model reversed (if it is flat
## shaded), if possible.  If the primitive type cannot be rotated, returns the
## original primitive, unrotated.
##
## If the current shade_model indicates flat_vertex_last, this should bring
## the last vertex to the first position; if it indicates flat_vertex_first,
## this should bring the first vertex to the last position.

proc doubleside*(this: GeomPrimitive): GeomPrimitive {.importcpp: "deconstify(#->doubleside())", header: deconstifyCode.} ## \
## Duplicates triangles in the primitive so that each triangle is back-to-back
## with another triangle facing in the opposite direction.  Note that this
## doesn't affect vertex normals, so this operation alone won't work in the
## presence of lighting (but see SceneGraphReducer::doubleside()).
##
## Also see CullFaceAttrib, which can enable rendering of both sides of a
## triangle without having to duplicate it (but which doesn't necessarily work
## in the presence of lighting).

proc reverse*(this: GeomPrimitive): GeomPrimitive {.importcpp: "deconstify(#->reverse())", header: deconstifyCode.} ## \
## Reverses the winding order in the primitive so that each triangle is facing
## in the opposite direction it was originally.  Note that this doesn't affect
## vertex normals, so this operation alone won't work in the presence of
## lighting (but see SceneGraphReducer::reverse()).
##
## Also see CullFaceAttrib, which can change the visible direction of a
## triangle without having to duplicate it (but which doesn't necessarily work
## in the presence of lighting).

proc makePoints*(this: GeomPrimitive): GeomPrimitive {.importcpp: "deconstify(#->make_points())", header: deconstifyCode.} ## \
## Returns a new GeomPoints primitive that represents each of the vertices in
## the original primitive, rendered exactly once.  If the original primitive
## is already a GeomPoints primitive, returns the original primitive
## unchanged.

proc makeLines*(this: GeomPrimitive): GeomPrimitive {.importcpp: "deconstify(#->make_lines())", header: deconstifyCode.} ## \
## Returns a new GeomLines primitive that represents each of the edges in the
## original primitive rendered as a line.  If the original primitive is
## already a GeomLines primitive, returns the original primitive unchanged.

proc makePatches*(this: GeomPrimitive): GeomPrimitive {.importcpp: "deconstify(#->make_patches())", header: deconstifyCode.} ## \
## Decomposes a complex primitive type into a simpler primitive type, for
## instance triangle strips to triangles, puts these in a new GeomPatches
## object and returns a pointer to the new primitive definition.  If the
## decomposition cannot be performed, this might return the original object.
##
## This method is useful for application code that wants to use tesselation
## shaders on arbitrary geometry.

proc makeAdjacency*(this: GeomPrimitive): GeomPrimitive {.importcpp: "deconstify(#->make_adjacency())", header: deconstifyCode.} ## \
## Adds adjacency information to this primitive.  May return null if this type
## of geometry does not support adjacency information.
##
## @since 1.10.0

proc getNumBytes*(this: GeomPrimitive): int {.importcpp: "#->get_num_bytes()".} ## \
## Returns the number of bytes consumed by the primitive and its index
## table(s).

proc getDataSizeBytes*(this: GeomPrimitive): int {.importcpp: "#->get_data_size_bytes()".} ## \
## Returns the number of bytes stored in the vertices array.

proc getModified*(this: GeomPrimitive): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the vertex index array is modified.

proc requestResident*(this: GeomPrimitive, current_thread: Thread): bool {.importcpp: "#->request_resident(#)".} ## \
## Returns true if the primitive data is currently resident in memory.  If
## this returns false, the primitive data will be brought back into memory
## shortly; try again later.

proc requestResident*(this: GeomPrimitive): bool {.importcpp: "#->request_resident()".} ## \
## Returns true if the primitive data is currently resident in memory.  If
## this returns false, the primitive data will be brought back into memory
## shortly; try again later.

proc checkValid*(this: GeomPrimitive, vertex_data: GeomVertexData): bool {.importcpp: "#->check_valid(#)".} ## \
## Verifies that the primitive only references vertices that actually exist
## within the indicated GeomVertexData.  Returns true if the primitive appears
## to be valid, false otherwise.

proc output*(this: GeomPrimitive, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: GeomPrimitive, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc getVertices*(this: GeomPrimitive): GeomVertexArrayData {.importcpp: "deconstify(#->get_vertices())", header: deconstifyCode.} ## \
## Returns a const pointer to the vertex index array so application code can
## read it directly.  This might return NULL if the primitive is nonindexed.
## Do not attempt to modify the returned array; use modify_vertices() or
## set_vertices() for this.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc getVerticesHandle*(this: GeomPrimitive, current_thread: Thread): GeomVertexArrayDataHandle {.importcpp: "deconstify(#->get_vertices_handle(#))", header: deconstifyCode.} ## \
## Equivalent to get_vertices().get_handle().

proc modifyVertices*(this: GeomPrimitive, num_vertices: int): GeomVertexArrayData {.importcpp: "#->modify_vertices(#)".} ## \
## Returns a modifiable pointer to the vertex index list, so application code
## can directly fiddle with this data.  Use with caution, since there are no
## checks that the data will be left in a stable state.
##
## If this is called on a nonindexed primitive, it will implicitly be
## converted to an indexed primitive.
##
## If num_vertices is not -1, it specifies an artificial limit to the number
## of vertices in the array.  Otherwise, all of the vertices in the array will
## be used.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc modifyVertices*(this: GeomPrimitive): GeomVertexArrayData {.importcpp: "#->modify_vertices()".} ## \
## Returns a modifiable pointer to the vertex index list, so application code
## can directly fiddle with this data.  Use with caution, since there are no
## checks that the data will be left in a stable state.
##
## If this is called on a nonindexed primitive, it will implicitly be
## converted to an indexed primitive.
##
## If num_vertices is not -1, it specifies an artificial limit to the number
## of vertices in the array.  Otherwise, all of the vertices in the array will
## be used.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc modifyVerticesHandle*(this: GeomPrimitive, current_thread: Thread): GeomVertexArrayDataHandle {.importcpp: "#->modify_vertices_handle(#)".} ## \
## Equivalent to modify_vertices().get_handle().

proc setVertices*(this: GeomPrimitive, vertices: GeomVertexArrayData, num_vertices: int) {.importcpp: "#->set_vertices(#, #)".} ## \
## Completely replaces the vertex index list with a new table.  Chances are
## good that you should also replace the ends list with set_ends() at the same
## time.
##
## If num_vertices is not -1, it specifies an artificial limit to the number
## of vertices in the array.  Otherwise, all of the vertices in the array will
## be used.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc setVertices*(this: GeomPrimitive, vertices: GeomVertexArrayData) {.importcpp: "#->set_vertices(#)".} ## \
## Completely replaces the vertex index list with a new table.  Chances are
## good that you should also replace the ends list with set_ends() at the same
## time.
##
## If num_vertices is not -1, it specifies an artificial limit to the number
## of vertices in the array.  Otherwise, all of the vertices in the array will
## be used.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc setNonindexedVertices*(this: GeomPrimitive, first_vertex: int, num_vertices: int) {.importcpp: "#->set_nonindexed_vertices(#, #)".} ## \
## Sets the primitive up as a nonindexed primitive, using the indicated vertex
## range.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc getIndexStride*(this: GeomPrimitive): int {.importcpp: "#->get_index_stride()".} ## \
## A convenience function to return the gap between successive index numbers,
## in bytes, of the index data.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc getStripCutIndex*(this: GeomPrimitive): int {.importcpp: "#->get_strip_cut_index()".} ## \
## If relevant, returns the index value that may be used in some cases to
## signify the end of a primitive.  This is typically the highest value that
## the numeric type can store.

proc getMins*(this: GeomPrimitive): GeomVertexArrayData {.importcpp: "deconstify(#->get_mins())", header: deconstifyCode.} ## \
## Returns a const pointer to the primitive mins array so application code can
## read it directly.  Do not attempt to modify the returned array; use
## set_minmax() for this.
##
## Note that simple primitive types, like triangles, do not have a mins array.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc getMaxs*(this: GeomPrimitive): GeomVertexArrayData {.importcpp: "deconstify(#->get_maxs())", header: deconstifyCode.} ## \
## Returns a const pointer to the primitive maxs array so application code can
## read it directly.  Do not attempt to modify the returned array; use
## set_minmax().
##
## Note that simple primitive types, like triangles, do not have a maxs array.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc setMinmax*(this: GeomPrimitive, min_vertex: int, max_vertex: int, mins: GeomVertexArrayData, maxs: GeomVertexArrayData) {.importcpp: "#->set_minmax(#, #, #, #)".} ## \
## Explicitly specifies the minimum and maximum vertices, as well as the lists
## of per-component min and max.
##
## Use this method with extreme caution.  It's generally better to let the
## GeomPrimitive compute these explicitly, unless for some reason you can do
## it faster and you absolutely need the speed improvement.
##
## Note that any modification to the vertex array will normally cause this to
## be recomputed, unless you set it immediately again.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc clearMinmax*(this: GeomPrimitive) {.importcpp: "#->clear_minmax()".} ## \
## Undoes a previous call to set_minmax(), and allows the minimum and maximum
## values to be recomputed normally.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc getNumVerticesPerPrimitive*(this: GeomPrimitive): int {.importcpp: "#->get_num_vertices_per_primitive()".} ## \
## If the primitive type is a simple type in which all primitives have the
## same number of vertices, like triangles, returns the number of vertices per
## primitive.  If the primitive type is a more complex type in which different
## primitives might have different numbers of vertices, for instance a
## triangle strip, returns 0.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc getMinNumVerticesPerPrimitive*(this: GeomPrimitive): int {.importcpp: "#->get_min_num_vertices_per_primitive()".} ## \
## Returns the minimum number of vertices that must be added before
## close_primitive() may legally be called.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

proc getNumUnusedVerticesPerPrimitive*(this: GeomPrimitive): int {.importcpp: "#->get_num_unused_vertices_per_primitive()".} ## \
## Returns the number of vertices that are added between primitives that
## aren't, strictly speaking, part of the primitives themselves.  This is
## used, for instance, to define degenerate triangles to connect otherwise
## disconnected triangle strips.
##
## This method is intended for low-level usage only.  There are higher-level
## methods for more common usage.  We recommend you do not use this method
## directly.  If you do, be sure you know what you are doing!

converter getClassType*(_: typedesc[GeomPrimitive]): TypeHandle {.importcpp: "GeomPrimitive::get_class_type()", header: "geomPrimitive.h".}

proc newTextureStage*(copy: TextureStage): TextureStage {.importcpp: "new TextureStage(#)".} ## \
## Initialize the texture stage from other

proc newTextureStage*(name: string): TextureStage {.importcpp: "new TextureStage(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Initialize the texture stage at construction

proc setName*(this: TextureStage, name: string) {.importcpp: "#->set_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name of this texture stage

proc getName*(this: TextureStage): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Returns the name of this texture stage

proc setSort*(this: TextureStage, sort: int) {.importcpp: "#->set_sort(#)".} ## \
## Changes the order in which the texture associated with this stage is
## rendered relative to the other texture stages.  When geometry is rendered
## with multiple textures, the textures are rendered in order from the lowest
## sort number to the highest sort number.
##
## Also see set_priority(), which is used to select the most important
## textures for rendering when some must be omitted because of hardware
## limitations.

proc getSort*(this: TextureStage): int {.importcpp: "#->get_sort()".} ## \
## Returns the sort order of this texture stage.

proc setPriority*(this: TextureStage, priority: int) {.importcpp: "#->set_priority(#)".} ## \
## Changes the relative importance of the texture associated with this stage
## relative to the other texture stages that are applied simultaneously.
##
## This is unrelated to set_sort(), which controls the order in which multiple
## textures are applied.  The priority number is used to decide which of the
## requested textures are to be selected for rendering when more textures are
## requested than the hardware will support.  The highest-priority n textures
## are selected for rendering, and then rendered in order by their sort
## factor.

proc getPriority*(this: TextureStage): int {.importcpp: "#->get_priority()".} ## \
## Returns the priority associated with this stage.
##
## This is specially helpful for cards that do not support more than n stages
## of multi-texturing.

proc setTexcoordName*(this: TextureStage, name: InternalName) {.importcpp: "#->set_texcoord_name(#)".} ## \
## Indicate which set of UV's this texture stage will use.  Geometry may have
## any number of associated UV sets, each of which must have a unique name.

proc setTexcoordName*(this: TextureStage, texcoord_name: string) {.importcpp: "#->set_texcoord_name(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Indicate which set of UV's this texture stage will use.  Geometry may have
## any number of associated UV sets, each of which must have a unique name.

proc getTexcoordName*(this: TextureStage): InternalName {.importcpp: "#->get_texcoord_name()".} ## \
## See set_texcoord_name.  The default is InternalName::get_texcoord().

proc getTangentName*(this: TextureStage): InternalName {.importcpp: "#->get_tangent_name()".} ## \
## Returns the set of tangents this texture stage will use.  This is the same
## as get_texcoord_name(), except that the first part is "tangent".

proc getBinormalName*(this: TextureStage): InternalName {.importcpp: "#->get_binormal_name()".} ## \
## Returns the set of binormals this texture stage will use.  This is the same
## as get_binormal_name(), except that the first part is "binormal".

proc isFixedFunction*(this: TextureStage): bool {.importcpp: "#->is_fixed_function()".} ## \
## Returns true if the TextureStage is relevant to the classic fixed function
## pipeline.  This excludes texture stages such as normal mapping and the
## like.

proc setColor*(this: TextureStage, color: LColor) {.importcpp: "#->set_color(#)".} ## \
## Set the color for this stage

proc getColor*(this: TextureStage): LColor {.importcpp: "#->get_color()".} ## \
## return the color for this stage

proc setRgbScale*(this: TextureStage, rgb_scale: int) {.importcpp: "#->set_rgb_scale(#)".} ## \
## Sets an additional factor that will scale all three r, g, b components
## after the texture has been applied.  This is used only when the mode is
## CM_combine.
##
## The only legal values are 1, 2, or 4.

proc getRgbScale*(this: TextureStage): int {.importcpp: "#->get_rgb_scale()".} ## \
## See set_rgb_scale().

proc setAlphaScale*(this: TextureStage, alpha_scale: int) {.importcpp: "#->set_alpha_scale(#)".} ## \
## Sets an additional factor that will scale the alpha component after the
## texture has been applied.  This is used only when the mode is CM_combine.
##
## The only legal values are 1, 2, or 4.

proc getAlphaScale*(this: TextureStage): int {.importcpp: "#->get_alpha_scale()".} ## \
## See set_alpha_scale().

proc setSavedResult*(this: TextureStage, saved_result: bool) {.importcpp: "#->set_saved_result(#)".} ## \
## Sets the saved_result flag.  When this is true, the output of this stage
## will be supplied as the "last_saved_result" source for any future stages,
## until the next TextureStage with a saved_result set true is encountered.
##
## This can be used to reuse the results of this texture stage as input to
## more than one stage later in the pipeline.
##
## The last texture in the pipeline (the one with the highest sort value)
## should not have this flag set.

proc getSavedResult*(this: TextureStage): bool {.importcpp: "#->get_saved_result()".} ## \
## Returns the current setting of the saved_result flag.  See
## set_saved_result().

proc setTexViewOffset*(this: TextureStage, tex_view_offset: int) {.importcpp: "#->set_tex_view_offset(#)".} ## \
## Sets the tex_view_offset value.  This is used only when a special multiview
## texture is bound to the TextureStage, and it selects the particular view of
## the texture that is to be used.
##
## This value is added to the similar parameter on DisplayRegion to derive the
## final texture view index that is selected for rendering.

proc getTexViewOffset*(this: TextureStage): int {.importcpp: "#->get_tex_view_offset()".} ## \
## Returns the current setting of the tex_view_offset.  See
## set_tex_view_offset().

proc getNumCombineRgbOperands*(this: TextureStage): int {.importcpp: "#->get_num_combine_rgb_operands()".} ## \
## Returns the number of meaningful operands that may be retrieved via
## get_combine_rgb_sourceN() and get_combine_rgb_operandN().

proc getNumCombineAlphaOperands*(this: TextureStage): int {.importcpp: "#->get_num_combine_alpha_operands()".} ## \
## Returns the number of meaningful operands that may be retrieved via
## get_combine_alpha_sourceN() and get_combine_alpha_operandN().

proc involvesColorScale*(this: TextureStage): bool {.importcpp: "#->involves_color_scale()".} ## \
## Returns true if the TextureStage is affected by the setting of the current
## ColorScaleAttrib, false otherwise.

proc usesColor*(this: TextureStage): bool {.importcpp: "#->uses_color()".} ## \
## Returns true if the TextureStage makes use of whatever color is specified
## in set_color(), false otherwise.

proc usesPrimaryColor*(this: TextureStage): bool {.importcpp: "#->uses_primary_color()".} ## \
## Returns true if the TextureStage makes use of the CS_primary_color combine
## source.

proc usesLastSavedResult*(this: TextureStage): bool {.importcpp: "#->uses_last_saved_result()".} ## \
## Returns true if the TextureStage makes use of the CS_primary_color combine
## source.

proc `==`*(this: TextureStage, other: TextureStage): bool {.importcpp: "#->operator ==(#)".}

proc `!=`*(this: TextureStage, other: TextureStage): bool {.importcpp: "#->operator !=(#)".}

proc `<`*(this: TextureStage, other: TextureStage): bool {.importcpp: "#->operator <(#)".}

proc compareTo*(this: TextureStage, other: TextureStage): int {.importcpp: "#->compare_to(#)".} ## \
## Returns a number less than zero if this TextureStage sorts before the other
## one, greater than zero if it sorts after, or zero if they are equivalent.
## The sorting order is arbitrary and largely meaningless, except to
## differentiate different stages.

proc write*(this: TextureStage, `out`: ostream) {.importcpp: "#->write(#)".} ## \
## Writes the details of this stage

proc output*(this: TextureStage, `out`: ostream) {.importcpp: "#->output(#)".} ## \
## Just a single line output

proc getDefault*(_: typedesc[TextureStage]): TextureStage {.importcpp: "TextureStage::get_default()", header: "textureStage.h".} ## \
## Returns the default TextureStage that will be used for all texturing that
## does not name a particular stage.  This generally handles the normal
## single-texture case.

converter getClassType*(_: typedesc[TextureStage]): TypeHandle {.importcpp: "TextureStage::get_class_type()", header: "textureStage.h".}

converter upcastToCopyOnWriteObject*(this: Geom): CopyOnWriteObject {.importcpp: "(PT(CopyOnWriteObject)(#))".}

converter upcastToGeomEnums*(this: Geom): GeomEnums {.importcpp: "((GeomEnums *)(Geom *)(#))".}

proc newGeom*(data: GeomVertexData): Geom {.importcpp: "new Geom(#)".}

proc makeCopy*(this: Geom): Geom {.importcpp: "#->make_copy()".} ## \
## Returns a newly-allocated Geom that is a shallow copy of this one.  It will
## be a different Geom pointer, but its internal data may or may not be shared
## with that of the original Geom.

proc getGeomRendering*(this: Geom): int {.importcpp: "#->get_geom_rendering()".} ## \
## Returns the set of GeomRendering bits that represent the rendering
## properties required to properly render this Geom.

proc getVertexData*(this: Geom, current_thread: Thread): GeomVertexData {.importcpp: "deconstify(#->get_vertex_data(#))", header: deconstifyCode.} ## \
## Returns a const pointer to the GeomVertexData, for application code to
## directly examine (but not modify) the geom's underlying data.

proc getVertexData*(this: Geom): GeomVertexData {.importcpp: "deconstify(#->get_vertex_data())", header: deconstifyCode.} ## \
## Returns a const pointer to the GeomVertexData, for application code to
## directly examine (but not modify) the geom's underlying data.

proc modifyVertexData*(this: Geom): GeomVertexData {.importcpp: "#->modify_vertex_data()".} ## \
## Returns a modifiable pointer to the GeomVertexData, so that application
## code may directly maniuplate the geom's underlying data.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc setVertexData*(this: Geom, data: GeomVertexData) {.importcpp: "#->set_vertex_data(#)".} ## \
## Replaces the Geom's underlying vertex data table with a completely new
## table.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc offsetVertices*(this: Geom, data: GeomVertexData, offset: int) {.importcpp: "#->offset_vertices(#, #)".} ## \
## Replaces a Geom's vertex table with a new table, and simultaneously adds
## the indicated offset to all vertex references within the Geom's primitives.
## This is intended to be used to combine multiple GeomVertexDatas from
## different Geoms into a single big buffer, with each Geom referencing a
## subset of the vertices in the buffer.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc makeNonindexed*(this: Geom, composite_only: bool): int {.importcpp: "#->make_nonindexed(#)".} ## \
## Converts the geom from indexed to nonindexed by duplicating vertices as
## necessary.  If composite_only is true, then only composite primitives such
## as trifans and tristrips are converted.  Returns the number of
## GeomPrimitive objects converted.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc getAnimatedVertexData*(this: Geom, force: bool, current_thread: Thread): GeomVertexData {.importcpp: "deconstify(#->get_animated_vertex_data(#, #))", header: deconstifyCode.} ## \
## Returns a GeomVertexData that represents the results of computing the
## vertex animation on the CPU for this Geom's vertex data.
##
## If there is no CPU-defined vertex animation on this object, this just
## returns the original object.
##
## If there is vertex animation, but the VertexTransform values have not
## changed since last time, this may return the same pointer it returned
## previously.  Even if the VertexTransform values have changed, it may still
## return the same pointer, but with its contents modified (this is preferred,
## since it allows the graphics backend to update vertex buffers optimally).
##
## If force is false, this method may return immediately with stale data, if
## the vertex data is not completely resident.  If force is true, this method
## will never return stale data, but may block until the data is available.

proc getAnimatedVertexData*(this: Geom, force: bool): GeomVertexData {.importcpp: "deconstify(#->get_animated_vertex_data(#))", header: deconstifyCode.} ## \
## Returns a GeomVertexData that represents the results of computing the
## vertex animation on the CPU for this Geom's vertex data.
##
## If there is no CPU-defined vertex animation on this object, this just
## returns the original object.
##
## If there is vertex animation, but the VertexTransform values have not
## changed since last time, this may return the same pointer it returned
## previously.  Even if the VertexTransform values have changed, it may still
## return the same pointer, but with its contents modified (this is preferred,
## since it allows the graphics backend to update vertex buffers optimally).
##
## If force is false, this method may return immediately with stale data, if
## the vertex data is not completely resident.  If force is true, this method
## will never return stale data, but may block until the data is available.

proc isEmpty*(this: Geom): bool {.importcpp: "#->is_empty()".} ## \
## Returns true if there appear to be no vertices to be rendered by this Geom,
## false if has some actual data.

proc getNumPrimitives*(this: Geom): clonglong {.importcpp: "#->get_num_primitives()".} ## \
## Returns the number of GeomPrimitive objects stored within the Geom, each of
## which represents a number of primitives of a particular type.

proc getPrimitive*(this: Geom, i: clonglong): GeomPrimitive {.importcpp: "deconstify(#->get_primitive(#))", header: deconstifyCode.} ## \
## Returns a const pointer to the ith GeomPrimitive object stored within the
## Geom.  Use this call only to inspect the ith object; use modify_primitive()
## or set_primitive() if you want to modify it.

proc modifyPrimitive*(this: Geom, i: clonglong): GeomPrimitive {.importcpp: "#->modify_primitive(#)".} ## \
## Returns a modifiable pointer to the ith GeomPrimitive object stored within
## the Geom, so application code can directly manipulate the properties of
## this primitive.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc setPrimitive*(this: Geom, i: clonglong, primitive: GeomPrimitive) {.importcpp: "#->set_primitive(#, #)".} ## \
## Replaces the ith GeomPrimitive object stored within the Geom with the new
## object.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc insertPrimitive*(this: Geom, i: clonglong, primitive: GeomPrimitive) {.importcpp: "#->insert_primitive(#, #)".} ## \
## Inserts a new GeomPrimitive structure to the Geom object.  This specifies a
## particular subset of vertices that are used to define geometric primitives
## of the indicated type.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc addPrimitive*(this: Geom, primitive: GeomPrimitive) {.importcpp: "#->add_primitive(#)".} ## \
## Inserts a new GeomPrimitive structure to the Geom object.  This specifies a
## particular subset of vertices that are used to define geometric primitives
## of the indicated type.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc removePrimitive*(this: Geom, i: clonglong) {.importcpp: "#->remove_primitive(#)".} ## \
## Removes the ith primitive from the list.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc clearPrimitives*(this: Geom) {.importcpp: "#->clear_primitives()".} ## \
## Removes all the primitives from the Geom object (but keeps the same table
## of vertices).  You may then re-add primitives one at a time via calls to
## add_primitive().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc decompose*(this: Geom): Geom {.importcpp: "#->decompose()".} ## \
## Decomposes all of the primitives within this Geom, returning the result.
## See GeomPrimitive::decompose().

proc doubleside*(this: Geom): Geom {.importcpp: "#->doubleside()".} ## \
## Doublesides all of the primitives within this Geom, returning the result.
## See GeomPrimitive::doubleside().

proc reverse*(this: Geom): Geom {.importcpp: "#->reverse()".} ## \
## Reverses all of the primitives within this Geom, returning the result.  See
## GeomPrimitive::reverse().

proc rotate*(this: Geom): Geom {.importcpp: "#->rotate()".} ## \
## Rotates all of the primitives within this Geom, returning the result.  See
## GeomPrimitive::rotate().

proc unify*(this: Geom, max_indices: int, preserve_order: bool): Geom {.importcpp: "#->unify(#, #)".} ## \
## Unifies all of the primitives contained within this Geom into a single (or
## as few as possible, within the constraints of max_indices) primitive
## objects.  This may require decomposing the primitives if, for instance, the
## Geom contains both triangle strips and triangle fans.
##
## max_indices represents the maximum number of indices that will be put in
## any one GeomPrimitive.  If preserve_order is true, then the primitives will
## not be reordered during the operation, even if this results in a suboptimal
## result.

proc makePoints*(this: Geom): Geom {.importcpp: "#->make_points()".} ## \
## Returns a new Geom with points at all the vertices.  See
## GeomPrimitive::make_points().

proc makeLines*(this: Geom): Geom {.importcpp: "#->make_lines()".} ## \
## Returns a new Geom with lines at all the edges.  See
## GeomPrimitive::make_lines().

proc makePatches*(this: Geom): Geom {.importcpp: "#->make_patches()".} ## \
## Returns a new Geom with each primitive converted into a patch.  Calls
## decompose() first.

proc makeAdjacency*(this: Geom): Geom {.importcpp: "#->make_adjacency()".} ## \
## Returns a new Geom with each primitive converted into a corresponding
## version with adjacency information.
##
## @since 1.10.0

proc decomposeInPlace*(this: Geom) {.importcpp: "#->decompose_in_place()".} ## \
## Decomposes all of the primitives within this Geom, leaving the results in
## place.  See GeomPrimitive::decompose().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc doublesideInPlace*(this: Geom) {.importcpp: "#->doubleside_in_place()".} ## \
## Doublesides all of the primitives within this Geom, leaving the results in
## place.  See GeomPrimitive::doubleside().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc reverseInPlace*(this: Geom) {.importcpp: "#->reverse_in_place()".} ## \
## Reverses all of the primitives within this Geom, leaving the results in
## place.  See GeomPrimitive::reverse().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc rotateInPlace*(this: Geom) {.importcpp: "#->rotate_in_place()".} ## \
## Rotates all of the primitives within this Geom, leaving the results in
## place.  See GeomPrimitive::rotate().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc unifyInPlace*(this: Geom, max_indices: int, preserve_order: bool) {.importcpp: "#->unify_in_place(#, #)".} ## \
## Unifies all of the primitives contained within this Geom into a single (or
## as few as possible, within the constraints of max_indices) primitive
## objects.  This may require decomposing the primitives if, for instance, the
## Geom contains both triangle strips and triangle fans.
##
## max_indices represents the maximum number of indices that will be put in
## any one GeomPrimitive.  If preserve_order is true, then the primitives will
## not be reordered during the operation, even if this results in a suboptimal
## result.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc makePointsInPlace*(this: Geom) {.importcpp: "#->make_points_in_place()".} ## \
## Replaces the GeomPrimitives within this Geom with corresponding GeomPoints.
## See GeomPrimitive::make_points().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc makeLinesInPlace*(this: Geom) {.importcpp: "#->make_lines_in_place()".} ## \
## Replaces the GeomPrimitives within this Geom with corresponding GeomLines,
## representing a wireframe of the primitives.  See
## GeomPrimitive::make_lines().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc makePatchesInPlace*(this: Geom) {.importcpp: "#->make_patches_in_place()".} ## \
## Replaces the GeomPrimitives within this Geom with corresponding
## GeomPatches.  See GeomPrimitive::make_patches().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc makeAdjacencyInPlace*(this: Geom) {.importcpp: "#->make_adjacency_in_place()".} ## \
## Replaces the GeomPrimitives within this Geom with corresponding versions
## with adjacency information.  See GeomPrimitive::make_adjacency().
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.
##
## @since 1.10.0

proc copyPrimitivesFrom*(this: Geom, other: Geom): bool {.importcpp: "#->copy_primitives_from(#)".} ## \
## Copies the primitives from the indicated Geom into this one.  This does
## require that both Geoms contain the same fundamental type primitives, both
## have a compatible shade model, and both use the same GeomVertexData.  Both
## Geoms must also be the same specific class type (i.e.  if one is a
## GeomTextGlyph, they both must be.)
##
## Returns true if the copy is successful, or false otherwise (because the
## Geoms were mismatched).

proc getNumBytes*(this: Geom): int {.importcpp: "#->get_num_bytes()".} ## \
## Returns the number of bytes consumed by the geom and its primitives (but
## not including its vertex table).

proc getModified*(this: Geom, current_thread: Thread): UpdateSeq {.importcpp: "#->get_modified(#)".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## any of the primitives in the Geom is modified, or the set of primitives is
## modified.  However, this does not include modifications to the vertex data,
## which should be tested separately.

proc getModified*(this: Geom): UpdateSeq {.importcpp: "#->get_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## any of the primitives in the Geom is modified, or the set of primitives is
## modified.  However, this does not include modifications to the vertex data,
## which should be tested separately.

proc requestResident*(this: Geom): bool {.importcpp: "#->request_resident()".} ## \
## Returns true if all the primitive arrays are currently resident in memory.
## If this returns false, the data will be brought back into memory shortly;
## try again later.
##
## This does not also test the Geom's associated GeomVertexData.  That must be
## tested separately.

proc transformVertices*(this: Geom, mat: LMatrix4) {.importcpp: "#->transform_vertices(#)".} ## \
## Applies the indicated transform to all of the vertices in the Geom.  If the
## Geom happens to share a vertex table with another Geom, this operation will
## duplicate the vertex table instead of breaking the other Geom; however, if
## multiple Geoms with shared tables are transformed by the same matrix, they
## will no longer share tables after the operation.  Consider using the
## GeomTransformer if you will be applying the same transform to multiple
## Geoms.

proc checkValid*(this: Geom): bool {.importcpp: "#->check_valid()".} ## \
## Verifies that the all of the primitives within the geom reference vertices
## that actually exist within the geom's GeomVertexData.  Returns true if the
## geom appears to be valid, false otherwise.

proc checkValid*(this: Geom, vertex_data: GeomVertexData): bool {.importcpp: "#->check_valid(#)".} ## \
## Verifies that the all of the primitives within the geom reference vertices
## that actually exist within the indicated GeomVertexData.  Returns true if
## the geom appears to be valid, false otherwise.

proc getBounds*(this: Geom, current_thread: Thread): BoundingVolume {.importcpp: "deconstify(#->get_bounds(#))", header: deconstifyCode.} ## \
## Returns the bounding volume for the Geom.

proc getBounds*(this: Geom): BoundingVolume {.importcpp: "deconstify(#->get_bounds())", header: deconstifyCode.} ## \
## Returns the bounding volume for the Geom.

proc getNestedVertices*(this: Geom, current_thread: Thread): int {.importcpp: "#->get_nested_vertices(#)".} ## \
## Returns the number of vertices rendered by all primitives within the Geom.

proc getNestedVertices*(this: Geom): int {.importcpp: "#->get_nested_vertices()".} ## \
## Returns the number of vertices rendered by all primitives within the Geom.

proc markBoundsStale*(this: Geom) {.importcpp: "#->mark_bounds_stale()".} ## \
## Marks the bounding volume of the Geom as stale so that it should be
## recomputed.  Usually it is not necessary to call this explicitly.

proc setBounds*(this: Geom, volume: BoundingVolume) {.importcpp: "#->set_bounds(#)".} ## \
## Resets the bounding volume so that it is the indicated volume.  When it is
## explicitly set, the bounding volume will no longer be automatically
## computed; call clear_bounds() if you would like to return the bounding
## volume to its default behavior.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc clearBounds*(this: Geom) {.importcpp: "#->clear_bounds()".} ## \
## Reverses the effect of a previous call to set_bounds(), and allows the
## bounding volume to be automatically computed once more based on the
## vertices.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc output*(this: Geom, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: Geom, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: Geom, `out`: ostream) {.importcpp: "#->write(#)".}

proc clearCache*(this: Geom) {.importcpp: "#->clear_cache()".} ## \
## Removes all of the previously-cached results of munge_geom().
##
## This blows away the entire cache, upstream and downstream the pipeline.
## Use clear_cache_stage() instead if you only want to blow away the cache at
## the current stage and upstream.

proc clearCacheStage*(this: Geom, current_thread: Thread) {.importcpp: "#->clear_cache_stage(#)".} ## \
## Removes all of the previously-cached results of munge_geom(), at the
## current pipeline stage and upstream.  Does not affect the downstream cache.
##
## Don't call this in a downstream thread unless you don't mind it blowing
## away other changes you might have recently made in an upstream thread.

proc prepare*(this: Geom, prepared_objects: PreparedGraphicsObjects) {.importcpp: "#->prepare(#)".} ## \
## Indicates that the geom should be enqueued to be prepared in the indicated
## prepared_objects at the beginning of the next frame.  This will ensure the
## geom is already loaded into geom memory if it is expected to be rendered
## soon.
##
## Use this function instead of prepare_now() to preload geoms from a user
## interface standpoint.

proc isPrepared*(this: Geom, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->is_prepared(#)".} ## \
## Returns true if the geom has already been prepared or enqueued for
## preparation on the indicated GSG, false otherwise.

proc release*(this: Geom, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->release(#)".} ## \
## Frees the geom context only on the indicated object, if it exists there.
## Returns true if it was released, false if it had not been prepared.

proc releaseAll*(this: Geom): int {.importcpp: "#->release_all()".} ## \
## Frees the context allocated on all objects for which the geom has been
## declared.  Returns the number of contexts which have been freed.

proc prepareNow*(this: Geom, prepared_objects: PreparedGraphicsObjects, gsg: GraphicsStateGuardianBase): GeomContext {.importcpp: "#->prepare_now(#, #)".} ## \
## Creates a context for the geom on the particular GSG, if it does not
## already exist.  Returns the new (or old) GeomContext.  This assumes that
## the GraphicsStateGuardian is the currently active rendering context and
## that it is ready to accept new geoms.  If this is not necessarily the case,
## you should use prepare() instead.
##
## Normally, this is not called directly except by the GraphicsStateGuardian;
## a geom does not need to be explicitly prepared by the user before it may be
## rendered.

converter getClassType*(_: typedesc[Geom]): TypeHandle {.importcpp: "Geom::get_class_type()", header: "geom.h".}

proc getGeom*(this: GeomContext): Geom {.importcpp: "#.get_geom()".}

converter getClassType*(_: typedesc[GeomContext]): TypeHandle {.importcpp: "GeomContext::get_class_type()", header: "geomContext.h".}

proc newGeomLines*(copy: GeomLines): GeomLines {.importcpp: "new GeomLines(#)".}

converter getClassType*(_: typedesc[GeomLines]): TypeHandle {.importcpp: "GeomLines::get_class_type()", header: "geomLines.h".}

proc newGeomLinesAdjacency*(copy: GeomLinesAdjacency): GeomLinesAdjacency {.importcpp: "new GeomLinesAdjacency(#)".}

converter getClassType*(_: typedesc[GeomLinesAdjacency]): TypeHandle {.importcpp: "GeomLinesAdjacency::get_class_type()", header: "geomLinesAdjacency.h".}

proc newGeomLinestrips*(copy: GeomLinestrips): GeomLinestrips {.importcpp: "new GeomLinestrips(#)".}

converter getClassType*(_: typedesc[GeomLinestrips]): TypeHandle {.importcpp: "GeomLinestrips::get_class_type()", header: "geomLinestrips.h".}

proc newGeomLinestripsAdjacency*(copy: GeomLinestripsAdjacency): GeomLinestripsAdjacency {.importcpp: "new GeomLinestripsAdjacency(#)".}

converter getClassType*(_: typedesc[GeomLinestripsAdjacency]): TypeHandle {.importcpp: "GeomLinestripsAdjacency::get_class_type()", header: "geomLinestripsAdjacency.h".}

proc newGeomPatches*(copy: GeomPatches): GeomPatches {.importcpp: "new GeomPatches(#)".}

converter getClassType*(_: typedesc[GeomPatches]): TypeHandle {.importcpp: "GeomPatches::get_class_type()", header: "geomPatches.h".}

proc newGeomPoints*(copy: GeomPoints): GeomPoints {.importcpp: "new GeomPoints(#)".}

converter getClassType*(_: typedesc[GeomPoints]): TypeHandle {.importcpp: "GeomPoints::get_class_type()", header: "geomPoints.h".}

proc newGeomTriangles*(copy: GeomTriangles): GeomTriangles {.importcpp: "new GeomTriangles(#)".}

converter getClassType*(_: typedesc[GeomTriangles]): TypeHandle {.importcpp: "GeomTriangles::get_class_type()", header: "geomTriangles.h".}

proc newGeomTrianglesAdjacency*(copy: GeomTrianglesAdjacency): GeomTrianglesAdjacency {.importcpp: "new GeomTrianglesAdjacency(#)".}

converter getClassType*(_: typedesc[GeomTrianglesAdjacency]): TypeHandle {.importcpp: "GeomTrianglesAdjacency::get_class_type()", header: "geomTrianglesAdjacency.h".}

proc newGeomTrifans*(copy: GeomTrifans): GeomTrifans {.importcpp: "new GeomTrifans(#)".}

converter getClassType*(_: typedesc[GeomTrifans]): TypeHandle {.importcpp: "GeomTrifans::get_class_type()", header: "geomTrifans.h".}

proc newGeomTristrips*(copy: GeomTristrips): GeomTristrips {.importcpp: "new GeomTristrips(#)".}

converter getClassType*(_: typedesc[GeomTristrips]): TypeHandle {.importcpp: "GeomTristrips::get_class_type()", header: "geomTristrips.h".}

proc newGeomTristripsAdjacency*(copy: GeomTristripsAdjacency): GeomTristripsAdjacency {.importcpp: "new GeomTristripsAdjacency(#)".}

converter getClassType*(_: typedesc[GeomTristripsAdjacency]): TypeHandle {.importcpp: "GeomTristripsAdjacency::get_class_type()", header: "geomTristripsAdjacency.h".}

proc initGeomVertexReader*(array_data: GeomVertexArrayData, current_thread: Thread): GeomVertexReader {.importcpp: "GeomVertexReader(#, #)".} ## \
## Constructs a new reader to process the vertices of the indicated array
## only.

converter initGeomVertexReader*(array_data: GeomVertexArrayData): GeomVertexReader {.importcpp: "GeomVertexReader(#)".} ## \
## Constructs a new reader to process the vertices of the indicated array
## only.

proc initGeomVertexReader*(array_data: GeomVertexArrayData, column: int, current_thread: Thread): GeomVertexReader {.importcpp: "GeomVertexReader(#, #, #)".} ## \
## Constructs a new reader to process the vertices of the indicated array
## only.

proc initGeomVertexReader*(array_data: GeomVertexArrayData, column: int): GeomVertexReader {.importcpp: "GeomVertexReader(#, #)".} ## \
## Constructs a new reader to process the vertices of the indicated array
## only.

proc initGeomVertexReader*(vertex_data: GeomVertexData, name: InternalName, current_thread: Thread): GeomVertexReader {.importcpp: "GeomVertexReader(#, #, #)".} ## \
## Constructs a new reader to process the vertices of the indicated data
## object.  This flavor creates the reader specifically to process the named
## data type.

proc initGeomVertexReader*(vertex_data: GeomVertexData, name: InternalName): GeomVertexReader {.importcpp: "GeomVertexReader(#, #)".} ## \
## Constructs a new reader to process the vertices of the indicated data
## object.  This flavor creates the reader specifically to process the named
## data type.

proc initGeomVertexReader*(vertex_data: GeomVertexData, current_thread: Thread): GeomVertexReader {.importcpp: "GeomVertexReader(#, #)".} ## \
## Constructs a new reader to process the vertices of the indicated data
## object.

converter initGeomVertexReader*(vertex_data: GeomVertexData): GeomVertexReader {.importcpp: "GeomVertexReader(#)".} ## \
## Constructs a new reader to process the vertices of the indicated data
## object.

proc initGeomVertexReader*(copy: GeomVertexReader): GeomVertexReader {.importcpp: "GeomVertexReader(#)".}

converter initGeomVertexReader*(current_thread: Thread): GeomVertexReader {.importcpp: "GeomVertexReader(#)".} ## \
## Constructs an invalid GeomVertexReader.  You must use the assignment
## operator to assign a valid GeomVertexReader to this object before you can
## use it.

proc initGeomVertexReader*(): GeomVertexReader {.importcpp: "GeomVertexReader()".} ## \
## Constructs an invalid GeomVertexReader.  You must use the assignment
## operator to assign a valid GeomVertexReader to this object before you can
## use it.

proc getVertexData*(this: GeomVertexReader): GeomVertexData {.importcpp: "#.get_vertex_data()".} ## \
## Returns the vertex data object that the reader is processing.  This may
## return NULL if the reader was constructed with just an array pointer.

proc getArrayData*(this: GeomVertexReader): GeomVertexArrayData {.importcpp: "#.get_array_data()".} ## \
## Returns the particular array object that the reader is currently
## processing.

proc getArrayHandle*(this: GeomVertexReader): GeomVertexArrayDataHandle {.importcpp: "#.get_array_handle()".} ## \
## Returns the read handle to the array object that the read is currently
## processing.  This low-level call should be used with caution.

proc getStride*(this: GeomVertexReader): clonglong {.importcpp: "#.get_stride()".} ## \
## Returns the per-row stride (bytes between consecutive rows) of the
## underlying vertex array.  This low-level information is normally not needed
## to use the GeomVertexReader directly.

proc getCurrentThread*(this: GeomVertexReader): Thread {.importcpp: "#.get_current_thread()".} ## \
## Returns the Thread pointer of the currently-executing thread, as passed to
## the constructor of this object.

proc setForce*(this: GeomVertexReader, force: bool) {.importcpp: "#.set_force(#)".} ## \
## Sets the value of the force flag.  When this is true (the default), vertex
## data will be paged in from disk if necessary.  When this is false, the
## GeomVertexData will simply return a failure code when attempting to read
## vertex data that is not resident (but will put it on the queue to become
## resident later).
##
## Normally, vertex data is always resident, so this will not be an issue.  It
## is only possible for vertex data to be nonresident if you have enabled
## vertex paging via the GeomVertexArrayData and VertexDataPage interfaces.

proc getForce*(this: GeomVertexReader): bool {.importcpp: "#.get_force()".} ## \
## Returns the value of the force flag.  See set_force().

proc setColumn*(this: GeomVertexReader, name: InternalName): bool {.importcpp: "#.set_column(#)".} ## \
## Sets up the reader to use the data type with the indicated name.
##
## This also resets the read row number to the start row (the same value
## passed to a previous call to set_row(), or 0 if set_row() was never
## called.)
##
## The return value is true if the data type is valid, false otherwise.

proc setColumn*(this: GeomVertexReader, column: int): bool {.importcpp: "#.set_column(#)".} ## \
## Sets up the reader to use the nth data type of the GeomVertexFormat,
## numbering from 0.
##
## This also resets the read row number to the start row (the same value
## passed to a previous call to set_row(), or 0 if set_row() was never
## called.)
##
## The return value is true if the data type is valid, false otherwise.

proc setColumn*(this: GeomVertexReader, array: int, column: GeomVertexColumn): bool {.importcpp: "#.set_column(#, #)".} ## \
## Sets up the reader to use the indicated column description on the given
## array.
##
## This also resets the current read row number to the start row (the same
## value passed to a previous call to set_row(), or 0 if set_row() was never
## called.)
##
## The return value is true if the data type is valid, false otherwise.

proc clear*(this: GeomVertexReader) {.importcpp: "#.clear()".} ## \
## Resets the GeomVertexReader to the initial state.

proc hasColumn*(this: GeomVertexReader): bool {.importcpp: "#.has_column()".} ## \
## Returns true if a valid data type has been successfully set, or false if
## the data type does not exist (or if get_force() is false and the vertex
## data is nonresident).

proc getArray*(this: GeomVertexReader): int {.importcpp: "#.get_array()".} ## \
## Returns the array index containing the data type that the reader is working
## on.

proc getColumn*(this: GeomVertexReader): GeomVertexColumn {.importcpp: "#.get_column()".} ## \
## Returns the description of the data type that the reader is working on.

proc setRowUnsafe*(this: GeomVertexReader, row: int) {.importcpp: "#.set_row_unsafe(#)".} ## \
## Sets the start row to the indicated value, without internal checks.  This
## is the same as set_row(), but it does not check for the possibility that
## the array has been reallocated internally for some reason; use only when
## you are confident that the array is unchanged and you really need every bit
## of available performance.

proc setRow*(this: GeomVertexReader, row: int) {.importcpp: "#.set_row(#)".} ## \
## Sets the start row to the indicated value.  The reader will begin reading
## from the indicated row; each subsequent get_data\*() call will return the
## data from the subsequent row.  If set_column() is called, the reader will
## return to this row.

proc getStartRow*(this: GeomVertexReader): int {.importcpp: "#.get_start_row()".} ## \
## Returns the row index at which the reader started.  It will return to this
## row if you reset the current column.

proc getReadRow*(this: GeomVertexReader): int {.importcpp: "#.get_read_row()".} ## \
## Returns the row index from which the data will be retrieved by the next
## call to get_data\*().

proc isAtEnd*(this: GeomVertexReader): bool {.importcpp: "#.is_at_end()".} ## \
## Returns true if the reader is currently at the end of the list of vertices,
## false otherwise.  If this is true, another call to get_data\*() will result
## in a crash.

proc getData1f*(this: GeomVertexReader): float32 {.importcpp: "#.get_data1f()".} ## \
## Returns the data associated with the read row, expressed as a 1-component
## value, and advances the read row.

proc getData2f*(this: GeomVertexReader): LVecBase2f {.importcpp: "#.get_data2f()".} ## \
## Returns the data associated with the read row, expressed as a 2-component
## value, and advances the read row.

proc getData3f*(this: GeomVertexReader): LVecBase3f {.importcpp: "#.get_data3f()".} ## \
## Returns the data associated with the read row, expressed as a 3-component
## value, and advances the read row.

proc getData4f*(this: GeomVertexReader): LVecBase4f {.importcpp: "#.get_data4f()".} ## \
## Returns the data associated with the read row, expressed as a 4-component
## value, and advances the read row.

proc getMatrix3f*(this: GeomVertexReader): LMatrix3f {.importcpp: "#.get_matrix3f()".} ## \
## Returns the 3-by-3 matrix associated with the read row and advances the
## read row.  This is a special method that only works when the column in
## question contains a matrix of an appropriate size.

proc getMatrix4f*(this: GeomVertexReader): LMatrix4f {.importcpp: "#.get_matrix4f()".} ## \
## Returns the 4-by-4 matrix associated with the read row and advances the
## read row.  This is a special method that only works when the column in
## question contains a matrix of an appropriate size.

proc getData1d*(this: GeomVertexReader): float64 {.importcpp: "#.get_data1d()".} ## \
## Returns the data associated with the read row, expressed as a 1-component
## value, and advances the read row.

proc getData2d*(this: GeomVertexReader): LVecBase2d {.importcpp: "#.get_data2d()".} ## \
## Returns the data associated with the read row, expressed as a 2-component
## value, and advances the read row.

proc getData3d*(this: GeomVertexReader): LVecBase3d {.importcpp: "#.get_data3d()".} ## \
## Returns the data associated with the read row, expressed as a 3-component
## value, and advances the read row.

proc getData4d*(this: GeomVertexReader): LVecBase4d {.importcpp: "#.get_data4d()".} ## \
## Returns the data associated with the read row, expressed as a 4-component
## value, and advances the read row.

proc getMatrix3d*(this: GeomVertexReader): LMatrix3d {.importcpp: "#.get_matrix3d()".} ## \
## Returns the 3-by-3 matrix associated with the read row and advances the
## read row.  This is a special method that only works when the column in
## question contains a matrix of an appropriate size.

proc getMatrix4d*(this: GeomVertexReader): LMatrix4d {.importcpp: "#.get_matrix4d()".} ## \
## Returns the 4-by-4 matrix associated with the read row and advances the
## read row.  This is a special method that only works when the column in
## question contains a matrix of an appropriate size.

proc getData1*(this: GeomVertexReader): float32 {.importcpp: "#.get_data1()".} ## \
## Returns the data associated with the read row, expressed as a 1-component
## value, and advances the read row.

proc getData2*(this: GeomVertexReader): LVecBase2 {.importcpp: "#.get_data2()".} ## \
## Returns the data associated with the read row, expressed as a 2-component
## value, and advances the read row.

proc getData3*(this: GeomVertexReader): LVecBase3 {.importcpp: "#.get_data3()".} ## \
## Returns the data associated with the read row, expressed as a 3-component
## value, and advances the read row.

proc getData4*(this: GeomVertexReader): LVecBase4 {.importcpp: "#.get_data4()".} ## \
## Returns the data associated with the read row, expressed as a 4-component
## value, and advances the read row.

proc getMatrix3*(this: GeomVertexReader): LMatrix3 {.importcpp: "#.get_matrix3()".} ## \
## Returns the 3-by-3 matrix associated with the read row and advances the
## read row.  This is a special method that only works when the column in
## question contains a matrix of an appropriate size.

proc getMatrix4*(this: GeomVertexReader): LMatrix4 {.importcpp: "#.get_matrix4()".} ## \
## Returns the 4-by-4 matrix associated with the read row and advances the
## read row.  This is a special method that only works when the column in
## question contains a matrix of an appropriate size.

proc getData1i*(this: GeomVertexReader): int {.importcpp: "#.get_data1i()".} ## \
## Returns the data associated with the read row, expressed as a 1-component
## value, and advances the read row.

proc getData2i*(this: GeomVertexReader): LVecBase2i {.importcpp: "#.get_data2i()".} ## \
## Returns the data associated with the read row, expressed as a 2-component
## value, and advances the read row.

proc getData3i*(this: GeomVertexReader): LVecBase3i {.importcpp: "#.get_data3i()".} ## \
## Returns the data associated with the read row, expressed as a 3-component
## value, and advances the read row.

proc getData4i*(this: GeomVertexReader): LVecBase4i {.importcpp: "#.get_data4i()".} ## \
## Returns the data associated with the read row, expressed as a 4-component
## value, and advances the read row.

proc output*(this: GeomVertexReader, `out`: ostream) {.importcpp: "#.output(#)".}

proc initGeomVertexWriter*(array_data: GeomVertexArrayData, current_thread: Thread): GeomVertexWriter {.importcpp: "GeomVertexWriter(#, #)".} ## \
## Constructs a new writer to process the vertices of the indicated array
## only.

converter initGeomVertexWriter*(array_data: GeomVertexArrayData): GeomVertexWriter {.importcpp: "GeomVertexWriter(#)".} ## \
## Constructs a new writer to process the vertices of the indicated array
## only.

proc initGeomVertexWriter*(array_data: GeomVertexArrayData, column: int, current_thread: Thread): GeomVertexWriter {.importcpp: "GeomVertexWriter(#, #, #)".} ## \
## Constructs a new writer to process the vertices of the indicated array
## only.

proc initGeomVertexWriter*(array_data: GeomVertexArrayData, column: int): GeomVertexWriter {.importcpp: "GeomVertexWriter(#, #)".} ## \
## Constructs a new writer to process the vertices of the indicated array
## only.

proc initGeomVertexWriter*(vertex_data: GeomVertexData, name: InternalName, current_thread: Thread): GeomVertexWriter {.importcpp: "GeomVertexWriter(#, #, #)".} ## \
## Constructs a new writer to process the vertices of the indicated data
## object.  This flavor creates the writer specifically to process the named
## data type.

proc initGeomVertexWriter*(vertex_data: GeomVertexData, name: InternalName): GeomVertexWriter {.importcpp: "GeomVertexWriter(#, #)".} ## \
## Constructs a new writer to process the vertices of the indicated data
## object.  This flavor creates the writer specifically to process the named
## data type.

proc initGeomVertexWriter*(vertex_data: GeomVertexData, current_thread: Thread): GeomVertexWriter {.importcpp: "GeomVertexWriter(#, #)".} ## \
## Constructs a new writer to process the vertices of the indicated data
## object.

converter initGeomVertexWriter*(vertex_data: GeomVertexData): GeomVertexWriter {.importcpp: "GeomVertexWriter(#)".} ## \
## Constructs a new writer to process the vertices of the indicated data
## object.

proc initGeomVertexWriter*(copy: GeomVertexWriter): GeomVertexWriter {.importcpp: "GeomVertexWriter(#)".}

converter initGeomVertexWriter*(current_thread: Thread): GeomVertexWriter {.importcpp: "GeomVertexWriter(#)".} ## \
## Constructs an invalid GeomVertexWriter.  You must use the assignment
## operator to assign a valid GeomVertexWriter to this object before you can
## use it.

proc initGeomVertexWriter*(): GeomVertexWriter {.importcpp: "GeomVertexWriter()".} ## \
## Constructs an invalid GeomVertexWriter.  You must use the assignment
## operator to assign a valid GeomVertexWriter to this object before you can
## use it.

proc getVertexData*(this: GeomVertexWriter): GeomVertexData {.importcpp: "#.get_vertex_data()".} ## \
## Returns the vertex data object that the writer is processing.  This may
## return NULL if the writer was constructed with just an array pointer.

proc getArrayData*(this: GeomVertexWriter): GeomVertexArrayData {.importcpp: "#.get_array_data()".} ## \
## Returns the particular array object that the writer is currently
## processing.

proc getArrayHandle*(this: GeomVertexWriter): GeomVertexArrayDataHandle {.importcpp: "#.get_array_handle()".} ## \
## Returns the write handle to the array object that the writer is currently
## processing.  This low-level call should be used with caution; be careful
## with modifying the data in the handle out from under the GeomVertexWriter.

proc getStride*(this: GeomVertexWriter): clonglong {.importcpp: "#.get_stride()".} ## \
## Returns the per-row stride (bytes between consecutive rows) of the
## underlying vertex array.  This low-level information is normally not needed
## to use the GeomVertexWriter directly.

proc getCurrentThread*(this: GeomVertexWriter): Thread {.importcpp: "#.get_current_thread()".} ## \
## Returns the Thread pointer of the currently-executing thread, as passed to
## the constructor of this object.

proc setColumn*(this: GeomVertexWriter, name: InternalName): bool {.importcpp: "#.set_column(#)".} ## \
## Sets up the writer to use the data type with the indicated name.
##
## This also resets the write number to the start row (the same value passed
## to a previous call to set_row(), or 0 if set_row() was never called.)
##
## The return value is true if the data type is valid, false otherwise.

proc setColumn*(this: GeomVertexWriter, column: int): bool {.importcpp: "#.set_column(#)".} ## \
## Sets up the writer to use the nth data type of the GeomVertexFormat,
## numbering from 0.
##
## This also resets the write row number to the start row (the same value
## passed to a previous call to set_row(), or 0 if set_row() was never
## called.)
##
## The return value is true if the data type is valid, false otherwise.

proc setColumn*(this: GeomVertexWriter, array: int, column: GeomVertexColumn): bool {.importcpp: "#.set_column(#, #)".} ## \
## Sets up the writer to use the indicated column description on the given
## array.
##
## This also resets the current write row number to the start row (the same
## value passed to a previous call to set_row(), or 0 if set_row() was never
## called.)
##
## The return value is true if the data type is valid, false otherwise.

proc clear*(this: GeomVertexWriter) {.importcpp: "#.clear()".} ## \
## Resets the GeomVertexWriter to the initial state.

proc reserveNumRows*(this: GeomVertexWriter, num_rows: int): bool {.importcpp: "#.reserve_num_rows(#)".} ## \
## This ensures that enough memory space for num_rows is allocated, so that
## you may add up to num_rows rows without causing a new memory allocation.
## This is a performance optimization only; it is especially useful when you
## know the number of rows you will be adding ahead of time.

proc hasColumn*(this: GeomVertexWriter): bool {.importcpp: "#.has_column()".} ## \
## Returns true if a valid data type has been successfully set, or false if
## the data type does not exist.

proc getArray*(this: GeomVertexWriter): int {.importcpp: "#.get_array()".} ## \
## Returns the array index containing the data type that the writer is working
## on.

proc getColumn*(this: GeomVertexWriter): GeomVertexColumn {.importcpp: "#.get_column()".} ## \
## Returns the description of the data type that the writer is working on.

proc setRowUnsafe*(this: GeomVertexWriter, row: int) {.importcpp: "#.set_row_unsafe(#)".} ## \
## Sets the start row to the indicated value, without internal checks.  This
## is the same as set_row(), but it does not check for the possibility that
## the array has been reallocated internally for some reason; use only when
## you are confident that the array is unchanged and you really need every bit
## of available performance.

proc setRow*(this: GeomVertexWriter, row: int) {.importcpp: "#.set_row(#)".} ## \
## Sets the start row to the indicated value.  The writer will begin writing
## to the indicated row; each subsequent set_data\*() call will store the data
## into the subsequent row.  If set_column() is called, the writer will return
## to this row.

proc getStartRow*(this: GeomVertexWriter): int {.importcpp: "#.get_start_row()".} ## \
## Returns the row index at which the writer started.  It will return to this
## row if you reset the current column.

proc getWriteRow*(this: GeomVertexWriter): int {.importcpp: "#.get_write_row()".} ## \
## Returns the row index to which the data will be written at the next call to
## set_data\*() or add_data\*().

proc isAtEnd*(this: GeomVertexWriter): bool {.importcpp: "#.is_at_end()".} ## \
## Returns true if the writer is currently at the end of the list of vertices,
## false otherwise.  If this is true, another call to set_data\*() will result
## in a crash, but another call to add_data\*() will add a new row.

proc setData1f*(this: GeomVertexWriter, data: float32) {.importcpp: "#.set_data1f(#)".} ## \
## Sets the write row to a particular 1-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData2f*(this: GeomVertexWriter, data: LVecBase2f) {.importcpp: "#.set_data2f(#)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData2f*(this: GeomVertexWriter, x: float32, y: float32) {.importcpp: "#.set_data2f(#, #)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData3f*(this: GeomVertexWriter, data: LVecBase3f) {.importcpp: "#.set_data3f(#)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData3f*(this: GeomVertexWriter, x: float32, y: float32, z: float32) {.importcpp: "#.set_data3f(#, #, #)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData4f*(this: GeomVertexWriter, data: LVecBase4f) {.importcpp: "#.set_data4f(#)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData4f*(this: GeomVertexWriter, x: float32, y: float32, z: float32, w: float32) {.importcpp: "#.set_data4f(#, #, #, #)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setMatrix3f*(this: GeomVertexWriter, mat: LMatrix3f) {.importcpp: "#.set_matrix3f(#)".} ## \
## Sets the write row to a 3-by-3 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## It is an error for the write row to advance past the end of data.

proc setMatrix4f*(this: GeomVertexWriter, mat: LMatrix4f) {.importcpp: "#.set_matrix4f(#)".} ## \
## Sets the write row to a 4-by-4 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## It is an error for the write row to advance past the end of data.

proc setData1d*(this: GeomVertexWriter, data: float64) {.importcpp: "#.set_data1d(#)".} ## \
## Sets the write row to a particular 1-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData2d*(this: GeomVertexWriter, data: LVecBase2d) {.importcpp: "#.set_data2d(#)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData2d*(this: GeomVertexWriter, x: float64, y: float64) {.importcpp: "#.set_data2d(#, #)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData3d*(this: GeomVertexWriter, data: LVecBase3d) {.importcpp: "#.set_data3d(#)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData3d*(this: GeomVertexWriter, x: float64, y: float64, z: float64) {.importcpp: "#.set_data3d(#, #, #)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData4d*(this: GeomVertexWriter, data: LVecBase4d) {.importcpp: "#.set_data4d(#)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData4d*(this: GeomVertexWriter, x: float64, y: float64, z: float64, w: float64) {.importcpp: "#.set_data4d(#, #, #, #)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setMatrix3d*(this: GeomVertexWriter, mat: LMatrix3d) {.importcpp: "#.set_matrix3d(#)".} ## \
## Sets the write row to a 3-by-3 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## It is an error for the write row to advance past the end of data.

proc setMatrix4d*(this: GeomVertexWriter, mat: LMatrix4d) {.importcpp: "#.set_matrix4d(#)".} ## \
## Sets the write row to a 4-by-4 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## It is an error for the write row to advance past the end of data.

proc setData1*(this: GeomVertexWriter, data: float32) {.importcpp: "#.set_data1(#)".} ## \
## Sets the write row to a particular 1-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData2*(this: GeomVertexWriter, data: LVecBase2) {.importcpp: "#.set_data2(#)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData2*(this: GeomVertexWriter, x: float32, y: float32) {.importcpp: "#.set_data2(#, #)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData3*(this: GeomVertexWriter, data: LVecBase3) {.importcpp: "#.set_data3(#)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData3*(this: GeomVertexWriter, x: float32, y: float32, z: float32) {.importcpp: "#.set_data3(#, #, #)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData4*(this: GeomVertexWriter, data: LVecBase4) {.importcpp: "#.set_data4(#)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData4*(this: GeomVertexWriter, x: float32, y: float32, z: float32, w: float32) {.importcpp: "#.set_data4(#, #, #, #)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setMatrix3*(this: GeomVertexWriter, mat: LMatrix3) {.importcpp: "#.set_matrix3(#)".} ## \
## Sets the write row to a 3-by-3 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## It is an error for the write row to advance past the end of data.

proc setMatrix4*(this: GeomVertexWriter, mat: LMatrix4) {.importcpp: "#.set_matrix4(#)".} ## \
## Sets the write row to a 4-by-4 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## It is an error for the write row to advance past the end of data.

proc setData1i*(this: GeomVertexWriter, data: int) {.importcpp: "#.set_data1i(#)".} ## \
## Sets the write row to a particular 1-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData2i*(this: GeomVertexWriter, data: LVecBase2i) {.importcpp: "#.set_data2i(#)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData2i*(this: GeomVertexWriter, a: int, b: int) {.importcpp: "#.set_data2i(#, #)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData3i*(this: GeomVertexWriter, data: LVecBase3i) {.importcpp: "#.set_data3i(#)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData3i*(this: GeomVertexWriter, a: int, b: int, c: int) {.importcpp: "#.set_data3i(#, #, #)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData4i*(this: GeomVertexWriter, data: LVecBase4i) {.importcpp: "#.set_data4i(#)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc setData4i*(this: GeomVertexWriter, a: int, b: int, c: int, d: int) {.importcpp: "#.set_data4i(#, #, #, #)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## It is an error for the write row to advance past the end of data.

proc addData1f*(this: GeomVertexWriter, data: float32) {.importcpp: "#.add_data1f(#)".} ## \
## Sets the write row to a particular 1-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData2f*(this: GeomVertexWriter, data: LVecBase2f) {.importcpp: "#.add_data2f(#)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData2f*(this: GeomVertexWriter, x: float32, y: float32) {.importcpp: "#.add_data2f(#, #)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData3f*(this: GeomVertexWriter, data: LVecBase3f) {.importcpp: "#.add_data3f(#)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData3f*(this: GeomVertexWriter, x: float32, y: float32, z: float32) {.importcpp: "#.add_data3f(#, #, #)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData4f*(this: GeomVertexWriter, data: LVecBase4f) {.importcpp: "#.add_data4f(#)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData4f*(this: GeomVertexWriter, x: float32, y: float32, z: float32, w: float32) {.importcpp: "#.add_data4f(#, #, #, #)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addMatrix3f*(this: GeomVertexWriter, mat: LMatrix3f) {.importcpp: "#.add_matrix3f(#)".} ## \
## Sets the write row to a 3-by-3 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addMatrix4f*(this: GeomVertexWriter, mat: LMatrix4f) {.importcpp: "#.add_matrix4f(#)".} ## \
## Sets the write row to a 4-by-4 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData1d*(this: GeomVertexWriter, data: float64) {.importcpp: "#.add_data1d(#)".} ## \
## Sets the write row to a particular 1-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData2d*(this: GeomVertexWriter, data: LVecBase2d) {.importcpp: "#.add_data2d(#)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData2d*(this: GeomVertexWriter, x: float64, y: float64) {.importcpp: "#.add_data2d(#, #)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData3d*(this: GeomVertexWriter, data: LVecBase3d) {.importcpp: "#.add_data3d(#)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData3d*(this: GeomVertexWriter, x: float64, y: float64, z: float64) {.importcpp: "#.add_data3d(#, #, #)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData4d*(this: GeomVertexWriter, data: LVecBase4d) {.importcpp: "#.add_data4d(#)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData4d*(this: GeomVertexWriter, x: float64, y: float64, z: float64, w: float64) {.importcpp: "#.add_data4d(#, #, #, #)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addMatrix3d*(this: GeomVertexWriter, mat: LMatrix3d) {.importcpp: "#.add_matrix3d(#)".} ## \
## Sets the write row to a 3-by-3 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addMatrix4d*(this: GeomVertexWriter, mat: LMatrix4d) {.importcpp: "#.add_matrix4d(#)".} ## \
## Sets the write row to a 4-by-4 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData1*(this: GeomVertexWriter, data: float32) {.importcpp: "#.add_data1(#)".} ## \
## Sets the write row to a particular 1-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData2*(this: GeomVertexWriter, data: LVecBase2) {.importcpp: "#.add_data2(#)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData2*(this: GeomVertexWriter, x: float32, y: float32) {.importcpp: "#.add_data2(#, #)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData3*(this: GeomVertexWriter, data: LVecBase3) {.importcpp: "#.add_data3(#)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData3*(this: GeomVertexWriter, x: float32, y: float32, z: float32) {.importcpp: "#.add_data3(#, #, #)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData4*(this: GeomVertexWriter, data: LVecBase4) {.importcpp: "#.add_data4(#)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData4*(this: GeomVertexWriter, x: float32, y: float32, z: float32, w: float32) {.importcpp: "#.add_data4(#, #, #, #)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addMatrix3*(this: GeomVertexWriter, mat: LMatrix3) {.importcpp: "#.add_matrix3(#)".} ## \
## Sets the write row to a 3-by-3 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addMatrix4*(this: GeomVertexWriter, mat: LMatrix4) {.importcpp: "#.add_matrix4(#)".} ## \
## Sets the write row to a 4-by-4 matrix, and advances the write row.  This is
## a special method that can only be used on matrix columns.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData1i*(this: GeomVertexWriter, data: int) {.importcpp: "#.add_data1i(#)".} ## \
## Sets the write row to a particular 1-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData2i*(this: GeomVertexWriter, data: LVecBase2i) {.importcpp: "#.add_data2i(#)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData2i*(this: GeomVertexWriter, a: int, b: int) {.importcpp: "#.add_data2i(#, #)".} ## \
## Sets the write row to a particular 2-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData3i*(this: GeomVertexWriter, data: LVecBase3i) {.importcpp: "#.add_data3i(#)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData3i*(this: GeomVertexWriter, a: int, b: int, c: int) {.importcpp: "#.add_data3i(#, #, #)".} ## \
## Sets the write row to a particular 3-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData4i*(this: GeomVertexWriter, data: LVecBase4i) {.importcpp: "#.add_data4i(#)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc addData4i*(this: GeomVertexWriter, a: int, b: int, c: int, d: int) {.importcpp: "#.add_data4i(#, #, #, #)".} ## \
## Sets the write row to a particular 4-component value, and advances the
## write row.
##
## If the write row advances past the end of data, implicitly adds a new row
## to the data.

proc output*(this: GeomVertexWriter, `out`: ostream) {.importcpp: "#.output(#)".}

converter upcastToGeomVertexWriter*(this: GeomVertexRewriter): GeomVertexWriter {.importcpp: "#.upcast_to_GeomVertexWriter()".}

converter upcastToGeomVertexReader*(this: GeomVertexRewriter): GeomVertexReader {.importcpp: "#.upcast_to_GeomVertexReader()".}

proc initGeomVertexRewriter*(array_data: GeomVertexArrayData, current_thread: Thread): GeomVertexRewriter {.importcpp: "GeomVertexRewriter(#, #)".} ## \
## Constructs a new rewriter to process the vertices of the indicated array
## only.

converter initGeomVertexRewriter*(array_data: GeomVertexArrayData): GeomVertexRewriter {.importcpp: "GeomVertexRewriter(#)".} ## \
## Constructs a new rewriter to process the vertices of the indicated array
## only.

proc initGeomVertexRewriter*(array_data: GeomVertexArrayData, column: int, current_thread: Thread): GeomVertexRewriter {.importcpp: "GeomVertexRewriter(#, #, #)".} ## \
## Constructs a new rewriter to process the vertices of the indicated array
## only.

proc initGeomVertexRewriter*(array_data: GeomVertexArrayData, column: int): GeomVertexRewriter {.importcpp: "GeomVertexRewriter(#, #)".} ## \
## Constructs a new rewriter to process the vertices of the indicated array
## only.

proc initGeomVertexRewriter*(vertex_data: GeomVertexData, name: InternalName, current_thread: Thread): GeomVertexRewriter {.importcpp: "GeomVertexRewriter(#, #, #)".} ## \
## Constructs a new rewriter to process the vertices of the indicated data
## object.  This flavor creates the rewriter specifically to process the named
## data type.

proc initGeomVertexRewriter*(vertex_data: GeomVertexData, name: InternalName): GeomVertexRewriter {.importcpp: "GeomVertexRewriter(#, #)".} ## \
## Constructs a new rewriter to process the vertices of the indicated data
## object.  This flavor creates the rewriter specifically to process the named
## data type.

proc initGeomVertexRewriter*(vertex_data: GeomVertexData, current_thread: Thread): GeomVertexRewriter {.importcpp: "GeomVertexRewriter(#, #)".} ## \
## Constructs a new rewriter to process the vertices of the indicated data
## object.

converter initGeomVertexRewriter*(vertex_data: GeomVertexData): GeomVertexRewriter {.importcpp: "GeomVertexRewriter(#)".} ## \
## Constructs a new rewriter to process the vertices of the indicated data
## object.

proc initGeomVertexRewriter*(copy: GeomVertexRewriter): GeomVertexRewriter {.importcpp: "GeomVertexRewriter(#)".}

converter initGeomVertexRewriter*(current_thread: Thread): GeomVertexRewriter {.importcpp: "GeomVertexRewriter(#)".} ## \
## Constructs an invalid GeomVertexRewriter.  You must use the assignment
## operator to assign a valid GeomVertexRewriter to this object before you can
## use it.

proc initGeomVertexRewriter*(): GeomVertexRewriter {.importcpp: "GeomVertexRewriter()".} ## \
## Constructs an invalid GeomVertexRewriter.  You must use the assignment
## operator to assign a valid GeomVertexRewriter to this object before you can
## use it.

proc getVertexData*(this: GeomVertexRewriter): GeomVertexData {.importcpp: "#.get_vertex_data()".} ## \
## Returns the vertex data object that the rewriter is processing.

proc getArrayData*(this: GeomVertexRewriter): GeomVertexArrayData {.importcpp: "#.get_array_data()".} ## \
## Returns the particular array object that the rewriter is currently
## processing.

proc getArrayHandle*(this: GeomVertexRewriter): GeomVertexArrayDataHandle {.importcpp: "#.get_array_handle()".} ## \
## Returns the write handle to the array object that the rewriter is currently
## processing.  This low-level call should be used with caution; be careful
## with modifying the data in the handle out from under the
## GeomVertexRewriter.

proc getStride*(this: GeomVertexRewriter): clonglong {.importcpp: "#.get_stride()".} ## \
## Returns the per-row stride (bytes between consecutive rows) of the
## underlying vertex array.  This low-level information is normally not needed
## to use the GeomVertexRewriter directly.

proc getCurrentThread*(this: GeomVertexRewriter): Thread {.importcpp: "#.get_current_thread()".} ## \
## Returns the Thread pointer of the currently-executing thread, as passed to
## the constructor of this object.

proc setColumn*(this: GeomVertexRewriter, name: InternalName): bool {.importcpp: "#.set_column(#)".} ## \
## Sets up the rewriter to use the data type with the indicated name.
##
## This also resets both the read and write row numbers to the start row (the
## same value passed to a previous call to set_row(), or 0 if set_row() was
## never called.)
##
## The return value is true if the data type is valid, false otherwise.

proc setColumn*(this: GeomVertexRewriter, column: int): bool {.importcpp: "#.set_column(#)".} ## \
## Sets up the rewriter to use the nth data type of the GeomVertexFormat,
## numbering from 0.
##
## This also resets both the read and write row numbers to the start row (the
## same value passed to a previous call to set_row(), or 0 if set_row() was
## never called.)
##
## The return value is true if the data type is valid, false otherwise.

proc setColumn*(this: GeomVertexRewriter, array: int, column: GeomVertexColumn): bool {.importcpp: "#.set_column(#, #)".} ## \
## Sets up the rewriter to use the indicated column description on the given
## array.
##
## This also resets both the read and write row numbers to the start row (the
## same value passed to a previous call to set_row(), or 0 if set_row() was
## never called.)
##
## The return value is true if the data type is valid, false otherwise.

proc clear*(this: GeomVertexRewriter) {.importcpp: "#.clear()".} ## \
## Resets the GeomVertexRewriter to the initial state.

proc hasColumn*(this: GeomVertexRewriter): bool {.importcpp: "#.has_column()".} ## \
## Returns true if a valid data type has been successfully set, or false if
## the data type does not exist.

proc getArray*(this: GeomVertexRewriter): int {.importcpp: "#.get_array()".} ## \
## Returns the array index containing the data type that the rewriter is
## working on.

proc getColumn*(this: GeomVertexRewriter): GeomVertexColumn {.importcpp: "#.get_column()".} ## \
## Returns the description of the data type that the rewriter is working on.

proc setRowUnsafe*(this: GeomVertexRewriter, row: int) {.importcpp: "#.set_row_unsafe(#)".} ## \
## Sets the start row to the indicated value, without internal checks.  This
## is the same as set_row(), but it does not check for the possibility that
## the array has been reallocated internally for some reason; use only when
## you are confident that the array is unchanged and you really need every bit
## of available performance.

proc setRow*(this: GeomVertexRewriter, row: int) {.importcpp: "#.set_row(#)".} ## \
## Sets the start, write, and write index to the indicated value.  The
## rewriter will begin traversing from the given row.

proc getStartRow*(this: GeomVertexRewriter): int {.importcpp: "#.get_start_row()".} ## \
## Returns the row index at which the rewriter started.  It will return to
## this row if you reset the current column.

proc isAtEnd*(this: GeomVertexRewriter): bool {.importcpp: "#.is_at_end()".} ## \
## Returns true if the reader or writer is currently at the end of the list of
## vertices, false otherwise.

proc output*(this: GeomVertexRewriter, `out`: ostream) {.importcpp: "#.output(#)".}

proc initSamplerState*(): SamplerState {.importcpp: "SamplerState()".} ## \
## Creates a new SamplerState initialized to the default values.

proc initSamplerState*(param0: SamplerState): SamplerState {.importcpp: "SamplerState(#)".}

proc getDefault*(_: typedesc[SamplerState]): SamplerState {.importcpp: "SamplerState::get_default()", header: "samplerState.h".} ## \
## Returns a reference to the global default immutable SamplerState object.

proc setAnisotropicDegree*(this: SamplerState, anisotropic_degree: int) {.importcpp: "#.set_anisotropic_degree(#)".} ## \
## Specifies the level of anisotropic filtering to apply to the SamplerState.
## Set this 0 to indicate the default value, which is specified in the
## SamplerState-anisotropic-degree config variable.
##
## To explicitly disable anisotropic filtering, set this value to 1.  To
## explicitly enable anisotropic filtering, set it to a value higher than 1;
## larger numbers indicate greater degrees of filtering.

proc setBorderColor*(this: SamplerState, color: LColor) {.importcpp: "#.set_border_color(#)".} ## \
## Specifies the solid color of the SamplerState's border.  Some OpenGL
## implementations use a border for tiling SamplerStates; in Panda, it is only
## used for specifying the clamp color.

proc setMinLod*(this: SamplerState, min_lod: float32) {.importcpp: "#.set_min_lod(#)".} ## \
## Sets the minimum level of detail that will be used when sampling this
## texture.  This may be a negative value.

proc setMaxLod*(this: SamplerState, max_lod: float32) {.importcpp: "#.set_max_lod(#)".} ## \
## Sets the maximum level of detail that will be used when sampling this
## texture.  This may exceed the number of mipmap levels that the texture has.

proc setLodBias*(this: SamplerState, lod_bias: float32) {.importcpp: "#.set_lod_bias(#)".} ## \
## Sets the value that will be added to the level of detail when sampling the
## texture.  This may be a negative value, although some graphics hardware may
## not support the use of negative LOD values.

proc getAnisotropicDegree*(this: SamplerState): int {.importcpp: "#.get_anisotropic_degree()".} ## \
## Returns the degree of anisotropic filtering that should be applied to the
## texture.  This value may return 0, indicating the default value; see also
## get_effective_anisotropic_degree.

proc getEffectiveAnisotropicDegree*(this: SamplerState): int {.importcpp: "#.get_effective_anisotropic_degree()".} ## \
## Returns the degree of anisotropic filtering that should be applied to the
## texture.  This value will normally not return 0, unless there is an error
## in the config file.

proc getBorderColor*(this: SamplerState): LColor {.importcpp: "#.get_border_color()".} ## \
## Returns the solid color of the texture's border.  Some OpenGL
## implementations use a border for tiling textures; in Panda, it is only used
## for specifying the clamp color.

proc getMinLod*(this: SamplerState): float32 {.importcpp: "#.get_min_lod()".} ## \
## Returns the minimum level of detail that will be observed when sampling
## this texture.

proc getMaxLod*(this: SamplerState): float32 {.importcpp: "#.get_max_lod()".} ## \
## Returns the maximum level of detail that will be observed when sampling
## this texture.

proc getLodBias*(this: SamplerState): float32 {.importcpp: "#.get_lod_bias()".} ## \
## Returns the bias that will be added to the texture level of detail when
## sampling this texture.

proc usesMipmaps*(this: SamplerState): bool {.importcpp: "#.uses_mipmaps()".} ## \
## Returns true if the minfilter settings on this sampler indicate the use of
## mipmapping, false otherwise.

proc `==`*(this: SamplerState, other: SamplerState): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: SamplerState, other: SamplerState): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: SamplerState, other: SamplerState): bool {.importcpp: "#.operator <(#)".}

proc prepare*(this: SamplerState, prepared_objects: PreparedGraphicsObjects) {.importcpp: "#.prepare(#)".} ## \
## Indicates that the sampler should be enqueued to be prepared in the
## indicated prepared_objects at the beginning of the next frame.
##
## Use this function instead of prepare_now() to preload samplers from a user
## interface standpoint.

proc isPrepared*(this: SamplerState, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#.is_prepared(#)".} ## \
## Returns true if the sampler has already been prepared or enqueued for
## preparation on the indicated GSG, false otherwise.

proc release*(this: SamplerState, prepared_objects: PreparedGraphicsObjects) {.importcpp: "#.release(#)".} ## \
## Frees the texture context only on the indicated object, if it exists there.
## Returns true if it was released, false if it had not been prepared.

converter getClassType*(_: typedesc[SamplerState]): TypeHandle {.importcpp: "SamplerState::get_class_type()", header: "samplerState.h".}

converter upcastToTypedWritableReferenceCount*(this: Texture): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcastToNamable*(this: Texture): Namable {.importcpp: "((Namable *)(Texture *)(#))".}

proc newTexture*(name: string): Texture {.importcpp: "new Texture(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Constructs an empty texture.  The default is to set up the texture as an
## empty 2-d texture; follow up with one of the variants of setup_texture() if
## this is not what you want.

proc newTexture*(): Texture {.importcpp: "new Texture()".} ## \
## Constructs an empty texture.  The default is to set up the texture as an
## empty 2-d texture; follow up with one of the variants of setup_texture() if
## this is not what you want.

proc makeCopy*(this: Texture): Texture {.importcpp: "#->make_copy()".} ## \
## Returns a new copy of the same Texture.  This copy, if applied to geometry,
## will be copied into texture as a separate texture from the original, so it
## will be duplicated in texture memory (and may be independently modified if
## desired).
##
## If the Texture is a VideoTexture, the resulting duplicate may be animated
## independently of the original.

proc clear*(this: Texture) {.importcpp: "#->clear()".} ## \
## Reinitializes the texture to its default, empty state (except for the
## name).

proc setup1dTexture*(this: Texture) {.importcpp: "#->setup_1d_texture()".} ## \
## Sets the texture as an empty 1-d texture with no dimensions.  Follow up
## with read() or load() to fill the texture properties and image data, or use
## set_clear_color to let the texture be cleared to a solid color.

proc setup2dTexture*(this: Texture) {.importcpp: "#->setup_2d_texture()".} ## \
## Sets the texture as an empty 2-d texture with no dimensions.  Follow up
## with read() or load() to fill the texture properties and image data, or use
## set_clear_color to let the texture be cleared to a solid color.

proc setup3dTexture*(this: Texture, z_size: int) {.importcpp: "#->setup_3d_texture(#)".} ## \
## Sets the texture as an empty 3-d texture with no dimensions (though if you
## know the depth ahead of time, it saves a bit of reallocation later). Follow
## up with read() or load() to fill the texture properties and image data, or
## use set_clear_color to let the texture be cleared to a solid color.

proc setup3dTexture*(this: Texture) {.importcpp: "#->setup_3d_texture()".} ## \
## Sets the texture as an empty 3-d texture with no dimensions (though if you
## know the depth ahead of time, it saves a bit of reallocation later). Follow
## up with read() or load() to fill the texture properties and image data, or
## use set_clear_color to let the texture be cleared to a solid color.

proc setupCubeMap*(this: Texture) {.importcpp: "#->setup_cube_map()".} ## \
## Sets the texture as an empty cube map texture with no dimensions.  Follow
## up with read() or load() to fill the texture properties and image data, or
## use set_clear_color to let the texture be cleared to a solid color.

proc setup2dTextureArray*(this: Texture, z_size: int) {.importcpp: "#->setup_2d_texture_array(#)".} ## \
## Sets the texture as an empty 2-d texture array with no dimensions (though
## if you know the depth ahead of time, it saves a bit of reallocation later).
## Follow up with read() or load() to fill the texture properties and image
## data, or use set_clear_color to let the texture be cleared to a solid
## color.

proc setup2dTextureArray*(this: Texture) {.importcpp: "#->setup_2d_texture_array()".} ## \
## Sets the texture as an empty 2-d texture array with no dimensions (though
## if you know the depth ahead of time, it saves a bit of reallocation later).
## Follow up with read() or load() to fill the texture properties and image
## data, or use set_clear_color to let the texture be cleared to a solid
## color.

proc setupCubeMapArray*(this: Texture, num_cube_maps: int) {.importcpp: "#->setup_cube_map_array(#)".} ## \
## Sets the texture as cube map array with N cube maps.  Note that this number
## is not the same as the z_size.  Follow up with read() or load() to fill the
## texture properties and image data, or use set_clear_color to let the
## texture be cleared to a solid color.
##
## @since 1.10.0

proc generateNormalizationCubeMap*(this: Texture, size: int) {.importcpp: "#->generate_normalization_cube_map(#)".} ## \
## Generates a special cube map image in the texture that can be used to apply
## bump mapping effects: for each texel in the cube map that is indexed by the
## 3-d texture coordinates (x, y, z), the resulting value is the normalized
## vector (x, y, z) (compressed from -1..1 into 0..1).

proc generateAlphaScaleMap*(this: Texture) {.importcpp: "#->generate_alpha_scale_map()".} ## \
## Generates a special 256x1 1-d texture that can be used to apply an
## arbitrary alpha scale to objects by judicious use of texture matrix.  The
## texture is a gradient, with an alpha of 0 on the left (U = 0), and 255 on
## the right (U = 1).

proc clearImage*(this: Texture) {.importcpp: "#->clear_image()".} ## \
## Clears the texture data without changing its format or resolution.  The
## texture is cleared on both the graphics hardware and from RAM, unlike
## clear_ram_image, which only removes the data from RAM.
##
## If a clear color has been specified using set_clear_color, the texture will
## be cleared using a solid color.
##
## The texture data will be cleared the first time in which the texture is
## used after this method is called.

proc hasClearColor*(this: Texture): bool {.importcpp: "#->has_clear_color()".} ## \
## Returns true if a color was previously set using set_clear_color.

proc getClearColor*(this: Texture): LColor {.importcpp: "#->get_clear_color()".} ## \
## Returns the color that was previously set using set_clear_color.

proc setClearColor*(this: Texture, color: LColor) {.importcpp: "#->set_clear_color(#)".} ## \
## Sets the color that will be used to fill the texture image in absence of
## any image data.  It is used when any of the setup_texture functions or
## clear_image is called and image data is not provided using read() or
## modify_ram_image().
##
## This does not affect a texture that has already been cleared; call
## clear_image to clear it again.

proc clearClearColor*(this: Texture) {.importcpp: "#->clear_clear_color()".} ## \
## The opposite of set_clear_color.  If the image is cleared after setting
## this, its contents may be undefined (or may in fact not be cleared at all).

proc read*(this: Texture, fullpath: Filename, alpha_fullpath: Filename, primary_file_num_channels: int, alpha_file_channel: int, options: LoaderOptions): bool {.importcpp: "#->read(#, #, #, #, #)".} ## \
## Combine a 3-component image with a grayscale image to get a 4-component
## image.
##
## See the description of the full-parameter read() method for the meaning of
## the primary_file_num_channels and alpha_file_channel parameters.

proc read*(this: Texture, fullpath: Filename, alpha_fullpath: Filename, primary_file_num_channels: int, alpha_file_channel: int): bool {.importcpp: "#->read(#, #, #, #)".} ## \
## Combine a 3-component image with a grayscale image to get a 4-component
## image.
##
## See the description of the full-parameter read() method for the meaning of
## the primary_file_num_channels and alpha_file_channel parameters.

proc read*(this: Texture, fullpath: Filename, alpha_fullpath: Filename, primary_file_num_channels: int, alpha_file_channel: int, z: int, n: int, read_pages: bool, read_mipmaps: bool, record: BamCacheRecord, options: LoaderOptions): bool {.importcpp: "#->read(#, #, #, #, #, #, #, #, #, #)".} ## \
## Reads the texture from the indicated filename.  If
## primary_file_num_channels is not 0, it specifies the number of components
## to downgrade the image to if it is greater than this number.
##
## If the filename has the extension .txo, this implicitly reads a texture
## object instead of a filename (which replaces all of the texture
## properties).  In this case, all the rest of the parameters are ignored, and
## the filename should not contain any hash marks; just the one named file
## will be read, since a single .txo file can contain all pages and mipmaps
## necessary to define a texture.
##
## If alpha_fullpath is not empty, it specifies the name of a file from which
## to retrieve the alpha.  In this case, alpha_file_channel represents the
## numeric channel of this image file to use as the resulting texture's alpha
## channel; usually, this is 0 to indicate the grayscale combination of r, g,
## b; or it may be a one-based channel number, e.g.  1 for the red channel, 2
## for the green channel, and so on.
##
## If read pages is false, then z indicates the page number into which this
## image will be assigned.  Normally this is 0 for the first (or only) page of
## the texture.  3-D textures have one page for each level of depth, and cube
## map textures always have six pages.
##
## If read_pages is true, multiple images will be read at once, one for each
## page of a cube map or a 3-D texture.  In this case, the filename should
## contain a sequence of one or more hash marks ("#") which will be filled in
## with the z value of each page, zero-based.  In this case, the z parameter
## indicates the maximum z value that will be loaded, or 0 to load all
## filenames that exist.
##
## If read_mipmaps is false, then n indicates the mipmap level to which this
## image will be assigned.  Normally this is 0 for the base texture image, but
## it is possible to load custom mipmap levels into the later images.  After
## the base texture image is loaded (thus defining the size of the texture),
## you can call get_expected_num_mipmap_levels() to determine the maximum
## sensible value for n.
##
## If read_mipmaps is true, multiple images will be read as above, but this
## time the images represent the different mipmap levels of the texture image.
## In this case, the n parameter indicates the maximum n value that will be
## loaded, or 0 to load all filenames that exist (up to the expected number of
## mipmap levels).
##
## If both read_pages and read_mipmaps is true, then both sequences will be
## read; the filename should contain two sequences of hash marks, separated by
## some character such as a hyphen, underscore, or dot.  The first hash mark
## sequence will be filled in with the mipmap level, while the second hash
## mark sequence will be the page index.
##
## This method implicitly sets keep_ram_image to false.

proc read*(this: Texture, fullpath: Filename, alpha_fullpath: Filename, primary_file_num_channels: int, alpha_file_channel: int, z: int, n: int, read_pages: bool, read_mipmaps: bool, record: BamCacheRecord): bool {.importcpp: "#->read(#, #, #, #, #, #, #, #, #)".} ## \
## Reads the texture from the indicated filename.  If
## primary_file_num_channels is not 0, it specifies the number of components
## to downgrade the image to if it is greater than this number.
##
## If the filename has the extension .txo, this implicitly reads a texture
## object instead of a filename (which replaces all of the texture
## properties).  In this case, all the rest of the parameters are ignored, and
## the filename should not contain any hash marks; just the one named file
## will be read, since a single .txo file can contain all pages and mipmaps
## necessary to define a texture.
##
## If alpha_fullpath is not empty, it specifies the name of a file from which
## to retrieve the alpha.  In this case, alpha_file_channel represents the
## numeric channel of this image file to use as the resulting texture's alpha
## channel; usually, this is 0 to indicate the grayscale combination of r, g,
## b; or it may be a one-based channel number, e.g.  1 for the red channel, 2
## for the green channel, and so on.
##
## If read pages is false, then z indicates the page number into which this
## image will be assigned.  Normally this is 0 for the first (or only) page of
## the texture.  3-D textures have one page for each level of depth, and cube
## map textures always have six pages.
##
## If read_pages is true, multiple images will be read at once, one for each
## page of a cube map or a 3-D texture.  In this case, the filename should
## contain a sequence of one or more hash marks ("#") which will be filled in
## with the z value of each page, zero-based.  In this case, the z parameter
## indicates the maximum z value that will be loaded, or 0 to load all
## filenames that exist.
##
## If read_mipmaps is false, then n indicates the mipmap level to which this
## image will be assigned.  Normally this is 0 for the base texture image, but
## it is possible to load custom mipmap levels into the later images.  After
## the base texture image is loaded (thus defining the size of the texture),
## you can call get_expected_num_mipmap_levels() to determine the maximum
## sensible value for n.
##
## If read_mipmaps is true, multiple images will be read as above, but this
## time the images represent the different mipmap levels of the texture image.
## In this case, the n parameter indicates the maximum n value that will be
## loaded, or 0 to load all filenames that exist (up to the expected number of
## mipmap levels).
##
## If both read_pages and read_mipmaps is true, then both sequences will be
## read; the filename should contain two sequences of hash marks, separated by
## some character such as a hyphen, underscore, or dot.  The first hash mark
## sequence will be filled in with the mipmap level, while the second hash
## mark sequence will be the page index.
##
## This method implicitly sets keep_ram_image to false.

proc read*(this: Texture, fullpath: Filename, alpha_fullpath: Filename, primary_file_num_channels: int, alpha_file_channel: int, z: int, n: int, read_pages: bool, read_mipmaps: bool): bool {.importcpp: "#->read(#, #, #, #, #, #, #, #)".} ## \
## Reads the texture from the indicated filename.  If
## primary_file_num_channels is not 0, it specifies the number of components
## to downgrade the image to if it is greater than this number.
##
## If the filename has the extension .txo, this implicitly reads a texture
## object instead of a filename (which replaces all of the texture
## properties).  In this case, all the rest of the parameters are ignored, and
## the filename should not contain any hash marks; just the one named file
## will be read, since a single .txo file can contain all pages and mipmaps
## necessary to define a texture.
##
## If alpha_fullpath is not empty, it specifies the name of a file from which
## to retrieve the alpha.  In this case, alpha_file_channel represents the
## numeric channel of this image file to use as the resulting texture's alpha
## channel; usually, this is 0 to indicate the grayscale combination of r, g,
## b; or it may be a one-based channel number, e.g.  1 for the red channel, 2
## for the green channel, and so on.
##
## If read pages is false, then z indicates the page number into which this
## image will be assigned.  Normally this is 0 for the first (or only) page of
## the texture.  3-D textures have one page for each level of depth, and cube
## map textures always have six pages.
##
## If read_pages is true, multiple images will be read at once, one for each
## page of a cube map or a 3-D texture.  In this case, the filename should
## contain a sequence of one or more hash marks ("#") which will be filled in
## with the z value of each page, zero-based.  In this case, the z parameter
## indicates the maximum z value that will be loaded, or 0 to load all
## filenames that exist.
##
## If read_mipmaps is false, then n indicates the mipmap level to which this
## image will be assigned.  Normally this is 0 for the base texture image, but
## it is possible to load custom mipmap levels into the later images.  After
## the base texture image is loaded (thus defining the size of the texture),
## you can call get_expected_num_mipmap_levels() to determine the maximum
## sensible value for n.
##
## If read_mipmaps is true, multiple images will be read as above, but this
## time the images represent the different mipmap levels of the texture image.
## In this case, the n parameter indicates the maximum n value that will be
## loaded, or 0 to load all filenames that exist (up to the expected number of
## mipmap levels).
##
## If both read_pages and read_mipmaps is true, then both sequences will be
## read; the filename should contain two sequences of hash marks, separated by
## some character such as a hyphen, underscore, or dot.  The first hash mark
## sequence will be filled in with the mipmap level, while the second hash
## mark sequence will be the page index.
##
## This method implicitly sets keep_ram_image to false.

proc read*(this: Texture, fullpath: Filename, options: LoaderOptions): bool {.importcpp: "#->read(#, #)".} ## \
## Reads the named filename into the texture.

proc read*(this: Texture, fullpath: Filename): bool {.importcpp: "#->read(#)".} ## \
## Reads the named filename into the texture.

proc read*(this: Texture, fullpath: Filename, z: int, n: int, read_pages: bool, read_mipmaps: bool, options: LoaderOptions): bool {.importcpp: "#->read(#, #, #, #, #, #)".} ## \
## Reads a single file into a single page or mipmap level, or automatically
## reads a series of files into a series of pages and/or mipmap levels.
##
## See the description of the full-parameter read() method for the meaning of
## the various parameters.

proc read*(this: Texture, fullpath: Filename, z: int, n: int, read_pages: bool, read_mipmaps: bool): bool {.importcpp: "#->read(#, #, #, #, #)".} ## \
## Reads a single file into a single page or mipmap level, or automatically
## reads a series of files into a series of pages and/or mipmap levels.
##
## See the description of the full-parameter read() method for the meaning of
## the various parameters.

proc write*(this: Texture, fullpath: Filename): bool {.importcpp: "#->write(#)".} ## \
## Writes the texture to the named filename.

proc write*(this: Texture, fullpath: Filename, z: int, n: int, write_pages: bool, write_mipmaps: bool): bool {.importcpp: "#->write(#, #, #, #, #)".} ## \
## Writes a single page or mipmap level to a single file, or automatically
## writes a series of pages and/or mipmap levels to a numbered series of
## files.
##
## If the filename ends in the extension .txo, this implicitly writes a Panda
## texture object (.txo) instead of an image file.  In this case, the
## remaining parameters are ignored, and only one file is written, which will
## contain all of the pages and resident mipmap levels in the texture.
##
## If write_pages is false, then z indicates the page number to write.  3-D
## textures have one page number for each level of depth; cube maps have six
## pages number 0 through 5.  Other kinds of textures have only one page,
## numbered 0.  If there are multiple views, the range of z is increased; the
## total range is [0, get_num_pages()).
##
## If write_pages is true, then all pages of the texture will be written.  In
## this case z is ignored, and the filename should contain a sequence of hash
## marks ("#") which will be filled in with the page index number.
##
## If write_mipmaps is false, then n indicates the mipmap level number to
## write.  Normally, this is 0, for the base texture image.  Normally, the
## mipmap levels of a texture are not available in RAM (they are generated
## automatically by the graphics card). However, if you have the mipmap levels
## available, for instance because you called generate_ram_mipmap_images() to
## generate them internally, or you called
## GraphicsEngine::extract_texture_data() to retrieve them from the graphics
## card, then you may write out each mipmap level with this parameter.
##
## If write_mipmaps is true, then all mipmap levels of the texture will be
## written.  In this case n is ignored, and the filename should contain a
## sequence of hash marks ("#") which will be filled in with the mipmap level
## number.
##
## If both write_pages and write_mipmaps is true, then all pages and all
## mipmap levels will be written.  In this case, the filename should contain
## two different sequences of hash marks, separated by a character such as a
## hyphen, underscore, or dot.  The first hash mark sequence will be filled in
## with the mipmap level, while the second hash mark sequence will be the page
## index.

proc readTxo*(this: Texture, `in`: istream, filename: string): bool {.importcpp: "#->read_txo(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Reads the texture from a Panda texture object.  This defines the complete
## Texture specification, including the image data as well as all texture
## properties.  This only works if the txo file contains a static Texture
## image, as opposed to a subclass of Texture such as a movie texture.
##
## Pass a real filename if it is available, or empty string if it is not.

proc readTxo*(this: Texture, `in`: istream): bool {.importcpp: "#->read_txo(#)".} ## \
## Reads the texture from a Panda texture object.  This defines the complete
## Texture specification, including the image data as well as all texture
## properties.  This only works if the txo file contains a static Texture
## image, as opposed to a subclass of Texture such as a movie texture.
##
## Pass a real filename if it is available, or empty string if it is not.

proc makeFromTxo*(_: typedesc[Texture], `in`: istream, filename: string): Texture {.importcpp: "#Texture::make_from_txo(#, nimStringToStdString(#))", header: "texture.h".} ## \
## Constructs a new Texture object from the txo file.  This is similar to
## Texture::read_txo(), but it constructs and returns a new object, which
## allows it to return a subclass of Texture (for instance, a movie texture).
##
## Pass a real filename if it is available, or empty string if it is not.

proc makeFromTxo*(_: typedesc[Texture], `in`: istream): Texture {.importcpp: "#Texture::make_from_txo(#)", header: "texture.h".} ## \
## Constructs a new Texture object from the txo file.  This is similar to
## Texture::read_txo(), but it constructs and returns a new object, which
## allows it to return a subclass of Texture (for instance, a movie texture).
##
## Pass a real filename if it is available, or empty string if it is not.

proc writeTxo*(this: Texture, `out`: ostream, filename: string): bool {.importcpp: "#->write_txo(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Writes the texture to a Panda texture object.  This defines the complete
## Texture specification, including the image data as well as all texture
## properties.
##
## The filename is just for reference.

proc writeTxo*(this: Texture, `out`: ostream): bool {.importcpp: "#->write_txo(#)".} ## \
## Writes the texture to a Panda texture object.  This defines the complete
## Texture specification, including the image data as well as all texture
## properties.
##
## The filename is just for reference.

proc readDds*(this: Texture, `in`: istream, filename: string, header_only: bool): bool {.importcpp: "#->read_dds(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Reads the texture from a DDS file object.  This is a Microsoft-defined file
## format; it is similar in principle to a txo object, in that it is designed
## to contain the texture image in a form as similar as possible to its
## runtime image, and it can contain mipmaps, pre-compressed textures, and so
## on.
##
## As with read_txo, the filename is just for reference.

proc readDds*(this: Texture, `in`: istream, filename: string): bool {.importcpp: "#->read_dds(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Reads the texture from a DDS file object.  This is a Microsoft-defined file
## format; it is similar in principle to a txo object, in that it is designed
## to contain the texture image in a form as similar as possible to its
## runtime image, and it can contain mipmaps, pre-compressed textures, and so
## on.
##
## As with read_txo, the filename is just for reference.

proc readDds*(this: Texture, `in`: istream): bool {.importcpp: "#->read_dds(#)".} ## \
## Reads the texture from a DDS file object.  This is a Microsoft-defined file
## format; it is similar in principle to a txo object, in that it is designed
## to contain the texture image in a form as similar as possible to its
## runtime image, and it can contain mipmaps, pre-compressed textures, and so
## on.
##
## As with read_txo, the filename is just for reference.

proc readKtx*(this: Texture, `in`: istream, filename: string, header_only: bool): bool {.importcpp: "#->read_ktx(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Reads the texture from a KTX file object.  This is a Khronos-defined file
## format; it is similar in principle to a dds object, in that it is designed
## to contain the texture image in a form as similar as possible to its
## runtime image, and it can contain mipmaps, pre-compressed textures, and so
## on.
##
## As with read_dds, the filename is just for reference.

proc readKtx*(this: Texture, `in`: istream, filename: string): bool {.importcpp: "#->read_ktx(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Reads the texture from a KTX file object.  This is a Khronos-defined file
## format; it is similar in principle to a dds object, in that it is designed
## to contain the texture image in a form as similar as possible to its
## runtime image, and it can contain mipmaps, pre-compressed textures, and so
## on.
##
## As with read_dds, the filename is just for reference.

proc readKtx*(this: Texture, `in`: istream): bool {.importcpp: "#->read_ktx(#)".} ## \
## Reads the texture from a KTX file object.  This is a Khronos-defined file
## format; it is similar in principle to a dds object, in that it is designed
## to contain the texture image in a form as similar as possible to its
## runtime image, and it can contain mipmaps, pre-compressed textures, and so
## on.
##
## As with read_dds, the filename is just for reference.

proc load*(this: Texture, pnmimage: PNMImage, options: LoaderOptions): bool {.importcpp: "#->load(#, #)".} ## \
## Replaces the texture with the indicated image.

proc load*(this: Texture, pnmimage: PNMImage): bool {.importcpp: "#->load(#)".} ## \
## Replaces the texture with the indicated image.

proc load*(this: Texture, pnmimage: PNMImage, z: int, n: int, options: LoaderOptions): bool {.importcpp: "#->load(#, #, #, #)".} ## \
## Stores the indicated image in the given page and mipmap level.  See read().

proc load*(this: Texture, pnmimage: PNMImage, z: int, n: int): bool {.importcpp: "#->load(#, #, #)".} ## \
## Stores the indicated image in the given page and mipmap level.  See read().

proc load*(this: Texture, pfm: PfmFile, options: LoaderOptions): bool {.importcpp: "#->load(#, #)".} ## \
## Replaces the texture with the indicated image.

proc load*(this: Texture, pfm: PfmFile): bool {.importcpp: "#->load(#)".} ## \
## Replaces the texture with the indicated image.

proc load*(this: Texture, pfm: PfmFile, z: int, n: int, options: LoaderOptions): bool {.importcpp: "#->load(#, #, #, #)".} ## \
## Stores the indicated image in the given page and mipmap level.  See read().

proc load*(this: Texture, pfm: PfmFile, z: int, n: int): bool {.importcpp: "#->load(#, #, #)".} ## \
## Stores the indicated image in the given page and mipmap level.  See read().

proc loadSubImage*(this: Texture, pnmimage: PNMImage, x: int, y: int, z: int, n: int): bool {.importcpp: "#->load_sub_image(#, #, #, #, #)".} ## \
## Stores the indicated image in a region of the texture.  The texture
## properties remain unchanged.  This can be more efficient than updating an
## entire texture, but has a few restrictions: for one, you must ensure that
## the texture is still in RAM (eg.  using set_keep_ram_image) and it may not
## be compressed.

proc loadSubImage*(this: Texture, pnmimage: PNMImage, x: int, y: int, z: int): bool {.importcpp: "#->load_sub_image(#, #, #, #)".} ## \
## Stores the indicated image in a region of the texture.  The texture
## properties remain unchanged.  This can be more efficient than updating an
## entire texture, but has a few restrictions: for one, you must ensure that
## the texture is still in RAM (eg.  using set_keep_ram_image) and it may not
## be compressed.

proc loadSubImage*(this: Texture, pnmimage: PNMImage, x: int, y: int): bool {.importcpp: "#->load_sub_image(#, #, #)".} ## \
## Stores the indicated image in a region of the texture.  The texture
## properties remain unchanged.  This can be more efficient than updating an
## entire texture, but has a few restrictions: for one, you must ensure that
## the texture is still in RAM (eg.  using set_keep_ram_image) and it may not
## be compressed.

proc store*(this: Texture, pnmimage: PNMImage): bool {.importcpp: "#->store(#)".} ## \
## Saves the texture to the indicated PNMImage, but does not write it to disk.

proc store*(this: Texture, pnmimage: PNMImage, z: int, n: int): bool {.importcpp: "#->store(#, #, #)".} ## \
## Saves the indicated page and mipmap level of the texture to the PNMImage.

proc store*(this: Texture, pfm: PfmFile): bool {.importcpp: "#->store(#)".} ## \
## Saves the texture to the indicated PfmFile, but does not write it to disk.

proc store*(this: Texture, pfm: PfmFile, z: int, n: int): bool {.importcpp: "#->store(#, #, #)".} ## \
## Saves the indicated page and mipmap level of the texture to the PfmFile.

proc reload*(this: Texture): bool {.importcpp: "#->reload()".} ## \
## Re-reads the Texture from its disk file.  Useful when you know the image on
## disk has recently changed, and you want to update the Texture image.
##
## Returns true on success, false on failure (in which case, the Texture may
## or may not still be valid).

proc loadRelated*(this: Texture, suffix: InternalName): Texture {.importcpp: "#->load_related(#)".} ## \
## Loads a texture whose filename is derived by concatenating a suffix to the
## filename of this texture.  May return NULL, for example, if this texture
## doesn't have a filename.

proc hasFilename*(this: Texture): bool {.importcpp: "#->has_filename()".} ## \
## Returns true if the filename has been set and is available.  See
## set_filename().

proc getFilename*(this: Texture): Filename {.importcpp: "#->get_filename()".} ## \
## Returns the filename that has been set.  This is the name of the file as it
## was requested.  Also see get_fullpath().

proc setFilename*(this: Texture, filename: Filename) {.importcpp: "#->set_filename(#)".} ## \
## Sets the name of the file that contains the image's contents.  Normally,
## this is set automatically when the image is loaded, for instance via
## Texture::read().
##
## The Texture's get_name() function used to return the filename, but now
## returns just the basename (without the extension), which is a more useful
## name for identifying an image in show code.

proc clearFilename*(this: Texture) {.importcpp: "#->clear_filename()".} ## \
## Removes the alpha filename, if it was previously set.  See set_filename().

proc hasAlphaFilename*(this: Texture): bool {.importcpp: "#->has_alpha_filename()".} ## \
## Returns true if the alpha_filename has been set and is available.  See
## set_alpha_filename().

proc getAlphaFilename*(this: Texture): Filename {.importcpp: "#->get_alpha_filename()".} ## \
## Returns the alpha_filename that has been set.  If this is set, it
## represents the name of the alpha component, which is stored in a separate
## file.  See also get_filename(), and get_alpha_fullpath().

proc setAlphaFilename*(this: Texture, alpha_filename: Filename) {.importcpp: "#->set_alpha_filename(#)".} ## \
## Sets the name of the file that contains the image's alpha channel contents.
## Normally, this is set automatically when the image is loaded, for instance
## via Texture::read().
##
## The Texture's get_filename() function returns the name of the image file
## that was loaded into the buffer.  In the case where a texture specified two
## separate files to load, a 1- or 3-channel color image and a 1-channel alpha
## image, this Filename is update to contain the name of the image file that
## was loaded into the buffer's alpha channel.

proc clearAlphaFilename*(this: Texture) {.importcpp: "#->clear_alpha_filename()".} ## \
## Removes the alpha filename, if it was previously set.  See
## set_alpha_filename().

proc hasFullpath*(this: Texture): bool {.importcpp: "#->has_fullpath()".} ## \
## Returns true if the fullpath has been set and is available.  See
## set_fullpath().

proc getFullpath*(this: Texture): Filename {.importcpp: "#->get_fullpath()".} ## \
## Returns the fullpath that has been set.  This is the full path to the file
## as it was found along the texture search path.

proc setFullpath*(this: Texture, fullpath: Filename) {.importcpp: "#->set_fullpath(#)".} ## \
## Sets the full pathname to the file that contains the image's contents, as
## found along the search path.  Normally, this is set automatically when the
## image is loaded, for instance via Texture::read().

proc clearFullpath*(this: Texture) {.importcpp: "#->clear_fullpath()".} ## \
## Removes the alpha fullpath, if it was previously set.  See set_fullpath().

proc hasAlphaFullpath*(this: Texture): bool {.importcpp: "#->has_alpha_fullpath()".} ## \
## Returns true if the alpha_fullpath has been set and is available.  See
## set_alpha_fullpath().

proc getAlphaFullpath*(this: Texture): Filename {.importcpp: "#->get_alpha_fullpath()".} ## \
## Returns the alpha_fullpath that has been set.  This is the full path to the
## alpha part of the image file as it was found along the texture search path.

proc setAlphaFullpath*(this: Texture, alpha_fullpath: Filename) {.importcpp: "#->set_alpha_fullpath(#)".} ## \
## Sets the full pathname to the file that contains the image's alpha channel
## contents, as found along the search path.  Normally, this is set
## automatically when the image is loaded, for instance via Texture::read().

proc clearAlphaFullpath*(this: Texture) {.importcpp: "#->clear_alpha_fullpath()".} ## \
## Removes the alpha fullpath, if it was previously set.  See
## set_alpha_fullpath().

proc getXSize*(this: Texture): int {.importcpp: "#->get_x_size()".} ## \
## Returns the width of the texture image in texels.

proc setXSize*(this: Texture, x_size: int) {.importcpp: "#->set_x_size(#)".} ## \
## Changes the x size indicated for the texture.  This also implicitly unloads
## the texture if it has already been loaded.

proc getYSize*(this: Texture): int {.importcpp: "#->get_y_size()".} ## \
## Returns the height of the texture image in texels.  For a 1-d texture, this
## will be 1.

proc setYSize*(this: Texture, y_size: int) {.importcpp: "#->set_y_size(#)".} ## \
## Changes the y size indicated for the texture.  This also implicitly unloads
## the texture if it has already been loaded.

proc getZSize*(this: Texture): int {.importcpp: "#->get_z_size()".} ## \
## Returns the depth of the texture image in texels.  For a 1-d texture or 2-d
## texture, this will be 1. For a cube map texture, this will be 6.

proc setZSize*(this: Texture, z_size: int) {.importcpp: "#->set_z_size(#)".} ## \
## Changes the z size indicated for the texture.  This also implicitly unloads
## the texture if it has already been loaded.

proc getNumViews*(this: Texture): int {.importcpp: "#->get_num_views()".} ## \
## Returns the number of "views" in the texture.  A view is a completely
## separate image stored within the Texture object.  Most textures have only
## one view, but a stereo texture, for instance, may have two views, a left
## and a right image.  Other uses for multiple views are not yet defined.
##
## If this value is greater than one, the additional views are accessed as
## additional pages beyond get_z_size().

proc setNumViews*(this: Texture, num_views: int) {.importcpp: "#->set_num_views(#)".} ## \
## Sets the number of "views" within a texture.  A view is a completely
## separate image stored within the Texture object.  Most textures have only
## one view, but a stereo texture, for instance, may have two views, a left
## and a right image.  Other uses for multiple views are not yet defined.
##
## If this value is greater than one, the additional views are accessed as
## additional pages beyond get_z_size().
##
## This also implicitly unloads the texture if it has already been loaded.

proc getNumPages*(this: Texture): int {.importcpp: "#->get_num_pages()".} ## \
## Returns the total number of pages in the texture.  Each "page" is a 2-d
## texture image within the larger image--a face of a cube map, or a level of
## a 3-d texture.  Normally, get_num_pages() is the same as get_z_size().
## However, in a multiview texture, this returns get_z_size() \*
## get_num_views().

proc getNumComponents*(this: Texture): int {.importcpp: "#->get_num_components()".} ## \
## Returns the number of color components for each texel of the texture image.
## This is 3 for an rgb texture or 4 for an rgba texture; it may also be 1 or
## 2 for a grayscale texture.

proc getComponentWidth*(this: Texture): int {.importcpp: "#->get_component_width()".} ## \
## Returns the number of bytes stored for each color component of a texel.
## Typically this is 1, but it may be 2 for 16-bit texels.

proc getAnisotropicDegree*(this: Texture): int {.importcpp: "#->get_anisotropic_degree()".} ## \
## Returns the degree of anisotropic filtering that should be applied to the
## texture.  This value may return 0, indicating the default value; see also
## get_effective_anisotropic_degree.
##
## This returns the default sampler state for this texture; it may still be
## overridden by a sampler state specified at a higher level.

proc getEffectiveAnisotropicDegree*(this: Texture): int {.importcpp: "#->get_effective_anisotropic_degree()".} ## \
## Returns the degree of anisotropic filtering that should be applied to the
## texture.  This value will normally not return 0, unless there is an error
## in the config file.
##
## This returns the default sampler state for this texture; it may still be
## overridden by a sampler state specified at a higher level.

proc setAnisotropicDegree*(this: Texture, anisotropic_degree: int) {.importcpp: "#->set_anisotropic_degree(#)".} ## \
## Specifies the level of anisotropic filtering to apply to the texture.  Set
## this 0 to indicate the default value, which is specified in the texture-
## anisotropic-degree config variable.
##
## To explicitly disable anisotropic filtering, set this value to 1.  To
## explicitly enable anisotropic filtering, set it to a value higher than 1;
## larger numbers indicate greater degrees of filtering.
##
## This sets the default sampler state for this texture; it may still be
## overridden by a sampler state specified at a higher level.

proc getBorderColor*(this: Texture): LColor {.importcpp: "#->get_border_color()".} ## \
## Returns the solid color of the texture's border.  Some OpenGL
## implementations use a border for tiling textures; in Panda, it is only used
## for specifying the clamp color.
##
## This returns the default sampler state for this texture; it may still be
## overridden by a sampler state specified at a higher level.

proc setBorderColor*(this: Texture, color: LColor) {.importcpp: "#->set_border_color(#)".} ## \
## Specifies the solid color of the texture's border.  Some OpenGL
## implementations use a border for tiling textures; in Panda, it is only used
## for specifying the clamp color.
##
## This sets the default sampler state for this texture; it may still be
## overridden by a sampler state specified at a higher level.

proc hasCompression*(this: Texture): bool {.importcpp: "#->has_compression()".} ## \
## Returns true if the texture indicates it wants to be compressed, either
## with CM_on or higher, or CM_default and compressed-textures is true.
##
## If true returned, this is not a guarantee that the texture is actually
## successfully compressed on the GSG.  It may be that the GSG does not
## support the requested compression mode, in which case the texture may
## actually be stored uncompressed in texture memory.

proc getRenderToTexture*(this: Texture): bool {.importcpp: "#->get_render_to_texture()".} ## \
## Returns a flag on the texture that indicates whether the texture is
## intended to be used as a direct-render target, by binding a framebuffer to
## a texture and rendering directly into the texture.
##
## Normally, a user should not need to set this flag directly; it is set
## automatically by the low-level display code when a texture is bound to a
## framebuffer.

proc setRenderToTexture*(this: Texture, render_to_texture: bool) {.importcpp: "#->set_render_to_texture(#)".} ## \
## Sets a flag on the texture that indicates whether the texture is intended
## to be used as a direct-render target, by binding a framebuffer to a texture
## and rendering directly into the texture.
##
## This controls some low-level choices made about the texture object itself.
## For instance, compressed textures are disallowed when this flag is set
## true.
##
## Normally, a user should not need to set this flag directly; it is set
## automatically by the low-level display code when a texture is bound to a
## framebuffer.

proc getDefaultSampler*(this: Texture): SamplerState {.importcpp: "#->get_default_sampler()".} ## \
## This returns the default sampler state for this texture, containing the
## wrap and filter properties specified on the texture level; it may still be
## overridden by a sampler state specified at a higher level.

proc setDefaultSampler*(this: Texture, sampler: SamplerState) {.importcpp: "#->set_default_sampler(#)".} ## \
## This sets the default sampler state for this texture, containing the wrap
## and filter properties specified on the texture level; it may still be
## overridden by a sampler state specified at a higher level.  This
## encompasses the settings for get_wrap_u, get_minfilter,
## get_anisotropic_degree, etc.
##
## This makes a copy of the SamplerState object, so future modifications of
## the same SamplerState will have no effect on this texture unless you call
## set_default_sampler again.

proc usesMipmaps*(this: Texture): bool {.importcpp: "#->uses_mipmaps()".} ## \
## Returns true if the minfilter settings on this texture indicate the use of
## mipmapping, false otherwise.

proc getExpectedNumMipmapLevels*(this: Texture): int {.importcpp: "#->get_expected_num_mipmap_levels()".} ## \
## Returns the number of mipmap levels that should be defined for this
## texture, given the texture's size.
##
## Note that this returns a number appropriate for mipmapping, even if the
## texture does not currently have mipmapping enabled.

proc getExpectedMipmapXSize*(this: Texture, n: int): int {.importcpp: "#->get_expected_mipmap_x_size(#)".} ## \
## Returns the x_size that the nth mipmap level should have, based on the
## texture's size.

proc getExpectedMipmapYSize*(this: Texture, n: int): int {.importcpp: "#->get_expected_mipmap_y_size(#)".} ## \
## Returns the y_size that the nth mipmap level should have, based on the
## texture's size.

proc getExpectedMipmapZSize*(this: Texture, n: int): int {.importcpp: "#->get_expected_mipmap_z_size(#)".} ## \
## Returns the z_size that the nth mipmap level should have, based on the
## texture's size.

proc getExpectedMipmapNumPages*(this: Texture, n: int): int {.importcpp: "#->get_expected_mipmap_num_pages(#)".} ## \
## Returns the total number of pages that the nth mipmap level should have,
## based on the texture's size.  This is usually the same as
## get_expected_mipmap_z_size(), except for a multiview texture, in which case
## it is get_expected_mipmap_z_size() \* get_num_views().

proc hasRamImage*(this: Texture): bool {.importcpp: "#->has_ram_image()".} ## \
## Returns true if the Texture has its image contents available in main RAM,
## false if it exists only in texture memory or in the prepared GSG context.
##
## Note that this has nothing to do with whether get_ram_image() will fail or
## not.  Even if has_ram_image() returns false, get_ram_image() may still
## return a valid RAM image, because get_ram_image() will automatically load
## the texture from disk if necessary.  The only thing has_ram_image() tells
## you is whether the texture is available right now without hitting the disk
## first.
##
## Note also that if an application uses only one GSG, it may appear that
## has_ram_image() returns true if the texture has not yet been loaded by the
## GSG, but this correlation is not true in general and should not be depended
## on.  Specifically, if an application ever uses multiple GSG's in its
## lifetime (for instance, by opening more than one window, or by closing its
## window and opening another one later), then has_ram_image() may well return
## false on textures that have never been loaded on the current GSG.

proc hasUncompressedRamImage*(this: Texture): bool {.importcpp: "#->has_uncompressed_ram_image()".} ## \
## Returns true if the Texture has its image contents available in main RAM
## and is uncompressed, false otherwise.  See has_ram_image().

proc mightHaveRamImage*(this: Texture): bool {.importcpp: "#->might_have_ram_image()".} ## \
## Returns true if the texture's image contents are currently available in
## main RAM, or there is reason to believe it can be loaded on demand.  That
## is, this function returns a "best guess" as to whether get_ram_image() will
## succeed without actually calling it first.

proc getRamImageSize*(this: Texture): clonglong {.importcpp: "#->get_ram_image_size()".} ## \
## Returns the total number of bytes used by the in-memory image, across all
## pages and views, or 0 if there is no in-memory image.

proc getRamViewSize*(this: Texture): clonglong {.importcpp: "#->get_ram_view_size()".} ## \
## Returns the number of bytes used by the in-memory image per view, or 0 if
## there is no in-memory image.  Since each view is a stack of z_size pages,
## this is get_z_size() \* get_ram_page_size().

proc getRamPageSize*(this: Texture): clonglong {.importcpp: "#->get_ram_page_size()".} ## \
## Returns the number of bytes used by the in-memory image per page, or 0 if
## there is no in-memory image.
##
## For a non-compressed texture, this is the same as
## get_expected_ram_page_size().  For a compressed texture, this may be a
## smaller value.  (We do assume that all pages will be the same size on a
## compressed texture).

proc getExpectedRamImageSize*(this: Texture): clonglong {.importcpp: "#->get_expected_ram_image_size()".} ## \
## Returns the number of bytes that \*ought\* to be used by the in-memory image,
## based on the texture parameters.

proc getExpectedRamPageSize*(this: Texture): clonglong {.importcpp: "#->get_expected_ram_page_size()".} ## \
## Returns the number of bytes that should be used per each Z page of the 3-d
## texture.  For a 2-d or 1-d texture, this is the same as
## get_expected_ram_image_size().

proc clearRamImage*(this: Texture) {.importcpp: "#->clear_ram_image()".} ## \
## Discards the current system-RAM image.

proc setKeepRamImage*(this: Texture, keep_ram_image: bool) {.importcpp: "#->set_keep_ram_image(#)".} ## \
## Sets the flag that indicates whether this Texture is eligible to have its
## main RAM copy of the texture memory dumped when the texture is prepared for
## rendering.
##
## This will be false for most textures, which can reload their images if
## needed by rereading the input file.  However, textures that were generated
## dynamically and cannot be easily reloaded will want to set this flag to
## true, so that the texture will always keep its image copy around.

proc getKeepRamImage*(this: Texture): bool {.importcpp: "#->get_keep_ram_image()".} ## \
## Returns the flag that indicates whether this Texture is eligible to have
## its main RAM copy of the texture memory dumped when the texture is prepared
## for rendering.  See set_keep_ram_image().

proc isCacheable*(this: Texture): bool {.importcpp: "#->is_cacheable()".} ## \
## Returns true if there is enough information in this Texture object to write
## it to the bam cache successfully, false otherwise.  For most textures, this
## is the same as has_ram_image().

proc compressRamImage*(this: Texture): bool {.importcpp: "#->compress_ram_image()".} ## \
## Attempts to compress the texture's RAM image internally, to a format
## supported by the indicated GSG.  In order for this to work, the squish
## library must have been compiled into Panda.
##
## If compression is CM_on, then an appropriate compression method that is
## supported by the indicated GSG is automatically chosen.  If the GSG pointer
## is NULL, any of the standard DXT1/3/5 compression methods will be used,
## regardless of whether it is supported.
##
## If compression is any specific compression method, that method is used
## regardless of whether the GSG supports it.
##
## quality_level determines the speed/quality tradeoff of the compression.  If
## it is QL_default, the texture's own quality_level parameter is used.
##
## Returns true if successful, false otherwise.

proc uncompressRamImage*(this: Texture): bool {.importcpp: "#->uncompress_ram_image()".} ## \
## Attempts to uncompress the texture's RAM image internally.  In order for
## this to work, the squish library must have been compiled into Panda, and
## the ram image must be compressed in a format supported by squish.
##
## Returns true if successful, false otherwise.

proc getNumRamMipmapImages*(this: Texture): int {.importcpp: "#->get_num_ram_mipmap_images()".} ## \
## Returns the maximum number of mipmap level images available in system
## memory.  The actual number may be less than this (that is, there might be
## gaps in the sequence); use has_ram_mipmap_image() to verify each level.
##
## Also see get_num_loadable_ram_mipmap_images().

proc hasRamMipmapImage*(this: Texture, n: int): bool {.importcpp: "#->has_ram_mipmap_image(#)".} ## \
## Returns true if the Texture has the nth mipmap level available in system
## memory, false otherwise.  If the texture's minfilter mode requires
## mipmapping (see uses_mipmaps()), and all the texture's mipmap levels are
## not available when the texture is rendered, they will be generated
## automatically.

proc getNumLoadableRamMipmapImages*(this: Texture): int {.importcpp: "#->get_num_loadable_ram_mipmap_images()".} ## \
## Returns the number of contiguous mipmap levels that exist in RAM, up until
## the first gap in the sequence.  It is guaranteed that at least mipmap
## levels [0, get_num_ram_mipmap_images()) exist.
##
## The number returned will never exceed the number of required mipmap images
## based on the size of the texture and its filter mode.
##
## This method is different from get_num_ram_mipmap_images() in that it
## returns only the number of mipmap levels that can actually be usefully
## loaded, regardless of the actual number that may be stored.

proc hasAllRamMipmapImages*(this: Texture): bool {.importcpp: "#->has_all_ram_mipmap_images()".} ## \
## Returns true if all expected mipmap levels have been defined and exist in
## the system RAM, or false if even one mipmap level is missing.

proc getRamMipmapImageSize*(this: Texture, n: int): clonglong {.importcpp: "#->get_ram_mipmap_image_size(#)".} ## \
## Returns the number of bytes used by the in-memory image for mipmap level n,
## or 0 if there is no in-memory image for this mipmap level.

proc getRamMipmapViewSize*(this: Texture, n: int): clonglong {.importcpp: "#->get_ram_mipmap_view_size(#)".} ## \
## Returns the number of bytes used by the in-memory image per view for mipmap
## level n, or 0 if there is no in-memory image for this mipmap level.
##
## A "view" is a collection of z_size pages for each mipmap level.  Most
## textures have only one view, except for multiview or stereo textures.
##
## For a non-compressed texture, this is the same as
## get_expected_ram_mipmap_view_size().  For a compressed texture, this may be
## a smaller value.  (We do assume that all pages will be the same size on a
## compressed texture).

proc getRamMipmapPageSize*(this: Texture, n: int): clonglong {.importcpp: "#->get_ram_mipmap_page_size(#)".} ## \
## Returns the number of bytes used by the in-memory image per page for mipmap
## level n, or 0 if there is no in-memory image for this mipmap level.
##
## For a non-compressed texture, this is the same as
## get_expected_ram_mipmap_page_size().  For a compressed texture, this may be
## a smaller value.  (We do assume that all pages will be the same size on a
## compressed texture).

proc getExpectedRamMipmapImageSize*(this: Texture, n: int): clonglong {.importcpp: "#->get_expected_ram_mipmap_image_size(#)".} ## \
## Returns the number of bytes that \*ought\* to be used by the in-memory image
## for mipmap level n, based on the texture parameters.

proc getExpectedRamMipmapViewSize*(this: Texture, n: int): clonglong {.importcpp: "#->get_expected_ram_mipmap_view_size(#)".} ## \
## Returns the number of bytes that \*ought\* to be used by each view of the in-
## memory image for mipmap level n, based on the texture parameters.  For a
## normal, non-multiview texture, this is the same as
## get_expected_ram_mipmap_image_size(n).

proc getExpectedRamMipmapPageSize*(this: Texture, n: int): clonglong {.importcpp: "#->get_expected_ram_mipmap_page_size(#)".} ## \
## Returns the number of bytes that should be used per each Z page of the 3-d
## texture, for mipmap level n.  For a 2-d or 1-d texture, this is the same as
## get_expected_ram_mipmap_view_size(n).

proc getRamMipmapPointer*(this: Texture, n: int) {.importcpp: "#->get_ram_mipmap_pointer(#)".} ## \
## Similiar to get_ram_mipmap_image(), however, in this case the void pointer
## for the given ram image is returned.  This will be NULL unless it has been
## explicitly set.

proc setRamMipmapPointerFromInt*(this: Texture, pointer: clonglong, n: int, page_size: int) {.importcpp: "#->set_ram_mipmap_pointer_from_int(#, #, #)".} ## \
## Accepts a raw pointer cast as an int, which is then passed to
## set_ram_mipmap_pointer(); see the documentation for that method.
##
## This variant is particularly useful to set an external pointer from a
## language like Python, which doesn't support void pointers directly.

proc clearRamMipmapImage*(this: Texture, n: int) {.importcpp: "#->clear_ram_mipmap_image(#)".} ## \
## Discards the current system-RAM image for the nth mipmap level.

proc clearRamMipmapImages*(this: Texture) {.importcpp: "#->clear_ram_mipmap_images()".} ## \
## Discards the current system-RAM image for all mipmap levels, except level 0
## (the base image).

proc generateRamMipmapImages*(this: Texture) {.importcpp: "#->generate_ram_mipmap_images()".} ## \
## Automatically fills in the n mipmap levels of the Texture, based on the
## texture's source image.  This requires the texture's uncompressed ram image
## to be available in system memory.  If it is not already, it will be fetched
## if possible.
##
## This call is not normally necessary, since the mipmap levels will be
## generated automatically if needed.  But there may be certain cases in which
## you would like to call this explicitly.

proc getSimpleXSize*(this: Texture): int {.importcpp: "#->get_simple_x_size()".} ## \
## Returns the width of the "simple" image in texels.

proc getSimpleYSize*(this: Texture): int {.importcpp: "#->get_simple_y_size()".} ## \
## Returns the height of the "simple" image in texels.

proc hasSimpleRamImage*(this: Texture): bool {.importcpp: "#->has_simple_ram_image()".} ## \
## Returns true if the Texture has a "simple" image available in main RAM.

proc getSimpleRamImageSize*(this: Texture): clonglong {.importcpp: "#->get_simple_ram_image_size()".} ## \
## Returns the number of bytes used by the "simple" image, or 0 if there is no
## simple image.

proc generateSimpleRamImage*(this: Texture) {.importcpp: "#->generate_simple_ram_image()".} ## \
## Computes the "simple" ram image by loading the main RAM image, if it is not
## already available, and reducing it to 16x16 or smaller.  This may be an
## expensive operation.

proc clearSimpleRamImage*(this: Texture) {.importcpp: "#->clear_simple_ram_image()".} ## \
## Discards the current "simple" image.

proc peek*(this: Texture): TexturePeeker {.importcpp: "#->peek()".} ## \
## Returns a TexturePeeker object that can be used to examine the individual
## texels stored within this Texture by (u, v) coordinate.
##
## If the texture has a ram image resident, that image is used.  If it does
## not have a full ram image but does have a simple_ram_image resident, that
## image is used instead.  If neither image is resident the full image is
## reloaded.
##
## Returns NULL if the texture cannot find an image to load, or the texture
## format is incompatible.

proc getPropertiesModified*(this: Texture): UpdateSeq {.importcpp: "#->get_properties_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the texture properties (unrelated to the image) are modified.

proc getImageModified*(this: Texture): UpdateSeq {.importcpp: "#->get_image_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the texture image data (including mipmap levels) are modified.

proc getSimpleImageModified*(this: Texture): UpdateSeq {.importcpp: "#->get_simple_image_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the texture's "simple" image data is modified.

proc hasAutoTextureScale*(this: Texture): bool {.importcpp: "#->has_auto_texture_scale()".} ## \
## Returns true if set_auto_texture_scale() has been set to something other
## than ATS_unspecified for this particular texture.

proc getAutoTextureScale*(this: Texture): AutoTextureScale {.importcpp: "#->get_auto_texture_scale()".} ## \
## Returns the power-of-2 texture-scaling mode that will be applied to this
## particular texture when it is next loaded from disk.  See
## set_textures_power_2().

proc setAutoTextureScale*(this: Texture, scale: AutoTextureScale) {.importcpp: "#->set_auto_texture_scale(#)".} ## \
## Specifies the power-of-2 texture-scaling mode that will be applied to this
## particular texture when it is next loaded from disk.  See
## set_textures_power_2().

proc prepare*(this: Texture, prepared_objects: PreparedGraphicsObjects): AsyncFuture {.importcpp: "#->prepare(#)".} ## \
## Indicates that the texture should be enqueued to be prepared in the
## indicated prepared_objects at the beginning of the next frame.  This will
## ensure the texture is already loaded into texture memory if it is expected
## to be rendered soon.
##
## Use this function instead of prepare_now() to preload textures from a user
## interface standpoint.

proc isPrepared*(this: Texture, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->is_prepared(#)".} ## \
## Returns true if the texture has already been prepared or enqueued for
## preparation on the indicated GSG, false otherwise.

proc wasImageModified*(this: Texture, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->was_image_modified(#)".} ## \
## Returns true if the texture needs to be re-loaded onto the indicated GSG,
## either because its image data is out-of-date, or because it's not fully
## prepared now.

proc getDataSizeBytes*(this: Texture, prepared_objects: PreparedGraphicsObjects): clonglong {.importcpp: "#->get_data_size_bytes(#)".} ## \
## Returns the number of bytes which the texture is reported to consume within
## graphics memory, for the indicated GSG.  This may return a nonzero value
## even if the texture is not currently resident; you should also check
## get_resident() if you want to know how much space the texture is actually
## consuming right now.

proc getActive*(this: Texture, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->get_active(#)".} ## \
## Returns true if this Texture was rendered in the most recent frame within
## the indicated GSG.

proc getResident*(this: Texture, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->get_resident(#)".} ## \
## Returns true if this Texture is reported to be resident within graphics
## memory for the indicated GSG.

proc release*(this: Texture, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->release(#)".} ## \
## Frees the texture context only on the indicated object, if it exists there.
## Returns true if it was released, false if it had not been prepared.

proc releaseAll*(this: Texture): int {.importcpp: "#->release_all()".} ## \
## Frees the context allocated on all objects for which the texture has been
## declared.  Returns the number of contexts which have been freed.

proc estimateTextureMemory*(this: Texture): clonglong {.importcpp: "#->estimate_texture_memory()".} ## \
## Estimates the amount of texture memory that will be consumed by loading
## this texture.  This returns a value that is not specific to any particular
## graphics card or driver; it tries to make a reasonable assumption about how
## a driver will load the texture.  It does not account for texture
## compression or anything fancy.  This is mainly useful for debugging and
## reporting purposes.
##
## Returns a value in bytes.

proc setAuxData*(this: Texture, key: string, aux_data: TypedReferenceCount) {.importcpp: "#->set_aux_data(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Records an arbitrary object in the Texture, associated with a specified
## key.  The object may later be retrieved by calling get_aux_data() with the
## same key.
##
## These data objects are not recorded to a bam or txo file.

proc clearAuxData*(this: Texture, key: string) {.importcpp: "#->clear_aux_data(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes a record previously recorded via set_aux_data().

proc getAuxData*(this: Texture, key: string): TypedReferenceCount {.importcpp: "#->get_aux_data(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a record previously recorded via set_aux_data().  Returns NULL if
## there was no record associated with the indicated key.

proc setTexturesPower2*(_: typedesc[Texture], scale: AutoTextureScale) {.importcpp: "#Texture::set_textures_power_2(#)", header: "texture.h".} ## \
## Set this flag to ATS_none, ATS_up, ATS_down, or ATS_pad to control the
## scaling of textures in general, if a particular texture does not override
## this.  See also set_auto_texture_scale() for the per-texture override.

proc getTexturesPower2*(_: typedesc[Texture]): AutoTextureScale {.importcpp: "Texture::get_textures_power_2()", header: "texture.h".} ## \
## This flag returns ATS_none, ATS_up, or ATS_down and controls the scaling of
## textures in general.  It is initialized from the config variable of the
## same name, but it can be subsequently adjusted.  See also
## get_auto_texture_scale().

proc hasTexturesPower2*(_: typedesc[Texture]): bool {.importcpp: "Texture::has_textures_power_2()", header: "texture.h".} ## \
## If true, then get_textures_power_2 has been set using set_textures_power_2.
## If false, then get_textures_power_2 simply returns the config variable of
## the same name.

proc getPadXSize*(this: Texture): int {.importcpp: "#->get_pad_x_size()".} ## \
## Returns size of the pad region.  See set_pad_size.

proc getPadYSize*(this: Texture): int {.importcpp: "#->get_pad_y_size()".} ## \
## Returns size of the pad region.  See set_pad_size.

proc getPadZSize*(this: Texture): int {.importcpp: "#->get_pad_z_size()".} ## \
## Returns size of the pad region.  See set_pad_size.

proc getTexScale*(this: Texture): LVecBase2 {.importcpp: "#->get_tex_scale()".} ## \
## Returns a scale pair that is suitable for applying to geometry via
## NodePath::set_tex_scale(), which will convert texture coordinates on the
## geometry from the range 0..1 into the appropriate range to render the video
## part of the texture.
##
## This is necessary only if a padding size has been set via set_pad_size()
## (or implicitly via something like "textures-power-2 pad" in the config.prc
## file).  In this case, this is a convenient way to generate UV's that
## reflect the built-in padding size.

proc setPadSize*(this: Texture, x: int, y: int, z: int) {.importcpp: "#->set_pad_size(#, #, #)".} ## \
## Sets the size of the pad region.
##
## Sometimes, when a video card demands power-of-two textures, it is necessary
## to create a big texture and then only use a portion of it.  The pad region
## indicates which portion of the texture is not really in use.  All
## operations use the texture as a whole, including the pad region, unless
## they explicitly state that they use only the non-pad region.
##
## Changing the texture's size clears the pad region.

proc setPadSize*(this: Texture, x: int, y: int) {.importcpp: "#->set_pad_size(#, #)".} ## \
## Sets the size of the pad region.
##
## Sometimes, when a video card demands power-of-two textures, it is necessary
## to create a big texture and then only use a portion of it.  The pad region
## indicates which portion of the texture is not really in use.  All
## operations use the texture as a whole, including the pad region, unless
## they explicitly state that they use only the non-pad region.
##
## Changing the texture's size clears the pad region.

proc setPadSize*(this: Texture, x: int) {.importcpp: "#->set_pad_size(#)".} ## \
## Sets the size of the pad region.
##
## Sometimes, when a video card demands power-of-two textures, it is necessary
## to create a big texture and then only use a portion of it.  The pad region
## indicates which portion of the texture is not really in use.  All
## operations use the texture as a whole, including the pad region, unless
## they explicitly state that they use only the non-pad region.
##
## Changing the texture's size clears the pad region.

proc setPadSize*(this: Texture) {.importcpp: "#->set_pad_size()".} ## \
## Sets the size of the pad region.
##
## Sometimes, when a video card demands power-of-two textures, it is necessary
## to create a big texture and then only use a portion of it.  The pad region
## indicates which portion of the texture is not really in use.  All
## operations use the texture as a whole, including the pad region, unless
## they explicitly state that they use only the non-pad region.
##
## Changing the texture's size clears the pad region.

proc setSizePadded*(this: Texture, x: int, y: int, z: int) {.importcpp: "#->set_size_padded(#, #, #)".} ## \
## Changes the size of the texture, padding if necessary, and setting the pad
## region as well.

proc setSizePadded*(this: Texture, x: int, y: int) {.importcpp: "#->set_size_padded(#, #)".} ## \
## Changes the size of the texture, padding if necessary, and setting the pad
## region as well.

proc setSizePadded*(this: Texture, x: int) {.importcpp: "#->set_size_padded(#)".} ## \
## Changes the size of the texture, padding if necessary, and setting the pad
## region as well.

proc setSizePadded*(this: Texture) {.importcpp: "#->set_size_padded()".} ## \
## Changes the size of the texture, padding if necessary, and setting the pad
## region as well.

proc getOrigFileXSize*(this: Texture): int {.importcpp: "#->get_orig_file_x_size()".} ## \
## Returns the X size of the original disk image that this Texture was loaded
## from (if it came from a disk file), before any automatic rescaling by
## Panda.

proc getOrigFileYSize*(this: Texture): int {.importcpp: "#->get_orig_file_y_size()".} ## \
## Returns the Y size of the original disk image that this Texture was loaded
## from (if it came from a disk file), before any automatic rescaling by
## Panda.

proc getOrigFileZSize*(this: Texture): int {.importcpp: "#->get_orig_file_z_size()".} ## \
## Returns the Z size of the original disk image that this Texture was loaded
## from (if it came from a disk file), before any automatic rescaling by
## Panda.

proc setOrigFileSize*(this: Texture, x: int, y: int, z: int) {.importcpp: "#->set_orig_file_size(#, #, #)".} ## \
## Specifies the size of the texture as it exists in its original disk file,
## before any Panda scaling.

proc setOrigFileSize*(this: Texture, x: int, y: int) {.importcpp: "#->set_orig_file_size(#, #)".} ## \
## Specifies the size of the texture as it exists in its original disk file,
## before any Panda scaling.

proc setLoadedFromImage*(this: Texture, flag: bool) {.importcpp: "#->set_loaded_from_image(#)".} ## \
## Sets the flag that indicates the texture has been loaded from a disk file
## or PNMImage.  You should also ensure the filename has been set correctly.
## When this flag is true, the texture may be automatically reloaded when its
## ram image needs to be replaced.

proc setLoadedFromImage*(this: Texture) {.importcpp: "#->set_loaded_from_image()".} ## \
## Sets the flag that indicates the texture has been loaded from a disk file
## or PNMImage.  You should also ensure the filename has been set correctly.
## When this flag is true, the texture may be automatically reloaded when its
## ram image needs to be replaced.

proc getLoadedFromImage*(this: Texture): bool {.importcpp: "#->get_loaded_from_image()".} ## \
## Returns the flag that indicates the texture has been loaded from a disk
## file or PNMImage.  See set_loaded_from_image().

proc setLoadedFromTxo*(this: Texture, flag: bool) {.importcpp: "#->set_loaded_from_txo(#)".} ## \
## Sets the flag that indicates the texture has been loaded from a txo file.
## You probably shouldn't be setting this directly; it is set automatically
## when a Texture is loaded.

proc setLoadedFromTxo*(this: Texture) {.importcpp: "#->set_loaded_from_txo()".} ## \
## Sets the flag that indicates the texture has been loaded from a txo file.
## You probably shouldn't be setting this directly; it is set automatically
## when a Texture is loaded.

proc getLoadedFromTxo*(this: Texture): bool {.importcpp: "#->get_loaded_from_txo()".} ## \
## Returns the flag that indicates the texture has been loaded from a txo
## file.

proc getMatchFramebufferFormat*(this: Texture): bool {.importcpp: "#->get_match_framebuffer_format()".} ## \
## Returns true if the special flag was set that indicates to the GSG that the
## Texture's format should be chosen to exactly match the framebuffer's
## format, presumably because the application intends to copy image data from
## the framebuffer into the Texture (or vice-versa).

proc setMatchFramebufferFormat*(this: Texture, flag: bool) {.importcpp: "#->set_match_framebuffer_format(#)".} ## \
## Sets the special flag that, if true, indicates to the GSG that the
## Texture's format should be chosen to exactly match the framebuffer's
## format, presumably because the application intends to copy image data from
## the framebuffer into the Texture (or vice-versa).
##
## This sets only the graphics card's idea of the texture format; it is not
## related to the system-memory format.

proc getPostLoadStoreCache*(this: Texture): bool {.importcpp: "#->get_post_load_store_cache()".} ## \
## Returns the setting of the post_load_store_cache flag.  See
## set_post_load_store_cache().

proc setPostLoadStoreCache*(this: Texture, flag: bool) {.importcpp: "#->set_post_load_store_cache(#)".} ## \
## Sets the post_load_store_cache flag.  When this is set, the next time the
## texture is loaded on a GSG, it will automatically extract its RAM image
## from the GSG and save it to the global BamCache.
##
## This is used to store compressed RAM images in the BamCache.  This flag
## should not be set explicitly; it is set automatically by the TexturePool
## when model-cache-compressed-textures is set true.

proc prepareNow*(this: Texture, view: int, prepared_objects: PreparedGraphicsObjects, gsg: GraphicsStateGuardianBase): TextureContext {.importcpp: "#->prepare_now(#, #, #)".} ## \
## Creates a context for the texture on the particular GSG, if it does not
## already exist.  Returns the new (or old) TextureContext.  This assumes that
## the GraphicsStateGuardian is the currently active rendering context and
## that it is ready to accept new textures.  If this is not necessarily the
## case, you should use prepare() instead.
##
## Normally, this is not called directly except by the GraphicsStateGuardian;
## a texture does not need to be explicitly prepared by the user before it may
## be rendered.

proc upToPower2*(_: typedesc[Texture], value: int): int {.importcpp: "#Texture::up_to_power_2(#)", header: "texture.h".} ## \
## Returns the smallest power of 2 greater than or equal to value.

proc downToPower2*(_: typedesc[Texture], value: int): int {.importcpp: "#Texture::down_to_power_2(#)", header: "texture.h".} ## \
## Returns the largest power of 2 less than or equal to value.

proc considerRescale*(this: Texture, pnmimage: PNMImage) {.importcpp: "#->consider_rescale(#)".} ## \
## Asks the PNMImage to change its scale when it reads the image, according to
## the whims of the Config.prc file.
##
## For most efficient results, this method should be called after
## pnmimage.read_header() has been called, but before pnmimage.read().  This
## method may also be called after pnmimage.read(), i.e.  when the pnmimage is
## already loaded; in this case it will rescale the image on the spot.  Also
## see rescale_texture().

proc considerRescale*(_: typedesc[Texture], pnmimage: PNMImage, name: string, auto_texture_scale: AutoTextureScale) {.importcpp: "#Texture::consider_rescale(#, nimStringToStdString(#), #)", header: "texture.h".} ## \
## Asks the PNMImage to change its scale when it reads the image, according to
## the whims of the Config.prc file.
##
## For most efficient results, this method should be called after
## pnmimage.read_header() has been called, but before pnmimage.read().  This
## method may also be called after pnmimage.read(), i.e.  when the pnmimage is
## already loaded; in this case it will rescale the image on the spot.  Also
## see rescale_texture().

proc considerRescale*(_: typedesc[Texture], pnmimage: PNMImage, name: string) {.importcpp: "#Texture::consider_rescale(#, nimStringToStdString(#))", header: "texture.h".} ## \
## Asks the PNMImage to change its scale when it reads the image, according to
## the whims of the Config.prc file.
##
## For most efficient results, this method should be called after
## pnmimage.read_header() has been called, but before pnmimage.read().  This
## method may also be called after pnmimage.read(), i.e.  when the pnmimage is
## already loaded; in this case it will rescale the image on the spot.  Also
## see rescale_texture().

proc rescaleTexture*(this: Texture): bool {.importcpp: "#->rescale_texture()".} ## \
## This method is similar to consider_rescale(), but instead of scaling a
## separate PNMImage, it will ask the Texture to rescale its own internal
## image to a power of 2, according to the config file requirements.  This may
## be useful after loading a Texture image by hand, instead of reading it from
## a disk file.  Returns true if the texture is changed, false if it was not.

converter getClassType*(_: typedesc[Texture]): TypeHandle {.importcpp: "Texture::get_class_type()", header: "texture.h".}

proc load*(_: typedesc[Shader], file: Filename): Shader {.importcpp: "#Shader::load(#)", header: "shader.h".} ## \
## Loads the shader with the given filename.

proc make*(_: typedesc[Shader], body: string): Shader {.importcpp: "#Shader::make(nimStringToStdString(#))", header: "shader.h".} ## \
## Loads the shader, using the string as shader body.

proc getFilename*(this: Shader): Filename {.importcpp: "#->get_filename()".} ## \
## Return the Shader's filename for the given shader type.

proc getText*(this: Shader): string {.importcpp: "nimStringFromStdString(#->get_text())", header: stringConversionCode.} ## \
## Return the Shader's text for the given shader type.

proc getErrorFlag*(this: Shader): bool {.importcpp: "#->get_error_flag()".} ## \
## Returns true if the shader contains a compile-time error.  This doesn't
## tell you whether or not the shader is supported on the current video card.

proc hasFullpath*(this: Shader): bool {.importcpp: "#->has_fullpath()".} ## \
## Returns true if the fullpath has been set and is available.  See
## set_fullpath().

proc getFullpath*(this: Shader): Filename {.importcpp: "#->get_fullpath()".} ## \
## Returns the fullpath that has been set.  This is the full path to the file
## as it was found along the model-path.

proc getCacheCompiledShader*(this: Shader): bool {.importcpp: "#->get_cache_compiled_shader()".} ## \
## Returns the setting of the cache_compiled_shader flag.  See
## set_cache_compiled_shader().

proc setCacheCompiledShader*(this: Shader, flag: bool) {.importcpp: "#->set_cache_compiled_shader(#)".} ## \
## Sets the cache_compiled_shader flag.  When this is set, the next time the
## Shader is loaded on a GSG, it will automatically extract the compiled
## shader from the GSG and save it to the global BamCache.
##
## This is used to store compiled shaders in the BamCache.  This flag should
## not be set explicitly; it is set automatically by the ShaderPool when
## model-cache-compiled-shaders is set true.

proc prepare*(this: Shader, prepared_objects: PreparedGraphicsObjects): AsyncFuture {.importcpp: "#->prepare(#)".} ## \
## Indicates that the shader should be enqueued to be prepared in the
## indicated prepared_objects at the beginning of the next frame.  This will
## ensure the texture is already loaded into texture memory if it is expected
## to be rendered soon.
##
## Use this function instead of prepare_now() to preload textures from a user
## interface standpoint.

proc isPrepared*(this: Shader, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->is_prepared(#)".} ## \
## Returns true if the shader has already been prepared or enqueued for
## preparation on the indicated GSG, false otherwise.

proc release*(this: Shader, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->release(#)".} ## \
## Frees the texture context only on the indicated object, if it exists there.
## Returns true if it was released, false if it had not been prepared.

proc releaseAll*(this: Shader): int {.importcpp: "#->release_all()".} ## \
## Frees the context allocated on all objects for which the texture has been
## declared.  Returns the number of contexts which have been freed.

proc prepareNow*(this: Shader, prepared_objects: PreparedGraphicsObjects, gsg: GraphicsStateGuardianBase): ShaderContext {.importcpp: "#->prepare_now(#, #)".} ## \
## Creates a context for the shader on the particular GSG, if it does not
## already exist.  Returns the new (or old) ShaderContext.  This assumes that
## the GraphicsStateGuardian is the currently active rendering context and
## that it is ready to accept new textures.  If this is not necessarily the
## case, you should use prepare() instead.
##
## Normally, this is not called directly except by the GraphicsStateGuardian;
## a shader does not need to be explicitly prepared by the user before it may
## be rendered.

converter getClassType*(_: typedesc[Shader]): TypeHandle {.importcpp: "Shader::get_class_type()", header: "shader.h".}

proc newShader*(param0: Shader): Shader {.importcpp: "new Shader(#)".}

converter upcastToTypedWritableReferenceCount*(this: ShaderBuffer): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcastToNamable*(this: ShaderBuffer): Namable {.importcpp: "((Namable *)(ShaderBuffer *)(#))".}

converter upcastToGeomEnums*(this: ShaderBuffer): GeomEnums {.importcpp: "((GeomEnums *)(ShaderBuffer *)(#))".}

proc newShaderBuffer*(param0: ShaderBuffer): ShaderBuffer {.importcpp: "new ShaderBuffer(#)".}

proc prepare*(this: ShaderBuffer, prepared_objects: PreparedGraphicsObjects) {.importcpp: "#->prepare(#)".} ## \
## Indicates that the data should be enqueued to be prepared in the indicated
## prepared_objects at the beginning of the next frame.  This will ensure the
## data is already loaded into the GSG if it is expected to be rendered soon.
##
## Use this function instead of prepare_now() to preload datas from a user
## interface standpoint.

proc isPrepared*(this: ShaderBuffer, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->is_prepared(#)".} ## \
## Returns true if the data has already been prepared or enqueued for
## preparation on the indicated GSG, false otherwise.

proc prepareNow*(this: ShaderBuffer, prepared_objects: PreparedGraphicsObjects, gsg: GraphicsStateGuardianBase): BufferContext {.importcpp: "#->prepare_now(#, #)".} ## \
## Creates a context for the data on the particular GSG, if it does not
## already exist.  Returns the new (or old) BufferContext.  This assumes
## that the GraphicsStateGuardian is the currently active rendering context
## and that it is ready to accept new datas.  If this is not necessarily the
## case, you should use prepare() instead.
##
## Normally, this is not called directly except by the GraphicsStateGuardian;
## a data does not need to be explicitly prepared by the user before it may be
## rendered.

proc release*(this: ShaderBuffer, prepared_objects: PreparedGraphicsObjects): bool {.importcpp: "#->release(#)".} ## \
## Frees the data context only on the indicated object, if it exists there.
## Returns true if it was released, false if it had not been prepared.

proc releaseAll*(this: ShaderBuffer): int {.importcpp: "#->release_all()".} ## \
## Frees the context allocated on all objects for which the data has been
## declared.  Returns the number of contexts which have been freed.

converter getClassType*(_: typedesc[ShaderBuffer]): TypeHandle {.importcpp: "ShaderBuffer::get_class_type()", header: "shaderBuffer.h".}

proc getName*(this: PreparedGraphicsObjects): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Returns the name of the PreparedGraphicsObjects structure.  This is an
## arbitrary name that serves mainly to uniquify the context for PStats
## reporting.

proc setGraphicsMemoryLimit*(this: PreparedGraphicsObjects, limit: clonglong) {.importcpp: "#->set_graphics_memory_limit(#)".} ## \
## Sets an artificial cap on graphics memory that will be imposed on this GSG.
##
## This limits the total amount of graphics memory, including texture memory
## and vertex buffer memory, that will be consumed by the GSG, regardless of
## whether the hardware claims to provide more graphics memory than this.  It
## is useful to put a ceiling on graphics memory consumed, since some drivers
## seem to allow the application to consume more memory than the hardware can
## realistically support.

proc getGraphicsMemoryLimit*(this: PreparedGraphicsObjects): clonglong {.importcpp: "#->get_graphics_memory_limit()".} ## \
## Returns the artificial cap on graphics memory that will be imposed on this
## GSG.  See set_graphics_memory_limit().

proc showGraphicsMemoryLru*(this: PreparedGraphicsObjects, `out`: ostream) {.importcpp: "#->show_graphics_memory_lru(#)".} ## \
## Writes to the indicated ostream a report of how the various textures and
## vertex buffers are allocated in the LRU.

proc showResidencyTrackers*(this: PreparedGraphicsObjects, `out`: ostream) {.importcpp: "#->show_residency_trackers(#)".} ## \
## Writes to the indicated ostream a report of how the various textures and
## vertex buffers are allocated in the LRU.

proc releaseAll*(this: PreparedGraphicsObjects) {.importcpp: "#->release_all()".} ## \
## Releases all prepared objects of all kinds at once.

proc getNumQueued*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_queued()".} ## \
## Returns the number of objects of any kind that have been enqueued to be
## prepared on this GSG.

proc getNumPrepared*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_prepared()".} ## \
## Returns the number of objects of any kind that have already been prepared
## on this GSG.

proc enqueueTexture*(this: PreparedGraphicsObjects, tex: Texture) {.importcpp: "#->enqueue_texture(#)".} ## \
## Indicates that a texture would like to be put on the list to be prepared
## when the GSG is next ready to do this (presumably at the next frame).

proc isTextureQueued*(this: PreparedGraphicsObjects, tex: Texture): bool {.importcpp: "#->is_texture_queued(#)".} ## \
## Returns true if the texture has been queued on this GSG, false otherwise.

proc dequeueTexture*(this: PreparedGraphicsObjects, tex: Texture): bool {.importcpp: "#->dequeue_texture(#)".} ## \
## Removes a texture from the queued list of textures to be prepared.
## Normally it is not necessary to call this, unless you change your mind
## about preparing it at the last minute, since the texture will automatically
## be dequeued and prepared at the next frame.
##
## The return value is true if the texture is successfully dequeued, false if
## it had not been queued.

proc isTexturePrepared*(this: PreparedGraphicsObjects, tex: Texture): bool {.importcpp: "#->is_texture_prepared(#)".} ## \
## Returns true if the texture has been prepared on this GSG, false otherwise.

proc releaseTexture*(this: PreparedGraphicsObjects, tex: Texture) {.importcpp: "#->release_texture(#)".} ## \
## Releases a texture if it has already been prepared, or removes it from the
## preparation queue.

proc releaseTexture*(this: PreparedGraphicsObjects, tc: TextureContext) {.importcpp: "#->release_texture(#)".} ## \
## Indicates that a texture context, created by a previous call to
## prepare_texture(), is no longer needed.  The driver resources will not be
## freed until some GSG calls update(), indicating it is at a stage where it
## is ready to release textures--this prevents conflicts from threading or
## multiple GSG's sharing textures (we have no way of knowing which graphics
## context is currently active, or what state it's in, at the time
## release_texture is called).

proc releaseAllTextures*(this: PreparedGraphicsObjects): int {.importcpp: "#->release_all_textures()".} ## \
## Releases all textures at once.  This will force them to be reloaded into
## texture memory for all GSG's that share this object.  Returns the number of
## textures released.

proc getNumQueuedTextures*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_queued_textures()".} ## \
## Returns the number of textures that have been enqueued to be prepared on
## this GSG.

proc getNumPreparedTextures*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_prepared_textures()".} ## \
## Returns the number of textures that have already been prepared on this GSG.

proc prepareTextureNow*(this: PreparedGraphicsObjects, tex: Texture, view: int, gsg: GraphicsStateGuardianBase): TextureContext {.importcpp: "#->prepare_texture_now(#, #, #)".} ## \
## Immediately creates a new TextureContext for the indicated texture and
## returns it.  This assumes that the GraphicsStateGuardian is the currently
## active rendering context and that it is ready to accept new textures.  If
## this is not necessarily the case, you should use enqueue_texture() instead.
##
## Normally, this function is not called directly.  Call
## Texture::prepare_now() instead.
##
## The TextureContext contains all of the pertinent information needed by the
## GSG to keep track of this one particular texture, and will exist as long as
## the texture is ready to be rendered.
##
## When either the Texture or the PreparedGraphicsObjects object destructs,
## the TextureContext will be deleted.

proc enqueueSampler*(this: PreparedGraphicsObjects, sampler: SamplerState) {.importcpp: "#->enqueue_sampler(#)".} ## \
## Indicates that a sampler would like to be put on the list to be prepared
## when the GSG is next ready to do this (presumably at the next frame).

proc isSamplerQueued*(this: PreparedGraphicsObjects, sampler: SamplerState): bool {.importcpp: "#->is_sampler_queued(#)".} ## \
## Returns true if the sampler has been queued on this GSG, false otherwise.

proc dequeueSampler*(this: PreparedGraphicsObjects, sampler: SamplerState): bool {.importcpp: "#->dequeue_sampler(#)".} ## \
## Removes a sampler from the queued list of samplers to be prepared.
## Normally it is not necessary to call this, unless you change your mind
## about preparing it at the last minute, since the sampler will automatically
## be dequeued and prepared at the next frame.
##
## The return value is true if the sampler is successfully dequeued, false if
## it had not been queued.

proc isSamplerPrepared*(this: PreparedGraphicsObjects, sampler: SamplerState): bool {.importcpp: "#->is_sampler_prepared(#)".} ## \
## Returns true if the sampler has been prepared on this GSG, false otherwise.

proc releaseSampler*(this: PreparedGraphicsObjects, sampler: SamplerState) {.importcpp: "#->release_sampler(#)".} ## \
## Releases a sampler if it has already been prepared, or removes it from the
## preparation queue.

proc releaseAllSamplers*(this: PreparedGraphicsObjects): int {.importcpp: "#->release_all_samplers()".} ## \
## Releases all samplers at once.  This will force them to be reloaded for all
## GSG's that share this object.  Returns the number of samplers released.

proc getNumQueuedSamplers*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_queued_samplers()".} ## \
## Returns the number of samplers that have been enqueued to be prepared on
## this GSG.

proc getNumPreparedSamplers*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_prepared_samplers()".} ## \
## Returns the number of samplers that have already been prepared on this GSG.

proc enqueueGeom*(this: PreparedGraphicsObjects, geom: Geom) {.importcpp: "#->enqueue_geom(#)".} ## \
## Indicates that a geom would like to be put on the list to be prepared when
## the GSG is next ready to do this (presumably at the next frame).

proc isGeomQueued*(this: PreparedGraphicsObjects, geom: Geom): bool {.importcpp: "#->is_geom_queued(#)".} ## \
## Returns true if the geom has been queued on this GSG, false otherwise.

proc dequeueGeom*(this: PreparedGraphicsObjects, geom: Geom): bool {.importcpp: "#->dequeue_geom(#)".} ## \
## Removes a geom from the queued list of geoms to be prepared.  Normally it
## is not necessary to call this, unless you change your mind about preparing
## it at the last minute, since the geom will automatically be dequeued and
## prepared at the next frame.
##
## The return value is true if the geom is successfully dequeued, false if it
## had not been queued.

proc isGeomPrepared*(this: PreparedGraphicsObjects, geom: Geom): bool {.importcpp: "#->is_geom_prepared(#)".} ## \
## Returns true if the vertex buffer has been prepared on this GSG, false
## otherwise.

proc releaseGeom*(this: PreparedGraphicsObjects, gc: GeomContext) {.importcpp: "#->release_geom(#)".} ## \
## Indicates that a geom context, created by a previous call to
## prepare_geom(), is no longer needed.  The driver resources will not be
## freed until some GSG calls update(), indicating it is at a stage where it
## is ready to release geoms--this prevents conflicts from threading or
## multiple GSG's sharing geoms (we have no way of knowing which graphics
## context is currently active, or what state it's in, at the time
## release_geom is called).

proc releaseAllGeoms*(this: PreparedGraphicsObjects): int {.importcpp: "#->release_all_geoms()".} ## \
## Releases all geoms at once.  This will force them to be reloaded into geom
## memory for all GSG's that share this object.  Returns the number of geoms
## released.

proc getNumQueuedGeoms*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_queued_geoms()".} ## \
## Returns the number of geoms that have been enqueued to be prepared on this
## GSG.

proc getNumPreparedGeoms*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_prepared_geoms()".} ## \
## Returns the number of geoms that have already been prepared on this GSG.

proc prepareGeomNow*(this: PreparedGraphicsObjects, geom: Geom, gsg: GraphicsStateGuardianBase): GeomContext {.importcpp: "#->prepare_geom_now(#, #)".} ## \
## Immediately creates a new GeomContext for the indicated geom and returns
## it.  This assumes that the GraphicsStateGuardian is the currently active
## rendering context and that it is ready to accept new geoms.  If this is not
## necessarily the case, you should use enqueue_geom() instead.
##
## Normally, this function is not called directly.  Call Geom::prepare_now()
## instead.
##
## The GeomContext contains all of the pertinent information needed by the GSG
## to keep track of this one particular geom, and will exist as long as the
## geom is ready to be rendered.
##
## When either the Geom or the PreparedGraphicsObjects object destructs, the
## GeomContext will be deleted.

proc enqueueShader*(this: PreparedGraphicsObjects, shader: Shader) {.importcpp: "#->enqueue_shader(#)".} ## \
## Indicates that a shader would like to be put on the list to be prepared
## when the GSG is next ready to do this (presumably at the next frame).

proc isShaderQueued*(this: PreparedGraphicsObjects, shader: Shader): bool {.importcpp: "#->is_shader_queued(#)".} ## \
## Returns true if the shader has been queued on this GSG, false otherwise.

proc dequeueShader*(this: PreparedGraphicsObjects, shader: Shader): bool {.importcpp: "#->dequeue_shader(#)".} ## \
## Removes a shader from the queued list of shaders to be prepared.  Normally
## it is not necessary to call this, unless you change your mind about
## preparing it at the last minute, since the shader will automatically be
## dequeued and prepared at the next frame.
##
## The return value is true if the shader is successfully dequeued, false if
## it had not been queued.

proc isShaderPrepared*(this: PreparedGraphicsObjects, shader: Shader): bool {.importcpp: "#->is_shader_prepared(#)".} ## \
## Returns true if the shader has been prepared on this GSG, false otherwise.

proc releaseShader*(this: PreparedGraphicsObjects, sc: ShaderContext) {.importcpp: "#->release_shader(#)".} ## \
## Indicates that a shader context, created by a previous call to
## prepare_shader(), is no longer needed.  The driver resources will not be
## freed until some GSG calls update(), indicating it is at a stage where it
## is ready to release shaders--this prevents conflicts from threading or
## multiple GSG's sharing shaders (we have no way of knowing which graphics
## context is currently active, or what state it's in, at the time
## release_shader is called).

proc releaseAllShaders*(this: PreparedGraphicsObjects): int {.importcpp: "#->release_all_shaders()".} ## \
## Releases all shaders at once.  This will force them to be reloaded into
## shader memory for all GSG's that share this object.  Returns the number of
## shaders released.

proc getNumQueuedShaders*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_queued_shaders()".} ## \
## Returns the number of shaders that have been enqueued to be prepared on
## this GSG.

proc getNumPreparedShaders*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_prepared_shaders()".} ## \
## Returns the number of shaders that have already been prepared on this GSG.

proc prepareShaderNow*(this: PreparedGraphicsObjects, shader: Shader, gsg: GraphicsStateGuardianBase): ShaderContext {.importcpp: "#->prepare_shader_now(#, #)".} ## \
## Immediately creates a new ShaderContext for the indicated shader and
## returns it.  This assumes that the GraphicsStateGuardian is the currently
## active rendering context and that it is ready to accept new shaders.  If
## this is not necessarily the case, you should use enqueue_shader() instead.
##
## Normally, this function is not called directly.  Call Shader::prepare_now()
## instead.
##
## The ShaderContext contains all of the pertinent information needed by the
## GSG to keep track of this one particular shader, and will exist as long as
## the shader is ready to be rendered.
##
## When either the Shader or the PreparedGraphicsObjects object destructs, the
## ShaderContext will be deleted.

proc enqueueVertexBuffer*(this: PreparedGraphicsObjects, data: GeomVertexArrayData) {.importcpp: "#->enqueue_vertex_buffer(#)".} ## \
## Indicates that a buffer would like to be put on the list to be prepared
## when the GSG is next ready to do this (presumably at the next frame).

proc isVertexBufferQueued*(this: PreparedGraphicsObjects, data: GeomVertexArrayData): bool {.importcpp: "#->is_vertex_buffer_queued(#)".} ## \
## Returns true if the vertex buffer has been queued on this GSG, false
## otherwise.

proc dequeueVertexBuffer*(this: PreparedGraphicsObjects, data: GeomVertexArrayData): bool {.importcpp: "#->dequeue_vertex_buffer(#)".} ## \
## Removes a buffer from the queued list of data arrays to be prepared.
## Normally it is not necessary to call this, unless you change your mind
## about preparing it at the last minute, since the data will automatically be
## dequeued and prepared at the next frame.
##
## The return value is true if the buffer is successfully dequeued, false if
## it had not been queued.

proc isVertexBufferPrepared*(this: PreparedGraphicsObjects, data: GeomVertexArrayData): bool {.importcpp: "#->is_vertex_buffer_prepared(#)".} ## \
## Returns true if the vertex buffer has been prepared on this GSG, false
## otherwise.

proc releaseVertexBuffer*(this: PreparedGraphicsObjects, vbc: VertexBufferContext) {.importcpp: "#->release_vertex_buffer(#)".} ## \
## Indicates that a data context, created by a previous call to
## prepare_vertex_buffer(), is no longer needed.  The driver resources will
## not be freed until some GSG calls update(), indicating it is at a stage
## where it is ready to release datas--this prevents conflicts from threading
## or multiple GSG's sharing datas (we have no way of knowing which graphics
## context is currently active, or what state it's in, at the time
## release_vertex_buffer is called).

proc releaseAllVertexBuffers*(this: PreparedGraphicsObjects): int {.importcpp: "#->release_all_vertex_buffers()".} ## \
## Releases all datas at once.  This will force them to be reloaded into data
## memory for all GSG's that share this object.  Returns the number of datas
## released.

proc getNumQueuedVertexBuffers*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_queued_vertex_buffers()".} ## \
## Returns the number of vertex buffers that have been enqueued to be prepared
## on this GSG.

proc getNumPreparedVertexBuffers*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_prepared_vertex_buffers()".} ## \
## Returns the number of vertex buffers that have already been prepared on
## this GSG.

proc prepareVertexBufferNow*(this: PreparedGraphicsObjects, data: GeomVertexArrayData, gsg: GraphicsStateGuardianBase): VertexBufferContext {.importcpp: "#->prepare_vertex_buffer_now(#, #)".} ## \
## Immediately creates a new VertexBufferContext for the indicated data and
## returns it.  This assumes that the GraphicsStateGuardian is the currently
## active rendering context and that it is ready to accept new datas.  If this
## is not necessarily the case, you should use enqueue_vertex_buffer()
## instead.
##
## Normally, this function is not called directly.  Call Data::prepare_now()
## instead.
##
## The VertexBufferContext contains all of the pertinent information needed by
## the GSG to keep track of this one particular data, and will exist as long
## as the data is ready to be rendered.
##
## When either the Data or the PreparedGraphicsObjects object destructs, the
## VertexBufferContext will be deleted.

proc enqueueIndexBuffer*(this: PreparedGraphicsObjects, data: GeomPrimitive) {.importcpp: "#->enqueue_index_buffer(#)".} ## \
## Indicates that a buffer would like to be put on the list to be prepared
## when the GSG is next ready to do this (presumably at the next frame).

proc isIndexBufferQueued*(this: PreparedGraphicsObjects, data: GeomPrimitive): bool {.importcpp: "#->is_index_buffer_queued(#)".} ## \
## Returns true if the index buffer has been queued on this GSG, false
## otherwise.

proc dequeueIndexBuffer*(this: PreparedGraphicsObjects, data: GeomPrimitive): bool {.importcpp: "#->dequeue_index_buffer(#)".} ## \
## Removes a buffer from the queued list of data arrays to be prepared.
## Normally it is not necessary to call this, unless you change your mind
## about preparing it at the last minute, since the data will automatically be
## dequeued and prepared at the next frame.
##
## The return value is true if the buffer is successfully dequeued, false if
## it had not been queued.

proc isIndexBufferPrepared*(this: PreparedGraphicsObjects, data: GeomPrimitive): bool {.importcpp: "#->is_index_buffer_prepared(#)".} ## \
## Returns true if the index buffer has been prepared on this GSG, false
## otherwise.

proc releaseIndexBuffer*(this: PreparedGraphicsObjects, ibc: IndexBufferContext) {.importcpp: "#->release_index_buffer(#)".} ## \
## Indicates that a data context, created by a previous call to
## prepare_index_buffer(), is no longer needed.  The driver resources will not
## be freed until some GSG calls update(), indicating it is at a stage where
## it is ready to release datas--this prevents conflicts from threading or
## multiple GSG's sharing datas (we have no way of knowing which graphics
## context is currently active, or what state it's in, at the time
## release_index_buffer is called).

proc releaseAllIndexBuffers*(this: PreparedGraphicsObjects): int {.importcpp: "#->release_all_index_buffers()".} ## \
## Releases all datas at once.  This will force them to be reloaded into data
## memory for all GSG's that share this object.  Returns the number of datas
## released.

proc getNumQueuedIndexBuffers*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_queued_index_buffers()".} ## \
## Returns the number of index buffers that have been enqueued to be prepared
## on this GSG.

proc getNumPreparedIndexBuffers*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_prepared_index_buffers()".} ## \
## Returns the number of index buffers that have already been prepared on this
## GSG.

proc prepareIndexBufferNow*(this: PreparedGraphicsObjects, data: GeomPrimitive, gsg: GraphicsStateGuardianBase): IndexBufferContext {.importcpp: "#->prepare_index_buffer_now(#, #)".} ## \
## Immediately creates a new IndexBufferContext for the indicated data and
## returns it.  This assumes that the GraphicsStateGuardian is the currently
## active rendering context and that it is ready to accept new datas.  If this
## is not necessarily the case, you should use enqueue_index_buffer() instead.
##
## Normally, this function is not called directly.  Call Data::prepare_now()
## instead.
##
## The IndexBufferContext contains all of the pertinent information needed by
## the GSG to keep track of this one particular data, and will exist as long
## as the data is ready to be rendered.
##
## When either the Data or the PreparedGraphicsObjects object destructs, the
## IndexBufferContext will be deleted.

proc enqueueShaderBuffer*(this: PreparedGraphicsObjects, data: ShaderBuffer) {.importcpp: "#->enqueue_shader_buffer(#)".} ## \
## Indicates that a buffer would like to be put on the list to be prepared
## when the GSG is next ready to do this (presumably at the next frame).

proc isShaderBufferQueued*(this: PreparedGraphicsObjects, data: ShaderBuffer): bool {.importcpp: "#->is_shader_buffer_queued(#)".} ## \
## Returns true if the index buffer has been queued on this GSG, false
## otherwise.

proc dequeueShaderBuffer*(this: PreparedGraphicsObjects, data: ShaderBuffer): bool {.importcpp: "#->dequeue_shader_buffer(#)".} ## \
## Removes a buffer from the queued list of data arrays to be prepared.
## Normally it is not necessary to call this, unless you change your mind
## about preparing it at the last minute, since the data will automatically be
## dequeued and prepared at the next frame.
##
## The return value is true if the buffer is successfully dequeued, false if
## it had not been queued.

proc isShaderBufferPrepared*(this: PreparedGraphicsObjects, data: ShaderBuffer): bool {.importcpp: "#->is_shader_buffer_prepared(#)".} ## \
## Returns true if the index buffer has been prepared on this GSG, false
## otherwise.

proc releaseShaderBuffer*(this: PreparedGraphicsObjects, bc: BufferContext) {.importcpp: "#->release_shader_buffer(#)".} ## \
## Indicates that a data context, created by a previous call to
## prepare_shader_buffer(), is no longer needed.  The driver resources will not
## be freed until some GSG calls update(), indicating it is at a stage where
## it is ready to release datas--this prevents conflicts from threading or
## multiple GSG's sharing datas (we have no way of knowing which graphics
## context is currently active, or what state it's in, at the time
## release_shader_buffer is called).

proc releaseAllShaderBuffers*(this: PreparedGraphicsObjects): int {.importcpp: "#->release_all_shader_buffers()".} ## \
## Releases all datas at once.  This will force them to be reloaded into data
## memory for all GSG's that share this object.  Returns the number of datas
## released.

proc getNumQueuedShaderBuffers*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_queued_shader_buffers()".} ## \
## Returns the number of index buffers that have been enqueued to be prepared
## on this GSG.

proc getNumPreparedShaderBuffers*(this: PreparedGraphicsObjects): int {.importcpp: "#->get_num_prepared_shader_buffers()".} ## \
## Returns the number of index buffers that have already been prepared on this
## GSG.

proc prepareShaderBufferNow*(this: PreparedGraphicsObjects, data: ShaderBuffer, gsg: GraphicsStateGuardianBase): BufferContext {.importcpp: "#->prepare_shader_buffer_now(#, #)".} ## \
## Immediately creates a new BufferContext for the indicated data and
## returns it.  This assumes that the GraphicsStateGuardian is the currently
## active rendering context and that it is ready to accept new datas.  If this
## is not necessarily the case, you should use enqueue_shader_buffer() instead.
##
## Normally, this function is not called directly.  Call Data::prepare_now()
## instead.
##
## The BufferContext contains all of the pertinent information needed by
## the GSG to keep track of this one particular data, and will exist as long
## as the data is ready to be rendered.
##
## When either the Data or the PreparedGraphicsObjects object destructs, the
## BufferContext will be deleted.

converter upcastToBufferContext*(this: IndexBufferContext): BufferContext {.importcpp: "#.upcast_to_BufferContext()".}

converter upcastToAdaptiveLruPage*(this: IndexBufferContext): AdaptiveLruPage {.importcpp: "#.upcast_to_AdaptiveLruPage()".}

proc getData*(this: IndexBufferContext): GeomPrimitive {.importcpp: "#.get_data()".} ## \
## Returns the pointer to the client-side array data object.

converter getClassType*(_: typedesc[IndexBufferContext]): TypeHandle {.importcpp: "IndexBufferContext::get_class_type()", header: "indexBufferContext.h".}

proc makeCopy*(this: Lens): Lens {.importcpp: "#->make_copy()".}

proc extrude*(this: Lens, point2d: LPoint2, near_point: LPoint3, far_point: LPoint3): bool {.importcpp: "#->extrude(#, #, #)".} ## \
## Given a 2-d point in the range (-1,1) in both dimensions, where (0,0) is
## the center of the lens and (-1,-1) is the lower-left corner, compute the
## corresponding vector in space that maps to this point, if such a vector can
## be determined.  The vector is returned by indicating the points on the near
## plane and far plane that both map to the indicated 2-d point.
##
## Returns true if the vector is defined, or false otherwise.

proc extrude*(this: Lens, point2d: LPoint3, near_point: LPoint3, far_point: LPoint3): bool {.importcpp: "#->extrude(#, #, #)".} ## \
## Given a 2-d point in the range (-1,1) in both dimensions, where (0,0) is
## the center of the lens and (-1,-1) is the lower-left corner, compute the
## corresponding vector in space that maps to this point, if such a vector can
## be determined.  The vector is returned by indicating the points on the near
## plane and far plane that both map to the indicated 2-d point.
##
## The z coordinate of the 2-d point is ignored.
##
## Returns true if the vector is defined, or false otherwise.

proc extrudeDepth*(this: Lens, point2d: LPoint3, point3d: LPoint3): bool {.importcpp: "#->extrude_depth(#, #)".} ## \
## Uses the depth component of the 3-d result from project() to compute the
## original point in 3-d space corresponding to a particular point on the
## lens.  This exactly reverses project(), assuming the point does fall
## legitimately within the lens.

proc extrudeVec*(this: Lens, point2d: LPoint2, vec3d: LVector3): bool {.importcpp: "#->extrude_vec(#, #)".} ## \
## Given a 2-d point in the range (-1,1) in both dimensions, where (0,0) is
## the center of the lens and (-1,-1) is the lower-left corner, compute the
## vector that corresponds to the view direction.  This will be parallel to
## the normal on the surface (the far plane) corresponding to the lens shape
## at this point.
##
## See the comment block on Lens::extrude_vec_impl() for a more in-depth
## comment on the meaning of this vector.
##
## Returns true if the vector is defined, or false otherwise.

proc extrudeVec*(this: Lens, point2d: LPoint3, vec3d: LVector3): bool {.importcpp: "#->extrude_vec(#, #)".} ## \
## Given a 2-d point in the range (-1,1) in both dimensions, where (0,0) is
## the center of the lens and (-1,-1) is the lower-left corner, compute the
## vector that corresponds to the view direction.  This will be parallel to
## the normal on the surface (the far plane) corresponding to the lens shape
## at this point.
##
## See the comment block on Lens::extrude_vec_impl() for a more in-depth
## comment on the meaning of this vector.
##
## The z coordinate of the 2-d point is ignored.
##
## Returns true if the vector is defined, or false otherwise.

proc project*(this: Lens, point3d: LPoint3, point2d: LPoint2): bool {.importcpp: "#->project(#, #)".} ## \
## Given a 3-d point in space, determine the 2-d point this maps to, in the
## range (-1,1) in both dimensions, where (0,0) is the center of the lens and
## (-1,-1) is the lower-left corner.
##
## Returns true if the 3-d point is in front of the lens and within the
## viewing frustum (in which case point2d is filled in), or false otherwise
## (in which case point2d will be filled in with something, which may or may
## not be meaningful).

proc project*(this: Lens, point3d: LPoint3, point2d: LPoint3): bool {.importcpp: "#->project(#, #)".} ## \
## Given a 3-d point in space, determine the 2-d point this maps to, in the
## range (-1,1) in both dimensions, where (0,0) is the center of the lens and
## (-1,-1) is the lower-left corner.
##
## The z coordinate will also be set to a value in the range (-1, 1), where 1
## represents a point on the near plane, and -1 represents a point on the far
## plane.
##
## Returns true if the 3-d point is in front of the lens and within the
## viewing frustum (in which case point2d is filled in), or false otherwise
## (in which case point2d will be filled in with something, which may or may
## not be meaningful).

proc setChangeEvent*(this: Lens, event: string) {.importcpp: "#->set_change_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the name of the event that will be generated whenever any properties
## of the Lens have changed.  If this is not set for a particular lens, no
## event will be generated.
##
## The event is thrown with one parameter, the lens itself.  This can be used
## to automatically track changes to camera fov, etc.  in the application.

proc getChangeEvent*(this: Lens): string {.importcpp: "nimStringFromStdString(#->get_change_event())", header: stringConversionCode.} ## \
## Returns the name of the event that will be generated whenever any
## properties of this particular Lens have changed.

proc setCoordinateSystem*(this: Lens, cs: CoordinateSystem) {.importcpp: "#->set_coordinate_system(#)".} ## \
## Specifies the coordinate system that all 3-d computations are performed
## within for this Lens.  Normally, this is CS_default.

proc getCoordinateSystem*(this: Lens): CoordinateSystem {.importcpp: "#->get_coordinate_system()".} ## \
## Returns the coordinate system that all 3-d computations are performed
## within for this Lens.  Normally, this is CS_default.

proc clear*(this: Lens) {.importcpp: "#->clear()".} ## \
## Resets all lens parameters to their initial default settings.

proc setFilmSize*(this: Lens, film_size: LVecBase2) {.importcpp: "#->set_film_size(#)".} ## \
## Sets the size and shape of the "film" within the lens.  This both
## establishes the units used by calls like set_focal_length(), and
## establishes the aspect ratio of the frame.
##
## In a physical camera, the field of view of a lens is determined by the
## lens' focal length and by the size of the film area exposed by the lens.
## For instance, a 35mm camera exposes a rectangle on the film about 24mm x
## 36mm, which means a 50mm lens gives about a 40-degree horizontal field of
## view.
##
## In the virtual camera, you may set the film size to any units here, and
## specify a focal length in the same units to simulate the same effect.  Or,
## you may ignore this parameter, and specify the field of view and aspect
## ratio of the lens directly.

proc setFilmSize*(this: Lens, width: float32) {.importcpp: "#->set_film_size(#)".} ## \
## Sets the horizontal size of the film without changing its shape.  The
## aspect ratio remains unchanged; this computes the vertical size of the film
## to automatically maintain the aspect ratio.

proc setFilmSize*(this: Lens, width: float32, height: float32) {.importcpp: "#->set_film_size(#, #)".} ## \
## Sets the size and shape of the "film" within the lens.  This both
## establishes the units used by calls like set_focal_length(), and
## establishes the aspect ratio of the frame.
##
## In a physical camera, the field of view of a lens is determined by the
## lens' focal length and by the size of the film area exposed by the lens.
## For instance, a 35mm camera exposes a rectangle on the film about 24mm x
## 36mm, which means a 50mm lens gives about a 40-degree horizontal field of
## view.
##
## In the virtual camera, you may set the film size to any units here, and
## specify a focal length in the same units to simulate the same effect.  Or,
## you may ignore this parameter, and specify the field of view and aspect
## ratio of the lens directly.

proc getFilmSize*(this: Lens): LVecBase2 {.importcpp: "#->get_film_size()".} ## \
## Returns the horizontal and vertical film size of the virtual film.  See
## set_film_size().

proc setFilmOffset*(this: Lens, film_offset: LVecBase2) {.importcpp: "#->set_film_offset(#)".} ## \
## Sets the horizontal and vertical offset amounts of this Lens.  These are
## both in the same units specified in set_film_size().
##
## This can be used to establish an off-axis lens.

proc setFilmOffset*(this: Lens, x: float32, y: float32) {.importcpp: "#->set_film_offset(#, #)".} ## \
## Sets the horizontal and vertical offset amounts of this Lens.  These are
## both in the same units specified in set_film_size().
##
## This can be used to establish an off-axis lens.

proc getFilmOffset*(this: Lens): LVector2 {.importcpp: "#->get_film_offset()".} ## \
## Returns the horizontal and vertical offset amounts of this Lens.  See
## set_film_offset().

proc setFocalLength*(this: Lens, focal_length: float32) {.importcpp: "#->set_focal_length(#)".} ## \
## Sets the focal length of the lens.  This may adjust the field-of-view
## correspondingly, and is an alternate way to specify field of view.
##
## For certain kinds of lenses (e.g.  OrthographicLens), the focal length has
## no meaning.

proc getFocalLength*(this: Lens): float32 {.importcpp: "#->get_focal_length()".} ## \
## Returns the focal length of the lens.  This may have been set explicitly by
## a previous call to set_focal_length(), or it may be computed based on the
## lens' fov and film_size.  For certain kinds of lenses, the focal length has
## no meaning.

proc setMinFov*(this: Lens, min_fov: float32) {.importcpp: "#->set_min_fov(#)".} ## \
## Sets the field of view of the smallest dimension of the window.  If the
## window is wider than it is tall, this specifies the vertical field of view;
## if it is taller than it is wide, this specifies the horizontal field of
## view.
##
## In many cases, this is preferable to setting either the horizontal or
## vertical field of view explicitly.  Setting this parameter means that
## pulling the window wider will widen the field of view, which is usually
## what you expect to happen.

proc setFov*(this: Lens, fov: LVecBase2) {.importcpp: "#->set_fov(#)".} ## \
## Sets the field of view of the lens in both dimensions.  This establishes
## both the field of view and the aspect ratio of the lens.  This is one way
## to specify the field of view of a lens; set_focal_length() is another way.
##
## For certain kinds of lenses (like OrthographicLens), the field of view has
## no meaning.

proc setFov*(this: Lens, fov: float32) {.importcpp: "#->set_fov(#)".} ## \
## Sets the horizontal field of view of the lens without changing the aspect
## ratio.  The vertical field of view is adjusted to maintain the same aspect
## ratio.

proc setFov*(this: Lens, hfov: float32, vfov: float32) {.importcpp: "#->set_fov(#, #)".} ## \
## Sets the field of view of the lens in both dimensions.  This establishes
## both the field of view and the aspect ratio of the lens.  This is one way
## to specify the field of view of a lens; set_focal_length() is another way.
##
## For certain kinds of lenses (like OrthoLens), the field of view has no
## meaning.

proc getFov*(this: Lens): LVecBase2 {.importcpp: "#->get_fov()".} ## \
## Returns the horizontal and vertical film size of the virtual film.  See
## set_fov().

proc getHfov*(this: Lens): float32 {.importcpp: "#->get_hfov()".} ## \
## Returns the horizontal component of fov only.  See get_fov().

proc getVfov*(this: Lens): float32 {.importcpp: "#->get_vfov()".} ## \
## Returns the vertical component of fov only.  See get_fov().

proc getMinFov*(this: Lens): float32 {.importcpp: "#->get_min_fov()".} ## \
## Returns the field of view of the narrowest dimension of the window.  See
## set_min_fov().

proc setAspectRatio*(this: Lens, aspect_ratio: float32) {.importcpp: "#->set_aspect_ratio(#)".} ## \
## Sets the aspect ratio of the lens.  This is the ratio of the height to the
## width of the generated image.  Setting this overrides the two-parameter fov
## or film size setting.

proc getAspectRatio*(this: Lens): float32 {.importcpp: "#->get_aspect_ratio()".} ## \
## Returns the aspect ratio of the Lens.  This is determined based on the
## indicated film size; see set_film_size().

proc setNear*(this: Lens, near_distance: float32) {.importcpp: "#->set_near(#)".} ## \
## Defines the position of the near plane (or cylinder, sphere, whatever).
## Points closer to the lens than this may not be rendered.

proc getNear*(this: Lens): float32 {.importcpp: "#->get_near()".} ## \
## Returns the position of the near plane (or cylinder, sphere, whatever).

proc setFar*(this: Lens, far_distance: float32) {.importcpp: "#->set_far(#)".} ## \
## Defines the position of the far plane (or cylinder, sphere, whatever).
## Points farther from the lens than this may not be rendered.

proc getFar*(this: Lens): float32 {.importcpp: "#->get_far()".} ## \
## Returns the position of the far plane (or cylinder, sphere, whatever).

proc setNearFar*(this: Lens, near_distance: float32, far_distance: float32) {.importcpp: "#->set_near_far(#, #)".} ## \
## Simultaneously changes the near and far planes.

proc getDefaultNear*(_: typedesc[Lens]): float32 {.importcpp: "Lens::get_default_near()", header: "lens.h".} ## \
## Returns the default near plane distance that will be assigned to each
## newly-created lens.  This is read from the Config.prc file.

proc getDefaultFar*(_: typedesc[Lens]): float32 {.importcpp: "Lens::get_default_far()", header: "lens.h".} ## \
## Returns the default far plane distance that will be assigned to each newly-
## created lens.  This is read from the Config.prc file.

proc setViewHpr*(this: Lens, view_hpr: LVecBase3) {.importcpp: "#->set_view_hpr(#)".} ## \
## Sets the direction in which the lens is facing.  Normally, this is down the
## forward axis (usually the Y axis), but it may be rotated.  This is only one
## way of specifying the rotation; you may also specify an explicit vector in
## which to look, or you may give a complete transformation matrix.

proc setViewHpr*(this: Lens, h: float32, p: float32, r: float32) {.importcpp: "#->set_view_hpr(#, #, #)".} ## \
## Sets the direction in which the lens is facing.  Normally, this is down the
## forward axis (usually the Y axis), but it may be rotated.  This is only one
## way of specifying the rotation; you may also specify an explicit vector in
## which to look, or you may give a complete transformation matrix.

proc getViewHpr*(this: Lens): LVecBase3 {.importcpp: "#->get_view_hpr()".} ## \
## Returns the direction in which the lens is facing.

proc setViewVector*(this: Lens, view_vector: LVector3, up_vector: LVector3) {.importcpp: "#->set_view_vector(#, #)".} ## \
## Specifies the direction in which the lens is facing by giving an axis to
## look along, and a perpendicular (or at least non-parallel) up axis.
##
## See also set_view_hpr().

proc setViewVector*(this: Lens, x: float32, y: float32, z: float32, i: float32, j: float32, k: float32) {.importcpp: "#->set_view_vector(#, #, #, #, #, #)".} ## \
## Specifies the direction in which the lens is facing by giving an axis to
## look along, and a perpendicular (or at least non-parallel) up axis.
##
## See also set_view_hpr().

proc getViewVector*(this: Lens): LVector3 {.importcpp: "#->get_view_vector()".} ## \
## Returns the axis along which the lens is facing.

proc getUpVector*(this: Lens): LVector3 {.importcpp: "#->get_up_vector()".} ## \
## Returns the axis perpendicular to the camera's view vector that indicates
## the "up" direction.

proc getNodalPoint*(this: Lens): LPoint3 {.importcpp: "#->get_nodal_point()".} ## \
## Returns the center point of the lens: the point from which the lens is
## viewing.

proc setInterocularDistance*(this: Lens, interocular_distance: float32) {.importcpp: "#->set_interocular_distance(#)".} ## \
## Sets the distance between the left and right eyes of a stereo camera.  This
## distance is used to apply a stereo effect when the lens is rendered on a
## stereo display region.  It only has an effect on a PerspectiveLens.
##
## The left eye and the right eye are each offset along the X axis by half of
## this distance, so that this parameter specifies the total distance between
## them.
##
## Also see set_convergence_distance(), which relates.

proc getInterocularDistance*(this: Lens): float32 {.importcpp: "#->get_interocular_distance()".} ## \
## See set_interocular_distance().

proc setConvergenceDistance*(this: Lens, convergence_distance: float32) {.importcpp: "#->set_convergence_distance(#)".} ## \
## Sets the distance between between the camera plane and the point in the
## distance that the left and right eyes are both looking at.  This distance
## is used to apply a stereo effect when the lens is rendered on a stereo
## display region.  It only has an effect on a PerspectiveLens.
##
## This parameter must be greater than 0, but may be as large as you like.  It
## controls the distance at which the two stereo images will appear to
## converge, which is a normal property of stereo vision.  Normally this
## should be set to the distance from the camera to the area of interest in
## your scene.  Anything beyond this distance will appear to go into the
## screen, and anything closer will appear to come out of the screen.  If you
## want to simulate parallel stereo, set this to infinity.
##
## Note that this creates an off-axis frustum, which means that the lenses are
## still pointing in the same direction, which is usually more desirable than
## the more naive toe-in approach, where the two lenses are simply tilted
## toward each other.
##
## Prior to Panda3D 1.9.0, the convergence was being calculated incorrectly.
## It has since been corrected.  To restore the legacy behavior you can set
## the stereo-lens-old-convergence variable to true.
##
## Also see set_interocular_distance(), which relates.

proc getConvergenceDistance*(this: Lens): float32 {.importcpp: "#->get_convergence_distance()".} ## \
## See set_convergence_distance().

proc setViewMat*(this: Lens, view_mat: LMatrix4) {.importcpp: "#->set_view_mat(#)".} ## \
## Sets an arbitrary transformation on the lens.  This replaces the individual
## transformation components like set_view_hpr().
##
## Setting a transformation here will have a slightly different effect than
## putting one on the LensNode that contains this lens.  In particular,
## lighting and other effects computations will still be performed on the lens
## in its untransformed (facing forward) position, but the actual projection
## matrix will be transformed by this matrix.

proc getViewMat*(this: Lens): LMatrix4 {.importcpp: "#->get_view_mat()".} ## \
## Returns the direction in which the lens is facing.

proc clearViewMat*(this: Lens) {.importcpp: "#->clear_view_mat()".} ## \
## Resets the lens transform to identity.

proc setKeystone*(this: Lens, keystone: LVecBase2) {.importcpp: "#->set_keystone(#)".} ## \
## Indicates the ratio of keystone correction to perform on the lens, in each
## of three axes.  This will build a special non-affine scale factor into the
## projection matrix that will compensate for keystoning of a projected image;
## this can be used to compensate for a projector that for physical reasons
## cannot be aimed directly at its screen.
##
## The default value is taken from the default-keystone Config variable.  0, 0
## indicates no keystone correction; specify a small value (usually in the
## range -1 .. 1) in either the x or y position to generate a keystone
## correction in that axis.

proc getKeystone*(this: Lens): LVecBase2 {.importcpp: "#->get_keystone()".} ## \
## Returns the keystone correction specified for the lens.

proc clearKeystone*(this: Lens) {.importcpp: "#->clear_keystone()".} ## \
## Disables the lens keystone correction.

proc setCustomFilmMat*(this: Lens, custom_film_mat: LMatrix4) {.importcpp: "#->set_custom_film_mat(#)".} ## \
## Specifies a custom matrix to transform the points on the film after they
## have been converted into nominal film space (-1 .. 1 in U and V).  This can
## be used to introduce arbitrary scales, rotations, or other linear
## transforms to the media plane.  This is normally a 2-d matrix, but a full
## 4x4 matrix may be specified.  This is applied on top of any film size, lens
## shift, and/or keystone correction.

proc getCustomFilmMat*(this: Lens): LMatrix4 {.importcpp: "#->get_custom_film_mat()".} ## \
## Returns the custom_film_mat specified for the lens.

proc clearCustomFilmMat*(this: Lens) {.importcpp: "#->clear_custom_film_mat()".} ## \
## Disables the lens custom_film_mat correction.

proc setFrustumFromCorners*(this: Lens, ul: LVecBase3, ur: LVecBase3, ll: LVecBase3, lr: LVecBase3, flags: int) {.importcpp: "#->set_frustum_from_corners(#, #, #, #, #)".} ## \
## Sets up the lens to use the frustum defined by the four indicated points.
## This is most useful for a PerspectiveLens, but it may be called for other
## kinds of lenses as well.
##
## The frustum will be rooted at the origin (or by whatever translation might
## have been specified in a previous call to set_view_mat).
##
## It is legal for the four points not to be arranged in a rectangle; if this
## is the case, the frustum will be fitted as tightly as possible to cover all
## four points.
##
## The flags parameter contains the union of one or more of the following bits
## to control the behavior of this function:
##
## FC_roll - If this is included, the camera may be rotated so that its up
## vector is perpendicular to the top line.  Otherwise, the standard up vector
## is used.
##
## FC_camera_plane - This allows the camera plane to be adjusted to be as
## nearly perpendicular to the center of the frustum as possible.  Without
## this bit, the orientation camera plane is defined by position of the four
## points (which should all be coplanar).  With this bit, the camera plane is
## arbitrary, and may be chosen so that the four points do not themselves lie
## in the camera plane (but the points will still be within the frustum).
##
## FC_off_axis - This allows the resulting frustum to be off-axis to get the
## tightest possible fit.  Without this bit, the viewing axis will be centered
## within the frustum, but there may be more wasted space along the edges.
##
## FC_aspect_ratio - This allows the frustum to be scaled non-proportionately
## in the vertical and horizontal dimensions, if necessary, to get a tighter
## fit.  Without this bit, the current aspect ratio will be preserved.
##
## FC_shear - This allows the frustum to be sheared, if necessary, to get the
## tightest possible fit.  This may result in a parallelogram-based frustum,
## which will give a slanted appearance to the rendered image.  Without this
## bit, the frustum will be rectangle-based.
##
## In general, if 0 is passed in as the value for flags, the generated frustum
## will be a loose fit but sane; if -1 is passed in, it will be a tighter fit
## and possibly screwy.

proc recomputeAll*(this: Lens) {.importcpp: "#->recompute_all()".} ## \
## Forces all internal parameters of the Lens to be recomputed.  Normally,
## this should never need to be called; it is provided only to assist in
## debugging.

proc isLinear*(this: Lens): bool {.importcpp: "#->is_linear()".} ## \
## Returns true if the lens represents a linear projection (e.g.
## PerspectiveLens, OrthographicLens), and therefore there is a valid matrix
## returned by get_projection_mat(), or false otherwise.

proc isPerspective*(this: Lens): bool {.importcpp: "#->is_perspective()".} ## \
## Returns true if the lens represents a perspective projection (i.e.  it is a
## PerspectiveLens), false otherwise.

proc isOrthographic*(this: Lens): bool {.importcpp: "#->is_orthographic()".} ## \
## Returns true if the lens represents a orthographic projection (i.e.  it is
## a OrthographicLens), false otherwise.

proc makeGeometry*(this: Lens): Geom {.importcpp: "#->make_geometry()".} ## \
## Allocates and returns a new Geom that can be rendered to show a visible
## representation of the frustum used for this kind of lens, if it makes sense
## to do so.  If a visible representation cannot be created, returns NULL.

proc makeBounds*(this: Lens): BoundingVolume {.importcpp: "#->make_bounds()".} ## \
## Allocates and returns a new BoundingVolume that encloses the frustum used
## for this kind of lens, if possible.  If a suitable bounding volume cannot
## be created, returns NULL.

proc getProjectionMat*(this: Lens): LMatrix4 {.importcpp: "#->get_projection_mat()".} ## \
## Returns the complete transformation matrix from a 3-d point in space to a
## point on the film, if such a matrix exists, or the identity matrix if the
## lens is nonlinear.

proc getProjectionMatInv*(this: Lens): LMatrix4 {.importcpp: "#->get_projection_mat_inv()".} ## \
## Returns the matrix that transforms from a 2-d point on the film to a 3-d
## vector in space, if such a matrix exists.

proc getFilmMat*(this: Lens): LMatrix4 {.importcpp: "#->get_film_mat()".} ## \
## Returns the matrix that transforms from a point behind the lens to a point
## on the film.

proc getFilmMatInv*(this: Lens): LMatrix4 {.importcpp: "#->get_film_mat_inv()".} ## \
## Returns the matrix that transforms from a point on the film to a point
## behind the lens.

proc getLensMat*(this: Lens): LMatrix4 {.importcpp: "#->get_lens_mat()".} ## \
## Returns the matrix that transforms from a point in front of the lens to a
## point in space.

proc getLensMatInv*(this: Lens): LMatrix4 {.importcpp: "#->get_lens_mat_inv()".} ## \
## Returns the matrix that transforms from a point in space to a point in
## front of the lens.

proc output*(this: Lens, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: Lens, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: Lens, `out`: ostream) {.importcpp: "#->write(#)".}

proc getLastChange*(this: Lens): UpdateSeq {.importcpp: "#->get_last_change()".} ## \
## Returns the UpdateSeq that is incremented whenever the lens properties are
## changed.  As long as this number remains the same, you may assume the lens
## properties are unchanged.

converter getClassType*(_: typedesc[Lens]): TypeHandle {.importcpp: "Lens::get_class_type()", header: "lens.h".}

converter upcastToTypedWritableReferenceCount*(this: Material): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcastToNamable*(this: Material): Namable {.importcpp: "((Namable *)(Material *)(#))".}

proc newMaterial*(copy: Material): Material {.importcpp: "new Material(#)".}

proc newMaterial*(name: string): Material {.importcpp: "new Material(nimStringToStdString(#))", header: stringConversionCode.}

proc newMaterial*(): Material {.importcpp: "new Material()".}

proc getDefault*(_: typedesc[Material]): Material {.importcpp: "Material::get_default()", header: "material.h".} ## \
## Returns the default material.

proc hasBaseColor*(this: Material): bool {.importcpp: "#->has_base_color()".} ## \
## Returns true if the base color has been explicitly set for this material,
## false otherwise.

proc getBaseColor*(this: Material): LColor {.importcpp: "#->get_base_color()".} ## \
## Returns the base_color color setting, if it has been set.  If neither the
## base color nor the metallic have been set, this returns the diffuse color.

proc setBaseColor*(this: Material, color: LColor) {.importcpp: "#->set_base_color(#)".} ## \
## Specifies the base color of the material.  In conjunction with
## set_metallic, this is an alternate way to specify the color of a material.
## For dielectrics, this will determine the value of the diffuse color, and
## for metals, this will determine the value of the specular color.
##
## Setting this will clear an explicit specular, diffuse or ambient color
## assignment.
##
## If this is not set, the object color will be used.

proc clearBaseColor*(this: Material) {.importcpp: "#->clear_base_color()".} ## \
## Removes the explicit base_color color from the material.

proc hasAmbient*(this: Material): bool {.importcpp: "#->has_ambient()".} ## \
## Returns true if the ambient color has been explicitly set for this
## material, false otherwise.

proc getAmbient*(this: Material): LColor {.importcpp: "#->get_ambient()".} ## \
## Returns the ambient color setting, if it has been set.  Returns (0,0,0,0)
## if the ambient color has not been set.

proc setAmbient*(this: Material, color: LColor) {.importcpp: "#->set_ambient(#)".} ## \
## Specifies the ambient color setting of the material.  This will be the
## multiplied by any ambient lights in effect on the material to set its base
## color.
##
## This is the color of the object as it appears in the absence of direct
## light.
##
## If this is not set, the object color will be used.

proc clearAmbient*(this: Material) {.importcpp: "#->clear_ambient()".} ## \
## Removes the explicit ambient color from the material.

proc hasDiffuse*(this: Material): bool {.importcpp: "#->has_diffuse()".} ## \
## Returns true if the diffuse color has been explicitly set for this
## material, false otherwise.

proc getDiffuse*(this: Material): LColor {.importcpp: "#->get_diffuse()".} ## \
## Returns the diffuse color setting, if it has been set.  Returns (1,1,1,1)
## if the diffuse color has not been set.

proc setDiffuse*(this: Material, color: LColor) {.importcpp: "#->set_diffuse(#)".} ## \
## Specifies the diffuse color setting of the material.  This will be
## multiplied by any lights in effect on the material to get the color in the
## parts of the object illuminated by the lights.
##
## This is the primary color of an object; the color of the object as it
## appears in direct light, in the absence of highlights.
##
## If this is not set, the object color will be used.

proc clearDiffuse*(this: Material) {.importcpp: "#->clear_diffuse()".} ## \
## Removes the explicit diffuse color from the material.

proc hasSpecular*(this: Material): bool {.importcpp: "#->has_specular()".} ## \
## Returns true if the specular color has been explicitly set for this
## material, false otherwise.

proc getSpecular*(this: Material): LColor {.importcpp: "#->get_specular()".} ## \
## Returns the specular color setting, if it has been set.  Returns (0,0,0,0)
## if the specular color has not been set.

proc setSpecular*(this: Material, color: LColor) {.importcpp: "#->set_specular(#)".} ## \
## Specifies the specular color setting of the material.  This will be
## multiplied by any lights in effect on the material to compute the color of
## specular highlights on the object.
##
## This is the highlight color of an object: the color of small highlight
## reflections.
##
## If this is not set, the specular color is taken from the index of
## refraction, which is 1 by default (meaning no specular reflections are
## generated).

proc clearSpecular*(this: Material) {.importcpp: "#->clear_specular()".} ## \
## Removes the explicit specular color from the material.

proc hasEmission*(this: Material): bool {.importcpp: "#->has_emission()".} ## \
## Returns true if the emission color has been explicitly set for this
## material, false otherwise.

proc getEmission*(this: Material): LColor {.importcpp: "#->get_emission()".} ## \
## Returns the emission color setting, if it has been set.  Returns (0,0,0,0)
## if the emission color has not been set.

proc setEmission*(this: Material, color: LColor) {.importcpp: "#->set_emission(#)".} ## \
## Specifies the emission color setting of the material.  This is the color of
## the object as it appears in the absence of any light whatsover, including
## ambient light.  It is as if the object is glowing by this color (although
## of course it will not illuminate neighboring objects).
##
## If this is not set, the object will not glow by its own light and will only
## appear visible in the presence of one or more lights.

proc clearEmission*(this: Material) {.importcpp: "#->clear_emission()".} ## \
## Removes the explicit emission color from the material.

proc getShininess*(this: Material): float32 {.importcpp: "#->get_shininess()".} ## \
## Returns the shininess exponent of the material.

proc setShininess*(this: Material, shininess: float32) {.importcpp: "#->set_shininess(#)".} ## \
## Sets the shininess exponent of the material.  This controls the size of the
## specular highlight spot.  In general, larger number produce a smaller
## specular highlight, which makes the object appear shinier.  Smaller numbers
## produce a larger highlight, which makes the object appear less shiny.
##
## This is usually in the range 0..128.
##
## Setting a shininess value removes any previous roughness assignment.

proc hasRoughness*(this: Material): bool {.importcpp: "#->has_roughness()".} ## \
## Returns true if the roughness has been explicitly set for this material,
## false otherwise.

proc getRoughness*(this: Material): float32 {.importcpp: "#->get_roughness()".} ## \
## Returns the roughness previously specified by set_roughness.  If none was
## previously set, this value is computed from the shininess value.

proc setRoughness*(this: Material, roughness: float32) {.importcpp: "#->set_roughness(#)".} ## \
## Sets the roughness exponent of the material, where 0 is completely shiny
## (infinite shininess), and 1 is a completely dull object (0 shininess).
## This is a different, more perceptually intuitive way of controlling the
## size of the specular spot, and more commonly used in physically-based
## rendering.
##
## Setting a roughness recalculates the shininess value.

proc hasMetallic*(this: Material): bool {.importcpp: "#->has_metallic()".} ## \
## Returns true if the metallic has been explicitly set for this material,
## false otherwise.

proc getMetallic*(this: Material): float32 {.importcpp: "#->get_metallic()".} ## \
## Returns the metallic setting, if it has been set.  Returns 0 if it has not
## been set.

proc setMetallic*(this: Material, metallic: float32) {.importcpp: "#->set_metallic(#)".} ## \
## Sets the metallic setting of the material, which is is used for physically-
## based rendering models.  This is usually 0 for dielectric materials and 1
## for metals.  It really does not make sense to set this to a value other
## than 0 or 1, but it is nonetheless a float for compatibility with tools
## that allow setting this to values other than 0 or 1.

proc clearMetallic*(this: Material) {.importcpp: "#->clear_metallic()".} ## \
## Removes the explicit metallic setting from the material.

proc hasRefractiveIndex*(this: Material): bool {.importcpp: "#->has_refractive_index()".} ## \
## Returns true if a refractive index has explicitly been specified for this
## material.

proc getRefractiveIndex*(this: Material): float32 {.importcpp: "#->get_refractive_index()".} ## \
## Returns the index of refraction, or 1 if none has been set for this
## material.

proc setRefractiveIndex*(this: Material, refractive_index: float32) {.importcpp: "#->set_refractive_index(#)".} ## \
## Sets the index of refraction of the material, which is used to determine
## the specular color in absence of an explicit specular color assignment.
## This is usually 1.5 for dielectric materials.  It is not very useful for
## metals, since they cannot be described as easily with a single number.
##
## Should be 1 or higher.  The default is 1.

proc getLocal*(this: Material): bool {.importcpp: "#->get_local()".} ## \
## Returns the local viewer flag.  Set set_local().

proc setLocal*(this: Material, local: bool) {.importcpp: "#->set_local(#)".} ## \
## Sets the local viewer flag.  Set this true to enable camera-relative
## specular highlights, or false to use orthogonal specular highlights.  The
## default value is true.  Applications that use orthogonal projection should
## specify false.

proc getTwoside*(this: Material): bool {.importcpp: "#->get_twoside()".} ## \
## Returns the state of the two-sided lighting flag.  See set_twoside().

proc setTwoside*(this: Material, twoside: bool) {.importcpp: "#->set_twoside(#)".} ## \
## Set this true to enable two-sided lighting.  When two-sided lighting is on,
## both sides of a polygon will be lit by this material.  The default is for
## two-sided lighting to be off, in which case only the front surface is lit.

proc `==`*(this: Material, other: Material): bool {.importcpp: "#->operator ==(#)".}

proc `!=`*(this: Material, other: Material): bool {.importcpp: "#->operator !=(#)".}

proc `<`*(this: Material, other: Material): bool {.importcpp: "#->operator <(#)".}

proc compareTo*(this: Material, other: Material): int {.importcpp: "#->compare_to(#)".} ## \
## Returns a number less than zero if this material sorts before the other
## one, greater than zero if it sorts after, or zero if they are equivalent.
## The sorting order is arbitrary and largely meaningless, except to
## differentiate different materials.

proc output*(this: Material, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: Material, `out`: ostream, indent: int) {.importcpp: "#->write(#, #)".}

proc isAttribLocked*(this: Material): bool {.importcpp: "#->is_attrib_locked()".} ## \
## @deprecated This no longer has any meaning in 1.10.

proc setAttribLock*(this: Material) {.importcpp: "#->set_attrib_lock()".} ## \
## @deprecated This no longer has any meaning in 1.10.

converter getClassType*(_: typedesc[Material]): TypeHandle {.importcpp: "Material::get_class_type()", header: "material.h".}

proc getMaterial*(_: typedesc[MaterialPool], temp: Material): Material {.importcpp: "#MaterialPool::get_material(#)", header: "materialPool.h".} ## \
## Returns a Material pointer that represents the same material described by
## temp, except that it is a shared pointer.
##
## Each call to get_material() passing an equivalent Material pointer will
## return the same shared pointer.
##
## If you modify the shared pointer, it will automatically disassociate it
## from the pool.
##
## Also, the return value may be a different pointer than that passed in, or
## it may be the same pointer.  In either case, the passed in pointer has now
## been sacrificed to the greater good and should not be used again (like any
## other PointerTo, it will be freed when the last reference count is
## removed).

proc releaseMaterial*(_: typedesc[MaterialPool], temp: Material) {.importcpp: "#MaterialPool::release_material(#)", header: "materialPool.h".} ## \
## Removes the indicated material from the pool.

proc releaseAllMaterials*(_: typedesc[MaterialPool]) {.importcpp: "MaterialPool::release_all_materials()", header: "materialPool.h".} ## \
## Releases all materials in the pool and restores the pool to the empty
## state.

proc garbageCollect*(_: typedesc[MaterialPool]): int {.importcpp: "MaterialPool::garbage_collect()", header: "materialPool.h".} ## \
## Releases only those materials in the pool that have a reference count of
## exactly 1; i.e.  only those materials that are not being used outside of
## the pool.  Returns the number of materials released.

proc listContents*(_: typedesc[MaterialPool], `out`: ostream) {.importcpp: "#MaterialPool::list_contents(#)", header: "materialPool.h".} ## \
## Lists the contents of the material pool to the indicated output stream.

proc write*(_: typedesc[MaterialPool], `out`: ostream) {.importcpp: "#MaterialPool::write(#)", header: "materialPool.h".} ## \
## Lists the contents of the material pool to the indicated output stream.

proc newMatrixLens*(): MatrixLens {.importcpp: "new MatrixLens()".}

proc setUserMat*(this: MatrixLens, user_mat: LMatrix4) {.importcpp: "#->set_user_mat(#)".} ## \
## Explicitly specifies the projection matrix.  This matrix should convert X
## and Y to the range [-film_size/2, film_size/2], where (-fs/2,-fs/2) is the
## lower left corner of the screen and (fs/2, fs/2) is the upper right.  Z
## should go to the range [-1, 1], where -1 is the near plane and 1 is the far
## plane.  Note that this is a left-handed Y-up coordinate system.
##
## The default film_size for a MatrixLens is 2, so the default range is [-1,
## 1] for both X and Y.  This is consistent with the GL conventions for
## projection matrices.

proc getUserMat*(this: MatrixLens): LMatrix4 {.importcpp: "#->get_user_mat()".} ## \
## Returns the explicit projection matrix as set by the user.  This does not
## include transforms on the lens or film (e.g.  a film offset or view hpr).

proc setLeftEyeMat*(this: MatrixLens, user_mat: LMatrix4) {.importcpp: "#->set_left_eye_mat(#)".} ## \
## Sets a custom projection matrix for the left eye.  This is only used if the
## lens is attached to a stereo camera, in which case the left eye matrix will
## be used to draw the scene in the left eye (but the center matrix--the
## user_mat--will still be used to cull the scene).
##
## This matrix should not be too different from the center matrix (set by
## set_user_mat()) or culling errors may become obvious.

proc clearLeftEyeMat*(this: MatrixLens) {.importcpp: "#->clear_left_eye_mat()".} ## \
## Removes the custom projection matrix set for the left eye, and uses the
## center matrix (set by set_user_mat) instead.

proc hasLeftEyeMat*(this: MatrixLens): bool {.importcpp: "#->has_left_eye_mat()".} ## \
## Returns true if the camera has a custom projection matrix set for the left
## eye, or false if the center matrix (set by set_user_mat) will be used for
## the left eye.

proc getLeftEyeMat*(this: MatrixLens): LMatrix4 {.importcpp: "#->get_left_eye_mat()".} ## \
## Returns the custom projection matrix for the left eye, if any, or the
## center matrix if there is no custom matrix set for the left eye.

proc setRightEyeMat*(this: MatrixLens, user_mat: LMatrix4) {.importcpp: "#->set_right_eye_mat(#)".} ## \
## Sets a custom projection matrix for the right eye.  This is only used if
## the lens is attached to a stereo camera, in which case the right eye matrix
## will be used to draw the scene in the right eye (but the center matrix--the
## user_mat--will still be used to cull the scene).
##
## This matrix should not be too different from the center matrix (set by
## set_user_mat()) or culling errors may become obvious.

proc clearRightEyeMat*(this: MatrixLens) {.importcpp: "#->clear_right_eye_mat()".} ## \
## Removes the custom projection matrix set for the right eye, and uses the
## center matrix (set by set_user_mat) instead.

proc hasRightEyeMat*(this: MatrixLens): bool {.importcpp: "#->has_right_eye_mat()".} ## \
## Returns true if the camera has a custom projection matrix set for the right
## eye, or false if the center matrix (set by set_user_mat) will be used for
## the right eye.

proc getRightEyeMat*(this: MatrixLens): LMatrix4 {.importcpp: "#->get_right_eye_mat()".} ## \
## Returns the custom projection matrix for the right eye, if any, or the
## center matrix if there is no custom matrix set for the right eye.

converter getClassType*(_: typedesc[MatrixLens]): TypeHandle {.importcpp: "MatrixLens::get_class_type()", header: "matrixLens.h".}

proc newOrthographicLens*(): OrthographicLens {.importcpp: "new OrthographicLens()".}

converter getClassType*(_: typedesc[OrthographicLens]): TypeHandle {.importcpp: "OrthographicLens::get_class_type()", header: "orthographicLens.h".}

proc newParamTextureSampler*(tex: Texture, sampler: SamplerState): ParamTextureSampler {.importcpp: "new ParamTextureSampler(#, #)".} ## \
## Creates a new ParamTextureSampler storing the given texture and sampler
## objects.

proc getTexture*(this: ParamTextureSampler): Texture {.importcpp: "#->get_texture()".} ## \
## Retrieves the texture stored in the parameter.

proc getSampler*(this: ParamTextureSampler): SamplerState {.importcpp: "#->get_sampler()".} ## \
## Retrieves the sampler state stored in the parameter.

converter getClassType*(_: typedesc[ParamTextureSampler]): TypeHandle {.importcpp: "ParamTextureSampler::get_class_type()", header: "paramTexture.h".}

proc newParamTextureImage*(tex: Texture, read: bool, write: bool, z: int, n: int): ParamTextureImage {.importcpp: "new ParamTextureImage(#, #, #, #, #)".} ## \
## Creates a new ParamTextureImage storing the given texture and image binding
## parameters.

proc newParamTextureImage*(tex: Texture, read: bool, write: bool, z: int): ParamTextureImage {.importcpp: "new ParamTextureImage(#, #, #, #)".} ## \
## Creates a new ParamTextureImage storing the given texture and image binding
## parameters.

proc newParamTextureImage*(tex: Texture, read: bool, write: bool): ParamTextureImage {.importcpp: "new ParamTextureImage(#, #, #)".} ## \
## Creates a new ParamTextureImage storing the given texture and image binding
## parameters.

proc getTexture*(this: ParamTextureImage): Texture {.importcpp: "#->get_texture()".} ## \
## Retrieves the texture stored in the parameter.

proc hasReadAccess*(this: ParamTextureImage): bool {.importcpp: "#->has_read_access()".} ## \
## Returns true if this image should be bound with read access enabled.

proc hasWriteAccess*(this: ParamTextureImage): bool {.importcpp: "#->has_write_access()".} ## \
## Returns true if this image should be bound with write access enabled.

proc getBindLayered*(this: ParamTextureImage): bool {.importcpp: "#->get_bind_layered()".} ## \
## Returns true if all layers of this image should be bound simultaneously.

proc getBindLevel*(this: ParamTextureImage): int {.importcpp: "#->get_bind_level()".} ## \
## Returns the image level that should be bound.

proc getBindLayer*(this: ParamTextureImage): int {.importcpp: "#->get_bind_layer()".} ## \
## Returns the image layer that should be bound.  This is undefined if
## get_bind_layered() returns false.

converter getClassType*(_: typedesc[ParamTextureImage]): TypeHandle {.importcpp: "ParamTextureImage::get_class_type()", header: "paramTexture.h".}

proc newPerspectiveLens*(): PerspectiveLens {.importcpp: "new PerspectiveLens()".}

proc newPerspectiveLens*(hfov: float32, vfov: float32): PerspectiveLens {.importcpp: "new PerspectiveLens(#, #)".}

converter getClassType*(_: typedesc[PerspectiveLens]): TypeHandle {.importcpp: "PerspectiveLens::get_class_type()", header: "perspectiveLens.h".}

proc newTextureReloadRequest*(param0: TextureReloadRequest): TextureReloadRequest {.importcpp: "new TextureReloadRequest(#)".}

proc newTextureReloadRequest*(name: string, pgo: PreparedGraphicsObjects, texture: Texture, allow_compressed: bool): TextureReloadRequest {.importcpp: "new TextureReloadRequest(nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## Create a new TextureReloadRequest, and add it to the loader via
## load_async(), to begin an asynchronous load.

proc getPreparedGraphicsObjects*(this: TextureReloadRequest): PreparedGraphicsObjects {.importcpp: "#->get_prepared_graphics_objects()".} ## \
## Returns the PreparedGraphicsObjects object associated with this
## asynchronous TextureReloadRequest.

proc getTexture*(this: TextureReloadRequest): Texture {.importcpp: "#->get_texture()".} ## \
## Returns the Texture object associated with this asynchronous
## TextureReloadRequest.

proc getAllowCompressed*(this: TextureReloadRequest): bool {.importcpp: "#->get_allow_compressed()".} ## \
## Returns the "allow compressed" flag associated with this asynchronous
## TextureReloadRequest.

proc isReady*(this: TextureReloadRequest): bool {.importcpp: "#->is_ready()".} ## \
## Returns true if this request has completed, false if it is still pending.
## Equivalent to `req.done() and not req.cancelled()`.
## @see done()

converter getClassType*(_: typedesc[TextureReloadRequest]): TypeHandle {.importcpp: "TextureReloadRequest::get_class_type()", header: "textureReloadRequest.h".}

converter upcastToBufferContext*(this: TextureContext): BufferContext {.importcpp: "#.upcast_to_BufferContext()".}

converter upcastToAdaptiveLruPage*(this: TextureContext): AdaptiveLruPage {.importcpp: "#.upcast_to_AdaptiveLruPage()".}

proc getTexture*(this: TextureContext): Texture {.importcpp: "#.get_texture()".} ## \
## Returns the pointer to the associated Texture object.

proc getView*(this: TextureContext): int {.importcpp: "#.get_view()".} ## \
## Returns the specific view of a multiview texture this context represents.
## In the usual case, with a non-multiview texture, this will be 0.

proc getNativeId*(this: TextureContext): clonglong {.importcpp: "#.get_native_id()".} ## \
## Returns an implementation-defined handle or pointer that can be used
## to interface directly with the underlying API.
## Returns 0 if the underlying implementation does not support this.

proc getNativeBufferId*(this: TextureContext): clonglong {.importcpp: "#.get_native_buffer_id()".} ## \
## Similar to get_native_id, but some implementations use a separate
## identifier for the buffer object associated with buffer textures.
## Returns 0 if the underlying implementation does not support this, or
## if this is not a buffer texture.

proc wasModified*(this: TextureContext): bool {.importcpp: "#.was_modified()".} ## \
## Returns true if the texture properties or image have been modified since
## the last time mark_loaded() was called.

proc wasPropertiesModified*(this: TextureContext): bool {.importcpp: "#.was_properties_modified()".} ## \
## Returns true if the texture properties (unrelated to the image) have been
## modified since the last time mark_loaded() was called.

proc wasImageModified*(this: TextureContext): bool {.importcpp: "#.was_image_modified()".} ## \
## Returns true if the texture image has been modified since the last time
## mark_loaded() was called.

proc wasSimpleImageModified*(this: TextureContext): bool {.importcpp: "#.was_simple_image_modified()".} ## \
## Returns true if the texture's "simple" image has been modified since the
## last time mark_simple_loaded() was called.

proc getPropertiesModified*(this: TextureContext): UpdateSeq {.importcpp: "#.get_properties_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the texture properties (unrelated to the image) are modified.

proc getImageModified*(this: TextureContext): UpdateSeq {.importcpp: "#.get_image_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the texture image data (including mipmap levels) are modified.

proc getSimpleImageModified*(this: TextureContext): UpdateSeq {.importcpp: "#.get_simple_image_modified()".} ## \
## Returns a sequence number which is guaranteed to change at least every time
## the texture's "simple" image data is modified.

converter getClassType*(_: typedesc[TextureContext]): TypeHandle {.importcpp: "TextureContext::get_class_type()", header: "textureContext.h".}

proc getShader*(this: ShaderContext): Shader {.importcpp: "#.get_shader()".}

converter getClassType*(_: typedesc[ShaderContext]): TypeHandle {.importcpp: "ShaderContext::get_class_type()", header: "shaderContext.h".}

proc newUserVertexSlider*(name: InternalName): UserVertexSlider {.importcpp: "new UserVertexSlider(#)".}

proc newUserVertexSlider*(name: string): UserVertexSlider {.importcpp: "new UserVertexSlider(nimStringToStdString(#))", header: stringConversionCode.}

proc setSlider*(this: UserVertexSlider, slider: float32) {.importcpp: "#->set_slider(#)".} ## \
## Stores the indicated slider value.

converter getClassType*(_: typedesc[UserVertexSlider]): TypeHandle {.importcpp: "UserVertexSlider::get_class_type()", header: "userVertexSlider.h".}

proc newUserVertexTransform*(name: string): UserVertexTransform {.importcpp: "new UserVertexTransform(nimStringToStdString(#))", header: stringConversionCode.}

proc getName*(this: UserVertexTransform): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Returns the name passed to the constructor.  Completely arbitrary.

proc setMatrix*(this: UserVertexTransform, matrix: LMatrix4) {.importcpp: "#->set_matrix(#)".} ## \
## Stores the indicated matrix.

converter getClassType*(_: typedesc[UserVertexTransform]): TypeHandle {.importcpp: "UserVertexTransform::get_class_type()", header: "userVertexTransform.h".}

converter upcastToTexture*(this: VideoTexture): Texture {.importcpp: "(PT(Texture)(#))".}

converter upcastToAnimInterface*(this: VideoTexture): AnimInterface {.importcpp: "((AnimInterface *)(VideoTexture *)(#))".}

proc getKeepRamImage*(this: VideoTexture): bool {.importcpp: "#->get_keep_ram_image()".} ## \
## Returns the flag that indicates whether this Texture is eligible to have
## its main RAM copy of the texture memory dumped when the texture is prepared
## for rendering.  See set_keep_ram_image().

proc getVideoWidth*(this: VideoTexture): int {.importcpp: "#->get_video_width()".} ## \
## Returns the width in texels of the source video stream.  This is not
## necessarily the width of the actual texture, since the texture may have
## been expanded to raise it to a power of 2.

proc getVideoHeight*(this: VideoTexture): int {.importcpp: "#->get_video_height()".} ## \
## Returns the height in texels of the source video stream.  This is not
## necessarily the height of the actual texture, since the texture may have
## been expanded to raise it to a power of 2.

converter getClassType*(_: typedesc[VideoTexture]): TypeHandle {.importcpp: "VideoTexture::get_class_type()", header: "videoTexture.h".}

converter upcastToBufferContext*(this: VertexBufferContext): BufferContext {.importcpp: "#.upcast_to_BufferContext()".}

converter upcastToAdaptiveLruPage*(this: VertexBufferContext): AdaptiveLruPage {.importcpp: "#.upcast_to_AdaptiveLruPage()".}

proc getData*(this: VertexBufferContext): GeomVertexArrayData {.importcpp: "#.get_data()".} ## \
## Returns the pointer to the client-side array data object.

proc changedSize*(this: VertexBufferContext, reader: GeomVertexArrayDataHandle): bool {.importcpp: "#.changed_size(#)".} ## \
## Returns true if the data has changed size since the last time mark_loaded()
## was called.

proc changedUsageHint*(this: VertexBufferContext, reader: GeomVertexArrayDataHandle): bool {.importcpp: "#.changed_usage_hint(#)".} ## \
## Returns true if the data has changed its usage hint since the last time
## mark_loaded() was called.

proc wasModified*(this: VertexBufferContext, reader: GeomVertexArrayDataHandle): bool {.importcpp: "#.was_modified(#)".} ## \
## Returns true if the data has been modified since the last time
## mark_loaded() was called.

converter getClassType*(_: typedesc[VertexBufferContext]): TypeHandle {.importcpp: "VertexBufferContext::get_class_type()", header: "vertexBufferContext.h".}

proc initTextureCollection*(): TextureCollection {.importcpp: "TextureCollection()".}

proc initTextureCollection*(copy: TextureCollection): TextureCollection {.importcpp: "TextureCollection(#)".}

proc addTexture*(this: TextureCollection, texture: Texture) {.importcpp: "#.add_texture(#)".} ## \
## Adds a new Texture to the collection.

proc removeTexture*(this: TextureCollection, texture: Texture): bool {.importcpp: "#.remove_texture(#)".} ## \
## Removes the indicated Texture from the collection.  Returns true if the
## texture was removed, false if it was not a member of the collection.

proc addTexturesFrom*(this: TextureCollection, other: TextureCollection) {.importcpp: "#.add_textures_from(#)".} ## \
## Adds all the Textures indicated in the other collection to this texture.
## The other textures are simply appended to the end of the textures in this
## list; duplicates are not automatically removed.

proc removeTexturesFrom*(this: TextureCollection, other: TextureCollection) {.importcpp: "#.remove_textures_from(#)".} ## \
## Removes from this collection all of the Textures listed in the other
## collection.

proc removeDuplicateTextures*(this: TextureCollection) {.importcpp: "#.remove_duplicate_textures()".} ## \
## Removes any duplicate entries of the same Textures on this collection.  If
## a Texture appears multiple times, the first appearance is retained;
## subsequent appearances are removed.

proc hasTexture*(this: TextureCollection, texture: Texture): bool {.importcpp: "#.has_texture(#)".} ## \
## Returns true if the indicated Texture appears in this collection, false
## otherwise.

proc clear*(this: TextureCollection) {.importcpp: "#.clear()".} ## \
## Removes all Textures from the collection.

proc reserve*(this: TextureCollection, num: clonglong) {.importcpp: "#.reserve(#)".} ## \
## This is a hint to Panda to allocate enough memory to hold the given number
## of NodePaths, if you know ahead of time how many you will be adding.

proc findTexture*(this: TextureCollection, name: string): Texture {.importcpp: "#.find_texture(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the texture in the collection with the indicated name, if any, or
## NULL if no texture has that name.

proc getNumTextures*(this: TextureCollection): int {.importcpp: "#.get_num_textures()".} ## \
## Returns the number of Textures in the collection.

proc getTexture*(this: TextureCollection, index: int): Texture {.importcpp: "#.get_texture(#)".} ## \
## Returns the nth Texture in the collection.

proc `[]`*(this: TextureCollection, index: int): Texture {.importcpp: "#.operator [](#)".} ## \
## Returns the nth Texture in the collection.  This is the same as
## get_texture(), but it may be a more convenient way to access it.

proc size*(this: TextureCollection): int {.importcpp: "#.size()".} ## \
## Returns the number of textures in the collection.  This is the same thing
## as get_num_textures().

proc `+=`*(this: var TextureCollection, other: TextureCollection): TextureCollection {.importcpp: "#.operator +=(#)".}

proc `+`*(this: TextureCollection, other: TextureCollection): TextureCollection {.importcpp: "#.operator +(#)".}

proc append*(this: TextureCollection, texture: Texture) {.importcpp: "#.append(#)".} ## \
## Adds a new Texture to the collection.  This method duplicates the
## add_texture() method; it is provided to satisfy Python's naming convention.

proc extend*(this: TextureCollection, other: TextureCollection) {.importcpp: "#.extend(#)".} ## \
## Appends the other list onto the end of this one.  This method duplicates
## the += operator; it is provided to satisfy Python's naming convention.

proc output*(this: TextureCollection, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Writes a brief one-line description of the TextureCollection to the
## indicated output stream.

proc write*(this: TextureCollection, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Writes a complete multi-line description of the TextureCollection to the
## indicated output stream.

proc write*(this: TextureCollection, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes a complete multi-line description of the TextureCollection to the
## indicated output stream.

proc hasTexture*(_: typedesc[TexturePool], filename: Filename): bool {.importcpp: "#TexturePool::has_texture(#)", header: "texturePool.h".} ## \
## Returns true if the texture has ever been loaded, false otherwise.

proc verifyTexture*(_: typedesc[TexturePool], filename: Filename): bool {.importcpp: "#TexturePool::verify_texture(#)", header: "texturePool.h".} ## \
## Loads the given filename up into a texture, if it has not already been
## loaded, and returns true to indicate success, or false to indicate failure.
## If this returns true, it is guaranteed that a subsequent call to
## load_texture() with the same texture name will return a valid Texture
## pointer.

proc getTexture*(_: typedesc[TexturePool], filename: Filename, alpha_filename: Filename, primary_file_num_channels: int, alpha_file_channel: int, read_mipmaps: bool): Texture {.importcpp: "#TexturePool::get_texture(#, #, #, #, #)", header: "texturePool.h".} ## \
## Returns the texture that has already been previously loaded, or NULL
## otherwise.

proc getTexture*(_: typedesc[TexturePool], filename: Filename, alpha_filename: Filename, primary_file_num_channels: int, alpha_file_channel: int): Texture {.importcpp: "#TexturePool::get_texture(#, #, #, #)", header: "texturePool.h".} ## \
## Returns the texture that has already been previously loaded, or NULL
## otherwise.

proc getTexture*(_: typedesc[TexturePool], filename: Filename, alpha_filename: Filename, primary_file_num_channels: int): Texture {.importcpp: "#TexturePool::get_texture(#, #, #)", header: "texturePool.h".} ## \
## Returns the texture that has already been previously loaded, or NULL
## otherwise.

proc getTexture*(_: typedesc[TexturePool], filename: Filename, alpha_filename: Filename): Texture {.importcpp: "#TexturePool::get_texture(#, #)", header: "texturePool.h".} ## \
## Returns the texture that has already been previously loaded, or NULL
## otherwise.

proc getTexture*(_: typedesc[TexturePool], filename: Filename, primary_file_num_channels: int, read_mipmaps: bool): Texture {.importcpp: "#TexturePool::get_texture(#, #, #)", header: "texturePool.h".} ## \
## Returns the texture that has already been previously loaded, or NULL
## otherwise.

proc getTexture*(_: typedesc[TexturePool], filename: Filename, primary_file_num_channels: int): Texture {.importcpp: "#TexturePool::get_texture(#, #)", header: "texturePool.h".} ## \
## Returns the texture that has already been previously loaded, or NULL
## otherwise.

proc getTexture*(_: typedesc[TexturePool], filename: Filename): Texture {.importcpp: "#TexturePool::get_texture(#)", header: "texturePool.h".} ## \
## Returns the texture that has already been previously loaded, or NULL
## otherwise.

proc loadTexture*(_: typedesc[TexturePool], filename: Filename, alpha_filename: Filename, primary_file_num_channels: int, alpha_file_channel: int, read_mipmaps: bool, options: LoaderOptions): Texture {.importcpp: "#TexturePool::load_texture(#, #, #, #, #, #)", header: "texturePool.h".} ## \
## Loads the given filename up into a texture, if it has not already been
## loaded, and returns the new texture.  If a texture with the same filename
## was previously loaded, returns that one instead.  If the texture file
## cannot be found, returns NULL.
##
## If read_mipmaps is true, both filenames should contain a hash mark ('#'),
## which will be filled in with the mipmap level number; and the texture will
## be defined with a series of images, two for each mipmap level.

proc loadTexture*(_: typedesc[TexturePool], filename: Filename, alpha_filename: Filename, primary_file_num_channels: int, alpha_file_channel: int, read_mipmaps: bool): Texture {.importcpp: "#TexturePool::load_texture(#, #, #, #, #)", header: "texturePool.h".} ## \
## Loads the given filename up into a texture, if it has not already been
## loaded, and returns the new texture.  If a texture with the same filename
## was previously loaded, returns that one instead.  If the texture file
## cannot be found, returns NULL.
##
## If read_mipmaps is true, both filenames should contain a hash mark ('#'),
## which will be filled in with the mipmap level number; and the texture will
## be defined with a series of images, two for each mipmap level.

proc loadTexture*(_: typedesc[TexturePool], filename: Filename, alpha_filename: Filename, primary_file_num_channels: int, alpha_file_channel: int): Texture {.importcpp: "#TexturePool::load_texture(#, #, #, #)", header: "texturePool.h".} ## \
## Loads the given filename up into a texture, if it has not already been
## loaded, and returns the new texture.  If a texture with the same filename
## was previously loaded, returns that one instead.  If the texture file
## cannot be found, returns NULL.
##
## If read_mipmaps is true, both filenames should contain a hash mark ('#'),
## which will be filled in with the mipmap level number; and the texture will
## be defined with a series of images, two for each mipmap level.

proc loadTexture*(_: typedesc[TexturePool], filename: Filename, alpha_filename: Filename, primary_file_num_channels: int): Texture {.importcpp: "#TexturePool::load_texture(#, #, #)", header: "texturePool.h".} ## \
## Loads the given filename up into a texture, if it has not already been
## loaded, and returns the new texture.  If a texture with the same filename
## was previously loaded, returns that one instead.  If the texture file
## cannot be found, returns NULL.
##
## If read_mipmaps is true, both filenames should contain a hash mark ('#'),
## which will be filled in with the mipmap level number; and the texture will
## be defined with a series of images, two for each mipmap level.

proc loadTexture*(_: typedesc[TexturePool], filename: Filename, alpha_filename: Filename): Texture {.importcpp: "#TexturePool::load_texture(#, #)", header: "texturePool.h".} ## \
## Loads the given filename up into a texture, if it has not already been
## loaded, and returns the new texture.  If a texture with the same filename
## was previously loaded, returns that one instead.  If the texture file
## cannot be found, returns NULL.
##
## If read_mipmaps is true, both filenames should contain a hash mark ('#'),
## which will be filled in with the mipmap level number; and the texture will
## be defined with a series of images, two for each mipmap level.

proc loadTexture*(_: typedesc[TexturePool], filename: Filename, primary_file_num_channels: int, read_mipmaps: bool, options: LoaderOptions): Texture {.importcpp: "#TexturePool::load_texture(#, #, #, #)", header: "texturePool.h".} ## \
## Loads the given filename up into a texture, if it has not already been
## loaded, and returns the new texture.  If a texture with the same filename
## was previously loaded, returns that one instead.  If the texture file
## cannot be found, returns NULL.
##
## If read_mipmaps is true, the filename should contain a hash mark ('#'),
## which will be filled in with the mipmap level number; and the texture will
## be defined with a series of images, one for each mipmap level.

proc loadTexture*(_: typedesc[TexturePool], filename: Filename, primary_file_num_channels: int, read_mipmaps: bool): Texture {.importcpp: "#TexturePool::load_texture(#, #, #)", header: "texturePool.h".} ## \
## Loads the given filename up into a texture, if it has not already been
## loaded, and returns the new texture.  If a texture with the same filename
## was previously loaded, returns that one instead.  If the texture file
## cannot be found, returns NULL.
##
## If read_mipmaps is true, the filename should contain a hash mark ('#'),
## which will be filled in with the mipmap level number; and the texture will
## be defined with a series of images, one for each mipmap level.

proc loadTexture*(_: typedesc[TexturePool], filename: Filename, primary_file_num_channels: int): Texture {.importcpp: "#TexturePool::load_texture(#, #)", header: "texturePool.h".} ## \
## Loads the given filename up into a texture, if it has not already been
## loaded, and returns the new texture.  If a texture with the same filename
## was previously loaded, returns that one instead.  If the texture file
## cannot be found, returns NULL.
##
## If read_mipmaps is true, the filename should contain a hash mark ('#'),
## which will be filled in with the mipmap level number; and the texture will
## be defined with a series of images, one for each mipmap level.

proc loadTexture*(_: typedesc[TexturePool], filename: Filename): Texture {.importcpp: "#TexturePool::load_texture(#)", header: "texturePool.h".} ## \
## Loads the given filename up into a texture, if it has not already been
## loaded, and returns the new texture.  If a texture with the same filename
## was previously loaded, returns that one instead.  If the texture file
## cannot be found, returns NULL.
##
## If read_mipmaps is true, the filename should contain a hash mark ('#'),
## which will be filled in with the mipmap level number; and the texture will
## be defined with a series of images, one for each mipmap level.

proc load3dTexture*(_: typedesc[TexturePool], filename_pattern: Filename, read_mipmaps: bool, options: LoaderOptions): Texture {.importcpp: "#TexturePool::load_3d_texture(#, #, #)", header: "texturePool.h".} ## \
## Loads a 3-D texture that is specified with a series of n pages, all
## numbered in sequence, and beginning with index 0.  The filename should
## include a sequence of one or more hash characters ("#") which will be
## filled in with the index number of each level.
##
## If read_mipmaps is true, the filename should contain an additional hash
## mark.  The first hash mark will be filled in with the mipmap level number,
## and the second with the index number of each 3-d level.

proc load3dTexture*(_: typedesc[TexturePool], filename_pattern: Filename, read_mipmaps: bool): Texture {.importcpp: "#TexturePool::load_3d_texture(#, #)", header: "texturePool.h".} ## \
## Loads a 3-D texture that is specified with a series of n pages, all
## numbered in sequence, and beginning with index 0.  The filename should
## include a sequence of one or more hash characters ("#") which will be
## filled in with the index number of each level.
##
## If read_mipmaps is true, the filename should contain an additional hash
## mark.  The first hash mark will be filled in with the mipmap level number,
## and the second with the index number of each 3-d level.

proc load3dTexture*(_: typedesc[TexturePool], filename_pattern: Filename): Texture {.importcpp: "#TexturePool::load_3d_texture(#)", header: "texturePool.h".} ## \
## Loads a 3-D texture that is specified with a series of n pages, all
## numbered in sequence, and beginning with index 0.  The filename should
## include a sequence of one or more hash characters ("#") which will be
## filled in with the index number of each level.
##
## If read_mipmaps is true, the filename should contain an additional hash
## mark.  The first hash mark will be filled in with the mipmap level number,
## and the second with the index number of each 3-d level.

proc load2dTextureArray*(_: typedesc[TexturePool], filename_pattern: Filename, read_mipmaps: bool, options: LoaderOptions): Texture {.importcpp: "#TexturePool::load_2d_texture_array(#, #, #)", header: "texturePool.h".} ## \
## Loads a 2-D texture array that is specified with a series of n pages, all
## numbered in sequence, and beginning with index 0.  The filename should
## include a sequence of one or more hash characters ("#") which will be
## filled in with the index number of each level.
##
## If read_mipmaps is true, the filename should contain an additional hash
## mark.  The first hash mark will be filled in with the mipmap level number,
## and the second with the index number of each 2-d level.

proc load2dTextureArray*(_: typedesc[TexturePool], filename_pattern: Filename, read_mipmaps: bool): Texture {.importcpp: "#TexturePool::load_2d_texture_array(#, #)", header: "texturePool.h".} ## \
## Loads a 2-D texture array that is specified with a series of n pages, all
## numbered in sequence, and beginning with index 0.  The filename should
## include a sequence of one or more hash characters ("#") which will be
## filled in with the index number of each level.
##
## If read_mipmaps is true, the filename should contain an additional hash
## mark.  The first hash mark will be filled in with the mipmap level number,
## and the second with the index number of each 2-d level.

proc load2dTextureArray*(_: typedesc[TexturePool], filename_pattern: Filename): Texture {.importcpp: "#TexturePool::load_2d_texture_array(#)", header: "texturePool.h".} ## \
## Loads a 2-D texture array that is specified with a series of n pages, all
## numbered in sequence, and beginning with index 0.  The filename should
## include a sequence of one or more hash characters ("#") which will be
## filled in with the index number of each level.
##
## If read_mipmaps is true, the filename should contain an additional hash
## mark.  The first hash mark will be filled in with the mipmap level number,
## and the second with the index number of each 2-d level.

proc loadCubeMap*(_: typedesc[TexturePool], filename_pattern: Filename, read_mipmaps: bool, options: LoaderOptions): Texture {.importcpp: "#TexturePool::load_cube_map(#, #, #)", header: "texturePool.h".} ## \
## Loads a cube map texture that is specified with a series of 6 pages,
## numbered 0 through 5.  The filename should include a sequence of one or
## more hash characters ("#") which will be filled in with the index number of
## each pagee.
##
## If read_mipmaps is true, the filename should contain an additional hash
## mark.  The first hash mark will be filled in with the mipmap level number,
## and the second with the face number, 0 through 5.

proc loadCubeMap*(_: typedesc[TexturePool], filename_pattern: Filename, read_mipmaps: bool): Texture {.importcpp: "#TexturePool::load_cube_map(#, #)", header: "texturePool.h".} ## \
## Loads a cube map texture that is specified with a series of 6 pages,
## numbered 0 through 5.  The filename should include a sequence of one or
## more hash characters ("#") which will be filled in with the index number of
## each pagee.
##
## If read_mipmaps is true, the filename should contain an additional hash
## mark.  The first hash mark will be filled in with the mipmap level number,
## and the second with the face number, 0 through 5.

proc loadCubeMap*(_: typedesc[TexturePool], filename_pattern: Filename): Texture {.importcpp: "#TexturePool::load_cube_map(#)", header: "texturePool.h".} ## \
## Loads a cube map texture that is specified with a series of 6 pages,
## numbered 0 through 5.  The filename should include a sequence of one or
## more hash characters ("#") which will be filled in with the index number of
## each pagee.
##
## If read_mipmaps is true, the filename should contain an additional hash
## mark.  The first hash mark will be filled in with the mipmap level number,
## and the second with the face number, 0 through 5.

proc getNormalizationCubeMap*(_: typedesc[TexturePool], size: int): Texture {.importcpp: "#TexturePool::get_normalization_cube_map(#)", header: "texturePool.h".} ## \
## Returns a standard Texture object that has been created with
## Texture::generate_normalization_cube_map().  This Texture may be shared by
## any application code requiring a normalization cube map.  It will be at
## least as large as the specified size, though it may be larger.

proc getAlphaScaleMap*(_: typedesc[TexturePool]): Texture {.importcpp: "TexturePool::get_alpha_scale_map()", header: "texturePool.h".} ## \
## Returns a standard Texture object that has been created with
## Texture::generate_alpha_scale_map().
##
## This Texture object is used internally by Panda to apply an alpha scale to
## an object (instead of munging its vertices) when
## gsg->get_alpha_scale_via_texture() returns true.

proc addTexture*(_: typedesc[TexturePool], texture: Texture) {.importcpp: "#TexturePool::add_texture(#)", header: "texturePool.h".} ## \
## Adds the indicated already-loaded texture to the pool.  The texture must
## have a filename set for its name.  The texture will always replace any
## previously-loaded texture in the pool that had the same filename.

proc releaseTexture*(_: typedesc[TexturePool], texture: Texture) {.importcpp: "#TexturePool::release_texture(#)", header: "texturePool.h".} ## \
## Removes the indicated texture from the pool, indicating it will never be
## loaded again; the texture may then be freed.  If this function is never
## called, a reference count will be maintained on every texture every loaded,
## and textures will never be freed.
##
## The texture's name should not have been changed during its lifetime, or
## this function may fail to locate it in the pool.

proc releaseAllTextures*(_: typedesc[TexturePool]) {.importcpp: "TexturePool::release_all_textures()", header: "texturePool.h".} ## \
## Releases all textures in the pool and restores the pool to the empty state.

proc rehash*(_: typedesc[TexturePool]) {.importcpp: "TexturePool::rehash()", header: "texturePool.h".} ## \
## Should be called when the model-path changes, to blow away the cache of
## texture pathnames found along the model-path.

proc garbageCollect*(_: typedesc[TexturePool]): int {.importcpp: "TexturePool::garbage_collect()", header: "texturePool.h".} ## \
## Releases only those textures in the pool that have a reference count of
## exactly 1; i.e.  only those textures that are not being used outside of the
## pool.  Returns the number of textures released.

proc listContents*(_: typedesc[TexturePool]) {.importcpp: "TexturePool::list_contents()", header: "texturePool.h".} ## \
## Lists the contents of the texture pool to cout

proc listContents*(_: typedesc[TexturePool], `out`: ostream) {.importcpp: "#TexturePool::list_contents(#)", header: "texturePool.h".} ## \
## Lists the contents of the texture pool to the indicated output stream.

proc findTexture*(_: typedesc[TexturePool], name: string): Texture {.importcpp: "#TexturePool::find_texture(nimStringToStdString(#))", header: "texturePool.h".} ## \
## Returns the first texture found in the pool that matches the indicated name
## (which may contain wildcards).  Returns the texture if it is found, or NULL
## if it is not.

proc findAllTextures*(_: typedesc[TexturePool], name: string): TextureCollection {.importcpp: "#TexturePool::find_all_textures(nimStringToStdString(#))", header: "texturePool.h".} ## \
## Returns the set of all textures found in the pool that match the indicated
## name (which may contain wildcards).

proc findAllTextures*(_: typedesc[TexturePool]): TextureCollection {.importcpp: "TexturePool::find_all_textures()", header: "texturePool.h".} ## \
## Returns the set of all textures found in the pool that match the indicated
## name (which may contain wildcards).

proc setFakeTextureImage*(_: typedesc[TexturePool], filename: Filename) {.importcpp: "#TexturePool::set_fake_texture_image(#)", header: "texturePool.h".} ## \
## Sets a bogus filename that will be loaded in lieu of any textures requested
## from this point on.

proc clearFakeTextureImage*(_: typedesc[TexturePool]) {.importcpp: "TexturePool::clear_fake_texture_image()", header: "texturePool.h".} ## \
## Restores normal behavior of loading the textures actually requested.

proc hasFakeTextureImage*(_: typedesc[TexturePool]): bool {.importcpp: "TexturePool::has_fake_texture_image()", header: "texturePool.h".} ## \
## Returns true if fake_texture_image mode has been enabled, false if we are
## in the normal mode.

proc getFakeTextureImage*(_: typedesc[TexturePool]): Filename {.importcpp: "TexturePool::get_fake_texture_image()", header: "texturePool.h".} ## \
## Returns the filename that was specified with a previous call to
## set_fake_texture_image().

proc makeTexture*(_: typedesc[TexturePool], extension: string): Texture {.importcpp: "#TexturePool::make_texture(nimStringToStdString(#))", header: "texturePool.h".} ## \
## Creates a new Texture object of the appropriate type for the indicated
## filename extension, according to the types that have been registered via
## register_texture_type().

proc write*(_: typedesc[TexturePool], `out`: ostream) {.importcpp: "#TexturePool::write(#)", header: "texturePool.h".} ## \
## Lists the contents of the texture pool to the indicated output stream.  For
## debugging.

proc getXSize*(this: TexturePeeker): int {.importcpp: "#->get_x_size()".} ## \
## Returns the width of the texture image that is contributing to the
## TexturePeeker's information.  This may be either the Texture's full width,
## or its simple ram image's width.

proc getYSize*(this: TexturePeeker): int {.importcpp: "#->get_y_size()".} ## \
## Returns the height of the texture image that is contributing to the
## TexturePeeker's information.  This may be either the Texture's full height,
## or its simple ram image's height.

proc getZSize*(this: TexturePeeker): int {.importcpp: "#->get_z_size()".} ## \
## Returns the depth of the texture image that is contributing to the
## TexturePeeker's information.

proc hasPixel*(this: TexturePeeker, x: int, y: int): bool {.importcpp: "#->has_pixel(#, #)".} ## \
## Returns whether a given coordinate is inside of the texture dimensions.

proc hasPixel*(this: TexturePeeker, x: int, y: int, z: int): bool {.importcpp: "#->has_pixel(#, #, #)".} ## \
## Returns whether a given coordinate is inside of the texture dimensions.

proc lookup*(this: TexturePeeker, color: LColor, u: float32, v: float32) {.importcpp: "#->lookup(#, #, #)".} ## \
## Fills "color" with the RGBA color of the texel at point (u, v).
##
## The texel color is determined via nearest-point sampling (no filtering of
## adjacent pixels), regardless of the filter type associated with the
## texture.  u, v, and w will wrap around regardless of the texture's wrap
## mode.

proc lookup*(this: TexturePeeker, color: LColor, u: float32, v: float32, w: float32) {.importcpp: "#->lookup(#, #, #, #)".} ## \
## Fills "color" with the RGBA color of the texel at point (u, v, w).
##
## The texel color is determined via nearest-point sampling (no filtering of
## adjacent pixels), regardless of the filter type associated with the
## texture.  u, v, and w will wrap around regardless of the texture's wrap
## mode.

proc fetchPixel*(this: TexturePeeker, color: LColor, x: int, y: int) {.importcpp: "#->fetch_pixel(#, #, #)".} ## \
## Works like TexturePeeker::lookup(), but instead of uv-coordinates, integer
## coordinates are used.

proc fetchPixel*(this: TexturePeeker, color: LColor, x: int, y: int, z: int) {.importcpp: "#->fetch_pixel(#, #, #, #)".} ## \
## Works like TexturePeeker::lookup(), but instead of uv-coordinates, integer
## coordinates are used.

proc lookupBilinear*(this: TexturePeeker, color: LColor, u: float32, v: float32): bool {.importcpp: "#->lookup_bilinear(#, #, #)".} ## \
## Performs a bilinear lookup to retrieve the color value stored at the uv
## coordinate (u, v).
##
## In case the point is outside of the uv range, color is set to zero,
## and false is returned.  Otherwise true is returned.

proc filterRect*(this: TexturePeeker, color: LColor, min_u: float32, min_v: float32, max_u: float32, max_v: float32) {.importcpp: "#->filter_rect(#, #, #, #, #)".} ## \
## Fills "color" with the average RGBA color of the texels within the
## rectangle defined by the specified coordinate range.
##
## The texel color is linearly filtered over the entire region.  u, v, and w
## must be in the range [0, 1].

proc filterRect*(this: TexturePeeker, color: LColor, min_u: float32, min_v: float32, min_w: float32, max_u: float32, max_v: float32, max_w: float32) {.importcpp: "#->filter_rect(#, #, #, #, #, #, #)".} ## \
## Fills "color" with the average RGBA color of the texels within the
## rectangle defined by the specified coordinate range.
##
## The texel color is linearly filtered over the entire region.  u, v, and w
## must be in the range [0, 1].

proc newTexturePeeker*(param0: TexturePeeker): TexturePeeker {.importcpp: "new TexturePeeker(#)".}

proc getStage*(_: typedesc[TextureStagePool], temp: TextureStage): TextureStage {.importcpp: "#TextureStagePool::get_stage(#)", header: "textureStagePool.h".} ## \
## Returns a TextureStage pointer that represents the same TextureStage
## described by temp, except that it is a shared pointer.
##
## Each call to get_stage() passing an equivalent TextureStage pointer will
## return the same shared pointer.
##
## If you modify the shared pointer, it will automatically disassociate it
## from the pool.
##
## Also, the return value may be a different pointer than that passed in, or
## it may be the same pointer.  In either case, the passed in pointer has now
## been sacrificed to the greater good and should not be used again (like any
## other PointerTo, it will be freed when the last reference count is
## removed).

proc releaseStage*(_: typedesc[TextureStagePool], temp: TextureStage) {.importcpp: "#TextureStagePool::release_stage(#)", header: "textureStagePool.h".} ## \
## Removes the indicated TextureStage from the pool.

proc releaseAllStages*(_: typedesc[TextureStagePool]) {.importcpp: "TextureStagePool::release_all_stages()", header: "textureStagePool.h".} ## \
## Releases all TextureStages in the pool and restores the pool to the empty
## state.

proc garbageCollect*(_: typedesc[TextureStagePool]): int {.importcpp: "TextureStagePool::garbage_collect()", header: "textureStagePool.h".} ## \
## Releases only those TextureStages in the pool that have a reference count
## of exactly 1; i.e.  only those TextureStages that are not being used
## outside of the pool.  Returns the number of TextureStages released.

proc listContents*(_: typedesc[TextureStagePool], `out`: ostream) {.importcpp: "#TextureStagePool::list_contents(#)", header: "textureStagePool.h".} ## \
## Lists the contents of the TextureStage pool to the indicated output stream.

proc write*(_: typedesc[TextureStagePool], `out`: ostream) {.importcpp: "#TextureStagePool::write(#)", header: "textureStagePool.h".} ## \
## Lists the contents of the TextureStage pool to the indicated output stream.

proc setSort*(this: GraphicsOutputBase, sort: int) {.importcpp: "#->set_sort(#)".}

proc getTexture*(this: GraphicsOutputBase, i: int): Texture {.importcpp: "#->get_texture(#)".}

proc getTexture*(this: GraphicsOutputBase): Texture {.importcpp: "#->get_texture()".}

converter getClassType*(_: typedesc[GraphicsOutputBase]): TypeHandle {.importcpp: "GraphicsOutputBase::get_class_type()", header: "graphicsOutputBase.h".}

proc getIncompleteRender*(this: GraphicsStateGuardianBase): bool {.importcpp: "#->get_incomplete_render()".}

proc getEffectiveIncompleteRender*(this: GraphicsStateGuardianBase): bool {.importcpp: "#->get_effective_incomplete_render()".}

proc prefersTriangleStrips*(this: GraphicsStateGuardianBase): bool {.importcpp: "#->prefers_triangle_strips()".}

proc getMaxVerticesPerArray*(this: GraphicsStateGuardianBase): int {.importcpp: "#->get_max_vertices_per_array()".}

proc getMaxVerticesPerPrimitive*(this: GraphicsStateGuardianBase): int {.importcpp: "#->get_max_vertices_per_primitive()".}

proc getMaxTextureDimension*(this: GraphicsStateGuardianBase): int {.importcpp: "#->get_max_texture_dimension()".}

proc getSupportsCompressedTextureFormat*(this: GraphicsStateGuardianBase, compression_mode: int): bool {.importcpp: "#->get_supports_compressed_texture_format(#)".}

proc getSupportsMultisample*(this: GraphicsStateGuardianBase): bool {.importcpp: "#->get_supports_multisample()".}

proc getSupportedGeomRendering*(this: GraphicsStateGuardianBase): int {.importcpp: "#->get_supported_geom_rendering()".}

proc getSupportsShadowFilter*(this: GraphicsStateGuardianBase): bool {.importcpp: "#->get_supports_shadow_filter()".}

proc getSupportsTextureSrgb*(this: GraphicsStateGuardianBase): bool {.importcpp: "#->get_supports_texture_srgb()".}

proc getSupportsHlsl*(this: GraphicsStateGuardianBase): bool {.importcpp: "#->get_supports_hlsl()".}

proc getDefaultGsg*(_: typedesc[GraphicsStateGuardianBase]): GraphicsStateGuardianBase {.importcpp: "GraphicsStateGuardianBase::get_default_gsg()", header: "graphicsStateGuardianBase.h".} ## \
## Returns a pointer to the "default" GSG.  This is typically the first GSG
## created in an application; in a single-window application, it will be the
## only GSG. This GSG is used to determine default optimization choices for
## loaded geometry.
##
## The return value may be NULL if a GSG has not been created.

proc setDefaultGsg*(_: typedesc[GraphicsStateGuardianBase], default_gsg: GraphicsStateGuardianBase) {.importcpp: "#GraphicsStateGuardianBase::set_default_gsg(#)", header: "graphicsStateGuardianBase.h".} ## \
## Specifies a particular GSG to use as the "default" GSG.  See
## get_default_gsg().

proc getNumGsgs*(_: typedesc[GraphicsStateGuardianBase]): clonglong {.importcpp: "GraphicsStateGuardianBase::get_num_gsgs()", header: "graphicsStateGuardianBase.h".} ## \
## Returns the total number of GSG's in the universe.

proc getGsg*(_: typedesc[GraphicsStateGuardianBase], n: clonglong): GraphicsStateGuardianBase {.importcpp: "#GraphicsStateGuardianBase::get_gsg(#)", header: "graphicsStateGuardianBase.h".} ## \
## Returns the nth GSG in the universe.  GSG's automatically add themselves
## and remove themselves from this list as they are created and destroyed.

converter getClassType*(_: typedesc[GraphicsStateGuardianBase]): TypeHandle {.importcpp: "GraphicsStateGuardianBase::get_class_type()", header: "graphicsStateGuardianBase.h".}

proc initMathNumbers*(): MathNumbers {.importcpp: "MathNumbers()".}

proc initMathNumbers*(param0: MathNumbers): MathNumbers {.importcpp: "MathNumbers(#)".}

proc deg2Rad*(f: float64): float64 {.importcpp: "deg_2_rad(#)".}

proc deg2Rad*(f: float32): float32 {.importcpp: "deg_2_rad(#)".}

proc rad2Deg*(f: float64): float64 {.importcpp: "rad_2_deg(#)".}

proc rad2Deg*(f: float32): float32 {.importcpp: "rad_2_deg(#)".}

proc zero*(_: typedesc[LVecBase2f]): LVecBase2f {.importcpp: "LVecBase2f::zero()", header: "lvecBase2.h".} ## \
## Returns a zero-length vector.

proc unitX*(_: typedesc[LVecBase2f]): LVecBase2f {.importcpp: "LVecBase2f::unit_x()", header: "lvecBase2.h".} ## \
## Returns a unit X vector.

proc unitY*(_: typedesc[LVecBase2f]): LVecBase2f {.importcpp: "LVecBase2f::unit_y()", header: "lvecBase2.h".} ## \
## Returns a unit Y vector.

proc `[]`*(this: LVecBase2f, i: int, assign_val: float32) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[LVecBase2f]): int {.importcpp: "LVecBase2f::size()", header: "lvecBase2.h".}

proc isNan*(this: LVecBase2f): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the vector is not-a-number, false
## otherwise.

proc getCell*(this: LVecBase2f, i: int): float32 {.importcpp: "#.get_cell(#)".}

proc setCell*(this: LVecBase2f, i: int, value: float32) {.importcpp: "#.set_cell(#, #)".}

proc getX*(this: LVecBase2f): float32 {.importcpp: "#.get_x()".}

proc getY*(this: LVecBase2f): float32 {.importcpp: "#.get_y()".}

proc setX*(this: LVecBase2f, value: float32) {.importcpp: "#.set_x(#)".}

proc setY*(this: LVecBase2f, value: float32) {.importcpp: "#.set_y(#)".}

proc addToCell*(this: LVecBase2f, i: int, value: float32) {.importcpp: "#.add_to_cell(#, #)".} ## \
## These next functions add to an existing value.  i.e.
## foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
## scripting languages:

proc addX*(this: LVecBase2f, value: float32) {.importcpp: "#.add_x(#)".}

proc addY*(this: LVecBase2f, value: float32) {.importcpp: "#.add_y(#)".}

proc getData*(this: LVecBase2f) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the two data elements in the vector.
## The next element occupies the next position consecutively in memory.

proc getNumComponents*(_: typedesc[LVecBase2f]): int {.importcpp: "LVecBase2f::get_num_components()", header: "lvecBase2.h".}

proc fill*(this: LVecBase2f, fill_value: float32) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: LVecBase2f, x: float32, y: float32) {.importcpp: "#.set(#, #)".}

proc dot*(this: LVecBase2f, other: LVecBase2f): float32 {.importcpp: "#.dot(#)".}

proc lengthSquared*(this: LVecBase2f): float32 {.importcpp: "#.length_squared()".} ## \
## Returns the square of the vector's length, cheap and easy.

proc length*(this: LVecBase2f): float32 {.importcpp: "#.length()".} ## \
## Returns the length of the vector, by the Pythagorean theorem.

proc normalize*(this: LVecBase2f): bool {.importcpp: "#.normalize()".} ## \
## Normalizes the vector in place.  Returns true if the vector was normalized,
## false if it was a zero-length vector.

proc normalized*(this: LVecBase2f): LVecBase2f {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVecBase2f, onto: LVecBase2f): LVecBase2f {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc `<`*(this: LVecBase2f, other: LVecBase2f): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LVecBase2f, other: LVecBase2f): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LVecBase2f, other: LVecBase2f): bool {.importcpp: "#.operator !=(#)".}

proc compareTo*(this: LVecBase2f, other: LVecBase2f): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc compareTo*(this: LVecBase2f, other: LVecBase2f, threshold: float32): int {.importcpp: "#.compare_to(#, #)".} ## \
## Sorts vectors lexicographically, componentwise.  Returns a number less than
## 0 if this vector sorts before the other one, greater than zero if it sorts
## after, 0 if they are equivalent (within the indicated tolerance).

proc getHash*(this: LVecBase2f): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc getHash*(this: LVecBase2f, threshold: float32): clonglong {.importcpp: "#.get_hash(#)".} ## \
## Returns a suitable hash for phash_map.

proc addHash*(this: LVecBase2f, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc addHash*(this: LVecBase2f, hash: clonglong, threshold: float32): clonglong {.importcpp: "#.add_hash(#, #)".} ## \
## Adds the vector into the running hash.

proc `-`*(this: LVecBase2f): LVecBase2f {.importcpp: "#.operator -()".}

proc `+`*(this: LVecBase2f, other: LVecBase2f): LVecBase2f {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVecBase2f, other: LVecBase2f): LVecBase2f {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVecBase2f, scalar: float32): LVecBase2f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVecBase2f, scalar: float32): LVecBase2f {.importcpp: "#.operator /(#)".}

proc `+=`*(this: var LVecBase2f, other: LVecBase2f): LVecBase2f {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: var LVecBase2f, other: LVecBase2f): LVecBase2f {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: var LVecBase2f, scalar: float32): LVecBase2f {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: var LVecBase2f, scalar: float32): LVecBase2f {.importcpp: "#.operator /=(#)".}

proc componentwiseMult*(this: LVecBase2f, other: LVecBase2f) {.importcpp: "#.componentwise_mult(#)".}

proc fmax*(this: LVecBase2f, other: LVecBase2f): LVecBase2f {.importcpp: "#.fmax(#)".}

proc fmin*(this: LVecBase2f, other: LVecBase2f): LVecBase2f {.importcpp: "#.fmin(#)".}

proc almostEqual*(this: LVecBase2f, other: LVecBase2f): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two vectors are memberwise equal within a default tolerance
## based on the numeric type.

proc almostEqual*(this: LVecBase2f, other: LVecBase2f, threshold: float32): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two vectors are memberwise equal within a specified
## tolerance.

proc output*(this: LVecBase2f, `out`: ostream) {.importcpp: "#.output(#)".}

proc writeDatagramFixed*(this: LVecBase2f, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the vector to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the vector, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc readDatagramFixed*(this: LVecBase2f, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the vector from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc writeDatagram*(this: LVecBase2f, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the vector to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc readDatagram*(this: LVecBase2f, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the vector from the Datagram using get_stdfloat().

converter getClassType*(_: typedesc[LVecBase2f]): TypeHandle {.importcpp: "LVecBase2f::get_class_type()", header: "lvecBase2.h".}

proc zero*(_: typedesc[LVecBase2d]): LVecBase2d {.importcpp: "LVecBase2d::zero()", header: "lvecBase2.h".} ## \
## Returns a zero-length vector.

proc unitX*(_: typedesc[LVecBase2d]): LVecBase2d {.importcpp: "LVecBase2d::unit_x()", header: "lvecBase2.h".} ## \
## Returns a unit X vector.

proc unitY*(_: typedesc[LVecBase2d]): LVecBase2d {.importcpp: "LVecBase2d::unit_y()", header: "lvecBase2.h".} ## \
## Returns a unit Y vector.

proc `[]`*(this: LVecBase2d, i: int, assign_val: float64) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[LVecBase2d]): int {.importcpp: "LVecBase2d::size()", header: "lvecBase2.h".}

proc isNan*(this: LVecBase2d): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the vector is not-a-number, false
## otherwise.

proc getCell*(this: LVecBase2d, i: int): float64 {.importcpp: "#.get_cell(#)".}

proc setCell*(this: LVecBase2d, i: int, value: float64) {.importcpp: "#.set_cell(#, #)".}

proc getX*(this: LVecBase2d): float64 {.importcpp: "#.get_x()".}

proc getY*(this: LVecBase2d): float64 {.importcpp: "#.get_y()".}

proc setX*(this: LVecBase2d, value: float64) {.importcpp: "#.set_x(#)".}

proc setY*(this: LVecBase2d, value: float64) {.importcpp: "#.set_y(#)".}

proc addToCell*(this: LVecBase2d, i: int, value: float64) {.importcpp: "#.add_to_cell(#, #)".} ## \
## These next functions add to an existing value.  i.e.
## foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
## scripting languages:

proc addX*(this: LVecBase2d, value: float64) {.importcpp: "#.add_x(#)".}

proc addY*(this: LVecBase2d, value: float64) {.importcpp: "#.add_y(#)".}

proc getData*(this: LVecBase2d) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the two data elements in the vector.
## The next element occupies the next position consecutively in memory.

proc getNumComponents*(_: typedesc[LVecBase2d]): int {.importcpp: "LVecBase2d::get_num_components()", header: "lvecBase2.h".}

proc fill*(this: LVecBase2d, fill_value: float64) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: LVecBase2d, x: float64, y: float64) {.importcpp: "#.set(#, #)".}

proc dot*(this: LVecBase2d, other: LVecBase2d): float64 {.importcpp: "#.dot(#)".}

proc lengthSquared*(this: LVecBase2d): float64 {.importcpp: "#.length_squared()".} ## \
## Returns the square of the vector's length, cheap and easy.

proc length*(this: LVecBase2d): float64 {.importcpp: "#.length()".} ## \
## Returns the length of the vector, by the Pythagorean theorem.

proc normalize*(this: LVecBase2d): bool {.importcpp: "#.normalize()".} ## \
## Normalizes the vector in place.  Returns true if the vector was normalized,
## false if it was a zero-length vector.

proc normalized*(this: LVecBase2d): LVecBase2d {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVecBase2d, onto: LVecBase2d): LVecBase2d {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc `<`*(this: LVecBase2d, other: LVecBase2d): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LVecBase2d, other: LVecBase2d): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LVecBase2d, other: LVecBase2d): bool {.importcpp: "#.operator !=(#)".}

proc compareTo*(this: LVecBase2d, other: LVecBase2d): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc compareTo*(this: LVecBase2d, other: LVecBase2d, threshold: float64): int {.importcpp: "#.compare_to(#, #)".} ## \
## Sorts vectors lexicographically, componentwise.  Returns a number less than
## 0 if this vector sorts before the other one, greater than zero if it sorts
## after, 0 if they are equivalent (within the indicated tolerance).

proc getHash*(this: LVecBase2d): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc getHash*(this: LVecBase2d, threshold: float64): clonglong {.importcpp: "#.get_hash(#)".} ## \
## Returns a suitable hash for phash_map.

proc addHash*(this: LVecBase2d, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc addHash*(this: LVecBase2d, hash: clonglong, threshold: float64): clonglong {.importcpp: "#.add_hash(#, #)".} ## \
## Adds the vector into the running hash.

proc `-`*(this: LVecBase2d): LVecBase2d {.importcpp: "#.operator -()".}

proc `+`*(this: LVecBase2d, other: LVecBase2d): LVecBase2d {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVecBase2d, other: LVecBase2d): LVecBase2d {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVecBase2d, scalar: float64): LVecBase2d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVecBase2d, scalar: float64): LVecBase2d {.importcpp: "#.operator /(#)".}

proc `+=`*(this: var LVecBase2d, other: LVecBase2d): LVecBase2d {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: var LVecBase2d, other: LVecBase2d): LVecBase2d {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: var LVecBase2d, scalar: float64): LVecBase2d {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: var LVecBase2d, scalar: float64): LVecBase2d {.importcpp: "#.operator /=(#)".}

proc componentwiseMult*(this: LVecBase2d, other: LVecBase2d) {.importcpp: "#.componentwise_mult(#)".}

proc fmax*(this: LVecBase2d, other: LVecBase2d): LVecBase2d {.importcpp: "#.fmax(#)".}

proc fmin*(this: LVecBase2d, other: LVecBase2d): LVecBase2d {.importcpp: "#.fmin(#)".}

proc almostEqual*(this: LVecBase2d, other: LVecBase2d): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two vectors are memberwise equal within a default tolerance
## based on the numeric type.

proc almostEqual*(this: LVecBase2d, other: LVecBase2d, threshold: float64): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two vectors are memberwise equal within a specified
## tolerance.

proc output*(this: LVecBase2d, `out`: ostream) {.importcpp: "#.output(#)".}

proc writeDatagramFixed*(this: LVecBase2d, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the vector to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the vector, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc readDatagramFixed*(this: LVecBase2d, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the vector from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc writeDatagram*(this: LVecBase2d, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the vector to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc readDatagram*(this: LVecBase2d, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the vector from the Datagram using get_stdfloat().

converter getClassType*(_: typedesc[LVecBase2d]): TypeHandle {.importcpp: "LVecBase2d::get_class_type()", header: "lvecBase2.h".}

proc zero*(_: typedesc[LVecBase2i]): LVecBase2i {.importcpp: "LVecBase2i::zero()", header: "lvecBase2.h".} ## \
## Returns a zero-length vector.

proc unitX*(_: typedesc[LVecBase2i]): LVecBase2i {.importcpp: "LVecBase2i::unit_x()", header: "lvecBase2.h".} ## \
## Returns a unit X vector.

proc unitY*(_: typedesc[LVecBase2i]): LVecBase2i {.importcpp: "LVecBase2i::unit_y()", header: "lvecBase2.h".} ## \
## Returns a unit Y vector.

proc `[]`*(this: LVecBase2i, i: int, assign_val: int) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[LVecBase2i]): int {.importcpp: "LVecBase2i::size()", header: "lvecBase2.h".}

proc isNan*(this: LVecBase2i): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the vector is not-a-number, false
## otherwise.

proc getCell*(this: LVecBase2i, i: int): int {.importcpp: "#.get_cell(#)".}

proc setCell*(this: LVecBase2i, i: int, value: int) {.importcpp: "#.set_cell(#, #)".}

proc getX*(this: LVecBase2i): int {.importcpp: "#.get_x()".}

proc getY*(this: LVecBase2i): int {.importcpp: "#.get_y()".}

proc setX*(this: LVecBase2i, value: int) {.importcpp: "#.set_x(#)".}

proc setY*(this: LVecBase2i, value: int) {.importcpp: "#.set_y(#)".}

proc addToCell*(this: LVecBase2i, i: int, value: int) {.importcpp: "#.add_to_cell(#, #)".} ## \
## These next functions add to an existing value.  i.e.
## foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
## scripting languages:

proc addX*(this: LVecBase2i, value: int) {.importcpp: "#.add_x(#)".}

proc addY*(this: LVecBase2i, value: int) {.importcpp: "#.add_y(#)".}

proc getData*(this: LVecBase2i) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the two data elements in the vector.
## The next element occupies the next position consecutively in memory.

proc getNumComponents*(_: typedesc[LVecBase2i]): int {.importcpp: "LVecBase2i::get_num_components()", header: "lvecBase2.h".}

proc fill*(this: LVecBase2i, fill_value: int) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: LVecBase2i, x: int, y: int) {.importcpp: "#.set(#, #)".}

proc dot*(this: LVecBase2i, other: LVecBase2i): int {.importcpp: "#.dot(#)".}

proc lengthSquared*(this: LVecBase2i): int {.importcpp: "#.length_squared()".} ## \
## Returns the square of the vector's length, cheap and easy.

proc `<`*(this: LVecBase2i, other: LVecBase2i): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LVecBase2i, other: LVecBase2i): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LVecBase2i, other: LVecBase2i): bool {.importcpp: "#.operator !=(#)".}

proc compareTo*(this: LVecBase2i, other: LVecBase2i): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc getHash*(this: LVecBase2i): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc addHash*(this: LVecBase2i, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc `-`*(this: LVecBase2i): LVecBase2i {.importcpp: "#.operator -()".}

proc `+`*(this: LVecBase2i, other: LVecBase2i): LVecBase2i {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVecBase2i, other: LVecBase2i): LVecBase2i {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVecBase2i, scalar: int): LVecBase2i {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVecBase2i, scalar: int): LVecBase2i {.importcpp: "#.operator /(#)".}

proc `+=`*(this: var LVecBase2i, other: LVecBase2i): LVecBase2i {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: var LVecBase2i, other: LVecBase2i): LVecBase2i {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: var LVecBase2i, scalar: int): LVecBase2i {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: var LVecBase2i, scalar: int): LVecBase2i {.importcpp: "#.operator /=(#)".}

proc componentwiseMult*(this: LVecBase2i, other: LVecBase2i) {.importcpp: "#.componentwise_mult(#)".}

proc fmax*(this: LVecBase2i, other: LVecBase2i): LVecBase2i {.importcpp: "#.fmax(#)".}

proc fmin*(this: LVecBase2i, other: LVecBase2i): LVecBase2i {.importcpp: "#.fmin(#)".}

proc almostEqual*(this: LVecBase2i, other: LVecBase2i): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two vectors are memberwise equal within a default tolerance
## based on the numeric type.

proc almostEqual*(this: LVecBase2i, other: LVecBase2i, threshold: int): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two vectors are memberwise equal within a specified
## tolerance.

proc output*(this: LVecBase2i, `out`: ostream) {.importcpp: "#.output(#)".}

proc writeDatagramFixed*(this: LVecBase2i, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the vector to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the vector, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc readDatagramFixed*(this: LVecBase2i, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the vector from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc writeDatagram*(this: LVecBase2i, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the vector to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc readDatagram*(this: LVecBase2i, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the vector from the Datagram using get_stdfloat().

converter getClassType*(_: typedesc[LVecBase2i]): TypeHandle {.importcpp: "LVecBase2i::get_class_type()", header: "lvecBase2.h".}

proc initLVector2f*(): LVector2f {.importcpp: "LVector2f()".}

converter initLVector2f*(copy: LVecBase2f): LVector2f {.importcpp: "LVector2f(#)".} ## \
## Constructs a new LVector2 from a LVecBase2

proc initLVector2f*(param0: LVector2f): LVector2f {.importcpp: "LVector2f(#)".}

proc initLVector2f*(fill_value: float32): LVector2f {.importcpp: "LVector2f(#)".} ## \
## Constructs a new LVector2 with all components set to the fill value.

proc initLVector2f*(x: float32, y: float32): LVector2f {.importcpp: "LVector2f(#, #)".}

proc zero*(_: typedesc[LVector2f]): LVector2f {.importcpp: "LVector2f::zero()", header: "lvector2.h".} ## \
## Returns a zero-length vector.

proc unitX*(_: typedesc[LVector2f]): LVector2f {.importcpp: "LVector2f::unit_x()", header: "lvector2.h".} ## \
## Returns a unit X vector.

proc unitY*(_: typedesc[LVector2f]): LVector2f {.importcpp: "LVector2f::unit_y()", header: "lvector2.h".} ## \
## Returns a unit Y vector.

proc `-`*(this: LVector2f): LVector2f {.importcpp: "#.operator -()".}

proc `+`*(this: LVector2f, other: LVecBase2f): LVecBase2f {.importcpp: "#.operator +(#)".}

proc `+`*(this: LVector2f, other: LVector2f): LVector2f {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVector2f, other: LVecBase2f): LVecBase2f {.importcpp: "#.operator -(#)".}

proc `-`*(this: LVector2f, other: LVector2f): LVector2f {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVector2f, scalar: float32): LVector2f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVector2f, scalar: float32): LVector2f {.importcpp: "#.operator /(#)".}

proc normalized*(this: LVector2f): LVector2f {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVector2f, onto: LVecBase2f): LVector2f {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc signedAngleRad*(this: LVector2f, other: LVector2f): float32 {.importcpp: "#.signed_angle_rad(#)".} ## \
## returns the signed angled between two vectors.  normalization is NOT
## necessary

proc signedAngleDeg*(this: LVector2f, other: LVector2f): float32 {.importcpp: "#.signed_angle_deg(#)".} ## \
## returns the signed angled between two vectors.  normalization is NOT
## necessary

converter getClassType*(_: typedesc[LVector2f]): TypeHandle {.importcpp: "LVector2f::get_class_type()", header: "lvector2.h".}

proc initLVector2d*(): LVector2d {.importcpp: "LVector2d()".}

converter initLVector2d*(copy: LVecBase2d): LVector2d {.importcpp: "LVector2d(#)".} ## \
## Constructs a new LVector2 from a LVecBase2

proc initLVector2d*(param0: LVector2d): LVector2d {.importcpp: "LVector2d(#)".}

proc initLVector2d*(fill_value: float64): LVector2d {.importcpp: "LVector2d(#)".} ## \
## Constructs a new LVector2 with all components set to the fill value.

proc initLVector2d*(x: float64, y: float64): LVector2d {.importcpp: "LVector2d(#, #)".}

proc zero*(_: typedesc[LVector2d]): LVector2d {.importcpp: "LVector2d::zero()", header: "lvector2.h".} ## \
## Returns a zero-length vector.

proc unitX*(_: typedesc[LVector2d]): LVector2d {.importcpp: "LVector2d::unit_x()", header: "lvector2.h".} ## \
## Returns a unit X vector.

proc unitY*(_: typedesc[LVector2d]): LVector2d {.importcpp: "LVector2d::unit_y()", header: "lvector2.h".} ## \
## Returns a unit Y vector.

proc `-`*(this: LVector2d): LVector2d {.importcpp: "#.operator -()".}

proc `+`*(this: LVector2d, other: LVecBase2d): LVecBase2d {.importcpp: "#.operator +(#)".}

proc `+`*(this: LVector2d, other: LVector2d): LVector2d {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVector2d, other: LVecBase2d): LVecBase2d {.importcpp: "#.operator -(#)".}

proc `-`*(this: LVector2d, other: LVector2d): LVector2d {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVector2d, scalar: float64): LVector2d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVector2d, scalar: float64): LVector2d {.importcpp: "#.operator /(#)".}

proc normalized*(this: LVector2d): LVector2d {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVector2d, onto: LVecBase2d): LVector2d {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc signedAngleRad*(this: LVector2d, other: LVector2d): float64 {.importcpp: "#.signed_angle_rad(#)".} ## \
## returns the signed angled between two vectors.  normalization is NOT
## necessary

proc signedAngleDeg*(this: LVector2d, other: LVector2d): float64 {.importcpp: "#.signed_angle_deg(#)".} ## \
## returns the signed angled between two vectors.  normalization is NOT
## necessary

converter getClassType*(_: typedesc[LVector2d]): TypeHandle {.importcpp: "LVector2d::get_class_type()", header: "lvector2.h".}

proc initLVector2i*(): LVector2i {.importcpp: "LVector2i()".}

converter initLVector2i*(copy: LVecBase2i): LVector2i {.importcpp: "LVector2i(#)".} ## \
## Constructs a new LVector2 from a LVecBase2

proc initLVector2i*(param0: LVector2i): LVector2i {.importcpp: "LVector2i(#)".}

proc initLVector2i*(fill_value: int): LVector2i {.importcpp: "LVector2i(#)".} ## \
## Constructs a new LVector2 with all components set to the fill value.

proc initLVector2i*(x: int, y: int): LVector2i {.importcpp: "LVector2i(#, #)".}

proc zero*(_: typedesc[LVector2i]): LVector2i {.importcpp: "LVector2i::zero()", header: "lvector2.h".} ## \
## Returns a zero-length vector.

proc unitX*(_: typedesc[LVector2i]): LVector2i {.importcpp: "LVector2i::unit_x()", header: "lvector2.h".} ## \
## Returns a unit X vector.

proc unitY*(_: typedesc[LVector2i]): LVector2i {.importcpp: "LVector2i::unit_y()", header: "lvector2.h".} ## \
## Returns a unit Y vector.

proc `-`*(this: LVector2i): LVector2i {.importcpp: "#.operator -()".}

proc `+`*(this: LVector2i, other: LVecBase2i): LVecBase2i {.importcpp: "#.operator +(#)".}

proc `+`*(this: LVector2i, other: LVector2i): LVector2i {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVector2i, other: LVecBase2i): LVecBase2i {.importcpp: "#.operator -(#)".}

proc `-`*(this: LVector2i, other: LVector2i): LVector2i {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVector2i, scalar: int): LVector2i {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVector2i, scalar: int): LVector2i {.importcpp: "#.operator /(#)".}

converter getClassType*(_: typedesc[LVector2i]): TypeHandle {.importcpp: "LVector2i::get_class_type()", header: "lvector2.h".}

proc initLPoint2f*(): LPoint2f {.importcpp: "LPoint2f()".}

proc initLPoint2f*(param0: LPoint2f): LPoint2f {.importcpp: "LPoint2f(#)".}

converter initLPoint2f*(copy: LVecBase2f): LPoint2f {.importcpp: "LPoint2f(#)".} ## \
## Constructs a new LPoint2 from a LVecBase2

proc initLPoint2f*(fill_value: float32): LPoint2f {.importcpp: "LPoint2f(#)".} ## \
## Constructs a new LPoint2 all components set to the fill value.

proc initLPoint2f*(x: float32, y: float32): LPoint2f {.importcpp: "LPoint2f(#, #)".} ## \
## Constructs a new LPoint2 with the given components

proc zero*(_: typedesc[LPoint2f]): LPoint2f {.importcpp: "LPoint2f::zero()", header: "lpoint2.h".} ## \
## Returns a zero-length point.

proc unitX*(_: typedesc[LPoint2f]): LPoint2f {.importcpp: "LPoint2f::unit_x()", header: "lpoint2.h".} ## \
## Returns a unit X point.

proc unitY*(_: typedesc[LPoint2f]): LPoint2f {.importcpp: "LPoint2f::unit_y()", header: "lpoint2.h".} ## \
## Returns a unit Y point.

proc `-`*(this: LPoint2f): LPoint2f {.importcpp: "#.operator -()".}

proc `+`*(this: LPoint2f, other: LVecBase2f): LVecBase2f {.importcpp: "#.operator +(#)".}

proc `+`*(this: LPoint2f, other: LVector2f): LPoint2f {.importcpp: "#.operator +(#)".}

proc `-`*(this: LPoint2f, other: LPoint2f): LVector2f {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint2f, other: LVecBase2f): LVecBase2f {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint2f, other: LVector2f): LPoint2f {.importcpp: "#.operator -(#)".}

proc `*`*(this: LPoint2f, scalar: float32): LPoint2f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LPoint2f, scalar: float32): LPoint2f {.importcpp: "#.operator /(#)".}

proc normalized*(this: LPoint2f): LPoint2f {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LPoint2f, onto: LVecBase2f): LPoint2f {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

converter getClassType*(_: typedesc[LPoint2f]): TypeHandle {.importcpp: "LPoint2f::get_class_type()", header: "lpoint2.h".}

proc initLPoint2d*(): LPoint2d {.importcpp: "LPoint2d()".}

proc initLPoint2d*(param0: LPoint2d): LPoint2d {.importcpp: "LPoint2d(#)".}

converter initLPoint2d*(copy: LVecBase2d): LPoint2d {.importcpp: "LPoint2d(#)".} ## \
## Constructs a new LPoint2 from a LVecBase2

proc initLPoint2d*(fill_value: float64): LPoint2d {.importcpp: "LPoint2d(#)".} ## \
## Constructs a new LPoint2 all components set to the fill value.

proc initLPoint2d*(x: float64, y: float64): LPoint2d {.importcpp: "LPoint2d(#, #)".} ## \
## Constructs a new LPoint2 with the given components

proc zero*(_: typedesc[LPoint2d]): LPoint2d {.importcpp: "LPoint2d::zero()", header: "lpoint2.h".} ## \
## Returns a zero-length point.

proc unitX*(_: typedesc[LPoint2d]): LPoint2d {.importcpp: "LPoint2d::unit_x()", header: "lpoint2.h".} ## \
## Returns a unit X point.

proc unitY*(_: typedesc[LPoint2d]): LPoint2d {.importcpp: "LPoint2d::unit_y()", header: "lpoint2.h".} ## \
## Returns a unit Y point.

proc `-`*(this: LPoint2d): LPoint2d {.importcpp: "#.operator -()".}

proc `+`*(this: LPoint2d, other: LVecBase2d): LVecBase2d {.importcpp: "#.operator +(#)".}

proc `+`*(this: LPoint2d, other: LVector2d): LPoint2d {.importcpp: "#.operator +(#)".}

proc `-`*(this: LPoint2d, other: LPoint2d): LVector2d {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint2d, other: LVecBase2d): LVecBase2d {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint2d, other: LVector2d): LPoint2d {.importcpp: "#.operator -(#)".}

proc `*`*(this: LPoint2d, scalar: float64): LPoint2d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LPoint2d, scalar: float64): LPoint2d {.importcpp: "#.operator /(#)".}

proc normalized*(this: LPoint2d): LPoint2d {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LPoint2d, onto: LVecBase2d): LPoint2d {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

converter getClassType*(_: typedesc[LPoint2d]): TypeHandle {.importcpp: "LPoint2d::get_class_type()", header: "lpoint2.h".}

proc initLPoint2i*(): LPoint2i {.importcpp: "LPoint2i()".}

proc initLPoint2i*(param0: LPoint2i): LPoint2i {.importcpp: "LPoint2i(#)".}

converter initLPoint2i*(copy: LVecBase2i): LPoint2i {.importcpp: "LPoint2i(#)".} ## \
## Constructs a new LPoint2 from a LVecBase2

proc initLPoint2i*(fill_value: int): LPoint2i {.importcpp: "LPoint2i(#)".} ## \
## Constructs a new LPoint2 all components set to the fill value.

proc initLPoint2i*(x: int, y: int): LPoint2i {.importcpp: "LPoint2i(#, #)".} ## \
## Constructs a new LPoint2 with the given components

proc zero*(_: typedesc[LPoint2i]): LPoint2i {.importcpp: "LPoint2i::zero()", header: "lpoint2.h".} ## \
## Returns a zero-length point.

proc unitX*(_: typedesc[LPoint2i]): LPoint2i {.importcpp: "LPoint2i::unit_x()", header: "lpoint2.h".} ## \
## Returns a unit X point.

proc unitY*(_: typedesc[LPoint2i]): LPoint2i {.importcpp: "LPoint2i::unit_y()", header: "lpoint2.h".} ## \
## Returns a unit Y point.

proc `-`*(this: LPoint2i): LPoint2i {.importcpp: "#.operator -()".}

proc `+`*(this: LPoint2i, other: LVecBase2i): LVecBase2i {.importcpp: "#.operator +(#)".}

proc `+`*(this: LPoint2i, other: LVector2i): LPoint2i {.importcpp: "#.operator +(#)".}

proc `-`*(this: LPoint2i, other: LPoint2i): LVector2i {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint2i, other: LVecBase2i): LVecBase2i {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint2i, other: LVector2i): LPoint2i {.importcpp: "#.operator -(#)".}

proc `*`*(this: LPoint2i, scalar: int): LPoint2i {.importcpp: "#.operator *(#)".}

proc `/`*(this: LPoint2i, scalar: int): LPoint2i {.importcpp: "#.operator /(#)".}

converter getClassType*(_: typedesc[LPoint2i]): TypeHandle {.importcpp: "LPoint2i::get_class_type()", header: "lpoint2.h".}

proc zero*(_: typedesc[LVecBase3f]): LVecBase3f {.importcpp: "LVecBase3f::zero()", header: "lvecBase3.h".} ## \
## Returns a zero-length vector.

proc unitX*(_: typedesc[LVecBase3f]): LVecBase3f {.importcpp: "LVecBase3f::unit_x()", header: "lvecBase3.h".} ## \
## Returns a unit X vector.

proc unitY*(_: typedesc[LVecBase3f]): LVecBase3f {.importcpp: "LVecBase3f::unit_y()", header: "lvecBase3.h".} ## \
## Returns a unit Y vector.

proc unitZ*(_: typedesc[LVecBase3f]): LVecBase3f {.importcpp: "LVecBase3f::unit_z()", header: "lvecBase3.h".} ## \
## Returns a unit Z vector.

proc `[]`*(this: LVecBase3f, i: int, assign_val: float32) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[LVecBase3f]): int {.importcpp: "LVecBase3f::size()", header: "lvecBase3.h".}

proc isNan*(this: LVecBase3f): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the vector is not-a-number, false
## otherwise.

proc getCell*(this: LVecBase3f, i: int): float32 {.importcpp: "#.get_cell(#)".}

proc getX*(this: LVecBase3f): float32 {.importcpp: "#.get_x()".}

proc getY*(this: LVecBase3f): float32 {.importcpp: "#.get_y()".}

proc getZ*(this: LVecBase3f): float32 {.importcpp: "#.get_z()".}

proc setCell*(this: LVecBase3f, i: int, value: float32) {.importcpp: "#.set_cell(#, #)".}

proc setX*(this: LVecBase3f, value: float32) {.importcpp: "#.set_x(#)".}

proc setY*(this: LVecBase3f, value: float32) {.importcpp: "#.set_y(#)".}

proc setZ*(this: LVecBase3f, value: float32) {.importcpp: "#.set_z(#)".}

proc getXy*(this: LVecBase3f): LVecBase2f {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

proc getXz*(this: LVecBase3f): LVecBase2f {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

proc getYz*(this: LVecBase3f): LVecBase2f {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

proc addToCell*(this: LVecBase3f, i: int, value: float32) {.importcpp: "#.add_to_cell(#, #)".} ## \
## These next functions add to an existing value.  i.e.
## foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
## scripting languages:

proc addX*(this: LVecBase3f, value: float32) {.importcpp: "#.add_x(#)".}

proc addY*(this: LVecBase3f, value: float32) {.importcpp: "#.add_y(#)".}

proc addZ*(this: LVecBase3f, value: float32) {.importcpp: "#.add_z(#)".}

proc getData*(this: LVecBase3f) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the three data elements in the vector.
## The remaining elements occupy the next positions consecutively in memory.

proc getNumComponents*(_: typedesc[LVecBase3f]): int {.importcpp: "LVecBase3f::get_num_components()", header: "lvecBase3.h".}

proc fill*(this: LVecBase3f, fill_value: float32) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: LVecBase3f, x: float32, y: float32, z: float32) {.importcpp: "#.set(#, #, #)".}

proc dot*(this: LVecBase3f, other: LVecBase3f): float32 {.importcpp: "#.dot(#)".}

proc lengthSquared*(this: LVecBase3f): float32 {.importcpp: "#.length_squared()".} ## \
## Returns the square of the vector's length, cheap and easy.

proc length*(this: LVecBase3f): float32 {.importcpp: "#.length()".} ## \
## Returns the length of the vector, by the Pythagorean theorem.

proc normalize*(this: LVecBase3f): bool {.importcpp: "#.normalize()".} ## \
## Normalizes the vector in place.  Returns true if the vector was normalized,
## false if it was a zero-length vector.

proc normalized*(this: LVecBase3f): LVecBase3f {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVecBase3f, onto: LVecBase3f): LVecBase3f {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc cross*(this: LVecBase3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.cross(#)".}

proc `<`*(this: LVecBase3f, other: LVecBase3f): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LVecBase3f, other: LVecBase3f): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LVecBase3f, other: LVecBase3f): bool {.importcpp: "#.operator !=(#)".}

proc getStandardizedHpr*(this: LVecBase3f): LVecBase3f {.importcpp: "#.get_standardized_hpr()".} ## \
## Try to un-spin the hpr to a standard form.  Like all standards, someone
## decides between many arbitrary possible standards.  This function assumes
## that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
## same.  Another example is -90 and 270. Each element will be in the range
## -180.0 to 179.99999. The original usage of this function is for human
## readable output.
##
## It doesn't work so well for asserting that foo_hpr is roughly equal to
## bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
## get_standardized_rotation, LQuaternion::is_same_direction

proc compareTo*(this: LVecBase3f, other: LVecBase3f): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc compareTo*(this: LVecBase3f, other: LVecBase3f, threshold: float32): int {.importcpp: "#.compare_to(#, #)".} ## \
## Sorts vectors lexicographically, componentwise.  Returns a number less than
## 0 if this vector sorts before the other one, greater than zero if it sorts
## after, 0 if they are equivalent (within the indicated tolerance).

proc getHash*(this: LVecBase3f): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc getHash*(this: LVecBase3f, threshold: float32): clonglong {.importcpp: "#.get_hash(#)".} ## \
## Returns a suitable hash for phash_map.

proc addHash*(this: LVecBase3f, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc addHash*(this: LVecBase3f, hash: clonglong, threshold: float32): clonglong {.importcpp: "#.add_hash(#, #)".} ## \
## Adds the vector into the running hash.

proc `-`*(this: LVecBase3f): LVecBase3f {.importcpp: "#.operator -()".}

proc `+`*(this: LVecBase3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVecBase3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVecBase3f, scalar: float32): LVecBase3f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVecBase3f, scalar: float32): LVecBase3f {.importcpp: "#.operator /(#)".}

proc `+=`*(this: var LVecBase3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: var LVecBase3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: var LVecBase3f, scalar: float32): LVecBase3f {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: var LVecBase3f, scalar: float32): LVecBase3f {.importcpp: "#.operator /=(#)".}

proc componentwiseMult*(this: LVecBase3f, other: LVecBase3f) {.importcpp: "#.componentwise_mult(#)".}

proc fmax*(this: LVecBase3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.fmax(#)".}

proc fmin*(this: LVecBase3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.fmin(#)".}

proc crossInto*(this: LVecBase3f, other: LVecBase3f) {.importcpp: "#.cross_into(#)".}

proc almostEqual*(this: LVecBase3f, other: LVecBase3f): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two vectors are memberwise equal within a default tolerance
## based on the numeric type.

proc almostEqual*(this: LVecBase3f, other: LVecBase3f, threshold: float32): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two vectors are memberwise equal within a specified
## tolerance.

proc output*(this: LVecBase3f, `out`: ostream) {.importcpp: "#.output(#)".}

proc writeDatagramFixed*(this: LVecBase3f, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the vector to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the vector, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc readDatagramFixed*(this: LVecBase3f, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the vector from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc writeDatagram*(this: LVecBase3f, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the vector to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc readDatagram*(this: LVecBase3f, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the vector from the Datagram using get_stdfloat().

converter getClassType*(_: typedesc[LVecBase3f]): TypeHandle {.importcpp: "LVecBase3f::get_class_type()", header: "lvecBase3.h".}

proc zero*(_: typedesc[LVecBase3d]): LVecBase3d {.importcpp: "LVecBase3d::zero()", header: "lvecBase3.h".} ## \
## Returns a zero-length vector.

proc unitX*(_: typedesc[LVecBase3d]): LVecBase3d {.importcpp: "LVecBase3d::unit_x()", header: "lvecBase3.h".} ## \
## Returns a unit X vector.

proc unitY*(_: typedesc[LVecBase3d]): LVecBase3d {.importcpp: "LVecBase3d::unit_y()", header: "lvecBase3.h".} ## \
## Returns a unit Y vector.

proc unitZ*(_: typedesc[LVecBase3d]): LVecBase3d {.importcpp: "LVecBase3d::unit_z()", header: "lvecBase3.h".} ## \
## Returns a unit Z vector.

proc `[]`*(this: LVecBase3d, i: int, assign_val: float64) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[LVecBase3d]): int {.importcpp: "LVecBase3d::size()", header: "lvecBase3.h".}

proc isNan*(this: LVecBase3d): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the vector is not-a-number, false
## otherwise.

proc getCell*(this: LVecBase3d, i: int): float64 {.importcpp: "#.get_cell(#)".}

proc getX*(this: LVecBase3d): float64 {.importcpp: "#.get_x()".}

proc getY*(this: LVecBase3d): float64 {.importcpp: "#.get_y()".}

proc getZ*(this: LVecBase3d): float64 {.importcpp: "#.get_z()".}

proc setCell*(this: LVecBase3d, i: int, value: float64) {.importcpp: "#.set_cell(#, #)".}

proc setX*(this: LVecBase3d, value: float64) {.importcpp: "#.set_x(#)".}

proc setY*(this: LVecBase3d, value: float64) {.importcpp: "#.set_y(#)".}

proc setZ*(this: LVecBase3d, value: float64) {.importcpp: "#.set_z(#)".}

proc getXy*(this: LVecBase3d): LVecBase2d {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

proc getXz*(this: LVecBase3d): LVecBase2d {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

proc getYz*(this: LVecBase3d): LVecBase2d {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

proc addToCell*(this: LVecBase3d, i: int, value: float64) {.importcpp: "#.add_to_cell(#, #)".} ## \
## These next functions add to an existing value.  i.e.
## foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
## scripting languages:

proc addX*(this: LVecBase3d, value: float64) {.importcpp: "#.add_x(#)".}

proc addY*(this: LVecBase3d, value: float64) {.importcpp: "#.add_y(#)".}

proc addZ*(this: LVecBase3d, value: float64) {.importcpp: "#.add_z(#)".}

proc getData*(this: LVecBase3d) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the three data elements in the vector.
## The remaining elements occupy the next positions consecutively in memory.

proc getNumComponents*(_: typedesc[LVecBase3d]): int {.importcpp: "LVecBase3d::get_num_components()", header: "lvecBase3.h".}

proc fill*(this: LVecBase3d, fill_value: float64) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: LVecBase3d, x: float64, y: float64, z: float64) {.importcpp: "#.set(#, #, #)".}

proc dot*(this: LVecBase3d, other: LVecBase3d): float64 {.importcpp: "#.dot(#)".}

proc lengthSquared*(this: LVecBase3d): float64 {.importcpp: "#.length_squared()".} ## \
## Returns the square of the vector's length, cheap and easy.

proc length*(this: LVecBase3d): float64 {.importcpp: "#.length()".} ## \
## Returns the length of the vector, by the Pythagorean theorem.

proc normalize*(this: LVecBase3d): bool {.importcpp: "#.normalize()".} ## \
## Normalizes the vector in place.  Returns true if the vector was normalized,
## false if it was a zero-length vector.

proc normalized*(this: LVecBase3d): LVecBase3d {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVecBase3d, onto: LVecBase3d): LVecBase3d {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc cross*(this: LVecBase3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.cross(#)".}

proc `<`*(this: LVecBase3d, other: LVecBase3d): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LVecBase3d, other: LVecBase3d): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LVecBase3d, other: LVecBase3d): bool {.importcpp: "#.operator !=(#)".}

proc getStandardizedHpr*(this: LVecBase3d): LVecBase3d {.importcpp: "#.get_standardized_hpr()".} ## \
## Try to un-spin the hpr to a standard form.  Like all standards, someone
## decides between many arbitrary possible standards.  This function assumes
## that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
## same.  Another example is -90 and 270. Each element will be in the range
## -180.0 to 179.99999. The original usage of this function is for human
## readable output.
##
## It doesn't work so well for asserting that foo_hpr is roughly equal to
## bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
## get_standardized_rotation, LQuaternion::is_same_direction

proc compareTo*(this: LVecBase3d, other: LVecBase3d): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc compareTo*(this: LVecBase3d, other: LVecBase3d, threshold: float64): int {.importcpp: "#.compare_to(#, #)".} ## \
## Sorts vectors lexicographically, componentwise.  Returns a number less than
## 0 if this vector sorts before the other one, greater than zero if it sorts
## after, 0 if they are equivalent (within the indicated tolerance).

proc getHash*(this: LVecBase3d): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc getHash*(this: LVecBase3d, threshold: float64): clonglong {.importcpp: "#.get_hash(#)".} ## \
## Returns a suitable hash for phash_map.

proc addHash*(this: LVecBase3d, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc addHash*(this: LVecBase3d, hash: clonglong, threshold: float64): clonglong {.importcpp: "#.add_hash(#, #)".} ## \
## Adds the vector into the running hash.

proc `-`*(this: LVecBase3d): LVecBase3d {.importcpp: "#.operator -()".}

proc `+`*(this: LVecBase3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVecBase3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVecBase3d, scalar: float64): LVecBase3d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVecBase3d, scalar: float64): LVecBase3d {.importcpp: "#.operator /(#)".}

proc `+=`*(this: var LVecBase3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: var LVecBase3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: var LVecBase3d, scalar: float64): LVecBase3d {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: var LVecBase3d, scalar: float64): LVecBase3d {.importcpp: "#.operator /=(#)".}

proc componentwiseMult*(this: LVecBase3d, other: LVecBase3d) {.importcpp: "#.componentwise_mult(#)".}

proc fmax*(this: LVecBase3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.fmax(#)".}

proc fmin*(this: LVecBase3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.fmin(#)".}

proc crossInto*(this: LVecBase3d, other: LVecBase3d) {.importcpp: "#.cross_into(#)".}

proc almostEqual*(this: LVecBase3d, other: LVecBase3d): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two vectors are memberwise equal within a default tolerance
## based on the numeric type.

proc almostEqual*(this: LVecBase3d, other: LVecBase3d, threshold: float64): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two vectors are memberwise equal within a specified
## tolerance.

proc output*(this: LVecBase3d, `out`: ostream) {.importcpp: "#.output(#)".}

proc writeDatagramFixed*(this: LVecBase3d, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the vector to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the vector, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc readDatagramFixed*(this: LVecBase3d, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the vector from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc writeDatagram*(this: LVecBase3d, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the vector to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc readDatagram*(this: LVecBase3d, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the vector from the Datagram using get_stdfloat().

converter getClassType*(_: typedesc[LVecBase3d]): TypeHandle {.importcpp: "LVecBase3d::get_class_type()", header: "lvecBase3.h".}

proc zero*(_: typedesc[LVecBase3i]): LVecBase3i {.importcpp: "LVecBase3i::zero()", header: "lvecBase3.h".} ## \
## Returns a zero-length vector.

proc unitX*(_: typedesc[LVecBase3i]): LVecBase3i {.importcpp: "LVecBase3i::unit_x()", header: "lvecBase3.h".} ## \
## Returns a unit X vector.

proc unitY*(_: typedesc[LVecBase3i]): LVecBase3i {.importcpp: "LVecBase3i::unit_y()", header: "lvecBase3.h".} ## \
## Returns a unit Y vector.

proc unitZ*(_: typedesc[LVecBase3i]): LVecBase3i {.importcpp: "LVecBase3i::unit_z()", header: "lvecBase3.h".} ## \
## Returns a unit Z vector.

proc `[]`*(this: LVecBase3i, i: int, assign_val: int) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[LVecBase3i]): int {.importcpp: "LVecBase3i::size()", header: "lvecBase3.h".}

proc isNan*(this: LVecBase3i): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the vector is not-a-number, false
## otherwise.

proc getCell*(this: LVecBase3i, i: int): int {.importcpp: "#.get_cell(#)".}

proc getX*(this: LVecBase3i): int {.importcpp: "#.get_x()".}

proc getY*(this: LVecBase3i): int {.importcpp: "#.get_y()".}

proc getZ*(this: LVecBase3i): int {.importcpp: "#.get_z()".}

proc setCell*(this: LVecBase3i, i: int, value: int) {.importcpp: "#.set_cell(#, #)".}

proc setX*(this: LVecBase3i, value: int) {.importcpp: "#.set_x(#)".}

proc setY*(this: LVecBase3i, value: int) {.importcpp: "#.set_y(#)".}

proc setZ*(this: LVecBase3i, value: int) {.importcpp: "#.set_z(#)".}

proc getXy*(this: LVecBase3i): LVecBase2i {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

proc getXz*(this: LVecBase3i): LVecBase2i {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

proc getYz*(this: LVecBase3i): LVecBase2i {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

proc addToCell*(this: LVecBase3i, i: int, value: int) {.importcpp: "#.add_to_cell(#, #)".} ## \
## These next functions add to an existing value.  i.e.
## foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
## scripting languages:

proc addX*(this: LVecBase3i, value: int) {.importcpp: "#.add_x(#)".}

proc addY*(this: LVecBase3i, value: int) {.importcpp: "#.add_y(#)".}

proc addZ*(this: LVecBase3i, value: int) {.importcpp: "#.add_z(#)".}

proc getData*(this: LVecBase3i) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the three data elements in the vector.
## The remaining elements occupy the next positions consecutively in memory.

proc getNumComponents*(_: typedesc[LVecBase3i]): int {.importcpp: "LVecBase3i::get_num_components()", header: "lvecBase3.h".}

proc fill*(this: LVecBase3i, fill_value: int) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: LVecBase3i, x: int, y: int, z: int) {.importcpp: "#.set(#, #, #)".}

proc dot*(this: LVecBase3i, other: LVecBase3i): int {.importcpp: "#.dot(#)".}

proc lengthSquared*(this: LVecBase3i): int {.importcpp: "#.length_squared()".} ## \
## Returns the square of the vector's length, cheap and easy.

proc cross*(this: LVecBase3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.cross(#)".}

proc `<`*(this: LVecBase3i, other: LVecBase3i): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LVecBase3i, other: LVecBase3i): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LVecBase3i, other: LVecBase3i): bool {.importcpp: "#.operator !=(#)".}

proc compareTo*(this: LVecBase3i, other: LVecBase3i): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc getHash*(this: LVecBase3i): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc addHash*(this: LVecBase3i, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc `-`*(this: LVecBase3i): LVecBase3i {.importcpp: "#.operator -()".}

proc `+`*(this: LVecBase3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVecBase3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVecBase3i, scalar: int): LVecBase3i {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVecBase3i, scalar: int): LVecBase3i {.importcpp: "#.operator /(#)".}

proc `+=`*(this: var LVecBase3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: var LVecBase3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: var LVecBase3i, scalar: int): LVecBase3i {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: var LVecBase3i, scalar: int): LVecBase3i {.importcpp: "#.operator /=(#)".}

proc componentwiseMult*(this: LVecBase3i, other: LVecBase3i) {.importcpp: "#.componentwise_mult(#)".}

proc fmax*(this: LVecBase3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.fmax(#)".}

proc fmin*(this: LVecBase3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.fmin(#)".}

proc crossInto*(this: LVecBase3i, other: LVecBase3i) {.importcpp: "#.cross_into(#)".}

proc almostEqual*(this: LVecBase3i, other: LVecBase3i): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two vectors are memberwise equal within a default tolerance
## based on the numeric type.

proc almostEqual*(this: LVecBase3i, other: LVecBase3i, threshold: int): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two vectors are memberwise equal within a specified
## tolerance.

proc output*(this: LVecBase3i, `out`: ostream) {.importcpp: "#.output(#)".}

proc writeDatagramFixed*(this: LVecBase3i, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the vector to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the vector, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc readDatagramFixed*(this: LVecBase3i, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the vector from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc writeDatagram*(this: LVecBase3i, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the vector to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc readDatagram*(this: LVecBase3i, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the vector from the Datagram using get_stdfloat().

converter getClassType*(_: typedesc[LVecBase3i]): TypeHandle {.importcpp: "LVecBase3i::get_class_type()", header: "lvecBase3.h".}

proc getDefaultCoordinateSystem*(): CoordinateSystem {.importcpp: "get_default_coordinate_system()".}

proc parseCoordinateSystemString*(str: string): CoordinateSystem {.importcpp: "parse_coordinate_system_string(nimStringToStdString(#))", header: stringConversionCode.}

proc formatCoordinateSystem*(cs: CoordinateSystem): string {.importcpp: "nimStringFromStdString(format_coordinate_system(#))", header: stringConversionCode.}

proc isRightHanded*(cs: CoordinateSystem): bool {.importcpp: "is_right_handed(#)".}

proc isRightHanded*(): bool {.importcpp: "is_right_handed()".}

proc initLVector3f*(): LVector3f {.importcpp: "LVector3f()".}

proc initLVector3f*(copy: LVecBase2f, z: float32): LVector3f {.importcpp: "LVector3f(#, #)".}

converter initLVector3f*(copy: LVecBase3f): LVector3f {.importcpp: "LVector3f(#)".}

proc initLVector3f*(param0: LVector3f): LVector3f {.importcpp: "LVector3f(#)".}

proc initLVector3f*(fill_value: float32): LVector3f {.importcpp: "LVector3f(#)".}

proc initLVector3f*(x: float32, y: float32, z: float32): LVector3f {.importcpp: "LVector3f(#, #, #)".}

proc zero*(_: typedesc[LVector3f]): LVector3f {.importcpp: "LVector3f::zero()", header: "lvector3.h".} ## \
## Returns a zero-length vector.

proc unitX*(_: typedesc[LVector3f]): LVector3f {.importcpp: "LVector3f::unit_x()", header: "lvector3.h".} ## \
## Returns a unit X vector.

proc unitY*(_: typedesc[LVector3f]): LVector3f {.importcpp: "LVector3f::unit_y()", header: "lvector3.h".} ## \
## Returns a unit Y vector.

proc unitZ*(_: typedesc[LVector3f]): LVector3f {.importcpp: "LVector3f::unit_z()", header: "lvector3.h".} ## \
## Returns a unit Z vector.

proc getXy*(this: LVector3f): LVector2f {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

proc getXz*(this: LVector3f): LVector2f {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

proc getYz*(this: LVector3f): LVector2f {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

proc `-`*(this: LVector3f): LVector3f {.importcpp: "#.operator -()".}

proc `+`*(this: LVector3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.operator +(#)".}

proc `+`*(this: LVector3f, other: LVector3f): LVector3f {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVector3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.operator -(#)".}

proc `-`*(this: LVector3f, other: LVector3f): LVector3f {.importcpp: "#.operator -(#)".}

proc cross*(this: LVector3f, other: LVecBase3f): LVector3f {.importcpp: "#.cross(#)".}

proc normalized*(this: LVector3f): LVector3f {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVector3f, onto: LVecBase3f): LVector3f {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc angleRad*(this: LVector3f, other: LVector3f): float32 {.importcpp: "#.angle_rad(#)".} ## \
## Returns the unsigned angle between this vector and the other one, expressed
## in radians.  Both vectors should be initially normalized.

proc angleDeg*(this: LVector3f, other: LVector3f): float32 {.importcpp: "#.angle_deg(#)".} ## \
## Returns the angle between this vector and the other one, expressed in
## degrees.  Both vectors should be initially normalized.

proc signedAngleRad*(this: LVector3f, other: LVector3f, `ref`: LVector3f): float32 {.importcpp: "#.signed_angle_rad(#, #)".} ## \
## returns the signed angle between two vectors.  The angle is positive if the
## rotation from this vector to other is clockwise when looking in the
## direction of the ref vector.
##
## Vectors (except the ref vector) should be initially normalized.

proc signedAngleDeg*(this: LVector3f, other: LVector3f, `ref`: LVector3f): float32 {.importcpp: "#.signed_angle_deg(#, #)".} ## \
## Returns the signed angle between two vectors.  The angle is positive if the
## rotation from this vector to other is clockwise when looking in the
## direction of the ref vector.
##
## Vectors (except the ref vector) should be initially normalized.

proc relativeAngleRad*(this: LVector3f, other: LVector3f): float32 {.importcpp: "#.relative_angle_rad(#)".} ## \
## @deprecated Do not use.

proc relativeAngleDeg*(this: LVector3f, other: LVector3f): float32 {.importcpp: "#.relative_angle_deg(#)".} ## \
## @deprecated Do not use.

proc `*`*(this: LVector3f, scalar: float32): LVector3f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVector3f, scalar: float32): LVector3f {.importcpp: "#.operator /(#)".}

proc up*(_: typedesc[LVector3f], cs: CoordinateSystem): LVector3f {.importcpp: "#LVector3f::up(#)", header: "lvector3.h".} ## \
## Returns the up vector for the given coordinate system.

proc up*(_: typedesc[LVector3f]): LVector3f {.importcpp: "LVector3f::up()", header: "lvector3.h".} ## \
## Returns the up vector for the given coordinate system.

proc right*(_: typedesc[LVector3f], cs: CoordinateSystem): LVector3f {.importcpp: "#LVector3f::right(#)", header: "lvector3.h".} ## \
## Returns the right vector for the given coordinate system.

proc right*(_: typedesc[LVector3f]): LVector3f {.importcpp: "LVector3f::right()", header: "lvector3.h".} ## \
## Returns the right vector for the given coordinate system.

proc forward*(_: typedesc[LVector3f], cs: CoordinateSystem): LVector3f {.importcpp: "#LVector3f::forward(#)", header: "lvector3.h".} ## \
## Returns the forward vector for the given coordinate system.

proc forward*(_: typedesc[LVector3f]): LVector3f {.importcpp: "LVector3f::forward()", header: "lvector3.h".} ## \
## Returns the forward vector for the given coordinate system.

proc down*(_: typedesc[LVector3f], cs: CoordinateSystem): LVector3f {.importcpp: "#LVector3f::down(#)", header: "lvector3.h".} ## \
## Returns the down vector for the given coordinate system.

proc down*(_: typedesc[LVector3f]): LVector3f {.importcpp: "LVector3f::down()", header: "lvector3.h".} ## \
## Returns the down vector for the given coordinate system.

proc left*(_: typedesc[LVector3f], cs: CoordinateSystem): LVector3f {.importcpp: "#LVector3f::left(#)", header: "lvector3.h".} ## \
## Returns the left vector for the given coordinate system.

proc left*(_: typedesc[LVector3f]): LVector3f {.importcpp: "LVector3f::left()", header: "lvector3.h".} ## \
## Returns the left vector for the given coordinate system.

proc back*(_: typedesc[LVector3f], cs: CoordinateSystem): LVector3f {.importcpp: "#LVector3f::back(#)", header: "lvector3.h".} ## \
## Returns the back vector for the given coordinate system.

proc back*(_: typedesc[LVector3f]): LVector3f {.importcpp: "LVector3f::back()", header: "lvector3.h".} ## \
## Returns the back vector for the given coordinate system.

proc rfu*(_: typedesc[LVector3f], right: float32, fwd: float32, up: float32, cs: CoordinateSystem): LVector3f {.importcpp: "#LVector3f::rfu(#, #, #, #)", header: "lvector3.h".} ## \
## Returns a vector that is described by its right, forward, and up
## components, in whatever way the coordinate system represents that vector.

proc rfu*(_: typedesc[LVector3f], right: float32, fwd: float32, up: float32): LVector3f {.importcpp: "#LVector3f::rfu(#, #, #)", header: "lvector3.h".} ## \
## Returns a vector that is described by its right, forward, and up
## components, in whatever way the coordinate system represents that vector.

converter getClassType*(_: typedesc[LVector3f]): TypeHandle {.importcpp: "LVector3f::get_class_type()", header: "lvector3.h".}

proc initLVector3d*(): LVector3d {.importcpp: "LVector3d()".}

proc initLVector3d*(copy: LVecBase2d, z: float64): LVector3d {.importcpp: "LVector3d(#, #)".}

converter initLVector3d*(copy: LVecBase3d): LVector3d {.importcpp: "LVector3d(#)".}

proc initLVector3d*(param0: LVector3d): LVector3d {.importcpp: "LVector3d(#)".}

proc initLVector3d*(fill_value: float64): LVector3d {.importcpp: "LVector3d(#)".}

proc initLVector3d*(x: float64, y: float64, z: float64): LVector3d {.importcpp: "LVector3d(#, #, #)".}

proc zero*(_: typedesc[LVector3d]): LVector3d {.importcpp: "LVector3d::zero()", header: "lvector3.h".} ## \
## Returns a zero-length vector.

proc unitX*(_: typedesc[LVector3d]): LVector3d {.importcpp: "LVector3d::unit_x()", header: "lvector3.h".} ## \
## Returns a unit X vector.

proc unitY*(_: typedesc[LVector3d]): LVector3d {.importcpp: "LVector3d::unit_y()", header: "lvector3.h".} ## \
## Returns a unit Y vector.

proc unitZ*(_: typedesc[LVector3d]): LVector3d {.importcpp: "LVector3d::unit_z()", header: "lvector3.h".} ## \
## Returns a unit Z vector.

proc getXy*(this: LVector3d): LVector2d {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

proc getXz*(this: LVector3d): LVector2d {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

proc getYz*(this: LVector3d): LVector2d {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

proc `-`*(this: LVector3d): LVector3d {.importcpp: "#.operator -()".}

proc `+`*(this: LVector3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.operator +(#)".}

proc `+`*(this: LVector3d, other: LVector3d): LVector3d {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVector3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.operator -(#)".}

proc `-`*(this: LVector3d, other: LVector3d): LVector3d {.importcpp: "#.operator -(#)".}

proc cross*(this: LVector3d, other: LVecBase3d): LVector3d {.importcpp: "#.cross(#)".}

proc normalized*(this: LVector3d): LVector3d {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVector3d, onto: LVecBase3d): LVector3d {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc angleRad*(this: LVector3d, other: LVector3d): float64 {.importcpp: "#.angle_rad(#)".} ## \
## Returns the unsigned angle between this vector and the other one, expressed
## in radians.  Both vectors should be initially normalized.

proc angleDeg*(this: LVector3d, other: LVector3d): float64 {.importcpp: "#.angle_deg(#)".} ## \
## Returns the angle between this vector and the other one, expressed in
## degrees.  Both vectors should be initially normalized.

proc signedAngleRad*(this: LVector3d, other: LVector3d, `ref`: LVector3d): float64 {.importcpp: "#.signed_angle_rad(#, #)".} ## \
## returns the signed angle between two vectors.  The angle is positive if the
## rotation from this vector to other is clockwise when looking in the
## direction of the ref vector.
##
## Vectors (except the ref vector) should be initially normalized.

proc signedAngleDeg*(this: LVector3d, other: LVector3d, `ref`: LVector3d): float64 {.importcpp: "#.signed_angle_deg(#, #)".} ## \
## Returns the signed angle between two vectors.  The angle is positive if the
## rotation from this vector to other is clockwise when looking in the
## direction of the ref vector.
##
## Vectors (except the ref vector) should be initially normalized.

proc relativeAngleRad*(this: LVector3d, other: LVector3d): float64 {.importcpp: "#.relative_angle_rad(#)".} ## \
## @deprecated Do not use.

proc relativeAngleDeg*(this: LVector3d, other: LVector3d): float64 {.importcpp: "#.relative_angle_deg(#)".} ## \
## @deprecated Do not use.

proc `*`*(this: LVector3d, scalar: float64): LVector3d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVector3d, scalar: float64): LVector3d {.importcpp: "#.operator /(#)".}

proc up*(_: typedesc[LVector3d], cs: CoordinateSystem): LVector3d {.importcpp: "#LVector3d::up(#)", header: "lvector3.h".} ## \
## Returns the up vector for the given coordinate system.

proc up*(_: typedesc[LVector3d]): LVector3d {.importcpp: "LVector3d::up()", header: "lvector3.h".} ## \
## Returns the up vector for the given coordinate system.

proc right*(_: typedesc[LVector3d], cs: CoordinateSystem): LVector3d {.importcpp: "#LVector3d::right(#)", header: "lvector3.h".} ## \
## Returns the right vector for the given coordinate system.

proc right*(_: typedesc[LVector3d]): LVector3d {.importcpp: "LVector3d::right()", header: "lvector3.h".} ## \
## Returns the right vector for the given coordinate system.

proc forward*(_: typedesc[LVector3d], cs: CoordinateSystem): LVector3d {.importcpp: "#LVector3d::forward(#)", header: "lvector3.h".} ## \
## Returns the forward vector for the given coordinate system.

proc forward*(_: typedesc[LVector3d]): LVector3d {.importcpp: "LVector3d::forward()", header: "lvector3.h".} ## \
## Returns the forward vector for the given coordinate system.

proc down*(_: typedesc[LVector3d], cs: CoordinateSystem): LVector3d {.importcpp: "#LVector3d::down(#)", header: "lvector3.h".} ## \
## Returns the down vector for the given coordinate system.

proc down*(_: typedesc[LVector3d]): LVector3d {.importcpp: "LVector3d::down()", header: "lvector3.h".} ## \
## Returns the down vector for the given coordinate system.

proc left*(_: typedesc[LVector3d], cs: CoordinateSystem): LVector3d {.importcpp: "#LVector3d::left(#)", header: "lvector3.h".} ## \
## Returns the left vector for the given coordinate system.

proc left*(_: typedesc[LVector3d]): LVector3d {.importcpp: "LVector3d::left()", header: "lvector3.h".} ## \
## Returns the left vector for the given coordinate system.

proc back*(_: typedesc[LVector3d], cs: CoordinateSystem): LVector3d {.importcpp: "#LVector3d::back(#)", header: "lvector3.h".} ## \
## Returns the back vector for the given coordinate system.

proc back*(_: typedesc[LVector3d]): LVector3d {.importcpp: "LVector3d::back()", header: "lvector3.h".} ## \
## Returns the back vector for the given coordinate system.

proc rfu*(_: typedesc[LVector3d], right: float64, fwd: float64, up: float64, cs: CoordinateSystem): LVector3d {.importcpp: "#LVector3d::rfu(#, #, #, #)", header: "lvector3.h".} ## \
## Returns a vector that is described by its right, forward, and up
## components, in whatever way the coordinate system represents that vector.

proc rfu*(_: typedesc[LVector3d], right: float64, fwd: float64, up: float64): LVector3d {.importcpp: "#LVector3d::rfu(#, #, #)", header: "lvector3.h".} ## \
## Returns a vector that is described by its right, forward, and up
## components, in whatever way the coordinate system represents that vector.

converter getClassType*(_: typedesc[LVector3d]): TypeHandle {.importcpp: "LVector3d::get_class_type()", header: "lvector3.h".}

proc initLVector3i*(): LVector3i {.importcpp: "LVector3i()".}

proc initLVector3i*(copy: LVecBase2i, z: int): LVector3i {.importcpp: "LVector3i(#, #)".}

converter initLVector3i*(copy: LVecBase3i): LVector3i {.importcpp: "LVector3i(#)".}

proc initLVector3i*(param0: LVector3i): LVector3i {.importcpp: "LVector3i(#)".}

proc initLVector3i*(fill_value: int): LVector3i {.importcpp: "LVector3i(#)".}

proc initLVector3i*(x: int, y: int, z: int): LVector3i {.importcpp: "LVector3i(#, #, #)".}

proc zero*(_: typedesc[LVector3i]): LVector3i {.importcpp: "LVector3i::zero()", header: "lvector3.h".} ## \
## Returns a zero-length vector.

proc unitX*(_: typedesc[LVector3i]): LVector3i {.importcpp: "LVector3i::unit_x()", header: "lvector3.h".} ## \
## Returns a unit X vector.

proc unitY*(_: typedesc[LVector3i]): LVector3i {.importcpp: "LVector3i::unit_y()", header: "lvector3.h".} ## \
## Returns a unit Y vector.

proc unitZ*(_: typedesc[LVector3i]): LVector3i {.importcpp: "LVector3i::unit_z()", header: "lvector3.h".} ## \
## Returns a unit Z vector.

proc getXy*(this: LVector3i): LVector2i {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

proc getXz*(this: LVector3i): LVector2i {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

proc getYz*(this: LVector3i): LVector2i {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

proc `-`*(this: LVector3i): LVector3i {.importcpp: "#.operator -()".}

proc `+`*(this: LVector3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.operator +(#)".}

proc `+`*(this: LVector3i, other: LVector3i): LVector3i {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVector3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.operator -(#)".}

proc `-`*(this: LVector3i, other: LVector3i): LVector3i {.importcpp: "#.operator -(#)".}

proc cross*(this: LVector3i, other: LVecBase3i): LVector3i {.importcpp: "#.cross(#)".}

proc `*`*(this: LVector3i, scalar: int): LVector3i {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVector3i, scalar: int): LVector3i {.importcpp: "#.operator /(#)".}

proc up*(_: typedesc[LVector3i], cs: CoordinateSystem): LVector3i {.importcpp: "#LVector3i::up(#)", header: "lvector3.h".} ## \
## Returns the up vector for the given coordinate system.

proc up*(_: typedesc[LVector3i]): LVector3i {.importcpp: "LVector3i::up()", header: "lvector3.h".} ## \
## Returns the up vector for the given coordinate system.

proc right*(_: typedesc[LVector3i], cs: CoordinateSystem): LVector3i {.importcpp: "#LVector3i::right(#)", header: "lvector3.h".} ## \
## Returns the right vector for the given coordinate system.

proc right*(_: typedesc[LVector3i]): LVector3i {.importcpp: "LVector3i::right()", header: "lvector3.h".} ## \
## Returns the right vector for the given coordinate system.

proc forward*(_: typedesc[LVector3i], cs: CoordinateSystem): LVector3i {.importcpp: "#LVector3i::forward(#)", header: "lvector3.h".} ## \
## Returns the forward vector for the given coordinate system.

proc forward*(_: typedesc[LVector3i]): LVector3i {.importcpp: "LVector3i::forward()", header: "lvector3.h".} ## \
## Returns the forward vector for the given coordinate system.

proc down*(_: typedesc[LVector3i], cs: CoordinateSystem): LVector3i {.importcpp: "#LVector3i::down(#)", header: "lvector3.h".} ## \
## Returns the down vector for the given coordinate system.

proc down*(_: typedesc[LVector3i]): LVector3i {.importcpp: "LVector3i::down()", header: "lvector3.h".} ## \
## Returns the down vector for the given coordinate system.

proc left*(_: typedesc[LVector3i], cs: CoordinateSystem): LVector3i {.importcpp: "#LVector3i::left(#)", header: "lvector3.h".} ## \
## Returns the left vector for the given coordinate system.

proc left*(_: typedesc[LVector3i]): LVector3i {.importcpp: "LVector3i::left()", header: "lvector3.h".} ## \
## Returns the left vector for the given coordinate system.

proc back*(_: typedesc[LVector3i], cs: CoordinateSystem): LVector3i {.importcpp: "#LVector3i::back(#)", header: "lvector3.h".} ## \
## Returns the back vector for the given coordinate system.

proc back*(_: typedesc[LVector3i]): LVector3i {.importcpp: "LVector3i::back()", header: "lvector3.h".} ## \
## Returns the back vector for the given coordinate system.

proc rfu*(_: typedesc[LVector3i], right: int, fwd: int, up: int, cs: CoordinateSystem): LVector3i {.importcpp: "#LVector3i::rfu(#, #, #, #)", header: "lvector3.h".} ## \
## Returns a vector that is described by its right, forward, and up
## components, in whatever way the coordinate system represents that vector.

proc rfu*(_: typedesc[LVector3i], right: int, fwd: int, up: int): LVector3i {.importcpp: "#LVector3i::rfu(#, #, #)", header: "lvector3.h".} ## \
## Returns a vector that is described by its right, forward, and up
## components, in whatever way the coordinate system represents that vector.

converter getClassType*(_: typedesc[LVector3i]): TypeHandle {.importcpp: "LVector3i::get_class_type()", header: "lvector3.h".}

proc initLPoint3f*(): LPoint3f {.importcpp: "LPoint3f()".}

proc initLPoint3f*(param0: LPoint3f): LPoint3f {.importcpp: "LPoint3f(#)".}

proc initLPoint3f*(copy: LVecBase2f, z: float32): LPoint3f {.importcpp: "LPoint3f(#, #)".}

converter initLPoint3f*(copy: LVecBase3f): LPoint3f {.importcpp: "LPoint3f(#)".}

proc initLPoint3f*(fill_value: float32): LPoint3f {.importcpp: "LPoint3f(#)".}

proc initLPoint3f*(x: float32, y: float32, z: float32): LPoint3f {.importcpp: "LPoint3f(#, #, #)".}

proc zero*(_: typedesc[LPoint3f]): LPoint3f {.importcpp: "LPoint3f::zero()", header: "lpoint3.h".} ## \
## Returns a zero-length point.

proc unitX*(_: typedesc[LPoint3f]): LPoint3f {.importcpp: "LPoint3f::unit_x()", header: "lpoint3.h".} ## \
## Returns a unit X point.

proc unitY*(_: typedesc[LPoint3f]): LPoint3f {.importcpp: "LPoint3f::unit_y()", header: "lpoint3.h".} ## \
## Returns a unit Y point.

proc unitZ*(_: typedesc[LPoint3f]): LPoint3f {.importcpp: "LPoint3f::unit_z()", header: "lpoint3.h".} ## \
## Returns a unit Z point.

proc getXy*(this: LPoint3f): LPoint2f {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

proc getXz*(this: LPoint3f): LPoint2f {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

proc getYz*(this: LPoint3f): LPoint2f {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

proc `-`*(this: LPoint3f): LPoint3f {.importcpp: "#.operator -()".}

proc `+`*(this: LPoint3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.operator +(#)".}

proc `+`*(this: LPoint3f, other: LVector3f): LPoint3f {.importcpp: "#.operator +(#)".}

proc `-`*(this: LPoint3f, other: LPoint3f): LVector3f {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint3f, other: LVecBase3f): LVecBase3f {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint3f, other: LVector3f): LPoint3f {.importcpp: "#.operator -(#)".}

proc cross*(this: LPoint3f, other: LVecBase3f): LPoint3f {.importcpp: "#.cross(#)".}

proc normalized*(this: LPoint3f): LPoint3f {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LPoint3f, onto: LVecBase3f): LPoint3f {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc `*`*(this: LPoint3f, scalar: float32): LPoint3f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LPoint3f, scalar: float32): LPoint3f {.importcpp: "#.operator /(#)".}

proc origin*(_: typedesc[LPoint3f], cs: CoordinateSystem): LPoint3f {.importcpp: "#LPoint3f::origin(#)", header: "lpoint3.h".} ## \
## Returns the origin of the indicated coordinate system.  This is always 0,
## 0, 0 with all of our existing coordinate systems; it's hard to imagine it
## ever being different.

proc origin*(_: typedesc[LPoint3f]): LPoint3f {.importcpp: "LPoint3f::origin()", header: "lpoint3.h".} ## \
## Returns the origin of the indicated coordinate system.  This is always 0,
## 0, 0 with all of our existing coordinate systems; it's hard to imagine it
## ever being different.

proc rfu*(_: typedesc[LPoint3f], right: float32, fwd: float32, up: float32, cs: CoordinateSystem): LPoint3f {.importcpp: "#LPoint3f::rfu(#, #, #, #)", header: "lpoint3.h".} ## \
## Returns a point described by right, forward, up displacements from the
## origin, wherever that maps to in the given coordinate system.

proc rfu*(_: typedesc[LPoint3f], right: float32, fwd: float32, up: float32): LPoint3f {.importcpp: "#LPoint3f::rfu(#, #, #)", header: "lpoint3.h".} ## \
## Returns a point described by right, forward, up displacements from the
## origin, wherever that maps to in the given coordinate system.

converter getClassType*(_: typedesc[LPoint3f]): TypeHandle {.importcpp: "LPoint3f::get_class_type()", header: "lpoint3.h".}

proc initLPoint3d*(): LPoint3d {.importcpp: "LPoint3d()".}

proc initLPoint3d*(param0: LPoint3d): LPoint3d {.importcpp: "LPoint3d(#)".}

proc initLPoint3d*(copy: LVecBase2d, z: float64): LPoint3d {.importcpp: "LPoint3d(#, #)".}

converter initLPoint3d*(copy: LVecBase3d): LPoint3d {.importcpp: "LPoint3d(#)".}

proc initLPoint3d*(fill_value: float64): LPoint3d {.importcpp: "LPoint3d(#)".}

proc initLPoint3d*(x: float64, y: float64, z: float64): LPoint3d {.importcpp: "LPoint3d(#, #, #)".}

proc zero*(_: typedesc[LPoint3d]): LPoint3d {.importcpp: "LPoint3d::zero()", header: "lpoint3.h".} ## \
## Returns a zero-length point.

proc unitX*(_: typedesc[LPoint3d]): LPoint3d {.importcpp: "LPoint3d::unit_x()", header: "lpoint3.h".} ## \
## Returns a unit X point.

proc unitY*(_: typedesc[LPoint3d]): LPoint3d {.importcpp: "LPoint3d::unit_y()", header: "lpoint3.h".} ## \
## Returns a unit Y point.

proc unitZ*(_: typedesc[LPoint3d]): LPoint3d {.importcpp: "LPoint3d::unit_z()", header: "lpoint3.h".} ## \
## Returns a unit Z point.

proc getXy*(this: LPoint3d): LPoint2d {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

proc getXz*(this: LPoint3d): LPoint2d {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

proc getYz*(this: LPoint3d): LPoint2d {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

proc `-`*(this: LPoint3d): LPoint3d {.importcpp: "#.operator -()".}

proc `+`*(this: LPoint3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.operator +(#)".}

proc `+`*(this: LPoint3d, other: LVector3d): LPoint3d {.importcpp: "#.operator +(#)".}

proc `-`*(this: LPoint3d, other: LPoint3d): LVector3d {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint3d, other: LVecBase3d): LVecBase3d {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint3d, other: LVector3d): LPoint3d {.importcpp: "#.operator -(#)".}

proc cross*(this: LPoint3d, other: LVecBase3d): LPoint3d {.importcpp: "#.cross(#)".}

proc normalized*(this: LPoint3d): LPoint3d {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LPoint3d, onto: LVecBase3d): LPoint3d {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc `*`*(this: LPoint3d, scalar: float64): LPoint3d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LPoint3d, scalar: float64): LPoint3d {.importcpp: "#.operator /(#)".}

proc origin*(_: typedesc[LPoint3d], cs: CoordinateSystem): LPoint3d {.importcpp: "#LPoint3d::origin(#)", header: "lpoint3.h".} ## \
## Returns the origin of the indicated coordinate system.  This is always 0,
## 0, 0 with all of our existing coordinate systems; it's hard to imagine it
## ever being different.

proc origin*(_: typedesc[LPoint3d]): LPoint3d {.importcpp: "LPoint3d::origin()", header: "lpoint3.h".} ## \
## Returns the origin of the indicated coordinate system.  This is always 0,
## 0, 0 with all of our existing coordinate systems; it's hard to imagine it
## ever being different.

proc rfu*(_: typedesc[LPoint3d], right: float64, fwd: float64, up: float64, cs: CoordinateSystem): LPoint3d {.importcpp: "#LPoint3d::rfu(#, #, #, #)", header: "lpoint3.h".} ## \
## Returns a point described by right, forward, up displacements from the
## origin, wherever that maps to in the given coordinate system.

proc rfu*(_: typedesc[LPoint3d], right: float64, fwd: float64, up: float64): LPoint3d {.importcpp: "#LPoint3d::rfu(#, #, #)", header: "lpoint3.h".} ## \
## Returns a point described by right, forward, up displacements from the
## origin, wherever that maps to in the given coordinate system.

converter getClassType*(_: typedesc[LPoint3d]): TypeHandle {.importcpp: "LPoint3d::get_class_type()", header: "lpoint3.h".}

proc initLPoint3i*(): LPoint3i {.importcpp: "LPoint3i()".}

proc initLPoint3i*(param0: LPoint3i): LPoint3i {.importcpp: "LPoint3i(#)".}

proc initLPoint3i*(copy: LVecBase2i, z: int): LPoint3i {.importcpp: "LPoint3i(#, #)".}

converter initLPoint3i*(copy: LVecBase3i): LPoint3i {.importcpp: "LPoint3i(#)".}

proc initLPoint3i*(fill_value: int): LPoint3i {.importcpp: "LPoint3i(#)".}

proc initLPoint3i*(x: int, y: int, z: int): LPoint3i {.importcpp: "LPoint3i(#, #, #)".}

proc zero*(_: typedesc[LPoint3i]): LPoint3i {.importcpp: "LPoint3i::zero()", header: "lpoint3.h".} ## \
## Returns a zero-length point.

proc unitX*(_: typedesc[LPoint3i]): LPoint3i {.importcpp: "LPoint3i::unit_x()", header: "lpoint3.h".} ## \
## Returns a unit X point.

proc unitY*(_: typedesc[LPoint3i]): LPoint3i {.importcpp: "LPoint3i::unit_y()", header: "lpoint3.h".} ## \
## Returns a unit Y point.

proc unitZ*(_: typedesc[LPoint3i]): LPoint3i {.importcpp: "LPoint3i::unit_z()", header: "lpoint3.h".} ## \
## Returns a unit Z point.

proc getXy*(this: LPoint3i): LPoint2i {.importcpp: "#.get_xy()".} ## \
## Returns a 2-component vector that shares just the first two components of
## this vector.

proc getXz*(this: LPoint3i): LPoint2i {.importcpp: "#.get_xz()".} ## \
## Returns a 2-component vector that shares just the first and last components
## of this vector.

proc getYz*(this: LPoint3i): LPoint2i {.importcpp: "#.get_yz()".} ## \
## Returns a 2-component vector that shares just the last two components of
## this vector.

proc `-`*(this: LPoint3i): LPoint3i {.importcpp: "#.operator -()".}

proc `+`*(this: LPoint3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.operator +(#)".}

proc `+`*(this: LPoint3i, other: LVector3i): LPoint3i {.importcpp: "#.operator +(#)".}

proc `-`*(this: LPoint3i, other: LPoint3i): LVector3i {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint3i, other: LVecBase3i): LVecBase3i {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint3i, other: LVector3i): LPoint3i {.importcpp: "#.operator -(#)".}

proc cross*(this: LPoint3i, other: LVecBase3i): LPoint3i {.importcpp: "#.cross(#)".}

proc `*`*(this: LPoint3i, scalar: int): LPoint3i {.importcpp: "#.operator *(#)".}

proc `/`*(this: LPoint3i, scalar: int): LPoint3i {.importcpp: "#.operator /(#)".}

proc origin*(_: typedesc[LPoint3i], cs: CoordinateSystem): LPoint3i {.importcpp: "#LPoint3i::origin(#)", header: "lpoint3.h".} ## \
## Returns the origin of the indicated coordinate system.  This is always 0,
## 0, 0 with all of our existing coordinate systems; it's hard to imagine it
## ever being different.

proc origin*(_: typedesc[LPoint3i]): LPoint3i {.importcpp: "LPoint3i::origin()", header: "lpoint3.h".} ## \
## Returns the origin of the indicated coordinate system.  This is always 0,
## 0, 0 with all of our existing coordinate systems; it's hard to imagine it
## ever being different.

proc rfu*(_: typedesc[LPoint3i], right: int, fwd: int, up: int, cs: CoordinateSystem): LPoint3i {.importcpp: "#LPoint3i::rfu(#, #, #, #)", header: "lpoint3.h".} ## \
## Returns a point described by right, forward, up displacements from the
## origin, wherever that maps to in the given coordinate system.

proc rfu*(_: typedesc[LPoint3i], right: int, fwd: int, up: int): LPoint3i {.importcpp: "#LPoint3i::rfu(#, #, #)", header: "lpoint3.h".} ## \
## Returns a point described by right, forward, up displacements from the
## origin, wherever that maps to in the given coordinate system.

converter getClassType*(_: typedesc[LPoint3i]): TypeHandle {.importcpp: "LPoint3i::get_class_type()", header: "lpoint3.h".}

proc zero*(_: typedesc[LVecBase4f]): LVecBase4f {.importcpp: "LVecBase4f::zero()", header: "lvecBase4.h".} ## \
## Returns a zero-length vector.

proc unitX*(_: typedesc[LVecBase4f]): LVecBase4f {.importcpp: "LVecBase4f::unit_x()", header: "lvecBase4.h".} ## \
## Returns a unit X vector.

proc unitY*(_: typedesc[LVecBase4f]): LVecBase4f {.importcpp: "LVecBase4f::unit_y()", header: "lvecBase4.h".} ## \
## Returns a unit Y vector.

proc unitZ*(_: typedesc[LVecBase4f]): LVecBase4f {.importcpp: "LVecBase4f::unit_z()", header: "lvecBase4.h".} ## \
## Returns a unit Z vector.

proc unitW*(_: typedesc[LVecBase4f]): LVecBase4f {.importcpp: "LVecBase4f::unit_w()", header: "lvecBase4.h".} ## \
## Returns a unit W vector.

proc `[]`*(this: LVecBase4f, i: int, assign_val: float32) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[LVecBase4f]): int {.importcpp: "LVecBase4f::size()", header: "lvecBase4.h".}

proc isNan*(this: LVecBase4f): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the vector is not-a-number, false
## otherwise.

proc getCell*(this: LVecBase4f, i: int): float32 {.importcpp: "#.get_cell(#)".}

proc setCell*(this: LVecBase4f, i: int, value: float32) {.importcpp: "#.set_cell(#, #)".}

proc getX*(this: LVecBase4f): float32 {.importcpp: "#.get_x()".}

proc getY*(this: LVecBase4f): float32 {.importcpp: "#.get_y()".}

proc getZ*(this: LVecBase4f): float32 {.importcpp: "#.get_z()".}

proc getW*(this: LVecBase4f): float32 {.importcpp: "#.get_w()".}

proc getXyz*(this: LVecBase4f): LVecBase3f {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

proc getXy*(this: LVecBase4f): LVecBase2f {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

proc setX*(this: LVecBase4f, value: float32) {.importcpp: "#.set_x(#)".}

proc setY*(this: LVecBase4f, value: float32) {.importcpp: "#.set_y(#)".}

proc setZ*(this: LVecBase4f, value: float32) {.importcpp: "#.set_z(#)".}

proc setW*(this: LVecBase4f, value: float32) {.importcpp: "#.set_w(#)".}

proc addToCell*(this: LVecBase4f, i: int, value: float32) {.importcpp: "#.add_to_cell(#, #)".} ## \
## These next functions add to an existing value.  i.e.
## foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
## scripting languages:

proc addX*(this: LVecBase4f, value: float32) {.importcpp: "#.add_x(#)".}

proc addY*(this: LVecBase4f, value: float32) {.importcpp: "#.add_y(#)".}

proc addZ*(this: LVecBase4f, value: float32) {.importcpp: "#.add_z(#)".}

proc addW*(this: LVecBase4f, value: float32) {.importcpp: "#.add_w(#)".}

proc getData*(this: LVecBase4f) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the four data elements in the vector.
## The remaining elements occupy the next positions consecutively in memory.

proc getNumComponents*(_: typedesc[LVecBase4f]): int {.importcpp: "LVecBase4f::get_num_components()", header: "lvecBase4.h".}

proc fill*(this: LVecBase4f, fill_value: float32) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: LVecBase4f, x: float32, y: float32, z: float32, w: float32) {.importcpp: "#.set(#, #, #, #)".}

proc dot*(this: LVecBase4f, other: LVecBase4f): float32 {.importcpp: "#.dot(#)".}

proc lengthSquared*(this: LVecBase4f): float32 {.importcpp: "#.length_squared()".} ## \
## Returns the square of the vector's length, cheap and easy.

proc length*(this: LVecBase4f): float32 {.importcpp: "#.length()".} ## \
## Returns the length of the vector, by the Pythagorean theorem.

proc normalize*(this: LVecBase4f): bool {.importcpp: "#.normalize()".} ## \
## Normalizes the vector in place.  Returns true if the vector was normalized,
## false if it was a zero-length vector.

proc normalized*(this: LVecBase4f): LVecBase4f {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVecBase4f, onto: LVecBase4f): LVecBase4f {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc `<`*(this: LVecBase4f, other: LVecBase4f): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LVecBase4f, other: LVecBase4f): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LVecBase4f, other: LVecBase4f): bool {.importcpp: "#.operator !=(#)".}

proc compareTo*(this: LVecBase4f, other: LVecBase4f): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc compareTo*(this: LVecBase4f, other: LVecBase4f, threshold: float32): int {.importcpp: "#.compare_to(#, #)".} ## \
## Sorts vectors lexicographically, componentwise.  Returns a number less than
## 0 if this vector sorts before the other one, greater than zero if it sorts
## after, 0 if they are equivalent (within the indicated tolerance).

proc getHash*(this: LVecBase4f): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc getHash*(this: LVecBase4f, threshold: float32): clonglong {.importcpp: "#.get_hash(#)".} ## \
## Returns a suitable hash for phash_map.

proc addHash*(this: LVecBase4f, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc addHash*(this: LVecBase4f, hash: clonglong, threshold: float32): clonglong {.importcpp: "#.add_hash(#, #)".} ## \
## Adds the vector into the running hash.

proc `-`*(this: LVecBase4f): LVecBase4f {.importcpp: "#.operator -()".}

proc `+`*(this: LVecBase4f, other: LVecBase4f): LVecBase4f {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVecBase4f, other: LVecBase4f): LVecBase4f {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVecBase4f, scalar: float32): LVecBase4f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVecBase4f, scalar: float32): LVecBase4f {.importcpp: "#.operator /(#)".}

proc `+=`*(this: var LVecBase4f, other: LVecBase4f): LVecBase4f {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: var LVecBase4f, other: LVecBase4f): LVecBase4f {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: var LVecBase4f, scalar: float32): LVecBase4f {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: var LVecBase4f, scalar: float32): LVecBase4f {.importcpp: "#.operator /=(#)".}

proc componentwiseMult*(this: LVecBase4f, other: LVecBase4f) {.importcpp: "#.componentwise_mult(#)".}

proc fmax*(this: LVecBase4f, other: LVecBase4f): LVecBase4f {.importcpp: "#.fmax(#)".}

proc fmin*(this: LVecBase4f, other: LVecBase4f): LVecBase4f {.importcpp: "#.fmin(#)".}

proc almostEqual*(this: LVecBase4f, other: LVecBase4f): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two vectors are memberwise equal within a default tolerance
## based on the numeric type.

proc almostEqual*(this: LVecBase4f, other: LVecBase4f, threshold: float32): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two vectors are memberwise equal within a specified
## tolerance.

proc output*(this: LVecBase4f, `out`: ostream) {.importcpp: "#.output(#)".}

proc writeDatagramFixed*(this: LVecBase4f, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the vector to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the vector, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc readDatagramFixed*(this: LVecBase4f, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the vector from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc writeDatagram*(this: LVecBase4f, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the vector to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc readDatagram*(this: LVecBase4f, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the vector from the Datagram using get_stdfloat().

converter getClassType*(_: typedesc[LVecBase4f]): TypeHandle {.importcpp: "LVecBase4f::get_class_type()", header: "lvecBase4.h".}

proc fill*(this: UnalignedLVecBase4f, fill_value: float32) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: UnalignedLVecBase4f, x: float32, y: float32, z: float32, w: float32) {.importcpp: "#.set(#, #, #, #)".}

proc `[]`*(this: UnalignedLVecBase4f, i: int, assign_val: float32) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[UnalignedLVecBase4f]): int {.importcpp: "UnalignedLVecBase4f::size()", header: "lvecBase4.h".}

proc getData*(this: UnalignedLVecBase4f) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the three data elements in the vector.
## The remaining elements occupy the next positions consecutively in memory.

proc getNumComponents*(_: typedesc[UnalignedLVecBase4f]): int {.importcpp: "UnalignedLVecBase4f::get_num_components()", header: "lvecBase4.h".}

proc `==`*(this: UnalignedLVecBase4f, other: UnalignedLVecBase4f): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: UnalignedLVecBase4f, other: UnalignedLVecBase4f): bool {.importcpp: "#.operator !=(#)".}

converter getClassType*(_: typedesc[UnalignedLVecBase4f]): TypeHandle {.importcpp: "UnalignedLVecBase4f::get_class_type()", header: "lvecBase4.h".}

proc zero*(_: typedesc[LVecBase4d]): LVecBase4d {.importcpp: "LVecBase4d::zero()", header: "lvecBase4.h".} ## \
## Returns a zero-length vector.

proc unitX*(_: typedesc[LVecBase4d]): LVecBase4d {.importcpp: "LVecBase4d::unit_x()", header: "lvecBase4.h".} ## \
## Returns a unit X vector.

proc unitY*(_: typedesc[LVecBase4d]): LVecBase4d {.importcpp: "LVecBase4d::unit_y()", header: "lvecBase4.h".} ## \
## Returns a unit Y vector.

proc unitZ*(_: typedesc[LVecBase4d]): LVecBase4d {.importcpp: "LVecBase4d::unit_z()", header: "lvecBase4.h".} ## \
## Returns a unit Z vector.

proc unitW*(_: typedesc[LVecBase4d]): LVecBase4d {.importcpp: "LVecBase4d::unit_w()", header: "lvecBase4.h".} ## \
## Returns a unit W vector.

proc `[]`*(this: LVecBase4d, i: int, assign_val: float64) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[LVecBase4d]): int {.importcpp: "LVecBase4d::size()", header: "lvecBase4.h".}

proc isNan*(this: LVecBase4d): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the vector is not-a-number, false
## otherwise.

proc getCell*(this: LVecBase4d, i: int): float64 {.importcpp: "#.get_cell(#)".}

proc setCell*(this: LVecBase4d, i: int, value: float64) {.importcpp: "#.set_cell(#, #)".}

proc getX*(this: LVecBase4d): float64 {.importcpp: "#.get_x()".}

proc getY*(this: LVecBase4d): float64 {.importcpp: "#.get_y()".}

proc getZ*(this: LVecBase4d): float64 {.importcpp: "#.get_z()".}

proc getW*(this: LVecBase4d): float64 {.importcpp: "#.get_w()".}

proc getXyz*(this: LVecBase4d): LVecBase3d {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

proc getXy*(this: LVecBase4d): LVecBase2d {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

proc setX*(this: LVecBase4d, value: float64) {.importcpp: "#.set_x(#)".}

proc setY*(this: LVecBase4d, value: float64) {.importcpp: "#.set_y(#)".}

proc setZ*(this: LVecBase4d, value: float64) {.importcpp: "#.set_z(#)".}

proc setW*(this: LVecBase4d, value: float64) {.importcpp: "#.set_w(#)".}

proc addToCell*(this: LVecBase4d, i: int, value: float64) {.importcpp: "#.add_to_cell(#, #)".} ## \
## These next functions add to an existing value.  i.e.
## foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
## scripting languages:

proc addX*(this: LVecBase4d, value: float64) {.importcpp: "#.add_x(#)".}

proc addY*(this: LVecBase4d, value: float64) {.importcpp: "#.add_y(#)".}

proc addZ*(this: LVecBase4d, value: float64) {.importcpp: "#.add_z(#)".}

proc addW*(this: LVecBase4d, value: float64) {.importcpp: "#.add_w(#)".}

proc getData*(this: LVecBase4d) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the four data elements in the vector.
## The remaining elements occupy the next positions consecutively in memory.

proc getNumComponents*(_: typedesc[LVecBase4d]): int {.importcpp: "LVecBase4d::get_num_components()", header: "lvecBase4.h".}

proc fill*(this: LVecBase4d, fill_value: float64) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: LVecBase4d, x: float64, y: float64, z: float64, w: float64) {.importcpp: "#.set(#, #, #, #)".}

proc dot*(this: LVecBase4d, other: LVecBase4d): float64 {.importcpp: "#.dot(#)".}

proc lengthSquared*(this: LVecBase4d): float64 {.importcpp: "#.length_squared()".} ## \
## Returns the square of the vector's length, cheap and easy.

proc length*(this: LVecBase4d): float64 {.importcpp: "#.length()".} ## \
## Returns the length of the vector, by the Pythagorean theorem.

proc normalize*(this: LVecBase4d): bool {.importcpp: "#.normalize()".} ## \
## Normalizes the vector in place.  Returns true if the vector was normalized,
## false if it was a zero-length vector.

proc normalized*(this: LVecBase4d): LVecBase4d {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVecBase4d, onto: LVecBase4d): LVecBase4d {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

proc `<`*(this: LVecBase4d, other: LVecBase4d): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LVecBase4d, other: LVecBase4d): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LVecBase4d, other: LVecBase4d): bool {.importcpp: "#.operator !=(#)".}

proc compareTo*(this: LVecBase4d, other: LVecBase4d): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc compareTo*(this: LVecBase4d, other: LVecBase4d, threshold: float64): int {.importcpp: "#.compare_to(#, #)".} ## \
## Sorts vectors lexicographically, componentwise.  Returns a number less than
## 0 if this vector sorts before the other one, greater than zero if it sorts
## after, 0 if they are equivalent (within the indicated tolerance).

proc getHash*(this: LVecBase4d): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc getHash*(this: LVecBase4d, threshold: float64): clonglong {.importcpp: "#.get_hash(#)".} ## \
## Returns a suitable hash for phash_map.

proc addHash*(this: LVecBase4d, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc addHash*(this: LVecBase4d, hash: clonglong, threshold: float64): clonglong {.importcpp: "#.add_hash(#, #)".} ## \
## Adds the vector into the running hash.

proc `-`*(this: LVecBase4d): LVecBase4d {.importcpp: "#.operator -()".}

proc `+`*(this: LVecBase4d, other: LVecBase4d): LVecBase4d {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVecBase4d, other: LVecBase4d): LVecBase4d {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVecBase4d, scalar: float64): LVecBase4d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVecBase4d, scalar: float64): LVecBase4d {.importcpp: "#.operator /(#)".}

proc `+=`*(this: var LVecBase4d, other: LVecBase4d): LVecBase4d {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: var LVecBase4d, other: LVecBase4d): LVecBase4d {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: var LVecBase4d, scalar: float64): LVecBase4d {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: var LVecBase4d, scalar: float64): LVecBase4d {.importcpp: "#.operator /=(#)".}

proc componentwiseMult*(this: LVecBase4d, other: LVecBase4d) {.importcpp: "#.componentwise_mult(#)".}

proc fmax*(this: LVecBase4d, other: LVecBase4d): LVecBase4d {.importcpp: "#.fmax(#)".}

proc fmin*(this: LVecBase4d, other: LVecBase4d): LVecBase4d {.importcpp: "#.fmin(#)".}

proc almostEqual*(this: LVecBase4d, other: LVecBase4d): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two vectors are memberwise equal within a default tolerance
## based on the numeric type.

proc almostEqual*(this: LVecBase4d, other: LVecBase4d, threshold: float64): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two vectors are memberwise equal within a specified
## tolerance.

proc output*(this: LVecBase4d, `out`: ostream) {.importcpp: "#.output(#)".}

proc writeDatagramFixed*(this: LVecBase4d, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the vector to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the vector, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc readDatagramFixed*(this: LVecBase4d, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the vector from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc writeDatagram*(this: LVecBase4d, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the vector to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc readDatagram*(this: LVecBase4d, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the vector from the Datagram using get_stdfloat().

converter getClassType*(_: typedesc[LVecBase4d]): TypeHandle {.importcpp: "LVecBase4d::get_class_type()", header: "lvecBase4.h".}

proc fill*(this: UnalignedLVecBase4d, fill_value: float64) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: UnalignedLVecBase4d, x: float64, y: float64, z: float64, w: float64) {.importcpp: "#.set(#, #, #, #)".}

proc `[]`*(this: UnalignedLVecBase4d, i: int, assign_val: float64) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[UnalignedLVecBase4d]): int {.importcpp: "UnalignedLVecBase4d::size()", header: "lvecBase4.h".}

proc getData*(this: UnalignedLVecBase4d) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the three data elements in the vector.
## The remaining elements occupy the next positions consecutively in memory.

proc getNumComponents*(_: typedesc[UnalignedLVecBase4d]): int {.importcpp: "UnalignedLVecBase4d::get_num_components()", header: "lvecBase4.h".}

proc `==`*(this: UnalignedLVecBase4d, other: UnalignedLVecBase4d): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: UnalignedLVecBase4d, other: UnalignedLVecBase4d): bool {.importcpp: "#.operator !=(#)".}

converter getClassType*(_: typedesc[UnalignedLVecBase4d]): TypeHandle {.importcpp: "UnalignedLVecBase4d::get_class_type()", header: "lvecBase4.h".}

proc zero*(_: typedesc[LVecBase4i]): LVecBase4i {.importcpp: "LVecBase4i::zero()", header: "lvecBase4.h".} ## \
## Returns a zero-length vector.

proc unitX*(_: typedesc[LVecBase4i]): LVecBase4i {.importcpp: "LVecBase4i::unit_x()", header: "lvecBase4.h".} ## \
## Returns a unit X vector.

proc unitY*(_: typedesc[LVecBase4i]): LVecBase4i {.importcpp: "LVecBase4i::unit_y()", header: "lvecBase4.h".} ## \
## Returns a unit Y vector.

proc unitZ*(_: typedesc[LVecBase4i]): LVecBase4i {.importcpp: "LVecBase4i::unit_z()", header: "lvecBase4.h".} ## \
## Returns a unit Z vector.

proc unitW*(_: typedesc[LVecBase4i]): LVecBase4i {.importcpp: "LVecBase4i::unit_w()", header: "lvecBase4.h".} ## \
## Returns a unit W vector.

proc `[]`*(this: LVecBase4i, i: int, assign_val: int) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[LVecBase4i]): int {.importcpp: "LVecBase4i::size()", header: "lvecBase4.h".}

proc isNan*(this: LVecBase4i): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the vector is not-a-number, false
## otherwise.

proc getCell*(this: LVecBase4i, i: int): int {.importcpp: "#.get_cell(#)".}

proc setCell*(this: LVecBase4i, i: int, value: int) {.importcpp: "#.set_cell(#, #)".}

proc getX*(this: LVecBase4i): int {.importcpp: "#.get_x()".}

proc getY*(this: LVecBase4i): int {.importcpp: "#.get_y()".}

proc getZ*(this: LVecBase4i): int {.importcpp: "#.get_z()".}

proc getW*(this: LVecBase4i): int {.importcpp: "#.get_w()".}

proc getXyz*(this: LVecBase4i): LVecBase3i {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

proc getXy*(this: LVecBase4i): LVecBase2i {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

proc setX*(this: LVecBase4i, value: int) {.importcpp: "#.set_x(#)".}

proc setY*(this: LVecBase4i, value: int) {.importcpp: "#.set_y(#)".}

proc setZ*(this: LVecBase4i, value: int) {.importcpp: "#.set_z(#)".}

proc setW*(this: LVecBase4i, value: int) {.importcpp: "#.set_w(#)".}

proc addToCell*(this: LVecBase4i, i: int, value: int) {.importcpp: "#.add_to_cell(#, #)".} ## \
## These next functions add to an existing value.  i.e.
## foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
## scripting languages:

proc addX*(this: LVecBase4i, value: int) {.importcpp: "#.add_x(#)".}

proc addY*(this: LVecBase4i, value: int) {.importcpp: "#.add_y(#)".}

proc addZ*(this: LVecBase4i, value: int) {.importcpp: "#.add_z(#)".}

proc addW*(this: LVecBase4i, value: int) {.importcpp: "#.add_w(#)".}

proc getData*(this: LVecBase4i) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the four data elements in the vector.
## The remaining elements occupy the next positions consecutively in memory.

proc getNumComponents*(_: typedesc[LVecBase4i]): int {.importcpp: "LVecBase4i::get_num_components()", header: "lvecBase4.h".}

proc fill*(this: LVecBase4i, fill_value: int) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: LVecBase4i, x: int, y: int, z: int, w: int) {.importcpp: "#.set(#, #, #, #)".}

proc dot*(this: LVecBase4i, other: LVecBase4i): int {.importcpp: "#.dot(#)".}

proc lengthSquared*(this: LVecBase4i): int {.importcpp: "#.length_squared()".} ## \
## Returns the square of the vector's length, cheap and easy.

proc `<`*(this: LVecBase4i, other: LVecBase4i): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LVecBase4i, other: LVecBase4i): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LVecBase4i, other: LVecBase4i): bool {.importcpp: "#.operator !=(#)".}

proc compareTo*(this: LVecBase4i, other: LVecBase4i): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc getHash*(this: LVecBase4i): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc addHash*(this: LVecBase4i, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc `-`*(this: LVecBase4i): LVecBase4i {.importcpp: "#.operator -()".}

proc `+`*(this: LVecBase4i, other: LVecBase4i): LVecBase4i {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVecBase4i, other: LVecBase4i): LVecBase4i {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVecBase4i, scalar: int): LVecBase4i {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVecBase4i, scalar: int): LVecBase4i {.importcpp: "#.operator /(#)".}

proc `+=`*(this: var LVecBase4i, other: LVecBase4i): LVecBase4i {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: var LVecBase4i, other: LVecBase4i): LVecBase4i {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: var LVecBase4i, scalar: int): LVecBase4i {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: var LVecBase4i, scalar: int): LVecBase4i {.importcpp: "#.operator /=(#)".}

proc componentwiseMult*(this: LVecBase4i, other: LVecBase4i) {.importcpp: "#.componentwise_mult(#)".}

proc fmax*(this: LVecBase4i, other: LVecBase4i): LVecBase4i {.importcpp: "#.fmax(#)".}

proc fmin*(this: LVecBase4i, other: LVecBase4i): LVecBase4i {.importcpp: "#.fmin(#)".}

proc almostEqual*(this: LVecBase4i, other: LVecBase4i): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two vectors are memberwise equal within a default tolerance
## based on the numeric type.

proc almostEqual*(this: LVecBase4i, other: LVecBase4i, threshold: int): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two vectors are memberwise equal within a specified
## tolerance.

proc output*(this: LVecBase4i, `out`: ostream) {.importcpp: "#.output(#)".}

proc writeDatagramFixed*(this: LVecBase4i, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the vector to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the vector, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc readDatagramFixed*(this: LVecBase4i, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the vector from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc writeDatagram*(this: LVecBase4i, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the vector to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc readDatagram*(this: LVecBase4i, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the vector from the Datagram using get_stdfloat().

converter getClassType*(_: typedesc[LVecBase4i]): TypeHandle {.importcpp: "LVecBase4i::get_class_type()", header: "lvecBase4.h".}

proc fill*(this: UnalignedLVecBase4i, fill_value: int) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the vector to the indicated fill_value.  This is
## particularly useful for initializing to zero.

proc set*(this: UnalignedLVecBase4i, x: int, y: int, z: int, w: int) {.importcpp: "#.set(#, #, #, #)".}

proc `[]`*(this: UnalignedLVecBase4i, i: int, assign_val: int) {.importcpp: "#.operator [](#, #)".}

proc size*(_: typedesc[UnalignedLVecBase4i]): int {.importcpp: "UnalignedLVecBase4i::size()", header: "lvecBase4.h".}

proc getData*(this: UnalignedLVecBase4i) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the three data elements in the vector.
## The remaining elements occupy the next positions consecutively in memory.

proc getNumComponents*(_: typedesc[UnalignedLVecBase4i]): int {.importcpp: "UnalignedLVecBase4i::get_num_components()", header: "lvecBase4.h".}

proc `==`*(this: UnalignedLVecBase4i, other: UnalignedLVecBase4i): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: UnalignedLVecBase4i, other: UnalignedLVecBase4i): bool {.importcpp: "#.operator !=(#)".}

converter getClassType*(_: typedesc[UnalignedLVecBase4i]): TypeHandle {.importcpp: "UnalignedLVecBase4i::get_class_type()", header: "lvecBase4.h".}

proc initLVector4f*(): LVector4f {.importcpp: "LVector4f()".}

proc initLVector4f*(copy: LVecBase3f, w: float32): LVector4f {.importcpp: "LVector4f(#, #)".}

converter initLVector4f*(copy: LVecBase4f): LVector4f {.importcpp: "LVector4f(#)".}

proc initLVector4f*(param0: LVector4f): LVector4f {.importcpp: "LVector4f(#)".}

proc initLVector4f*(fill_value: float32): LVector4f {.importcpp: "LVector4f(#)".}

proc initLVector4f*(x: float32, y: float32, z: float32, w: float32): LVector4f {.importcpp: "LVector4f(#, #, #, #)".}

proc zero*(_: typedesc[LVector4f]): LVector4f {.importcpp: "LVector4f::zero()", header: "lvector4.h".} ## \
## Returns a zero-length vector.

proc unitX*(_: typedesc[LVector4f]): LVector4f {.importcpp: "LVector4f::unit_x()", header: "lvector4.h".} ## \
## Returns a unit X vector.

proc unitY*(_: typedesc[LVector4f]): LVector4f {.importcpp: "LVector4f::unit_y()", header: "lvector4.h".} ## \
## Returns a unit Y vector.

proc unitZ*(_: typedesc[LVector4f]): LVector4f {.importcpp: "LVector4f::unit_z()", header: "lvector4.h".} ## \
## Returns a unit Z vector.

proc unitW*(_: typedesc[LVector4f]): LVector4f {.importcpp: "LVector4f::unit_w()", header: "lvector4.h".} ## \
## Returns a unit W vector.

proc getXyz*(this: LVector4f): LVector3f {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

proc getXy*(this: LVector4f): LVector2f {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

proc `-`*(this: LVector4f): LVector4f {.importcpp: "#.operator -()".}

proc `+`*(this: LVector4f, other: LVecBase4f): LVecBase4f {.importcpp: "#.operator +(#)".}

proc `+`*(this: LVector4f, other: LVector4f): LVector4f {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVector4f, other: LVecBase4f): LVecBase4f {.importcpp: "#.operator -(#)".}

proc `-`*(this: LVector4f, other: LVector4f): LVector4f {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVector4f, scalar: float32): LVector4f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVector4f, scalar: float32): LVector4f {.importcpp: "#.operator /(#)".}

proc normalized*(this: LVector4f): LVector4f {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVector4f, onto: LVecBase4f): LVector4f {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

converter getClassType*(_: typedesc[LVector4f]): TypeHandle {.importcpp: "LVector4f::get_class_type()", header: "lvector4.h".}

proc initLVector4d*(): LVector4d {.importcpp: "LVector4d()".}

proc initLVector4d*(copy: LVecBase3d, w: float64): LVector4d {.importcpp: "LVector4d(#, #)".}

converter initLVector4d*(copy: LVecBase4d): LVector4d {.importcpp: "LVector4d(#)".}

proc initLVector4d*(param0: LVector4d): LVector4d {.importcpp: "LVector4d(#)".}

proc initLVector4d*(fill_value: float64): LVector4d {.importcpp: "LVector4d(#)".}

proc initLVector4d*(x: float64, y: float64, z: float64, w: float64): LVector4d {.importcpp: "LVector4d(#, #, #, #)".}

proc zero*(_: typedesc[LVector4d]): LVector4d {.importcpp: "LVector4d::zero()", header: "lvector4.h".} ## \
## Returns a zero-length vector.

proc unitX*(_: typedesc[LVector4d]): LVector4d {.importcpp: "LVector4d::unit_x()", header: "lvector4.h".} ## \
## Returns a unit X vector.

proc unitY*(_: typedesc[LVector4d]): LVector4d {.importcpp: "LVector4d::unit_y()", header: "lvector4.h".} ## \
## Returns a unit Y vector.

proc unitZ*(_: typedesc[LVector4d]): LVector4d {.importcpp: "LVector4d::unit_z()", header: "lvector4.h".} ## \
## Returns a unit Z vector.

proc unitW*(_: typedesc[LVector4d]): LVector4d {.importcpp: "LVector4d::unit_w()", header: "lvector4.h".} ## \
## Returns a unit W vector.

proc getXyz*(this: LVector4d): LVector3d {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

proc getXy*(this: LVector4d): LVector2d {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

proc `-`*(this: LVector4d): LVector4d {.importcpp: "#.operator -()".}

proc `+`*(this: LVector4d, other: LVecBase4d): LVecBase4d {.importcpp: "#.operator +(#)".}

proc `+`*(this: LVector4d, other: LVector4d): LVector4d {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVector4d, other: LVecBase4d): LVecBase4d {.importcpp: "#.operator -(#)".}

proc `-`*(this: LVector4d, other: LVector4d): LVector4d {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVector4d, scalar: float64): LVector4d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVector4d, scalar: float64): LVector4d {.importcpp: "#.operator /(#)".}

proc normalized*(this: LVector4d): LVector4d {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LVector4d, onto: LVecBase4d): LVector4d {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

converter getClassType*(_: typedesc[LVector4d]): TypeHandle {.importcpp: "LVector4d::get_class_type()", header: "lvector4.h".}

proc initLVector4i*(): LVector4i {.importcpp: "LVector4i()".}

proc initLVector4i*(copy: LVecBase3i, w: int): LVector4i {.importcpp: "LVector4i(#, #)".}

converter initLVector4i*(copy: LVecBase4i): LVector4i {.importcpp: "LVector4i(#)".}

proc initLVector4i*(param0: LVector4i): LVector4i {.importcpp: "LVector4i(#)".}

proc initLVector4i*(fill_value: int): LVector4i {.importcpp: "LVector4i(#)".}

proc initLVector4i*(x: int, y: int, z: int, w: int): LVector4i {.importcpp: "LVector4i(#, #, #, #)".}

proc zero*(_: typedesc[LVector4i]): LVector4i {.importcpp: "LVector4i::zero()", header: "lvector4.h".} ## \
## Returns a zero-length vector.

proc unitX*(_: typedesc[LVector4i]): LVector4i {.importcpp: "LVector4i::unit_x()", header: "lvector4.h".} ## \
## Returns a unit X vector.

proc unitY*(_: typedesc[LVector4i]): LVector4i {.importcpp: "LVector4i::unit_y()", header: "lvector4.h".} ## \
## Returns a unit Y vector.

proc unitZ*(_: typedesc[LVector4i]): LVector4i {.importcpp: "LVector4i::unit_z()", header: "lvector4.h".} ## \
## Returns a unit Z vector.

proc unitW*(_: typedesc[LVector4i]): LVector4i {.importcpp: "LVector4i::unit_w()", header: "lvector4.h".} ## \
## Returns a unit W vector.

proc getXyz*(this: LVector4i): LVector3i {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

proc getXy*(this: LVector4i): LVector2i {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

proc `-`*(this: LVector4i): LVector4i {.importcpp: "#.operator -()".}

proc `+`*(this: LVector4i, other: LVecBase4i): LVecBase4i {.importcpp: "#.operator +(#)".}

proc `+`*(this: LVector4i, other: LVector4i): LVector4i {.importcpp: "#.operator +(#)".}

proc `-`*(this: LVector4i, other: LVecBase4i): LVecBase4i {.importcpp: "#.operator -(#)".}

proc `-`*(this: LVector4i, other: LVector4i): LVector4i {.importcpp: "#.operator -(#)".}

proc `*`*(this: LVector4i, scalar: int): LVector4i {.importcpp: "#.operator *(#)".}

proc `/`*(this: LVector4i, scalar: int): LVector4i {.importcpp: "#.operator /(#)".}

converter getClassType*(_: typedesc[LVector4i]): TypeHandle {.importcpp: "LVector4i::get_class_type()", header: "lvector4.h".}

proc initLPoint4f*(): LPoint4f {.importcpp: "LPoint4f()".}

proc initLPoint4f*(param0: LPoint4f): LPoint4f {.importcpp: "LPoint4f(#)".}

proc initLPoint4f*(copy: LVecBase3f, w: float32): LPoint4f {.importcpp: "LPoint4f(#, #)".}

converter initLPoint4f*(copy: LVecBase4f): LPoint4f {.importcpp: "LPoint4f(#)".}

proc initLPoint4f*(fill_value: float32): LPoint4f {.importcpp: "LPoint4f(#)".}

proc initLPoint4f*(x: float32, y: float32, z: float32, w: float32): LPoint4f {.importcpp: "LPoint4f(#, #, #, #)".}

proc zero*(_: typedesc[LPoint4f]): LPoint4f {.importcpp: "LPoint4f::zero()", header: "lpoint4.h".} ## \
## Returns a zero-length point.

proc unitX*(_: typedesc[LPoint4f]): LPoint4f {.importcpp: "LPoint4f::unit_x()", header: "lpoint4.h".} ## \
## Returns a unit X point.

proc unitY*(_: typedesc[LPoint4f]): LPoint4f {.importcpp: "LPoint4f::unit_y()", header: "lpoint4.h".} ## \
## Returns a unit Y point.

proc unitZ*(_: typedesc[LPoint4f]): LPoint4f {.importcpp: "LPoint4f::unit_z()", header: "lpoint4.h".} ## \
## Returns a unit Z point.

proc unitW*(_: typedesc[LPoint4f]): LPoint4f {.importcpp: "LPoint4f::unit_w()", header: "lpoint4.h".} ## \
## Returns a unit W point.

proc getXyz*(this: LPoint4f): LPoint3f {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

proc getXy*(this: LPoint4f): LPoint2f {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

proc `-`*(this: LPoint4f): LPoint4f {.importcpp: "#.operator -()".}

proc `+`*(this: LPoint4f, other: LVecBase4f): LVecBase4f {.importcpp: "#.operator +(#)".}

proc `+`*(this: LPoint4f, other: LVector4f): LPoint4f {.importcpp: "#.operator +(#)".}

proc `-`*(this: LPoint4f, other: LPoint4f): LVector4f {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint4f, other: LVecBase4f): LVecBase4f {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint4f, other: LVector4f): LPoint4f {.importcpp: "#.operator -(#)".}

proc `*`*(this: LPoint4f, scalar: float32): LPoint4f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LPoint4f, scalar: float32): LPoint4f {.importcpp: "#.operator /(#)".}

proc normalized*(this: LPoint4f): LPoint4f {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LPoint4f, onto: LVecBase4f): LPoint4f {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

converter getClassType*(_: typedesc[LPoint4f]): TypeHandle {.importcpp: "LPoint4f::get_class_type()", header: "lpoint4.h".}

proc initLPoint4d*(): LPoint4d {.importcpp: "LPoint4d()".}

proc initLPoint4d*(param0: LPoint4d): LPoint4d {.importcpp: "LPoint4d(#)".}

proc initLPoint4d*(copy: LVecBase3d, w: float64): LPoint4d {.importcpp: "LPoint4d(#, #)".}

converter initLPoint4d*(copy: LVecBase4d): LPoint4d {.importcpp: "LPoint4d(#)".}

proc initLPoint4d*(fill_value: float64): LPoint4d {.importcpp: "LPoint4d(#)".}

proc initLPoint4d*(x: float64, y: float64, z: float64, w: float64): LPoint4d {.importcpp: "LPoint4d(#, #, #, #)".}

proc zero*(_: typedesc[LPoint4d]): LPoint4d {.importcpp: "LPoint4d::zero()", header: "lpoint4.h".} ## \
## Returns a zero-length point.

proc unitX*(_: typedesc[LPoint4d]): LPoint4d {.importcpp: "LPoint4d::unit_x()", header: "lpoint4.h".} ## \
## Returns a unit X point.

proc unitY*(_: typedesc[LPoint4d]): LPoint4d {.importcpp: "LPoint4d::unit_y()", header: "lpoint4.h".} ## \
## Returns a unit Y point.

proc unitZ*(_: typedesc[LPoint4d]): LPoint4d {.importcpp: "LPoint4d::unit_z()", header: "lpoint4.h".} ## \
## Returns a unit Z point.

proc unitW*(_: typedesc[LPoint4d]): LPoint4d {.importcpp: "LPoint4d::unit_w()", header: "lpoint4.h".} ## \
## Returns a unit W point.

proc getXyz*(this: LPoint4d): LPoint3d {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

proc getXy*(this: LPoint4d): LPoint2d {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

proc `-`*(this: LPoint4d): LPoint4d {.importcpp: "#.operator -()".}

proc `+`*(this: LPoint4d, other: LVecBase4d): LVecBase4d {.importcpp: "#.operator +(#)".}

proc `+`*(this: LPoint4d, other: LVector4d): LPoint4d {.importcpp: "#.operator +(#)".}

proc `-`*(this: LPoint4d, other: LPoint4d): LVector4d {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint4d, other: LVecBase4d): LVecBase4d {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint4d, other: LVector4d): LPoint4d {.importcpp: "#.operator -(#)".}

proc `*`*(this: LPoint4d, scalar: float64): LPoint4d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LPoint4d, scalar: float64): LPoint4d {.importcpp: "#.operator /(#)".}

proc normalized*(this: LPoint4d): LPoint4d {.importcpp: "#.normalized()".} ## \
## Normalizes the vector and returns the normalized vector as a copy.  If the
## vector was a zero-length vector, a zero length vector will be returned.

proc project*(this: LPoint4d, onto: LVecBase4d): LPoint4d {.importcpp: "#.project(#)".} ## \
## Returns a new vector representing the projection of this vector onto
## another one.  The resulting vector will be a scalar multiple of onto.

converter getClassType*(_: typedesc[LPoint4d]): TypeHandle {.importcpp: "LPoint4d::get_class_type()", header: "lpoint4.h".}

proc initLPoint4i*(): LPoint4i {.importcpp: "LPoint4i()".}

proc initLPoint4i*(param0: LPoint4i): LPoint4i {.importcpp: "LPoint4i(#)".}

proc initLPoint4i*(copy: LVecBase3i, w: int): LPoint4i {.importcpp: "LPoint4i(#, #)".}

converter initLPoint4i*(copy: LVecBase4i): LPoint4i {.importcpp: "LPoint4i(#)".}

proc initLPoint4i*(fill_value: int): LPoint4i {.importcpp: "LPoint4i(#)".}

proc initLPoint4i*(x: int, y: int, z: int, w: int): LPoint4i {.importcpp: "LPoint4i(#, #, #, #)".}

proc zero*(_: typedesc[LPoint4i]): LPoint4i {.importcpp: "LPoint4i::zero()", header: "lpoint4.h".} ## \
## Returns a zero-length point.

proc unitX*(_: typedesc[LPoint4i]): LPoint4i {.importcpp: "LPoint4i::unit_x()", header: "lpoint4.h".} ## \
## Returns a unit X point.

proc unitY*(_: typedesc[LPoint4i]): LPoint4i {.importcpp: "LPoint4i::unit_y()", header: "lpoint4.h".} ## \
## Returns a unit Y point.

proc unitZ*(_: typedesc[LPoint4i]): LPoint4i {.importcpp: "LPoint4i::unit_z()", header: "lpoint4.h".} ## \
## Returns a unit Z point.

proc unitW*(_: typedesc[LPoint4i]): LPoint4i {.importcpp: "LPoint4i::unit_w()", header: "lpoint4.h".} ## \
## Returns a unit W point.

proc getXyz*(this: LPoint4i): LPoint3i {.importcpp: "#.get_xyz()".} ## \
## Returns the x, y and z component of this vector

proc getXy*(this: LPoint4i): LPoint2i {.importcpp: "#.get_xy()".} ## \
## Returns the x and y component of this vector

proc `-`*(this: LPoint4i): LPoint4i {.importcpp: "#.operator -()".}

proc `+`*(this: LPoint4i, other: LVecBase4i): LVecBase4i {.importcpp: "#.operator +(#)".}

proc `+`*(this: LPoint4i, other: LVector4i): LPoint4i {.importcpp: "#.operator +(#)".}

proc `-`*(this: LPoint4i, other: LPoint4i): LVector4i {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint4i, other: LVecBase4i): LVecBase4i {.importcpp: "#.operator -(#)".}

proc `-`*(this: LPoint4i, other: LVector4i): LPoint4i {.importcpp: "#.operator -(#)".}

proc `*`*(this: LPoint4i, scalar: int): LPoint4i {.importcpp: "#.operator *(#)".}

proc `/`*(this: LPoint4i, scalar: int): LPoint4i {.importcpp: "#.operator /(#)".}

converter getClassType*(_: typedesc[LPoint4i]): TypeHandle {.importcpp: "LPoint4i::get_class_type()", header: "lpoint4.h".}

proc initLMatrix3f*(): LMatrix3f {.importcpp: "LMatrix3f()".}

proc initLMatrix3f*(other: LMatrix3f): LMatrix3f {.importcpp: "LMatrix3f(#)".}

proc initLMatrix3f*(param0: LVecBase3f, param1: LVecBase3f, param2: LVecBase3f): LMatrix3f {.importcpp: "LMatrix3f(#, #, #)".} ## \
## Constructs the matrix from three individual rows.

proc initLMatrix3f*(param0: float32, param1: float32, param2: float32, param3: float32, param4: float32, param5: float32, param6: float32, param7: float32, param8: float32): LMatrix3f {.importcpp: "LMatrix3f(#, #, #, #, #, #, #, #, #)".}

proc fill*(this: LMatrix3f, fill_value: float32) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the matrix to the indicated fill_value.  This is of
## questionable value, but is sometimes useful when initializing to zero.

proc set*(this: LMatrix3f, e00: float32, e01: float32, e02: float32, e10: float32, e11: float32, e12: float32, e20: float32, e21: float32, e22: float32) {.importcpp: "#.set(#, #, #, #, #, #, #, #, #)".}

proc size*(_: typedesc[LMatrix3f]): int {.importcpp: "LMatrix3f::size()", header: "lmatrix.h".} ## \
## Returns 3: the number of rows of a LMatrix3.

proc setRow*(this: LMatrix3f, row: int, v: LVecBase2f) {.importcpp: "#.set_row(#, #)".} ## \
## Replaces the indicated row of the matrix from a two-component vector,
## ignoring the last column.

proc setRow*(this: LMatrix3f, row: int, v: LVecBase3f) {.importcpp: "#.set_row(#, #)".} ## \
## Replaces the indicated row of the matrix from a three-component vector.

proc setCol*(this: LMatrix3f, col: int, v: LVecBase2f) {.importcpp: "#.set_col(#, #)".} ## \
## Replaces the indicated column of the matrix from a two-component vector,
## ignoring the last row.

proc setCol*(this: LMatrix3f, col: int, v: LVecBase3f) {.importcpp: "#.set_col(#, #)".} ## \
## Replaces the indicated column of the matrix from a three-component vector.

proc getRow*(this: LMatrix3f, result_vec: LVecBase3f, row: int) {.importcpp: "#.get_row(#, #)".} ## \
## Stores the indicated row of the matrix as a three-component vector.

proc getRow*(this: LMatrix3f, row: int): LVecBase3f {.importcpp: "#.get_row(#)".} ## \
## Returns the indicated row of the matrix as a three-component vector.

proc getCol*(this: LMatrix3f, col: int): LVecBase3f {.importcpp: "#.get_col(#)".} ## \
## Returns the indicated column of the matrix as a three-component vector.

proc getRow2*(this: LMatrix3f, row: int): LVecBase2f {.importcpp: "#.get_row2(#)".} ## \
## Returns the indicated row of the matrix as a two-component vector, ignoring
## the last column.

proc getCol2*(this: LMatrix3f, col: int): LVecBase2f {.importcpp: "#.get_col2(#)".} ## \
## Returns the indicated column of the matrix as a two-component vector,
## ignoring the last row.

proc isNan*(this: LMatrix3f): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the matrix is not-a-number, false
## otherwise.

proc isIdentity*(this: LMatrix3f): bool {.importcpp: "#.is_identity()".} ## \
## Returns true if this is (close enough to) the identity matrix, false
## otherwise.

proc getCell*(this: LMatrix3f, row: int, col: int): float32 {.importcpp: "#.get_cell(#, #)".} ## \
## Returns a particular element of the matrix.

proc setCell*(this: LMatrix3f, row: int, col: int, value: float32) {.importcpp: "#.set_cell(#, #, #)".} ## \
## Changes a particular element of the matrix.

proc getData*(this: LMatrix3f) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the nine data elements in the matrix.
## The remaining elements occupy the next eight positions in row-major order.

proc getNumComponents*(this: LMatrix3f): int {.importcpp: "#.get_num_components()".} ## \
## Returns the number of elements in the matrix, nine.

proc `<`*(this: LMatrix3f, other: LMatrix3f): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LMatrix3f, other: LMatrix3f): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LMatrix3f, other: LMatrix3f): bool {.importcpp: "#.operator !=(#)".}

proc compareTo*(this: LMatrix3f, other: LMatrix3f): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc compareTo*(this: LMatrix3f, other: LMatrix3f, threshold: float32): int {.importcpp: "#.compare_to(#, #)".} ## \
## Sorts matrices lexicographically, componentwise.  Returns a number less
## than 0 if this matrix sorts before the other one, greater than zero if it
## sorts after, 0 if they are equivalent (within the indicated tolerance).

proc getHash*(this: LMatrix3f): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc getHash*(this: LMatrix3f, threshold: float32): clonglong {.importcpp: "#.get_hash(#)".} ## \
## Returns a suitable hash for phash_map.

proc addHash*(this: LMatrix3f, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc addHash*(this: LMatrix3f, hash: clonglong, threshold: float32): clonglong {.importcpp: "#.add_hash(#, #)".} ## \
## Adds the vector into the running hash.

proc xform*(this: LMatrix3f, v: LVecBase3f): LVecBase3f {.importcpp: "#.xform(#)".} ## \
## 3-component vector or point times matrix.

proc xformPoint*(this: LMatrix3f, v: LVecBase2f): LVecBase2f {.importcpp: "#.xform_point(#)".} ## \
## The matrix transforms a 2-component point (including translation component)
## and returns the result.  This assumes the matrix is an affine transform.

proc xformVec*(this: LMatrix3f, v: LVecBase2f): LVecBase2f {.importcpp: "#.xform_vec(#)".} ## \
## The matrix transforms a 2-component vector (without translation component)
## and returns the result.  This assumes the matrix is an affine transform.

proc xformVec*(this: LMatrix3f, v: LVecBase3f): LVecBase3f {.importcpp: "#.xform_vec(#)".} ## \
## The matrix transforms a 3-component vector and returns the result.  This
## assumes the matrix is an orthonormal transform.
##
## In practice, this is the same computation as xform().

proc xformVecGeneral*(this: LMatrix3f, v: LVecBase3f): LVecBase3f {.importcpp: "#.xform_vec_general(#)".} ## \
## The matrix transforms a 3-component vector (without translation component)
## and returns the result, as a fully general operation.

proc xformInPlace*(this: LMatrix3f, v: LVecBase3f) {.importcpp: "#.xform_in_place(#)".} ## \
## 3-component vector or point times matrix.

proc xformPointInPlace*(this: LMatrix3f, v: LVecBase2f) {.importcpp: "#.xform_point_in_place(#)".} ## \
## The matrix transforms a 2-component point (including translation
## component).  This assumes the matrix is an affine transform.

proc xformVecInPlace*(this: LMatrix3f, v: LVecBase2f) {.importcpp: "#.xform_vec_in_place(#)".} ## \
## The matrix transforms a 2-component vector (without translation component).
## This assumes the matrix is an affine transform.

proc xformVecInPlace*(this: LMatrix3f, v: LVecBase3f) {.importcpp: "#.xform_vec_in_place(#)".} ## \
## The matrix transforms a 3-component vector.  This assumes the matrix is an
## orthonormal transform.
##
## In practice, this is the same computation as xform().

proc xformVecGeneralInPlace*(this: LMatrix3f, v: LVecBase3f) {.importcpp: "#.xform_vec_general_in_place(#)".} ## \
## The matrix transforms a 3-component vector (without translation component),
## as a fully general operation.

proc multiply*(this: LMatrix3f, other1: LMatrix3f, other2: LMatrix3f) {.importcpp: "#.multiply(#, #)".} ## \
## this = other1 \* other2

proc `*`*(this: LMatrix3f, other: LMatrix3f): LMatrix3f {.importcpp: "#.operator *(#)".}

proc `*`*(this: LMatrix3f, scalar: float32): LMatrix3f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LMatrix3f, scalar: float32): LMatrix3f {.importcpp: "#.operator /(#)".}

proc `+=`*(this: var LMatrix3f, other: LMatrix3f): LMatrix3f {.importcpp: "#.operator +=(#)".} ## \
## Performs a memberwise addition between two matrices.

proc `-=`*(this: var LMatrix3f, other: LMatrix3f): LMatrix3f {.importcpp: "#.operator -=(#)".} ## \
## Performs a memberwise subtraction between two matrices.

proc `*=`*(this: var LMatrix3f, other: LMatrix3f): LMatrix3f {.importcpp: "#.operator *=(#)".}

proc `*=`*(this: var LMatrix3f, scalar: float32): LMatrix3f {.importcpp: "#.operator *=(#)".} ## \
## Performs a memberwise scale.

proc `/=`*(this: var LMatrix3f, scalar: float32): LMatrix3f {.importcpp: "#.operator /=(#)".} ## \
## Performs a memberwise scale.

proc componentwiseMult*(this: LMatrix3f, other: LMatrix3f) {.importcpp: "#.componentwise_mult(#)".}

proc determinant*(this: LMatrix3f): float32 {.importcpp: "#.determinant()".} ## \
## Returns the determinant of the matrix.

proc transposeFrom*(this: LMatrix3f, other: LMatrix3f) {.importcpp: "#.transpose_from(#)".}

proc transposeInPlace*(this: LMatrix3f) {.importcpp: "#.transpose_in_place()".}

proc invertFrom*(this: LMatrix3f, other: LMatrix3f): bool {.importcpp: "#.invert_from(#)".} ## \
## Computes the inverse of the other matrix, and stores the result in this
## matrix.  This is a fully general operation and makes no assumptions about
## the type of transform represented by the matrix.
##
## The other matrix must be a different object than this matrix.  However, if
## you need to invert a matrix in place, see invert_in_place.
##
## The return value is true if the matrix was successfully inverted, false if
## there was a singularity.

proc invertInPlace*(this: LMatrix3f): bool {.importcpp: "#.invert_in_place()".} ## \
## Inverts the current matrix.  Returns true if the inverse is successful,
## false if the matrix was singular.

proc invertTransposeFrom*(this: LMatrix3f, other: LMatrix3f): bool {.importcpp: "#.invert_transpose_from(#)".} ## \
## Simultaneously computes the inverse of the indicated matrix, and then the
## transpose of that inverse.

proc invertTransposeFrom*(this: LMatrix3f, other: LMatrix4f): bool {.importcpp: "#.invert_transpose_from(#)".} ## \
## Simultaneously computes the inverse of the indicated matrix, and then the
## transpose of that inverse.

proc identMat*(_: typedesc[LMatrix3f]): LMatrix3f {.importcpp: "LMatrix3f::ident_mat()", header: "lmatrix.h".} ## \
## Returns an identity matrix.
##
## This function definition must appear first, since some inline functions
## below take advantage of it.

proc setTranslateMat*(this: LMatrix3f, trans: LVecBase2f) {.importcpp: "#.set_translate_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated translation.

proc setRotateMat*(this: LMatrix3f, angle: float32) {.importcpp: "#.set_rotate_mat(#)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise.

proc setRotateMat*(this: LMatrix3f, angle: float32, axis: LVecBase3f, cs: CoordinateSystem) {.importcpp: "#.set_rotate_mat(#, #, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc setRotateMat*(this: LMatrix3f, angle: float32, axis: LVecBase3f) {.importcpp: "#.set_rotate_mat(#, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc setScaleMat*(this: LMatrix3f, scale: LVecBase2f) {.importcpp: "#.set_scale_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated scale in each of the two
## axes.

proc setScaleMat*(this: LMatrix3f, scale: LVecBase3f) {.importcpp: "#.set_scale_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated scale in each of the
## three axes.

proc translateMat*(_: typedesc[LMatrix3f], trans: LVecBase2f): LMatrix3f {.importcpp: "#LMatrix3f::translate_mat(#)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated translation.

proc translateMat*(_: typedesc[LMatrix3f], tx: float32, ty: float32): LMatrix3f {.importcpp: "#LMatrix3f::translate_mat(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated translation.

proc rotateMat*(_: typedesc[LMatrix3f], angle: float32): LMatrix3f {.importcpp: "#LMatrix3f::rotate_mat(#)", header: "lmatrix.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise.

proc rotateMat*(_: typedesc[LMatrix3f], angle: float32, axis: LVecBase3f, cs: CoordinateSystem): LMatrix3f {.importcpp: "#LMatrix3f::rotate_mat(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc rotateMat*(_: typedesc[LMatrix3f], angle: float32, axis: LVecBase3f): LMatrix3f {.importcpp: "#LMatrix3f::rotate_mat(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc scaleMat*(_: typedesc[LMatrix3f], scale: LVecBase2f): LMatrix3f {.importcpp: "#LMatrix3f::scale_mat(#)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale in each of the two axes.

proc scaleMat*(_: typedesc[LMatrix3f], scale: LVecBase3f): LMatrix3f {.importcpp: "#LMatrix3f::scale_mat(#)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale in each of the three
## axes.

proc scaleMat*(_: typedesc[LMatrix3f], sx: float32, sy: float32): LMatrix3f {.importcpp: "#LMatrix3f::scale_mat(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale in each of the two axes.

proc scaleMat*(_: typedesc[LMatrix3f], sx: float32, sy: float32, sz: float32): LMatrix3f {.importcpp: "#LMatrix3f::scale_mat(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale in each of the three
## axes.

proc setRotateMatNormaxis*(this: LMatrix3f, angle: float32, axis: LVecBase3f, cs: CoordinateSystem) {.importcpp: "#.set_rotate_mat_normaxis(#, #, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## normalized.

proc setRotateMatNormaxis*(this: LMatrix3f, angle: float32, axis: LVecBase3f) {.importcpp: "#.set_rotate_mat_normaxis(#, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## normalized.

proc rotateMatNormaxis*(_: typedesc[LMatrix3f], angle: float32, axis: LVecBase3f, cs: CoordinateSystem): LMatrix3f {.importcpp: "#LMatrix3f::rotate_mat_normaxis(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## normalized.

proc rotateMatNormaxis*(_: typedesc[LMatrix3f], angle: float32, axis: LVecBase3f): LMatrix3f {.importcpp: "#LMatrix3f::rotate_mat_normaxis(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## normalized.

proc setShearMat*(this: LMatrix3f, shear: LVecBase3f, cs: CoordinateSystem) {.importcpp: "#.set_shear_mat(#, #)".} ## \
## Fills mat with a matrix that applies the indicated shear in each of the
## three planes.

proc setShearMat*(this: LMatrix3f, shear: LVecBase3f) {.importcpp: "#.set_shear_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated shear in each of the
## three planes.

proc shearMat*(_: typedesc[LMatrix3f], shear: LVecBase3f, cs: CoordinateSystem): LMatrix3f {.importcpp: "#LMatrix3f::shear_mat(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shearMat*(_: typedesc[LMatrix3f], shear: LVecBase3f): LMatrix3f {.importcpp: "#LMatrix3f::shear_mat(#)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shearMat*(_: typedesc[LMatrix3f], shxy: float32, shxz: float32, shyz: float32, cs: CoordinateSystem): LMatrix3f {.importcpp: "#LMatrix3f::shear_mat(#, #, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shearMat*(_: typedesc[LMatrix3f], shxy: float32, shxz: float32, shyz: float32): LMatrix3f {.importcpp: "#LMatrix3f::shear_mat(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc setScaleShearMat*(this: LMatrix3f, scale: LVecBase3f, shear: LVecBase3f, cs: CoordinateSystem) {.importcpp: "#.set_scale_shear_mat(#, #, #)".} ## \
## Fills mat with a matrix that applies the indicated scale and shear.

proc setScaleShearMat*(this: LMatrix3f, scale: LVecBase3f, shear: LVecBase3f) {.importcpp: "#.set_scale_shear_mat(#, #)".} ## \
## Fills mat with a matrix that applies the indicated scale and shear.

proc scaleShearMat*(_: typedesc[LMatrix3f], scale: LVecBase3f, shear: LVecBase3f, cs: CoordinateSystem): LMatrix3f {.importcpp: "#LMatrix3f::scale_shear_mat(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scaleShearMat*(_: typedesc[LMatrix3f], scale: LVecBase3f, shear: LVecBase3f): LMatrix3f {.importcpp: "#LMatrix3f::scale_shear_mat(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scaleShearMat*(_: typedesc[LMatrix3f], sx: float32, sy: float32, sz: float32, shxy: float32, shxz: float32, shyz: float32, cs: CoordinateSystem): LMatrix3f {.importcpp: "#LMatrix3f::scale_shear_mat(#, #, #, #, #, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scaleShearMat*(_: typedesc[LMatrix3f], sx: float32, sy: float32, sz: float32, shxy: float32, shxz: float32, shyz: float32): LMatrix3f {.importcpp: "#LMatrix3f::scale_shear_mat(#, #, #, #, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc convertMat*(_: typedesc[LMatrix3f], `from`: CoordinateSystem, to: CoordinateSystem): LMatrix3f {.importcpp: "#LMatrix3f::convert_mat(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that transforms from the indicated coordinate system to
## the indicated coordinate system.

proc almostEqual*(this: LMatrix3f, other: LMatrix3f): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two matrices are memberwise equal within a default
## tolerance based on the numeric type.

proc almostEqual*(this: LMatrix3f, other: LMatrix3f, threshold: float32): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two matrices are memberwise equal within a specified
## tolerance.

proc output*(this: LMatrix3f, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: LMatrix3f, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: LMatrix3f, `out`: ostream) {.importcpp: "#.write(#)".}

proc writeDatagramFixed*(this: LMatrix3f, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the matrix to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the matrix, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc readDatagramFixed*(this: LMatrix3f, scan: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the matrix from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc writeDatagram*(this: LMatrix3f, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the matrix to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the matrix using the standard width
## setting, especially when you are writing a bam file.

proc readDatagram*(this: LMatrix3f, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the matrix from the Datagram using get_stdfloat().

converter getClassType*(_: typedesc[LMatrix3f]): TypeHandle {.importcpp: "LMatrix3f::get_class_type()", header: "lmatrix.h".}

proc transpose*(a: LMatrix3d): LMatrix3d {.importcpp: "transpose(#)".}

proc transpose*(a: LMatrix3f): LMatrix3f {.importcpp: "transpose(#)".}

proc transpose*(a: LMatrix4d): LMatrix4d {.importcpp: "transpose(#)".}

proc transpose*(a: LMatrix4f): LMatrix4f {.importcpp: "transpose(#)".}

proc invert*(a: LMatrix3d): LMatrix3d {.importcpp: "invert(#)".}

proc invert*(a: LMatrix3f): LMatrix3f {.importcpp: "invert(#)".}

proc invert*(a: LMatrix4d): LMatrix4d {.importcpp: "invert(#)".}

proc invert*(a: LMatrix4f): LMatrix4f {.importcpp: "invert(#)".}

proc invert*(a: LQuaterniond): LQuaterniond {.importcpp: "invert(#)".}

proc invert*(a: LQuaternionf): LQuaternionf {.importcpp: "invert(#)".}

proc initLMatrix4f*(): LMatrix4f {.importcpp: "LMatrix4f()".}

converter initLMatrix4f*(upper3: LMatrix3f): LMatrix4f {.importcpp: "LMatrix4f(#)".} ## \
## Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
## translation component.

proc initLMatrix4f*(upper3: LMatrix3f, trans: LVecBase3f): LMatrix4f {.importcpp: "LMatrix4f(#, #)".}

proc initLMatrix4f*(other: LMatrix4f): LMatrix4f {.importcpp: "LMatrix4f(#)".}

proc initLMatrix4f*(param0: LVecBase4f, param1: LVecBase4f, param2: LVecBase4f, param3: LVecBase4f): LMatrix4f {.importcpp: "LMatrix4f(#, #, #, #)".} ## \
## Constructs the matrix from four individual rows.

converter initLMatrix4f*(other: UnalignedLMatrix4f): LMatrix4f {.importcpp: "LMatrix4f(#)".}

proc initLMatrix4f*(param0: float32, param1: float32, param2: float32, param3: float32, param4: float32, param5: float32, param6: float32, param7: float32, param8: float32, param9: float32, param10: float32, param11: float32, param12: float32, param13: float32, param14: float32, param15: float32): LMatrix4f {.importcpp: "LMatrix4f(#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)".}

proc fill*(this: LMatrix4f, fill_value: float32) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the matrix to the indicated fill_value.  This is of
## questionable value, but is sometimes useful when initializing to zero.

proc set*(this: LMatrix4f, e00: float32, e01: float32, e02: float32, e03: float32, e10: float32, e11: float32, e12: float32, e13: float32, e20: float32, e21: float32, e22: float32, e23: float32, e30: float32, e31: float32, e32: float32, e33: float32) {.importcpp: "#.set(#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)".}

proc setUpper3*(this: LMatrix4f, upper3: LMatrix3f) {.importcpp: "#.set_upper_3(#)".} ## \
## Get and set the upper 3x3 rotation matrix.

proc getUpper3*(this: LMatrix4f): LMatrix3f {.importcpp: "#.get_upper_3()".} ## \
## Retrieves the upper 3x3 submatrix.

proc size*(_: typedesc[LMatrix4f]): int {.importcpp: "LMatrix4f::size()", header: "lmatrix.h".} ## \
## Returns 4: the number of rows of a LMatrix4.

proc setRow*(this: LMatrix4f, row: int, v: LVecBase3f) {.importcpp: "#.set_row(#, #)".} ## \
## Replaces the indicated row of the matrix with the indicated 3-component
## vector, ignoring the last column.

proc setRow*(this: LMatrix4f, row: int, v: LVecBase4f) {.importcpp: "#.set_row(#, #)".} ## \
## Replaces the indicated row of the matrix.

proc setCol*(this: LMatrix4f, col: int, v: LVecBase3f) {.importcpp: "#.set_col(#, #)".} ## \
## Replaces the indicated column of the matrix with the indicated 3-component
## vector, ignoring the last row.

proc setCol*(this: LMatrix4f, col: int, v: LVecBase4f) {.importcpp: "#.set_col(#, #)".} ## \
## Replaces the indicated column of the matrix.

proc getRow*(this: LMatrix4f, result_vec: LVecBase4f, row: int) {.importcpp: "#.get_row(#, #)".} ## \
## Stores the indicated row of the matrix as a 4-component vector.

proc getRow*(this: LMatrix4f, row: int): LVecBase4f {.importcpp: "#.get_row(#)".} ## \
## Retrieves the indicated row of the matrix as a 4-component vector.

proc getCol*(this: LMatrix4f, col: int): LVecBase4f {.importcpp: "#.get_col(#)".} ## \
## Retrieves the indicated column of the matrix as a 4-component vector.

proc getRow3*(this: LMatrix4f, result_vec: LVecBase3f, row: int) {.importcpp: "#.get_row3(#, #)".} ## \
## Stores the row column of the matrix as a 3-component vector, ignoring the
## last column.

proc getRow3*(this: LMatrix4f, row: int): LVecBase3f {.importcpp: "#.get_row3(#)".} ## \
## Retrieves the row column of the matrix as a 3-component vector, ignoring
## the last column.

proc getCol3*(this: LMatrix4f, col: int): LVecBase3f {.importcpp: "#.get_col3(#)".} ## \
## Retrieves the indicated column of the matrix as a 3-component vector,
## ignoring the last row.

proc isNan*(this: LMatrix4f): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the matrix is not-a-number, false
## otherwise.

proc isIdentity*(this: LMatrix4f): bool {.importcpp: "#.is_identity()".} ## \
## Returns true if this is (close enough to) the identity matrix, false
## otherwise.

proc getCell*(this: LMatrix4f, row: int, col: int): float32 {.importcpp: "#.get_cell(#, #)".} ## \
## Returns a particular element of the matrix.

proc setCell*(this: LMatrix4f, row: int, col: int, value: float32) {.importcpp: "#.set_cell(#, #, #)".} ## \
## Changes a particular element of the matrix.

proc getData*(this: LMatrix4f) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the nine data elements in the matrix.
## The remaining elements occupy the next eight positions in row-major order.

proc getNumComponents*(this: LMatrix4f): int {.importcpp: "#.get_num_components()".} ## \
## Returns the number of elements in the matrix, 16.

proc begin*(this: LMatrix4f) {.importcpp: "#.begin()".} ## \
## Returns an iterator that may be used to traverse the elements of the
## matrix, STL-style.

proc `<`*(this: LMatrix4f, other: LMatrix4f): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LMatrix4f, other: LMatrix4f): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LMatrix4f, other: LMatrix4f): bool {.importcpp: "#.operator !=(#)".}

proc compareTo*(this: LMatrix4f, other: LMatrix4f): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc compareTo*(this: LMatrix4f, other: LMatrix4f, threshold: float32): int {.importcpp: "#.compare_to(#, #)".} ## \
## Sorts matrices lexicographically, componentwise.  Returns a number less
## than 0 if this matrix sorts before the other one, greater than zero if it
## sorts after, 0 if they are equivalent (within the indicated tolerance).

proc getHash*(this: LMatrix4f): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc getHash*(this: LMatrix4f, threshold: float32): clonglong {.importcpp: "#.get_hash(#)".} ## \
## Returns a suitable hash for phash_map.

proc addHash*(this: LMatrix4f, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc addHash*(this: LMatrix4f, hash: clonglong, threshold: float32): clonglong {.importcpp: "#.add_hash(#, #)".} ## \
## Adds the vector into the running hash.

proc xform*(this: LMatrix4f, v: LVecBase4f): LVecBase4f {.importcpp: "#.xform(#)".} ## \
## 4-component vector or point times matrix.  This is a fully general
## operation.

proc xformPoint*(this: LMatrix4f, v: LVecBase3f): LVecBase3f {.importcpp: "#.xform_point(#)".} ## \
## The matrix transforms a 3-component point (including translation component)
## and returns the result.  This assumes the matrix is an affine transform.

proc xformPointGeneral*(this: LMatrix4f, v: LVecBase3f): LVecBase3f {.importcpp: "#.xform_point_general(#)".} ## \
## The matrix transforms a 3-component point (including translation component)
## and returns the result, as a fully general operation.

proc xformVec*(this: LMatrix4f, v: LVecBase3f): LVecBase3f {.importcpp: "#.xform_vec(#)".} ## \
## The matrix transforms a 3-component vector (without translation component)
## and returns the result.  This assumes the matrix is an orthonormal
## transform.

proc xformVecGeneral*(this: LMatrix4f, v: LVecBase3f): LVecBase3f {.importcpp: "#.xform_vec_general(#)".} ## \
## The matrix transforms a 3-component vector (without translation component)
## and returns the result, as a fully general operation.

proc xformInPlace*(this: LMatrix4f, v: LVecBase4f) {.importcpp: "#.xform_in_place(#)".} ## \
## 4-component vector or point times matrix.  This is a fully general
## operation.

proc xformPointInPlace*(this: LMatrix4f, v: LVecBase3f) {.importcpp: "#.xform_point_in_place(#)".} ## \
## The matrix transforms a 3-component point (including translation
## component).  This assumes the matrix is an affine transform.

proc xformPointGeneralInPlace*(this: LMatrix4f, v: LVecBase3f) {.importcpp: "#.xform_point_general_in_place(#)".} ## \
## The matrix transforms a 3-component point (including translation
## component), as a fully general operation.

proc xformVecInPlace*(this: LMatrix4f, v: LVecBase3f) {.importcpp: "#.xform_vec_in_place(#)".} ## \
## The matrix transforms a 3-component vector (without translation component).
## This assumes the matrix is an orthonormal transform.

proc xformVecGeneralInPlace*(this: LMatrix4f, v: LVecBase3f) {.importcpp: "#.xform_vec_general_in_place(#)".} ## \
## The matrix transforms a 3-component vector (without translation component),
## as a fully general operation.

proc multiply*(this: LMatrix4f, other1: LMatrix4f, other2: LMatrix4f) {.importcpp: "#.multiply(#, #)".} ## \
## this = other1 \* other2

proc `*`*(this: LMatrix4f, other: LMatrix4f): LMatrix4f {.importcpp: "#.operator *(#)".}

proc `*`*(this: LMatrix4f, scalar: float32): LMatrix4f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LMatrix4f, scalar: float32): LMatrix4f {.importcpp: "#.operator /(#)".}

proc `+=`*(this: var LMatrix4f, other: LMatrix4f): LMatrix4f {.importcpp: "#.operator +=(#)".} ## \
## Performs a memberwise addition between two matrices.

proc `-=`*(this: var LMatrix4f, other: LMatrix4f): LMatrix4f {.importcpp: "#.operator -=(#)".} ## \
## Performs a memberwise subtraction between two matrices.

proc `*=`*(this: var LMatrix4f, other: LMatrix4f): LMatrix4f {.importcpp: "#.operator *=(#)".}

proc `*=`*(this: var LMatrix4f, scalar: float32): LMatrix4f {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: var LMatrix4f, scalar: float32): LMatrix4f {.importcpp: "#.operator /=(#)".}

proc componentwiseMult*(this: LMatrix4f, other: LMatrix4f) {.importcpp: "#.componentwise_mult(#)".}

proc transposeFrom*(this: LMatrix4f, other: LMatrix4f) {.importcpp: "#.transpose_from(#)".}

proc transposeInPlace*(this: LMatrix4f) {.importcpp: "#.transpose_in_place()".}

proc invertFrom*(this: LMatrix4f, other: LMatrix4f): bool {.importcpp: "#.invert_from(#)".} ## \
## Computes the inverse of the other matrix, and stores the result in this
## matrix.  This is a fully general operation and makes no assumptions about
## the type of transform represented by the matrix.
##
## The other matrix must be a different object than this matrix.  However, if
## you need to invert a matrix in place, see invert_in_place.
##
## The return value is true if the matrix was successfully inverted, false if
## the was a singularity.

proc invertAffineFrom*(this: LMatrix4f, other: LMatrix4f): bool {.importcpp: "#.invert_affine_from(#)".} ## \
## bugbug: we could optimize this for rotationscaletranslation matrices
## (transpose upper 3x3 and take negative of translation component)

proc invertInPlace*(this: LMatrix4f): bool {.importcpp: "#.invert_in_place()".} ## \
## Inverts the current matrix.  Returns true if the inverse is successful,
## false if the matrix was singular.

proc accumulate*(this: LMatrix4f, other: LMatrix4f, weight: float32) {.importcpp: "#.accumulate(#, #)".} ## \
## Computes `(\*this) += other \* weight`.

proc identMat*(_: typedesc[LMatrix4f]): LMatrix4f {.importcpp: "LMatrix4f::ident_mat()", header: "lmatrix.h".} ## \
## Returns an identity matrix.
##
## This function definition must appear first, since some inline functions
## below take advantage of it.

proc onesMat*(_: typedesc[LMatrix4f]): LMatrix4f {.importcpp: "LMatrix4f::ones_mat()", header: "lmatrix.h".} ## \
## Returns an matrix filled with ones.

proc zerosMat*(_: typedesc[LMatrix4f]): LMatrix4f {.importcpp: "LMatrix4f::zeros_mat()", header: "lmatrix.h".} ## \
## Returns an matrix filled with zeros.

proc setTranslateMat*(this: LMatrix4f, trans: LVecBase3f) {.importcpp: "#.set_translate_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated translation.

proc setRotateMat*(this: LMatrix4f, angle: float32, axis: LVecBase3f, cs: CoordinateSystem) {.importcpp: "#.set_rotate_mat(#, #, #)".} ## \
## Sets mat to a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc setRotateMat*(this: LMatrix4f, angle: float32, axis: LVecBase3f) {.importcpp: "#.set_rotate_mat(#, #)".} ## \
## Sets mat to a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc setRotateMatNormaxis*(this: LMatrix4f, angle: float32, axis: LVecBase3f, cs: CoordinateSystem) {.importcpp: "#.set_rotate_mat_normaxis(#, #, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## prenormalized.

proc setRotateMatNormaxis*(this: LMatrix4f, angle: float32, axis: LVecBase3f) {.importcpp: "#.set_rotate_mat_normaxis(#, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## prenormalized.

proc setScaleMat*(this: LMatrix4f, scale: LVecBase3f) {.importcpp: "#.set_scale_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated scale in each of the
## three axes.

proc setShearMat*(this: LMatrix4f, shear: LVecBase3f, cs: CoordinateSystem) {.importcpp: "#.set_shear_mat(#, #)".} ## \
## Fills mat with a matrix that applies the indicated shear in each of the
## three planes.

proc setShearMat*(this: LMatrix4f, shear: LVecBase3f) {.importcpp: "#.set_shear_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated shear in each of the
## three planes.

proc setScaleShearMat*(this: LMatrix4f, scale: LVecBase3f, shear: LVecBase3f, cs: CoordinateSystem) {.importcpp: "#.set_scale_shear_mat(#, #, #)".} ## \
## Fills mat with a matrix that applies the indicated scale and shear.

proc setScaleShearMat*(this: LMatrix4f, scale: LVecBase3f, shear: LVecBase3f) {.importcpp: "#.set_scale_shear_mat(#, #)".} ## \
## Fills mat with a matrix that applies the indicated scale and shear.

proc translateMat*(_: typedesc[LMatrix4f], trans: LVecBase3f): LMatrix4f {.importcpp: "#LMatrix4f::translate_mat(#)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated translation.

proc translateMat*(_: typedesc[LMatrix4f], tx: float32, ty: float32, tz: float32): LMatrix4f {.importcpp: "#LMatrix4f::translate_mat(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated translation.

proc rotateMat*(_: typedesc[LMatrix4f], angle: float32, axis: LVecBase3f, cs: CoordinateSystem): LMatrix4f {.importcpp: "#LMatrix4f::rotate_mat(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc rotateMat*(_: typedesc[LMatrix4f], angle: float32, axis: LVecBase3f): LMatrix4f {.importcpp: "#LMatrix4f::rotate_mat(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc rotateMatNormaxis*(_: typedesc[LMatrix4f], angle: float32, axis: LVecBase3f, cs: CoordinateSystem): LMatrix4f {.importcpp: "#LMatrix4f::rotate_mat_normaxis(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## prenormalized.

proc rotateMatNormaxis*(_: typedesc[LMatrix4f], angle: float32, axis: LVecBase3f): LMatrix4f {.importcpp: "#LMatrix4f::rotate_mat_normaxis(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## prenormalized.

proc scaleMat*(_: typedesc[LMatrix4f], scale: LVecBase3f): LMatrix4f {.importcpp: "#LMatrix4f::scale_mat(#)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale in each of the three
## axes.

proc scaleMat*(_: typedesc[LMatrix4f], scale: float32): LMatrix4f {.importcpp: "#LMatrix4f::scale_mat(#)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated uniform scale.

proc scaleMat*(_: typedesc[LMatrix4f], sx: float32, sy: float32, sz: float32): LMatrix4f {.importcpp: "#LMatrix4f::scale_mat(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale in each of the three
## axes.

proc shearMat*(_: typedesc[LMatrix4f], shear: LVecBase3f, cs: CoordinateSystem): LMatrix4f {.importcpp: "#LMatrix4f::shear_mat(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shearMat*(_: typedesc[LMatrix4f], shear: LVecBase3f): LMatrix4f {.importcpp: "#LMatrix4f::shear_mat(#)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shearMat*(_: typedesc[LMatrix4f], shxy: float32, shxz: float32, shyz: float32, cs: CoordinateSystem): LMatrix4f {.importcpp: "#LMatrix4f::shear_mat(#, #, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shearMat*(_: typedesc[LMatrix4f], shxy: float32, shxz: float32, shyz: float32): LMatrix4f {.importcpp: "#LMatrix4f::shear_mat(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc scaleShearMat*(_: typedesc[LMatrix4f], scale: LVecBase3f, shear: LVecBase3f, cs: CoordinateSystem): LMatrix4f {.importcpp: "#LMatrix4f::scale_shear_mat(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scaleShearMat*(_: typedesc[LMatrix4f], scale: LVecBase3f, shear: LVecBase3f): LMatrix4f {.importcpp: "#LMatrix4f::scale_shear_mat(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scaleShearMat*(_: typedesc[LMatrix4f], sx: float32, sy: float32, sz: float32, shxy: float32, shxz: float32, shyz: float32, cs: CoordinateSystem): LMatrix4f {.importcpp: "#LMatrix4f::scale_shear_mat(#, #, #, #, #, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scaleShearMat*(_: typedesc[LMatrix4f], sx: float32, sy: float32, sz: float32, shxy: float32, shxz: float32, shyz: float32): LMatrix4f {.importcpp: "#LMatrix4f::scale_shear_mat(#, #, #, #, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc yToZUpMat*(_: typedesc[LMatrix4f]): LMatrix4f {.importcpp: "LMatrix4f::y_to_z_up_mat()", header: "lmatrix.h".} ## \
## Returns a matrix that transforms from the Y-up coordinate system to the
## Z-up coordinate system.

proc zToYUpMat*(_: typedesc[LMatrix4f]): LMatrix4f {.importcpp: "LMatrix4f::z_to_y_up_mat()", header: "lmatrix.h".} ## \
## Returns a matrix that transforms from the Y-up coordinate system to the
## Z-up coordinate system.

proc convertMat*(_: typedesc[LMatrix4f], `from`: CoordinateSystem, to: CoordinateSystem): LMatrix4f {.importcpp: "#LMatrix4f::convert_mat(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that transforms from the indicated coordinate system to
## the indicated coordinate system.

proc almostEqual*(this: LMatrix4f, other: LMatrix4f): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two matrices are memberwise equal within a default
## tolerance based on the numeric type.

proc almostEqual*(this: LMatrix4f, other: LMatrix4f, threshold: float32): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two matrices are memberwise equal within a specified
## tolerance.  This is faster than the equivalence operator as this doesn't
## have to guarantee that it is transitive.

proc output*(this: LMatrix4f, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: LMatrix4f, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: LMatrix4f, `out`: ostream) {.importcpp: "#.write(#)".}

proc writeDatagramFixed*(this: LMatrix4f, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the matrix to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the matrix, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc readDatagramFixed*(this: LMatrix4f, scan: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the matrix from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc writeDatagram*(this: LMatrix4f, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the matrix to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the matrix using the standard width
## setting, especially when you are writing a bam file.

proc readDatagram*(this: LMatrix4f, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the matrix from the Datagram using get_stdfloat().

converter getClassType*(_: typedesc[LMatrix4f]): TypeHandle {.importcpp: "LMatrix4f::get_class_type()", header: "lmatrix.h".}

proc initUnalignedLMatrix4f*(): UnalignedLMatrix4f {.importcpp: "UnalignedLMatrix4f()".}

converter initUnalignedLMatrix4f*(copy: LMatrix4f): UnalignedLMatrix4f {.importcpp: "UnalignedLMatrix4f(#)".}

proc initUnalignedLMatrix4f*(copy: UnalignedLMatrix4f): UnalignedLMatrix4f {.importcpp: "UnalignedLMatrix4f(#)".}

proc initUnalignedLMatrix4f*(e00: float32, e01: float32, e02: float32, e03: float32, e10: float32, e11: float32, e12: float32, e13: float32, e20: float32, e21: float32, e22: float32, e23: float32, e30: float32, e31: float32, e32: float32, e33: float32): UnalignedLMatrix4f {.importcpp: "UnalignedLMatrix4f(#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)".}

proc set*(this: UnalignedLMatrix4f, e00: float32, e01: float32, e02: float32, e03: float32, e10: float32, e11: float32, e12: float32, e13: float32, e20: float32, e21: float32, e22: float32, e23: float32, e30: float32, e31: float32, e32: float32, e33: float32) {.importcpp: "#.set(#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)".}

proc getData*(this: UnalignedLMatrix4f) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the nine data elements in the matrix.
## The remaining elements occupy the next eight positions in row-major order.

proc getNumComponents*(this: UnalignedLMatrix4f): int {.importcpp: "#.get_num_components()".} ## \
## Returns the number of elements in the matrix, sixteen.

proc `==`*(this: UnalignedLMatrix4f, other: UnalignedLMatrix4f): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: UnalignedLMatrix4f, other: UnalignedLMatrix4f): bool {.importcpp: "#.operator !=(#)".}

converter getClassType*(_: typedesc[UnalignedLMatrix4f]): TypeHandle {.importcpp: "UnalignedLMatrix4f::get_class_type()", header: "lmatrix.h".}

proc initLMatrix3d*(): LMatrix3d {.importcpp: "LMatrix3d()".}

proc initLMatrix3d*(other: LMatrix3d): LMatrix3d {.importcpp: "LMatrix3d(#)".}

proc initLMatrix3d*(param0: LVecBase3d, param1: LVecBase3d, param2: LVecBase3d): LMatrix3d {.importcpp: "LMatrix3d(#, #, #)".} ## \
## Constructs the matrix from three individual rows.

proc initLMatrix3d*(param0: float64, param1: float64, param2: float64, param3: float64, param4: float64, param5: float64, param6: float64, param7: float64, param8: float64): LMatrix3d {.importcpp: "LMatrix3d(#, #, #, #, #, #, #, #, #)".}

proc fill*(this: LMatrix3d, fill_value: float64) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the matrix to the indicated fill_value.  This is of
## questionable value, but is sometimes useful when initializing to zero.

proc set*(this: LMatrix3d, e00: float64, e01: float64, e02: float64, e10: float64, e11: float64, e12: float64, e20: float64, e21: float64, e22: float64) {.importcpp: "#.set(#, #, #, #, #, #, #, #, #)".}

proc size*(_: typedesc[LMatrix3d]): int {.importcpp: "LMatrix3d::size()", header: "lmatrix.h".} ## \
## Returns 3: the number of rows of a LMatrix3.

proc setRow*(this: LMatrix3d, row: int, v: LVecBase2d) {.importcpp: "#.set_row(#, #)".} ## \
## Replaces the indicated row of the matrix from a two-component vector,
## ignoring the last column.

proc setRow*(this: LMatrix3d, row: int, v: LVecBase3d) {.importcpp: "#.set_row(#, #)".} ## \
## Replaces the indicated row of the matrix from a three-component vector.

proc setCol*(this: LMatrix3d, col: int, v: LVecBase2d) {.importcpp: "#.set_col(#, #)".} ## \
## Replaces the indicated column of the matrix from a two-component vector,
## ignoring the last row.

proc setCol*(this: LMatrix3d, col: int, v: LVecBase3d) {.importcpp: "#.set_col(#, #)".} ## \
## Replaces the indicated column of the matrix from a three-component vector.

proc getRow*(this: LMatrix3d, result_vec: LVecBase3d, row: int) {.importcpp: "#.get_row(#, #)".} ## \
## Stores the indicated row of the matrix as a three-component vector.

proc getRow*(this: LMatrix3d, row: int): LVecBase3d {.importcpp: "#.get_row(#)".} ## \
## Returns the indicated row of the matrix as a three-component vector.

proc getCol*(this: LMatrix3d, col: int): LVecBase3d {.importcpp: "#.get_col(#)".} ## \
## Returns the indicated column of the matrix as a three-component vector.

proc getRow2*(this: LMatrix3d, row: int): LVecBase2d {.importcpp: "#.get_row2(#)".} ## \
## Returns the indicated row of the matrix as a two-component vector, ignoring
## the last column.

proc getCol2*(this: LMatrix3d, col: int): LVecBase2d {.importcpp: "#.get_col2(#)".} ## \
## Returns the indicated column of the matrix as a two-component vector,
## ignoring the last row.

proc isNan*(this: LMatrix3d): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the matrix is not-a-number, false
## otherwise.

proc isIdentity*(this: LMatrix3d): bool {.importcpp: "#.is_identity()".} ## \
## Returns true if this is (close enough to) the identity matrix, false
## otherwise.

proc getCell*(this: LMatrix3d, row: int, col: int): float64 {.importcpp: "#.get_cell(#, #)".} ## \
## Returns a particular element of the matrix.

proc setCell*(this: LMatrix3d, row: int, col: int, value: float64) {.importcpp: "#.set_cell(#, #, #)".} ## \
## Changes a particular element of the matrix.

proc getData*(this: LMatrix3d) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the nine data elements in the matrix.
## The remaining elements occupy the next eight positions in row-major order.

proc getNumComponents*(this: LMatrix3d): int {.importcpp: "#.get_num_components()".} ## \
## Returns the number of elements in the matrix, nine.

proc `<`*(this: LMatrix3d, other: LMatrix3d): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LMatrix3d, other: LMatrix3d): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LMatrix3d, other: LMatrix3d): bool {.importcpp: "#.operator !=(#)".}

proc compareTo*(this: LMatrix3d, other: LMatrix3d): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc compareTo*(this: LMatrix3d, other: LMatrix3d, threshold: float64): int {.importcpp: "#.compare_to(#, #)".} ## \
## Sorts matrices lexicographically, componentwise.  Returns a number less
## than 0 if this matrix sorts before the other one, greater than zero if it
## sorts after, 0 if they are equivalent (within the indicated tolerance).

proc getHash*(this: LMatrix3d): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc getHash*(this: LMatrix3d, threshold: float64): clonglong {.importcpp: "#.get_hash(#)".} ## \
## Returns a suitable hash for phash_map.

proc addHash*(this: LMatrix3d, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc addHash*(this: LMatrix3d, hash: clonglong, threshold: float64): clonglong {.importcpp: "#.add_hash(#, #)".} ## \
## Adds the vector into the running hash.

proc xform*(this: LMatrix3d, v: LVecBase3d): LVecBase3d {.importcpp: "#.xform(#)".} ## \
## 3-component vector or point times matrix.

proc xformPoint*(this: LMatrix3d, v: LVecBase2d): LVecBase2d {.importcpp: "#.xform_point(#)".} ## \
## The matrix transforms a 2-component point (including translation component)
## and returns the result.  This assumes the matrix is an affine transform.

proc xformVec*(this: LMatrix3d, v: LVecBase2d): LVecBase2d {.importcpp: "#.xform_vec(#)".} ## \
## The matrix transforms a 2-component vector (without translation component)
## and returns the result.  This assumes the matrix is an affine transform.

proc xformVec*(this: LMatrix3d, v: LVecBase3d): LVecBase3d {.importcpp: "#.xform_vec(#)".} ## \
## The matrix transforms a 3-component vector and returns the result.  This
## assumes the matrix is an orthonormal transform.
##
## In practice, this is the same computation as xform().

proc xformVecGeneral*(this: LMatrix3d, v: LVecBase3d): LVecBase3d {.importcpp: "#.xform_vec_general(#)".} ## \
## The matrix transforms a 3-component vector (without translation component)
## and returns the result, as a fully general operation.

proc xformInPlace*(this: LMatrix3d, v: LVecBase3d) {.importcpp: "#.xform_in_place(#)".} ## \
## 3-component vector or point times matrix.

proc xformPointInPlace*(this: LMatrix3d, v: LVecBase2d) {.importcpp: "#.xform_point_in_place(#)".} ## \
## The matrix transforms a 2-component point (including translation
## component).  This assumes the matrix is an affine transform.

proc xformVecInPlace*(this: LMatrix3d, v: LVecBase2d) {.importcpp: "#.xform_vec_in_place(#)".} ## \
## The matrix transforms a 2-component vector (without translation component).
## This assumes the matrix is an affine transform.

proc xformVecInPlace*(this: LMatrix3d, v: LVecBase3d) {.importcpp: "#.xform_vec_in_place(#)".} ## \
## The matrix transforms a 3-component vector.  This assumes the matrix is an
## orthonormal transform.
##
## In practice, this is the same computation as xform().

proc xformVecGeneralInPlace*(this: LMatrix3d, v: LVecBase3d) {.importcpp: "#.xform_vec_general_in_place(#)".} ## \
## The matrix transforms a 3-component vector (without translation component),
## as a fully general operation.

proc multiply*(this: LMatrix3d, other1: LMatrix3d, other2: LMatrix3d) {.importcpp: "#.multiply(#, #)".} ## \
## this = other1 \* other2

proc `*`*(this: LMatrix3d, other: LMatrix3d): LMatrix3d {.importcpp: "#.operator *(#)".}

proc `*`*(this: LMatrix3d, scalar: float64): LMatrix3d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LMatrix3d, scalar: float64): LMatrix3d {.importcpp: "#.operator /(#)".}

proc `+=`*(this: var LMatrix3d, other: LMatrix3d): LMatrix3d {.importcpp: "#.operator +=(#)".} ## \
## Performs a memberwise addition between two matrices.

proc `-=`*(this: var LMatrix3d, other: LMatrix3d): LMatrix3d {.importcpp: "#.operator -=(#)".} ## \
## Performs a memberwise subtraction between two matrices.

proc `*=`*(this: var LMatrix3d, other: LMatrix3d): LMatrix3d {.importcpp: "#.operator *=(#)".}

proc `*=`*(this: var LMatrix3d, scalar: float64): LMatrix3d {.importcpp: "#.operator *=(#)".} ## \
## Performs a memberwise scale.

proc `/=`*(this: var LMatrix3d, scalar: float64): LMatrix3d {.importcpp: "#.operator /=(#)".} ## \
## Performs a memberwise scale.

proc componentwiseMult*(this: LMatrix3d, other: LMatrix3d) {.importcpp: "#.componentwise_mult(#)".}

proc determinant*(this: LMatrix3d): float64 {.importcpp: "#.determinant()".} ## \
## Returns the determinant of the matrix.

proc transposeFrom*(this: LMatrix3d, other: LMatrix3d) {.importcpp: "#.transpose_from(#)".}

proc transposeInPlace*(this: LMatrix3d) {.importcpp: "#.transpose_in_place()".}

proc invertFrom*(this: LMatrix3d, other: LMatrix3d): bool {.importcpp: "#.invert_from(#)".} ## \
## Computes the inverse of the other matrix, and stores the result in this
## matrix.  This is a fully general operation and makes no assumptions about
## the type of transform represented by the matrix.
##
## The other matrix must be a different object than this matrix.  However, if
## you need to invert a matrix in place, see invert_in_place.
##
## The return value is true if the matrix was successfully inverted, false if
## there was a singularity.

proc invertInPlace*(this: LMatrix3d): bool {.importcpp: "#.invert_in_place()".} ## \
## Inverts the current matrix.  Returns true if the inverse is successful,
## false if the matrix was singular.

proc invertTransposeFrom*(this: LMatrix3d, other: LMatrix3d): bool {.importcpp: "#.invert_transpose_from(#)".} ## \
## Simultaneously computes the inverse of the indicated matrix, and then the
## transpose of that inverse.

proc invertTransposeFrom*(this: LMatrix3d, other: LMatrix4d): bool {.importcpp: "#.invert_transpose_from(#)".} ## \
## Simultaneously computes the inverse of the indicated matrix, and then the
## transpose of that inverse.

proc identMat*(_: typedesc[LMatrix3d]): LMatrix3d {.importcpp: "LMatrix3d::ident_mat()", header: "lmatrix.h".} ## \
## Returns an identity matrix.
##
## This function definition must appear first, since some inline functions
## below take advantage of it.

proc setTranslateMat*(this: LMatrix3d, trans: LVecBase2d) {.importcpp: "#.set_translate_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated translation.

proc setRotateMat*(this: LMatrix3d, angle: float64) {.importcpp: "#.set_rotate_mat(#)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise.

proc setRotateMat*(this: LMatrix3d, angle: float64, axis: LVecBase3d, cs: CoordinateSystem) {.importcpp: "#.set_rotate_mat(#, #, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc setRotateMat*(this: LMatrix3d, angle: float64, axis: LVecBase3d) {.importcpp: "#.set_rotate_mat(#, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc setScaleMat*(this: LMatrix3d, scale: LVecBase2d) {.importcpp: "#.set_scale_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated scale in each of the two
## axes.

proc setScaleMat*(this: LMatrix3d, scale: LVecBase3d) {.importcpp: "#.set_scale_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated scale in each of the
## three axes.

proc translateMat*(_: typedesc[LMatrix3d], trans: LVecBase2d): LMatrix3d {.importcpp: "#LMatrix3d::translate_mat(#)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated translation.

proc translateMat*(_: typedesc[LMatrix3d], tx: float64, ty: float64): LMatrix3d {.importcpp: "#LMatrix3d::translate_mat(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated translation.

proc rotateMat*(_: typedesc[LMatrix3d], angle: float64): LMatrix3d {.importcpp: "#LMatrix3d::rotate_mat(#)", header: "lmatrix.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise.

proc rotateMat*(_: typedesc[LMatrix3d], angle: float64, axis: LVecBase3d, cs: CoordinateSystem): LMatrix3d {.importcpp: "#LMatrix3d::rotate_mat(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc rotateMat*(_: typedesc[LMatrix3d], angle: float64, axis: LVecBase3d): LMatrix3d {.importcpp: "#LMatrix3d::rotate_mat(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc scaleMat*(_: typedesc[LMatrix3d], scale: LVecBase2d): LMatrix3d {.importcpp: "#LMatrix3d::scale_mat(#)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale in each of the two axes.

proc scaleMat*(_: typedesc[LMatrix3d], scale: LVecBase3d): LMatrix3d {.importcpp: "#LMatrix3d::scale_mat(#)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale in each of the three
## axes.

proc scaleMat*(_: typedesc[LMatrix3d], sx: float64, sy: float64): LMatrix3d {.importcpp: "#LMatrix3d::scale_mat(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale in each of the two axes.

proc scaleMat*(_: typedesc[LMatrix3d], sx: float64, sy: float64, sz: float64): LMatrix3d {.importcpp: "#LMatrix3d::scale_mat(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale in each of the three
## axes.

proc setRotateMatNormaxis*(this: LMatrix3d, angle: float64, axis: LVecBase3d, cs: CoordinateSystem) {.importcpp: "#.set_rotate_mat_normaxis(#, #, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## normalized.

proc setRotateMatNormaxis*(this: LMatrix3d, angle: float64, axis: LVecBase3d) {.importcpp: "#.set_rotate_mat_normaxis(#, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## normalized.

proc rotateMatNormaxis*(_: typedesc[LMatrix3d], angle: float64, axis: LVecBase3d, cs: CoordinateSystem): LMatrix3d {.importcpp: "#LMatrix3d::rotate_mat_normaxis(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## normalized.

proc rotateMatNormaxis*(_: typedesc[LMatrix3d], angle: float64, axis: LVecBase3d): LMatrix3d {.importcpp: "#LMatrix3d::rotate_mat_normaxis(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## normalized.

proc setShearMat*(this: LMatrix3d, shear: LVecBase3d, cs: CoordinateSystem) {.importcpp: "#.set_shear_mat(#, #)".} ## \
## Fills mat with a matrix that applies the indicated shear in each of the
## three planes.

proc setShearMat*(this: LMatrix3d, shear: LVecBase3d) {.importcpp: "#.set_shear_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated shear in each of the
## three planes.

proc shearMat*(_: typedesc[LMatrix3d], shear: LVecBase3d, cs: CoordinateSystem): LMatrix3d {.importcpp: "#LMatrix3d::shear_mat(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shearMat*(_: typedesc[LMatrix3d], shear: LVecBase3d): LMatrix3d {.importcpp: "#LMatrix3d::shear_mat(#)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shearMat*(_: typedesc[LMatrix3d], shxy: float64, shxz: float64, shyz: float64, cs: CoordinateSystem): LMatrix3d {.importcpp: "#LMatrix3d::shear_mat(#, #, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shearMat*(_: typedesc[LMatrix3d], shxy: float64, shxz: float64, shyz: float64): LMatrix3d {.importcpp: "#LMatrix3d::shear_mat(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc setScaleShearMat*(this: LMatrix3d, scale: LVecBase3d, shear: LVecBase3d, cs: CoordinateSystem) {.importcpp: "#.set_scale_shear_mat(#, #, #)".} ## \
## Fills mat with a matrix that applies the indicated scale and shear.

proc setScaleShearMat*(this: LMatrix3d, scale: LVecBase3d, shear: LVecBase3d) {.importcpp: "#.set_scale_shear_mat(#, #)".} ## \
## Fills mat with a matrix that applies the indicated scale and shear.

proc scaleShearMat*(_: typedesc[LMatrix3d], scale: LVecBase3d, shear: LVecBase3d, cs: CoordinateSystem): LMatrix3d {.importcpp: "#LMatrix3d::scale_shear_mat(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scaleShearMat*(_: typedesc[LMatrix3d], scale: LVecBase3d, shear: LVecBase3d): LMatrix3d {.importcpp: "#LMatrix3d::scale_shear_mat(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scaleShearMat*(_: typedesc[LMatrix3d], sx: float64, sy: float64, sz: float64, shxy: float64, shxz: float64, shyz: float64, cs: CoordinateSystem): LMatrix3d {.importcpp: "#LMatrix3d::scale_shear_mat(#, #, #, #, #, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scaleShearMat*(_: typedesc[LMatrix3d], sx: float64, sy: float64, sz: float64, shxy: float64, shxz: float64, shyz: float64): LMatrix3d {.importcpp: "#LMatrix3d::scale_shear_mat(#, #, #, #, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc convertMat*(_: typedesc[LMatrix3d], `from`: CoordinateSystem, to: CoordinateSystem): LMatrix3d {.importcpp: "#LMatrix3d::convert_mat(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that transforms from the indicated coordinate system to
## the indicated coordinate system.

proc almostEqual*(this: LMatrix3d, other: LMatrix3d): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two matrices are memberwise equal within a default
## tolerance based on the numeric type.

proc almostEqual*(this: LMatrix3d, other: LMatrix3d, threshold: float64): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two matrices are memberwise equal within a specified
## tolerance.

proc output*(this: LMatrix3d, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: LMatrix3d, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: LMatrix3d, `out`: ostream) {.importcpp: "#.write(#)".}

proc writeDatagramFixed*(this: LMatrix3d, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the matrix to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the matrix, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc readDatagramFixed*(this: LMatrix3d, scan: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the matrix from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc writeDatagram*(this: LMatrix3d, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the matrix to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the matrix using the standard width
## setting, especially when you are writing a bam file.

proc readDatagram*(this: LMatrix3d, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the matrix from the Datagram using get_stdfloat().

converter getClassType*(_: typedesc[LMatrix3d]): TypeHandle {.importcpp: "LMatrix3d::get_class_type()", header: "lmatrix.h".}

proc initLMatrix4d*(): LMatrix4d {.importcpp: "LMatrix4d()".}

converter initLMatrix4d*(upper3: LMatrix3d): LMatrix4d {.importcpp: "LMatrix4d(#)".} ## \
## Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
## translation component.

proc initLMatrix4d*(upper3: LMatrix3d, trans: LVecBase3d): LMatrix4d {.importcpp: "LMatrix4d(#, #)".}

proc initLMatrix4d*(other: LMatrix4d): LMatrix4d {.importcpp: "LMatrix4d(#)".}

proc initLMatrix4d*(param0: LVecBase4d, param1: LVecBase4d, param2: LVecBase4d, param3: LVecBase4d): LMatrix4d {.importcpp: "LMatrix4d(#, #, #, #)".} ## \
## Constructs the matrix from four individual rows.

converter initLMatrix4d*(other: UnalignedLMatrix4d): LMatrix4d {.importcpp: "LMatrix4d(#)".}

proc initLMatrix4d*(param0: float64, param1: float64, param2: float64, param3: float64, param4: float64, param5: float64, param6: float64, param7: float64, param8: float64, param9: float64, param10: float64, param11: float64, param12: float64, param13: float64, param14: float64, param15: float64): LMatrix4d {.importcpp: "LMatrix4d(#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)".}

proc fill*(this: LMatrix4d, fill_value: float64) {.importcpp: "#.fill(#)".} ## \
## Sets each element of the matrix to the indicated fill_value.  This is of
## questionable value, but is sometimes useful when initializing to zero.

proc set*(this: LMatrix4d, e00: float64, e01: float64, e02: float64, e03: float64, e10: float64, e11: float64, e12: float64, e13: float64, e20: float64, e21: float64, e22: float64, e23: float64, e30: float64, e31: float64, e32: float64, e33: float64) {.importcpp: "#.set(#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)".}

proc setUpper3*(this: LMatrix4d, upper3: LMatrix3d) {.importcpp: "#.set_upper_3(#)".} ## \
## Get and set the upper 3x3 rotation matrix.

proc getUpper3*(this: LMatrix4d): LMatrix3d {.importcpp: "#.get_upper_3()".} ## \
## Retrieves the upper 3x3 submatrix.

proc size*(_: typedesc[LMatrix4d]): int {.importcpp: "LMatrix4d::size()", header: "lmatrix.h".} ## \
## Returns 4: the number of rows of a LMatrix4.

proc setRow*(this: LMatrix4d, row: int, v: LVecBase3d) {.importcpp: "#.set_row(#, #)".} ## \
## Replaces the indicated row of the matrix with the indicated 3-component
## vector, ignoring the last column.

proc setRow*(this: LMatrix4d, row: int, v: LVecBase4d) {.importcpp: "#.set_row(#, #)".} ## \
## Replaces the indicated row of the matrix.

proc setCol*(this: LMatrix4d, col: int, v: LVecBase3d) {.importcpp: "#.set_col(#, #)".} ## \
## Replaces the indicated column of the matrix with the indicated 3-component
## vector, ignoring the last row.

proc setCol*(this: LMatrix4d, col: int, v: LVecBase4d) {.importcpp: "#.set_col(#, #)".} ## \
## Replaces the indicated column of the matrix.

proc getRow*(this: LMatrix4d, result_vec: LVecBase4d, row: int) {.importcpp: "#.get_row(#, #)".} ## \
## Stores the indicated row of the matrix as a 4-component vector.

proc getRow*(this: LMatrix4d, row: int): LVecBase4d {.importcpp: "#.get_row(#)".} ## \
## Retrieves the indicated row of the matrix as a 4-component vector.

proc getCol*(this: LMatrix4d, col: int): LVecBase4d {.importcpp: "#.get_col(#)".} ## \
## Retrieves the indicated column of the matrix as a 4-component vector.

proc getRow3*(this: LMatrix4d, result_vec: LVecBase3d, row: int) {.importcpp: "#.get_row3(#, #)".} ## \
## Stores the row column of the matrix as a 3-component vector, ignoring the
## last column.

proc getRow3*(this: LMatrix4d, row: int): LVecBase3d {.importcpp: "#.get_row3(#)".} ## \
## Retrieves the row column of the matrix as a 3-component vector, ignoring
## the last column.

proc getCol3*(this: LMatrix4d, col: int): LVecBase3d {.importcpp: "#.get_col3(#)".} ## \
## Retrieves the indicated column of the matrix as a 3-component vector,
## ignoring the last row.

proc isNan*(this: LMatrix4d): bool {.importcpp: "#.is_nan()".} ## \
## Returns true if any component of the matrix is not-a-number, false
## otherwise.

proc isIdentity*(this: LMatrix4d): bool {.importcpp: "#.is_identity()".} ## \
## Returns true if this is (close enough to) the identity matrix, false
## otherwise.

proc getCell*(this: LMatrix4d, row: int, col: int): float64 {.importcpp: "#.get_cell(#, #)".} ## \
## Returns a particular element of the matrix.

proc setCell*(this: LMatrix4d, row: int, col: int, value: float64) {.importcpp: "#.set_cell(#, #, #)".} ## \
## Changes a particular element of the matrix.

proc getData*(this: LMatrix4d) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the nine data elements in the matrix.
## The remaining elements occupy the next eight positions in row-major order.

proc getNumComponents*(this: LMatrix4d): int {.importcpp: "#.get_num_components()".} ## \
## Returns the number of elements in the matrix, 16.

proc begin*(this: LMatrix4d) {.importcpp: "#.begin()".} ## \
## Returns an iterator that may be used to traverse the elements of the
## matrix, STL-style.

proc `<`*(this: LMatrix4d, other: LMatrix4d): bool {.importcpp: "#.operator <(#)".}

proc `==`*(this: LMatrix4d, other: LMatrix4d): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: LMatrix4d, other: LMatrix4d): bool {.importcpp: "#.operator !=(#)".}

proc compareTo*(this: LMatrix4d, other: LMatrix4d): int {.importcpp: "#.compare_to(#)".} ## \
## This flavor of compare_to uses a default threshold value based on the
## numeric type.

proc compareTo*(this: LMatrix4d, other: LMatrix4d, threshold: float64): int {.importcpp: "#.compare_to(#, #)".} ## \
## Sorts matrices lexicographically, componentwise.  Returns a number less
## than 0 if this matrix sorts before the other one, greater than zero if it
## sorts after, 0 if they are equivalent (within the indicated tolerance).

proc getHash*(this: LMatrix4d): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a suitable hash for phash_map.

proc getHash*(this: LMatrix4d, threshold: float64): clonglong {.importcpp: "#.get_hash(#)".} ## \
## Returns a suitable hash for phash_map.

proc addHash*(this: LMatrix4d, hash: clonglong): clonglong {.importcpp: "#.add_hash(#)".} ## \
## Adds the vector into the running hash.

proc addHash*(this: LMatrix4d, hash: clonglong, threshold: float64): clonglong {.importcpp: "#.add_hash(#, #)".} ## \
## Adds the vector into the running hash.

proc xform*(this: LMatrix4d, v: LVecBase4d): LVecBase4d {.importcpp: "#.xform(#)".} ## \
## 4-component vector or point times matrix.  This is a fully general
## operation.

proc xformPoint*(this: LMatrix4d, v: LVecBase3d): LVecBase3d {.importcpp: "#.xform_point(#)".} ## \
## The matrix transforms a 3-component point (including translation component)
## and returns the result.  This assumes the matrix is an affine transform.

proc xformPointGeneral*(this: LMatrix4d, v: LVecBase3d): LVecBase3d {.importcpp: "#.xform_point_general(#)".} ## \
## The matrix transforms a 3-component point (including translation component)
## and returns the result, as a fully general operation.

proc xformVec*(this: LMatrix4d, v: LVecBase3d): LVecBase3d {.importcpp: "#.xform_vec(#)".} ## \
## The matrix transforms a 3-component vector (without translation component)
## and returns the result.  This assumes the matrix is an orthonormal
## transform.

proc xformVecGeneral*(this: LMatrix4d, v: LVecBase3d): LVecBase3d {.importcpp: "#.xform_vec_general(#)".} ## \
## The matrix transforms a 3-component vector (without translation component)
## and returns the result, as a fully general operation.

proc xformInPlace*(this: LMatrix4d, v: LVecBase4d) {.importcpp: "#.xform_in_place(#)".} ## \
## 4-component vector or point times matrix.  This is a fully general
## operation.

proc xformPointInPlace*(this: LMatrix4d, v: LVecBase3d) {.importcpp: "#.xform_point_in_place(#)".} ## \
## The matrix transforms a 3-component point (including translation
## component).  This assumes the matrix is an affine transform.

proc xformPointGeneralInPlace*(this: LMatrix4d, v: LVecBase3d) {.importcpp: "#.xform_point_general_in_place(#)".} ## \
## The matrix transforms a 3-component point (including translation
## component), as a fully general operation.

proc xformVecInPlace*(this: LMatrix4d, v: LVecBase3d) {.importcpp: "#.xform_vec_in_place(#)".} ## \
## The matrix transforms a 3-component vector (without translation component).
## This assumes the matrix is an orthonormal transform.

proc xformVecGeneralInPlace*(this: LMatrix4d, v: LVecBase3d) {.importcpp: "#.xform_vec_general_in_place(#)".} ## \
## The matrix transforms a 3-component vector (without translation component),
## as a fully general operation.

proc multiply*(this: LMatrix4d, other1: LMatrix4d, other2: LMatrix4d) {.importcpp: "#.multiply(#, #)".} ## \
## this = other1 \* other2

proc `*`*(this: LMatrix4d, other: LMatrix4d): LMatrix4d {.importcpp: "#.operator *(#)".}

proc `*`*(this: LMatrix4d, scalar: float64): LMatrix4d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LMatrix4d, scalar: float64): LMatrix4d {.importcpp: "#.operator /(#)".}

proc `+=`*(this: var LMatrix4d, other: LMatrix4d): LMatrix4d {.importcpp: "#.operator +=(#)".} ## \
## Performs a memberwise addition between two matrices.

proc `-=`*(this: var LMatrix4d, other: LMatrix4d): LMatrix4d {.importcpp: "#.operator -=(#)".} ## \
## Performs a memberwise subtraction between two matrices.

proc `*=`*(this: var LMatrix4d, other: LMatrix4d): LMatrix4d {.importcpp: "#.operator *=(#)".}

proc `*=`*(this: var LMatrix4d, scalar: float64): LMatrix4d {.importcpp: "#.operator *=(#)".}

proc `/=`*(this: var LMatrix4d, scalar: float64): LMatrix4d {.importcpp: "#.operator /=(#)".}

proc componentwiseMult*(this: LMatrix4d, other: LMatrix4d) {.importcpp: "#.componentwise_mult(#)".}

proc transposeFrom*(this: LMatrix4d, other: LMatrix4d) {.importcpp: "#.transpose_from(#)".}

proc transposeInPlace*(this: LMatrix4d) {.importcpp: "#.transpose_in_place()".}

proc invertFrom*(this: LMatrix4d, other: LMatrix4d): bool {.importcpp: "#.invert_from(#)".} ## \
## Computes the inverse of the other matrix, and stores the result in this
## matrix.  This is a fully general operation and makes no assumptions about
## the type of transform represented by the matrix.
##
## The other matrix must be a different object than this matrix.  However, if
## you need to invert a matrix in place, see invert_in_place.
##
## The return value is true if the matrix was successfully inverted, false if
## the was a singularity.

proc invertAffineFrom*(this: LMatrix4d, other: LMatrix4d): bool {.importcpp: "#.invert_affine_from(#)".} ## \
## bugbug: we could optimize this for rotationscaletranslation matrices
## (transpose upper 3x3 and take negative of translation component)

proc invertInPlace*(this: LMatrix4d): bool {.importcpp: "#.invert_in_place()".} ## \
## Inverts the current matrix.  Returns true if the inverse is successful,
## false if the matrix was singular.

proc accumulate*(this: LMatrix4d, other: LMatrix4d, weight: float64) {.importcpp: "#.accumulate(#, #)".} ## \
## Computes `(\*this) += other \* weight`.

proc identMat*(_: typedesc[LMatrix4d]): LMatrix4d {.importcpp: "LMatrix4d::ident_mat()", header: "lmatrix.h".} ## \
## Returns an identity matrix.
##
## This function definition must appear first, since some inline functions
## below take advantage of it.

proc onesMat*(_: typedesc[LMatrix4d]): LMatrix4d {.importcpp: "LMatrix4d::ones_mat()", header: "lmatrix.h".} ## \
## Returns an matrix filled with ones.

proc zerosMat*(_: typedesc[LMatrix4d]): LMatrix4d {.importcpp: "LMatrix4d::zeros_mat()", header: "lmatrix.h".} ## \
## Returns an matrix filled with zeros.

proc setTranslateMat*(this: LMatrix4d, trans: LVecBase3d) {.importcpp: "#.set_translate_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated translation.

proc setRotateMat*(this: LMatrix4d, angle: float64, axis: LVecBase3d, cs: CoordinateSystem) {.importcpp: "#.set_rotate_mat(#, #, #)".} ## \
## Sets mat to a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc setRotateMat*(this: LMatrix4d, angle: float64, axis: LVecBase3d) {.importcpp: "#.set_rotate_mat(#, #)".} ## \
## Sets mat to a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc setRotateMatNormaxis*(this: LMatrix4d, angle: float64, axis: LVecBase3d, cs: CoordinateSystem) {.importcpp: "#.set_rotate_mat_normaxis(#, #, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## prenormalized.

proc setRotateMatNormaxis*(this: LMatrix4d, angle: float64, axis: LVecBase3d) {.importcpp: "#.set_rotate_mat_normaxis(#, #)".} ## \
## Fills mat with a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## prenormalized.

proc setScaleMat*(this: LMatrix4d, scale: LVecBase3d) {.importcpp: "#.set_scale_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated scale in each of the
## three axes.

proc setShearMat*(this: LMatrix4d, shear: LVecBase3d, cs: CoordinateSystem) {.importcpp: "#.set_shear_mat(#, #)".} ## \
## Fills mat with a matrix that applies the indicated shear in each of the
## three planes.

proc setShearMat*(this: LMatrix4d, shear: LVecBase3d) {.importcpp: "#.set_shear_mat(#)".} ## \
## Fills mat with a matrix that applies the indicated shear in each of the
## three planes.

proc setScaleShearMat*(this: LMatrix4d, scale: LVecBase3d, shear: LVecBase3d, cs: CoordinateSystem) {.importcpp: "#.set_scale_shear_mat(#, #, #)".} ## \
## Fills mat with a matrix that applies the indicated scale and shear.

proc setScaleShearMat*(this: LMatrix4d, scale: LVecBase3d, shear: LVecBase3d) {.importcpp: "#.set_scale_shear_mat(#, #)".} ## \
## Fills mat with a matrix that applies the indicated scale and shear.

proc translateMat*(_: typedesc[LMatrix4d], trans: LVecBase3d): LMatrix4d {.importcpp: "#LMatrix4d::translate_mat(#)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated translation.

proc translateMat*(_: typedesc[LMatrix4d], tx: float64, ty: float64, tz: float64): LMatrix4d {.importcpp: "#LMatrix4d::translate_mat(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated translation.

proc rotateMat*(_: typedesc[LMatrix4d], angle: float64, axis: LVecBase3d, cs: CoordinateSystem): LMatrix4d {.importcpp: "#LMatrix4d::rotate_mat(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc rotateMat*(_: typedesc[LMatrix4d], angle: float64, axis: LVecBase3d): LMatrix4d {.importcpp: "#LMatrix4d::rotate_mat(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.

proc rotateMatNormaxis*(_: typedesc[LMatrix4d], angle: float64, axis: LVecBase3d, cs: CoordinateSystem): LMatrix4d {.importcpp: "#LMatrix4d::rotate_mat_normaxis(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## prenormalized.

proc rotateMatNormaxis*(_: typedesc[LMatrix4d], angle: float64, axis: LVecBase3d): LMatrix4d {.importcpp: "#LMatrix4d::rotate_mat_normaxis(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that rotates by the given angle in degrees
## counterclockwise about the indicated vector.  Assumes axis has been
## prenormalized.

proc scaleMat*(_: typedesc[LMatrix4d], scale: LVecBase3d): LMatrix4d {.importcpp: "#LMatrix4d::scale_mat(#)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale in each of the three
## axes.

proc scaleMat*(_: typedesc[LMatrix4d], scale: float64): LMatrix4d {.importcpp: "#LMatrix4d::scale_mat(#)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated uniform scale.

proc scaleMat*(_: typedesc[LMatrix4d], sx: float64, sy: float64, sz: float64): LMatrix4d {.importcpp: "#LMatrix4d::scale_mat(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale in each of the three
## axes.

proc shearMat*(_: typedesc[LMatrix4d], shear: LVecBase3d, cs: CoordinateSystem): LMatrix4d {.importcpp: "#LMatrix4d::shear_mat(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shearMat*(_: typedesc[LMatrix4d], shear: LVecBase3d): LMatrix4d {.importcpp: "#LMatrix4d::shear_mat(#)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shearMat*(_: typedesc[LMatrix4d], shxy: float64, shxz: float64, shyz: float64, cs: CoordinateSystem): LMatrix4d {.importcpp: "#LMatrix4d::shear_mat(#, #, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc shearMat*(_: typedesc[LMatrix4d], shxy: float64, shxz: float64, shyz: float64): LMatrix4d {.importcpp: "#LMatrix4d::shear_mat(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated shear in each of the three
## planes.

proc scaleShearMat*(_: typedesc[LMatrix4d], scale: LVecBase3d, shear: LVecBase3d, cs: CoordinateSystem): LMatrix4d {.importcpp: "#LMatrix4d::scale_shear_mat(#, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scaleShearMat*(_: typedesc[LMatrix4d], scale: LVecBase3d, shear: LVecBase3d): LMatrix4d {.importcpp: "#LMatrix4d::scale_shear_mat(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scaleShearMat*(_: typedesc[LMatrix4d], sx: float64, sy: float64, sz: float64, shxy: float64, shxz: float64, shyz: float64, cs: CoordinateSystem): LMatrix4d {.importcpp: "#LMatrix4d::scale_shear_mat(#, #, #, #, #, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc scaleShearMat*(_: typedesc[LMatrix4d], sx: float64, sy: float64, sz: float64, shxy: float64, shxz: float64, shyz: float64): LMatrix4d {.importcpp: "#LMatrix4d::scale_shear_mat(#, #, #, #, #, #)", header: "lmatrix.h".} ## \
## Returns a matrix that applies the indicated scale and shear.

proc yToZUpMat*(_: typedesc[LMatrix4d]): LMatrix4d {.importcpp: "LMatrix4d::y_to_z_up_mat()", header: "lmatrix.h".} ## \
## Returns a matrix that transforms from the Y-up coordinate system to the
## Z-up coordinate system.

proc zToYUpMat*(_: typedesc[LMatrix4d]): LMatrix4d {.importcpp: "LMatrix4d::z_to_y_up_mat()", header: "lmatrix.h".} ## \
## Returns a matrix that transforms from the Y-up coordinate system to the
## Z-up coordinate system.

proc convertMat*(_: typedesc[LMatrix4d], `from`: CoordinateSystem, to: CoordinateSystem): LMatrix4d {.importcpp: "#LMatrix4d::convert_mat(#, #)", header: "lmatrix.h".} ## \
## Returns a matrix that transforms from the indicated coordinate system to
## the indicated coordinate system.

proc almostEqual*(this: LMatrix4d, other: LMatrix4d): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two matrices are memberwise equal within a default
## tolerance based on the numeric type.

proc almostEqual*(this: LMatrix4d, other: LMatrix4d, threshold: float64): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two matrices are memberwise equal within a specified
## tolerance.  This is faster than the equivalence operator as this doesn't
## have to guarantee that it is transitive.

proc output*(this: LMatrix4d, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: LMatrix4d, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: LMatrix4d, `out`: ostream) {.importcpp: "#.write(#)".}

proc writeDatagramFixed*(this: LMatrix4d, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the matrix to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the matrix, regardless of the setting of
## Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc readDatagramFixed*(this: LMatrix4d, scan: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the matrix from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc writeDatagram*(this: LMatrix4d, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the matrix to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the matrix using the standard width
## setting, especially when you are writing a bam file.

proc readDatagram*(this: LMatrix4d, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the matrix from the Datagram using get_stdfloat().

converter getClassType*(_: typedesc[LMatrix4d]): TypeHandle {.importcpp: "LMatrix4d::get_class_type()", header: "lmatrix.h".}

proc initUnalignedLMatrix4d*(): UnalignedLMatrix4d {.importcpp: "UnalignedLMatrix4d()".}

converter initUnalignedLMatrix4d*(copy: LMatrix4d): UnalignedLMatrix4d {.importcpp: "UnalignedLMatrix4d(#)".}

proc initUnalignedLMatrix4d*(copy: UnalignedLMatrix4d): UnalignedLMatrix4d {.importcpp: "UnalignedLMatrix4d(#)".}

proc initUnalignedLMatrix4d*(e00: float64, e01: float64, e02: float64, e03: float64, e10: float64, e11: float64, e12: float64, e13: float64, e20: float64, e21: float64, e22: float64, e23: float64, e30: float64, e31: float64, e32: float64, e33: float64): UnalignedLMatrix4d {.importcpp: "UnalignedLMatrix4d(#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)".}

proc set*(this: UnalignedLMatrix4d, e00: float64, e01: float64, e02: float64, e03: float64, e10: float64, e11: float64, e12: float64, e13: float64, e20: float64, e21: float64, e22: float64, e23: float64, e30: float64, e31: float64, e32: float64, e33: float64) {.importcpp: "#.set(#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #)".}

proc getData*(this: UnalignedLMatrix4d) {.importcpp: "#.get_data()".} ## \
## Returns the address of the first of the nine data elements in the matrix.
## The remaining elements occupy the next eight positions in row-major order.

proc getNumComponents*(this: UnalignedLMatrix4d): int {.importcpp: "#.get_num_components()".} ## \
## Returns the number of elements in the matrix, sixteen.

proc `==`*(this: UnalignedLMatrix4d, other: UnalignedLMatrix4d): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: UnalignedLMatrix4d, other: UnalignedLMatrix4d): bool {.importcpp: "#.operator !=(#)".}

converter getClassType*(_: typedesc[UnalignedLMatrix4d]): TypeHandle {.importcpp: "UnalignedLMatrix4d::get_class_type()", header: "lmatrix.h".}

proc `*`*(m: LMatrix3d, q: LQuaterniond): LMatrix3d {.importcpp: "operator *(#, #)".}

proc `*`*(m: LMatrix3f, q: LQuaternionf): LMatrix3f {.importcpp: "operator *(#, #)".}

proc `*`*(m: LMatrix4d, q: LQuaterniond): LMatrix4d {.importcpp: "operator *(#, #)".}

proc `*`*(m: LMatrix4f, q: LQuaternionf): LMatrix4f {.importcpp: "operator *(#, #)".}

proc `*`*(v: LPoint2d, m: LMatrix3d): LPoint2d {.importcpp: "operator *(#, #)".}

proc `*`*(v: LPoint2f, m: LMatrix3f): LPoint2f {.importcpp: "operator *(#, #)".}

proc `*`*(v: LPoint3d, m: LMatrix3d): LPoint3d {.importcpp: "operator *(#, #)".}

proc `*`*(v: LPoint3d, m: LMatrix4d): LPoint3d {.importcpp: "operator *(#, #)".}

proc `*`*(v: LPoint3f, m: LMatrix3f): LPoint3f {.importcpp: "operator *(#, #)".}

proc `*`*(v: LPoint3f, m: LMatrix4f): LPoint3f {.importcpp: "operator *(#, #)".}

proc `*`*(v: LPoint4d, m: LMatrix4d): LPoint4d {.importcpp: "operator *(#, #)".}

proc `*`*(v: LPoint4f, m: LMatrix4f): LPoint4f {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVecBase3d, m: LMatrix3d): LVecBase3d {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVecBase3f, m: LMatrix3f): LVecBase3f {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVecBase4d, m: LMatrix4d): LVecBase4d {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVecBase4f, m: LMatrix4f): LVecBase4f {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVector2d, m: LMatrix3d): LVector2d {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVector2f, m: LMatrix3f): LVector2f {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVector3d, m: LMatrix3d): LVector3d {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVector3d, m: LMatrix4d): LVector3d {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVector3f, m: LMatrix3f): LVector3f {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVector3f, m: LMatrix4f): LVector3f {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVector4d, m: LMatrix4d): LVector4d {.importcpp: "operator *(#, #)".}

proc `*`*(v: LVector4f, m: LMatrix4f): LVector4f {.importcpp: "operator *(#, #)".}

proc `*=`*(v: LPoint2d, m: LMatrix3d) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LPoint2f, m: LMatrix3f) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LPoint3d, m: LMatrix3d) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LPoint3d, m: LMatrix4d) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LPoint3f, m: LMatrix3f) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LPoint3f, m: LMatrix4f) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LVecBase3d, m: LMatrix3d) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LVecBase3f, m: LMatrix3f) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LVecBase4d, m: LMatrix4d) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LVecBase4f, m: LMatrix4f) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LVector2d, m: LMatrix3d) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LVector2f, m: LMatrix3f) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LVector3d, m: LMatrix3d) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LVector3d, m: LMatrix4d) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LVector3f, m: LMatrix3f) {.importcpp: "operator *=(#, #)".}

proc `*=`*(v: LVector3f, m: LMatrix4f) {.importcpp: "operator *=(#, #)".}

proc genericWriteDatagram*(dest: Datagram, value: LMatrix3d) {.importcpp: "generic_write_datagram(#, #)".}

proc genericWriteDatagram*(dest: Datagram, value: LMatrix3f) {.importcpp: "generic_write_datagram(#, #)".}

proc genericWriteDatagram*(dest: Datagram, value: LMatrix4d) {.importcpp: "generic_write_datagram(#, #)".}

proc genericWriteDatagram*(dest: Datagram, value: LMatrix4f) {.importcpp: "generic_write_datagram(#, #)".}

proc genericReadDatagram*(result: LMatrix3d, source: DatagramIterator) {.importcpp: "generic_read_datagram(#, #)".}

proc genericReadDatagram*(result: LMatrix3f, source: DatagramIterator) {.importcpp: "generic_read_datagram(#, #)".}

proc genericReadDatagram*(result: LMatrix4d, source: DatagramIterator) {.importcpp: "generic_read_datagram(#, #)".}

proc genericReadDatagram*(result: LMatrix4f, source: DatagramIterator) {.importcpp: "generic_read_datagram(#, #)".}

proc composeMatrix*(mat: LMatrix3d, scale: LVecBase3d, hpr: LVecBase3d, cs: CoordinateSystem) {.importcpp: "compose_matrix(#, #, #, #)".}

proc composeMatrix*(mat: LMatrix3d, scale: LVecBase3d, hpr: LVecBase3d) {.importcpp: "compose_matrix(#, #, #)".}

proc composeMatrix*(mat: LMatrix3d, scale: LVecBase3d, shear: LVecBase3d, hpr: LVecBase3d, cs: CoordinateSystem) {.importcpp: "compose_matrix(#, #, #, #, #)".}

proc composeMatrix*(mat: LMatrix3d, scale: LVecBase3d, shear: LVecBase3d, hpr: LVecBase3d) {.importcpp: "compose_matrix(#, #, #, #)".}

proc composeMatrix*(mat: LMatrix3f, scale: LVecBase3f, hpr: LVecBase3f, cs: CoordinateSystem) {.importcpp: "compose_matrix(#, #, #, #)".}

proc composeMatrix*(mat: LMatrix3f, scale: LVecBase3f, hpr: LVecBase3f) {.importcpp: "compose_matrix(#, #, #)".}

proc composeMatrix*(mat: LMatrix3f, scale: LVecBase3f, shear: LVecBase3f, hpr: LVecBase3f, cs: CoordinateSystem) {.importcpp: "compose_matrix(#, #, #, #, #)".}

proc composeMatrix*(mat: LMatrix3f, scale: LVecBase3f, shear: LVecBase3f, hpr: LVecBase3f) {.importcpp: "compose_matrix(#, #, #, #)".}

proc composeMatrix*(mat: LMatrix4d, scale: LVecBase3d, hpr: LVecBase3d, translate: LVecBase3d, cs: CoordinateSystem) {.importcpp: "compose_matrix(#, #, #, #, #)".}

proc composeMatrix*(mat: LMatrix4d, scale: LVecBase3d, hpr: LVecBase3d, translate: LVecBase3d) {.importcpp: "compose_matrix(#, #, #, #)".}

proc composeMatrix*(mat: LMatrix4d, scale: LVecBase3d, shear: LVecBase3d, hpr: LVecBase3d, translate: LVecBase3d, cs: CoordinateSystem) {.importcpp: "compose_matrix(#, #, #, #, #, #)".}

proc composeMatrix*(mat: LMatrix4d, scale: LVecBase3d, shear: LVecBase3d, hpr: LVecBase3d, translate: LVecBase3d) {.importcpp: "compose_matrix(#, #, #, #, #)".}

proc composeMatrix*(mat: LMatrix4f, scale: LVecBase3f, hpr: LVecBase3f, translate: LVecBase3f, cs: CoordinateSystem) {.importcpp: "compose_matrix(#, #, #, #, #)".}

proc composeMatrix*(mat: LMatrix4f, scale: LVecBase3f, hpr: LVecBase3f, translate: LVecBase3f) {.importcpp: "compose_matrix(#, #, #, #)".}

proc composeMatrix*(mat: LMatrix4f, scale: LVecBase3f, shear: LVecBase3f, hpr: LVecBase3f, translate: LVecBase3f, cs: CoordinateSystem) {.importcpp: "compose_matrix(#, #, #, #, #, #)".}

proc composeMatrix*(mat: LMatrix4f, scale: LVecBase3f, shear: LVecBase3f, hpr: LVecBase3f, translate: LVecBase3f) {.importcpp: "compose_matrix(#, #, #, #, #)".}

proc decomposeMatrix*(mat: LMatrix3d, scale: LVecBase3d, hpr: LVecBase3d, cs: CoordinateSystem): bool {.importcpp: "decompose_matrix(#, #, #, #)".}

proc decomposeMatrix*(mat: LMatrix3d, scale: LVecBase3d, hpr: LVecBase3d): bool {.importcpp: "decompose_matrix(#, #, #)".}

proc decomposeMatrix*(mat: LMatrix3d, scale: LVecBase3d, shear: LVecBase3d, hpr: LVecBase3d, cs: CoordinateSystem): bool {.importcpp: "decompose_matrix(#, #, #, #, #)".}

proc decomposeMatrix*(mat: LMatrix3d, scale: LVecBase3d, shear: LVecBase3d, hpr: LVecBase3d): bool {.importcpp: "decompose_matrix(#, #, #, #)".}

proc decomposeMatrix*(mat: LMatrix3f, scale: LVecBase3f, hpr: LVecBase3f, cs: CoordinateSystem): bool {.importcpp: "decompose_matrix(#, #, #, #)".}

proc decomposeMatrix*(mat: LMatrix3f, scale: LVecBase3f, hpr: LVecBase3f): bool {.importcpp: "decompose_matrix(#, #, #)".}

proc decomposeMatrix*(mat: LMatrix3f, scale: LVecBase3f, shear: LVecBase3f, hpr: LVecBase3f, cs: CoordinateSystem): bool {.importcpp: "decompose_matrix(#, #, #, #, #)".}

proc decomposeMatrix*(mat: LMatrix3f, scale: LVecBase3f, shear: LVecBase3f, hpr: LVecBase3f): bool {.importcpp: "decompose_matrix(#, #, #, #)".}

proc decomposeMatrix*(mat: LMatrix4d, scale: LVecBase3d, hpr: LVecBase3d, translate: LVecBase3d, cs: CoordinateSystem): bool {.importcpp: "decompose_matrix(#, #, #, #, #)".}

proc decomposeMatrix*(mat: LMatrix4d, scale: LVecBase3d, hpr: LVecBase3d, translate: LVecBase3d): bool {.importcpp: "decompose_matrix(#, #, #, #)".}

proc decomposeMatrix*(mat: LMatrix4d, scale: LVecBase3d, shear: LVecBase3d, hpr: LVecBase3d, translate: LVecBase3d, cs: CoordinateSystem): bool {.importcpp: "decompose_matrix(#, #, #, #, #, #)".}

proc decomposeMatrix*(mat: LMatrix4d, scale: LVecBase3d, shear: LVecBase3d, hpr: LVecBase3d, translate: LVecBase3d): bool {.importcpp: "decompose_matrix(#, #, #, #, #)".}

proc decomposeMatrix*(mat: LMatrix4f, scale: LVecBase3f, hpr: LVecBase3f, translate: LVecBase3f, cs: CoordinateSystem): bool {.importcpp: "decompose_matrix(#, #, #, #, #)".}

proc decomposeMatrix*(mat: LMatrix4f, scale: LVecBase3f, hpr: LVecBase3f, translate: LVecBase3f): bool {.importcpp: "decompose_matrix(#, #, #, #)".}

proc decomposeMatrix*(mat: LMatrix4f, scale: LVecBase3f, shear: LVecBase3f, hpr: LVecBase3f, translate: LVecBase3f, cs: CoordinateSystem): bool {.importcpp: "decompose_matrix(#, #, #, #, #, #)".}

proc decomposeMatrix*(mat: LMatrix4f, scale: LVecBase3f, shear: LVecBase3f, hpr: LVecBase3f, translate: LVecBase3f): bool {.importcpp: "decompose_matrix(#, #, #, #, #)".}

proc decomposeMatrixOldHpr*(mat: LMatrix3d, scale: LVecBase3d, shear: LVecBase3d, hpr: LVecBase3d, cs: CoordinateSystem): bool {.importcpp: "decompose_matrix_old_hpr(#, #, #, #, #)".}

proc decomposeMatrixOldHpr*(mat: LMatrix3d, scale: LVecBase3d, shear: LVecBase3d, hpr: LVecBase3d): bool {.importcpp: "decompose_matrix_old_hpr(#, #, #, #)".}

proc decomposeMatrixOldHpr*(mat: LMatrix3f, scale: LVecBase3f, shear: LVecBase3f, hpr: LVecBase3f, cs: CoordinateSystem): bool {.importcpp: "decompose_matrix_old_hpr(#, #, #, #, #)".}

proc decomposeMatrixOldHpr*(mat: LMatrix3f, scale: LVecBase3f, shear: LVecBase3f, hpr: LVecBase3f): bool {.importcpp: "decompose_matrix_old_hpr(#, #, #, #)".}

proc oldToNewHpr*(old_hpr: LVecBase3d): LVecBase3d {.importcpp: "old_to_new_hpr(#)".}

proc oldToNewHpr*(old_hpr: LVecBase3f): LVecBase3f {.importcpp: "old_to_new_hpr(#)".}

proc initLQuaternionf*(): LQuaternionf {.importcpp: "LQuaternionf()".}

proc initLQuaternionf*(param0: LQuaternionf): LQuaternionf {.importcpp: "LQuaternionf(#)".}

converter initLQuaternionf*(copy: LVecBase4f): LQuaternionf {.importcpp: "LQuaternionf(#)".}

proc initLQuaternionf*(r: float32, copy: LVecBase3f): LQuaternionf {.importcpp: "LQuaternionf(#, #)".}

proc initLQuaternionf*(r: float32, i: float32, j: float32, k: float32): LQuaternionf {.importcpp: "LQuaternionf(#, #, #, #)".}

proc pureImaginary*(_: typedesc[LQuaternionf], v: LVector3f): LQuaternionf {.importcpp: "#LQuaternionf::pure_imaginary(#)", header: "lquaternion.h".}

proc conjugate*(this: LQuaternionf): LQuaternionf {.importcpp: "#.conjugate()".} ## \
## Returns the complex conjugate of this quat.

proc xform*(this: LQuaternionf, v: LVecBase3f): LVecBase3f {.importcpp: "#.xform(#)".} ## \
## Transforms a 3-d vector by the indicated rotation

proc xform*(this: LQuaternionf, v: LVecBase4f): LVecBase4f {.importcpp: "#.xform(#)".} ## \
## Transforms a 4-d vector by the indicated rotation

proc multiply*(this: LQuaternionf, rhs: LQuaternionf): LQuaternionf {.importcpp: "#.multiply(#)".} ## \
## actual multiply call (non virtual)

proc `-`*(this: LQuaternionf): LQuaternionf {.importcpp: "#.operator -()".}

proc `+`*(this: LQuaternionf, other: LQuaternionf): LQuaternionf {.importcpp: "#.operator +(#)".}

proc `-`*(this: LQuaternionf, other: LQuaternionf): LQuaternionf {.importcpp: "#.operator -(#)".}

proc angleRad*(this: LQuaternionf, other: LQuaternionf): float32 {.importcpp: "#.angle_rad(#)".} ## \
## Returns the angle between the orientation represented by this quaternion
## and the other one, expressed in radians.

proc angleDeg*(this: LQuaternionf, other: LQuaternionf): float32 {.importcpp: "#.angle_deg(#)".} ## \
## Returns the angle between the orientation represented by this quaternion
## and the other one, expressed in degrees.

proc `*`*(this: LQuaternionf, param0: LMatrix3f): LMatrix3f {.importcpp: "#.operator *(#)".}

proc `*`*(this: LQuaternionf, param0: LMatrix4f): LMatrix4f {.importcpp: "#.operator *(#)".}

proc `/`*(this: LQuaternionf, scalar: float32): LQuaternionf {.importcpp: "#.operator /(#)".}

proc `*=`*(this: var LQuaternionf, param0: LQuaternionf): LQuaternionf {.importcpp: "#.operator *=(#)".}

proc almostEqual*(this: LQuaternionf, other: LQuaternionf): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two quaternions are memberwise equal within a default
## tolerance based on the numeric type.

proc almostEqual*(this: LQuaternionf, other: LQuaternionf, threshold: float32): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two quaternions are memberwise equal within a specified
## tolerance.

proc isSameDirection*(this: LQuaternionf, other: LQuaternionf): bool {.importcpp: "#.is_same_direction(#)".} ## \
## Returns true if two quaternions represent the same rotation within a
## default tolerance based on the numeric type.

proc almostSameDirection*(this: LQuaternionf, other: LQuaternionf, threshold: float32): bool {.importcpp: "#.almost_same_direction(#, #)".} ## \
## Returns true if two quaternions represent the same rotation within a
## specified tolerance.

proc output*(this: LQuaternionf, param0: ostream) {.importcpp: "#.output(#)".}

proc extractToMatrix*(this: LQuaternionf, m: LMatrix3f) {.importcpp: "#.extract_to_matrix(#)".} ## \
## Based on the quat lib from VRPN.

proc extractToMatrix*(this: LQuaternionf, m: LMatrix4f) {.importcpp: "#.extract_to_matrix(#)".} ## \
## Based on the quat lib from VRPN.

proc setFromMatrix*(this: LQuaternionf, m: LMatrix3f) {.importcpp: "#.set_from_matrix(#)".} ## \
## Sets the quaternion according to the rotation represented by the matrix.
## Originally we tried an algorithm presented by Do-While Jones, but that
## turned out to be broken.  This is based on the quat lib from UNC.

proc setFromMatrix*(this: LQuaternionf, m: LMatrix4f) {.importcpp: "#.set_from_matrix(#)".}

proc setHpr*(this: LQuaternionf, hpr: LVecBase3f, cs: CoordinateSystem) {.importcpp: "#.set_hpr(#, #)".} ## \
## Sets the quaternion as the unit quaternion that is equivalent to these
## Euler angles.  (from Real-time Rendering, p.49)

proc setHpr*(this: LQuaternionf, hpr: LVecBase3f) {.importcpp: "#.set_hpr(#)".} ## \
## Sets the quaternion as the unit quaternion that is equivalent to these
## Euler angles.  (from Real-time Rendering, p.49)

proc getHpr*(this: LQuaternionf, cs: CoordinateSystem): LVecBase3f {.importcpp: "#.get_hpr(#)".} ## \
## Extracts the equivalent Euler angles from the unit quaternion.

proc getHpr*(this: LQuaternionf): LVecBase3f {.importcpp: "#.get_hpr()".} ## \
## Extracts the equivalent Euler angles from the unit quaternion.

proc getAxis*(this: LQuaternionf): LVector3f {.importcpp: "#.get_axis()".} ## \
## This, along with get_angle(), returns the rotation represented by the
## quaternion as an angle about an arbitrary axis.  This returns the axis; it
## is not normalized.

proc getAxisNormalized*(this: LQuaternionf): LVector3f {.importcpp: "#.get_axis_normalized()".} ## \
## This, along with get_angle(), returns the rotation represented by the
## quaternion as an angle about an arbitrary axis.  This returns the
## normalized axis.

proc getAngleRad*(this: LQuaternionf): float32 {.importcpp: "#.get_angle_rad()".} ## \
## This, along with get_axis(), returns the rotation represented by the
## quaternion as an angle about an arbitrary axis.  This returns the angle, in
## radians counterclockwise about the axis.
##
## It is necessary to ensure the quaternion has been normalized (for instance,
## with a call to normalize()) before calling this method.

proc getAngle*(this: LQuaternionf): float32 {.importcpp: "#.get_angle()".} ## \
## This, along with get_axis(), returns the rotation represented by the
## quaternion as an angle about an arbitrary axis.  This returns the angle, in
## degrees counterclockwise about the axis.
##
## It is necessary to ensure the quaternion has been normalized (for instance,
## with a call to normalize()) before calling this method.

proc setFromAxisAngleRad*(this: LQuaternionf, angle_rad: float32, axis: LVector3f) {.importcpp: "#.set_from_axis_angle_rad(#, #)".} ## \
## angle_rad is the angle about the axis in radians.  axis must be normalized.

proc setFromAxisAngle*(this: LQuaternionf, angle_deg: float32, axis: LVector3f) {.importcpp: "#.set_from_axis_angle(#, #)".} ## \
## angle_deg is the angle about the axis in degrees.  axis must be normalized.

proc getUp*(this: LQuaternionf, cs: CoordinateSystem): LVector3f {.importcpp: "#.get_up(#)".} ## \
## Returns the orientation represented by this quaternion, expressed as an up
## vector.

proc getUp*(this: LQuaternionf): LVector3f {.importcpp: "#.get_up()".} ## \
## Returns the orientation represented by this quaternion, expressed as an up
## vector.

proc getRight*(this: LQuaternionf, cs: CoordinateSystem): LVector3f {.importcpp: "#.get_right(#)".} ## \
## Returns the orientation represented by this quaternion, expressed as a
## right vector.

proc getRight*(this: LQuaternionf): LVector3f {.importcpp: "#.get_right()".} ## \
## Returns the orientation represented by this quaternion, expressed as a
## right vector.

proc getForward*(this: LQuaternionf, cs: CoordinateSystem): LVector3f {.importcpp: "#.get_forward(#)".} ## \
## Returns the orientation represented by this quaternion, expressed as a
## forward vector.

proc getForward*(this: LQuaternionf): LVector3f {.importcpp: "#.get_forward()".} ## \
## Returns the orientation represented by this quaternion, expressed as a
## forward vector.

proc getR*(this: LQuaternionf): float32 {.importcpp: "#.get_r()".}

proc getI*(this: LQuaternionf): float32 {.importcpp: "#.get_i()".}

proc getJ*(this: LQuaternionf): float32 {.importcpp: "#.get_j()".}

proc getK*(this: LQuaternionf): float32 {.importcpp: "#.get_k()".}

proc setR*(this: LQuaternionf, r: float32) {.importcpp: "#.set_r(#)".}

proc setI*(this: LQuaternionf, i: float32) {.importcpp: "#.set_i(#)".}

proc setJ*(this: LQuaternionf, j: float32) {.importcpp: "#.set_j(#)".}

proc setK*(this: LQuaternionf, k: float32) {.importcpp: "#.set_k(#)".}

proc normalize*(this: LQuaternionf): bool {.importcpp: "#.normalize()".}

proc conjugateFrom*(this: LQuaternionf, other: LQuaternionf): bool {.importcpp: "#.conjugate_from(#)".} ## \
## Computes the conjugate of the other quat, and stores the result in this
## quat.  This is a fully general operation and makes no assumptions about the
## type of transform represented by the quat.
##
## The other quat must be a different object than this quat.  However, if you
## need to get a conjugate of a quat in place, see conjugate_in_place.
##
## The return value is true if the quat was successfully inverted, false if
## there was a singularity.

proc conjugateInPlace*(this: LQuaternionf): bool {.importcpp: "#.conjugate_in_place()".} ## \
## Sets this to be the conjugate of the current quat.  Returns true if the
## successful, false if the quat was singular.

proc invertFrom*(this: LQuaternionf, other: LQuaternionf): bool {.importcpp: "#.invert_from(#)".} ## \
## Computes the inverse of the other quat, and stores the result in this quat.
## This is a fully general operation and makes no assumptions about the type
## of transform represented by the quat.
##
## The other quat must be a different object than this quat.  However, if you
## need to invert a quat in place, see invert_in_place.
##
## The return value is true if the quat was successfully inverted, false if
## there was a singularity.

proc invertInPlace*(this: LQuaternionf): bool {.importcpp: "#.invert_in_place()".} ## \
## Inverts the current quat.  Returns true if the inverse is successful, false
## if the quat was singular.

proc isIdentity*(this: LQuaternionf): bool {.importcpp: "#.is_identity()".} ## \
## Returns true if this quaternion represents the identity transformation: no
## rotation.

proc isAlmostIdentity*(this: LQuaternionf, tolerance: float32): bool {.importcpp: "#.is_almost_identity(#)".} ## \
## Returns true if this quaternion represents the identity transformation
## within a given tolerance.

proc identQuat*(_: typedesc[LQuaternionf]): LQuaternionf {.importcpp: "LQuaternionf::ident_quat()", header: "lquaternion.h".} ## \
## Returns an identity quaternion.

converter getClassType*(_: typedesc[LQuaternionf]): TypeHandle {.importcpp: "LQuaternionf::get_class_type()", header: "lquaternion.h".}

proc initLQuaterniond*(): LQuaterniond {.importcpp: "LQuaterniond()".}

proc initLQuaterniond*(param0: LQuaterniond): LQuaterniond {.importcpp: "LQuaterniond(#)".}

converter initLQuaterniond*(copy: LVecBase4d): LQuaterniond {.importcpp: "LQuaterniond(#)".}

proc initLQuaterniond*(r: float64, copy: LVecBase3d): LQuaterniond {.importcpp: "LQuaterniond(#, #)".}

proc initLQuaterniond*(r: float64, i: float64, j: float64, k: float64): LQuaterniond {.importcpp: "LQuaterniond(#, #, #, #)".}

proc pureImaginary*(_: typedesc[LQuaterniond], v: LVector3d): LQuaterniond {.importcpp: "#LQuaterniond::pure_imaginary(#)", header: "lquaternion.h".}

proc conjugate*(this: LQuaterniond): LQuaterniond {.importcpp: "#.conjugate()".} ## \
## Returns the complex conjugate of this quat.

proc xform*(this: LQuaterniond, v: LVecBase3d): LVecBase3d {.importcpp: "#.xform(#)".} ## \
## Transforms a 3-d vector by the indicated rotation

proc xform*(this: LQuaterniond, v: LVecBase4d): LVecBase4d {.importcpp: "#.xform(#)".} ## \
## Transforms a 4-d vector by the indicated rotation

proc multiply*(this: LQuaterniond, rhs: LQuaterniond): LQuaterniond {.importcpp: "#.multiply(#)".} ## \
## actual multiply call (non virtual)

proc `-`*(this: LQuaterniond): LQuaterniond {.importcpp: "#.operator -()".}

proc `+`*(this: LQuaterniond, other: LQuaterniond): LQuaterniond {.importcpp: "#.operator +(#)".}

proc `-`*(this: LQuaterniond, other: LQuaterniond): LQuaterniond {.importcpp: "#.operator -(#)".}

proc angleRad*(this: LQuaterniond, other: LQuaterniond): float64 {.importcpp: "#.angle_rad(#)".} ## \
## Returns the angle between the orientation represented by this quaternion
## and the other one, expressed in radians.

proc angleDeg*(this: LQuaterniond, other: LQuaterniond): float64 {.importcpp: "#.angle_deg(#)".} ## \
## Returns the angle between the orientation represented by this quaternion
## and the other one, expressed in degrees.

proc `*`*(this: LQuaterniond, param0: LMatrix3d): LMatrix3d {.importcpp: "#.operator *(#)".}

proc `*`*(this: LQuaterniond, param0: LMatrix4d): LMatrix4d {.importcpp: "#.operator *(#)".}

proc `/`*(this: LQuaterniond, scalar: float64): LQuaterniond {.importcpp: "#.operator /(#)".}

proc `*=`*(this: var LQuaterniond, param0: LQuaterniond): LQuaterniond {.importcpp: "#.operator *=(#)".}

proc almostEqual*(this: LQuaterniond, other: LQuaterniond): bool {.importcpp: "#.almost_equal(#)".} ## \
## Returns true if two quaternions are memberwise equal within a default
## tolerance based on the numeric type.

proc almostEqual*(this: LQuaterniond, other: LQuaterniond, threshold: float64): bool {.importcpp: "#.almost_equal(#, #)".} ## \
## Returns true if two quaternions are memberwise equal within a specified
## tolerance.

proc isSameDirection*(this: LQuaterniond, other: LQuaterniond): bool {.importcpp: "#.is_same_direction(#)".} ## \
## Returns true if two quaternions represent the same rotation within a
## default tolerance based on the numeric type.

proc almostSameDirection*(this: LQuaterniond, other: LQuaterniond, threshold: float64): bool {.importcpp: "#.almost_same_direction(#, #)".} ## \
## Returns true if two quaternions represent the same rotation within a
## specified tolerance.

proc output*(this: LQuaterniond, param0: ostream) {.importcpp: "#.output(#)".}

proc extractToMatrix*(this: LQuaterniond, m: LMatrix3d) {.importcpp: "#.extract_to_matrix(#)".} ## \
## Based on the quat lib from VRPN.

proc extractToMatrix*(this: LQuaterniond, m: LMatrix4d) {.importcpp: "#.extract_to_matrix(#)".} ## \
## Based on the quat lib from VRPN.

proc setFromMatrix*(this: LQuaterniond, m: LMatrix3d) {.importcpp: "#.set_from_matrix(#)".} ## \
## Sets the quaternion according to the rotation represented by the matrix.
## Originally we tried an algorithm presented by Do-While Jones, but that
## turned out to be broken.  This is based on the quat lib from UNC.

proc setFromMatrix*(this: LQuaterniond, m: LMatrix4d) {.importcpp: "#.set_from_matrix(#)".}

proc setHpr*(this: LQuaterniond, hpr: LVecBase3d, cs: CoordinateSystem) {.importcpp: "#.set_hpr(#, #)".} ## \
## Sets the quaternion as the unit quaternion that is equivalent to these
## Euler angles.  (from Real-time Rendering, p.49)

proc setHpr*(this: LQuaterniond, hpr: LVecBase3d) {.importcpp: "#.set_hpr(#)".} ## \
## Sets the quaternion as the unit quaternion that is equivalent to these
## Euler angles.  (from Real-time Rendering, p.49)

proc getHpr*(this: LQuaterniond, cs: CoordinateSystem): LVecBase3d {.importcpp: "#.get_hpr(#)".} ## \
## Extracts the equivalent Euler angles from the unit quaternion.

proc getHpr*(this: LQuaterniond): LVecBase3d {.importcpp: "#.get_hpr()".} ## \
## Extracts the equivalent Euler angles from the unit quaternion.

proc getAxis*(this: LQuaterniond): LVector3d {.importcpp: "#.get_axis()".} ## \
## This, along with get_angle(), returns the rotation represented by the
## quaternion as an angle about an arbitrary axis.  This returns the axis; it
## is not normalized.

proc getAxisNormalized*(this: LQuaterniond): LVector3d {.importcpp: "#.get_axis_normalized()".} ## \
## This, along with get_angle(), returns the rotation represented by the
## quaternion as an angle about an arbitrary axis.  This returns the
## normalized axis.

proc getAngleRad*(this: LQuaterniond): float64 {.importcpp: "#.get_angle_rad()".} ## \
## This, along with get_axis(), returns the rotation represented by the
## quaternion as an angle about an arbitrary axis.  This returns the angle, in
## radians counterclockwise about the axis.
##
## It is necessary to ensure the quaternion has been normalized (for instance,
## with a call to normalize()) before calling this method.

proc getAngle*(this: LQuaterniond): float64 {.importcpp: "#.get_angle()".} ## \
## This, along with get_axis(), returns the rotation represented by the
## quaternion as an angle about an arbitrary axis.  This returns the angle, in
## degrees counterclockwise about the axis.
##
## It is necessary to ensure the quaternion has been normalized (for instance,
## with a call to normalize()) before calling this method.

proc setFromAxisAngleRad*(this: LQuaterniond, angle_rad: float64, axis: LVector3d) {.importcpp: "#.set_from_axis_angle_rad(#, #)".} ## \
## angle_rad is the angle about the axis in radians.  axis must be normalized.

proc setFromAxisAngle*(this: LQuaterniond, angle_deg: float64, axis: LVector3d) {.importcpp: "#.set_from_axis_angle(#, #)".} ## \
## angle_deg is the angle about the axis in degrees.  axis must be normalized.

proc getUp*(this: LQuaterniond, cs: CoordinateSystem): LVector3d {.importcpp: "#.get_up(#)".} ## \
## Returns the orientation represented by this quaternion, expressed as an up
## vector.

proc getUp*(this: LQuaterniond): LVector3d {.importcpp: "#.get_up()".} ## \
## Returns the orientation represented by this quaternion, expressed as an up
## vector.

proc getRight*(this: LQuaterniond, cs: CoordinateSystem): LVector3d {.importcpp: "#.get_right(#)".} ## \
## Returns the orientation represented by this quaternion, expressed as a
## right vector.

proc getRight*(this: LQuaterniond): LVector3d {.importcpp: "#.get_right()".} ## \
## Returns the orientation represented by this quaternion, expressed as a
## right vector.

proc getForward*(this: LQuaterniond, cs: CoordinateSystem): LVector3d {.importcpp: "#.get_forward(#)".} ## \
## Returns the orientation represented by this quaternion, expressed as a
## forward vector.

proc getForward*(this: LQuaterniond): LVector3d {.importcpp: "#.get_forward()".} ## \
## Returns the orientation represented by this quaternion, expressed as a
## forward vector.

proc getR*(this: LQuaterniond): float64 {.importcpp: "#.get_r()".}

proc getI*(this: LQuaterniond): float64 {.importcpp: "#.get_i()".}

proc getJ*(this: LQuaterniond): float64 {.importcpp: "#.get_j()".}

proc getK*(this: LQuaterniond): float64 {.importcpp: "#.get_k()".}

proc setR*(this: LQuaterniond, r: float64) {.importcpp: "#.set_r(#)".}

proc setI*(this: LQuaterniond, i: float64) {.importcpp: "#.set_i(#)".}

proc setJ*(this: LQuaterniond, j: float64) {.importcpp: "#.set_j(#)".}

proc setK*(this: LQuaterniond, k: float64) {.importcpp: "#.set_k(#)".}

proc normalize*(this: LQuaterniond): bool {.importcpp: "#.normalize()".}

proc conjugateFrom*(this: LQuaterniond, other: LQuaterniond): bool {.importcpp: "#.conjugate_from(#)".} ## \
## Computes the conjugate of the other quat, and stores the result in this
## quat.  This is a fully general operation and makes no assumptions about the
## type of transform represented by the quat.
##
## The other quat must be a different object than this quat.  However, if you
## need to get a conjugate of a quat in place, see conjugate_in_place.
##
## The return value is true if the quat was successfully inverted, false if
## there was a singularity.

proc conjugateInPlace*(this: LQuaterniond): bool {.importcpp: "#.conjugate_in_place()".} ## \
## Sets this to be the conjugate of the current quat.  Returns true if the
## successful, false if the quat was singular.

proc invertFrom*(this: LQuaterniond, other: LQuaterniond): bool {.importcpp: "#.invert_from(#)".} ## \
## Computes the inverse of the other quat, and stores the result in this quat.
## This is a fully general operation and makes no assumptions about the type
## of transform represented by the quat.
##
## The other quat must be a different object than this quat.  However, if you
## need to invert a quat in place, see invert_in_place.
##
## The return value is true if the quat was successfully inverted, false if
## there was a singularity.

proc invertInPlace*(this: LQuaterniond): bool {.importcpp: "#.invert_in_place()".} ## \
## Inverts the current quat.  Returns true if the inverse is successful, false
## if the quat was singular.

proc isIdentity*(this: LQuaterniond): bool {.importcpp: "#.is_identity()".} ## \
## Returns true if this quaternion represents the identity transformation: no
## rotation.

proc isAlmostIdentity*(this: LQuaterniond, tolerance: float64): bool {.importcpp: "#.is_almost_identity(#)".} ## \
## Returns true if this quaternion represents the identity transformation
## within a given tolerance.

proc identQuat*(_: typedesc[LQuaterniond]): LQuaterniond {.importcpp: "LQuaterniond::ident_quat()", header: "lquaternion.h".} ## \
## Returns an identity quaternion.

converter getClassType*(_: typedesc[LQuaterniond]): TypeHandle {.importcpp: "LQuaterniond::get_class_type()", header: "lquaternion.h".}

proc initLRotationf*(): LRotationf {.importcpp: "LRotationf()".}

converter initLRotationf*(m: LMatrix3f): LRotationf {.importcpp: "LRotationf(#)".} ## \
## lmatrix3

converter initLRotationf*(m: LMatrix4f): LRotationf {.importcpp: "LRotationf(#)".} ## \
## lmatrix4

converter initLRotationf*(c: LQuaternionf): LRotationf {.importcpp: "LRotationf(#)".}

proc initLRotationf*(param0: LRotationf): LRotationf {.importcpp: "LRotationf(#)".}

converter initLRotationf*(copy: LVecBase4f): LRotationf {.importcpp: "LRotationf(#)".}

proc initLRotationf*(axis: LVector3f, angle: float32): LRotationf {.importcpp: "LRotationf(#, #)".} ## \
## axis + angle (in degrees)

proc initLRotationf*(h: float32, p: float32, r: float32): LRotationf {.importcpp: "LRotationf(#, #, #)".} ## \
## Sets the rotation from the given Euler angles.

proc initLRotationf*(r: float32, i: float32, j: float32, k: float32): LRotationf {.importcpp: "LRotationf(#, #, #, #)".}

proc `*`*(this: LRotationf, other: LQuaternionf): LQuaternionf {.importcpp: "#.operator *(#)".}

proc `*`*(this: LRotationf, other: LRotationf): LRotationf {.importcpp: "#.operator *(#)".}

proc `*`*(this: LRotationf, scalar: float32): LRotationf {.importcpp: "#.operator *(#)".}

proc `/`*(this: LRotationf, scalar: float32): LRotationf {.importcpp: "#.operator /(#)".}

converter getClassType*(_: typedesc[LRotationf]): TypeHandle {.importcpp: "LRotationf::get_class_type()", header: "lrotation.h".}

proc initLRotationd*(): LRotationd {.importcpp: "LRotationd()".}

converter initLRotationd*(m: LMatrix3d): LRotationd {.importcpp: "LRotationd(#)".} ## \
## lmatrix3

converter initLRotationd*(m: LMatrix4d): LRotationd {.importcpp: "LRotationd(#)".} ## \
## lmatrix4

converter initLRotationd*(c: LQuaterniond): LRotationd {.importcpp: "LRotationd(#)".}

proc initLRotationd*(param0: LRotationd): LRotationd {.importcpp: "LRotationd(#)".}

converter initLRotationd*(copy: LVecBase4d): LRotationd {.importcpp: "LRotationd(#)".}

proc initLRotationd*(axis: LVector3d, angle: float64): LRotationd {.importcpp: "LRotationd(#, #)".} ## \
## axis + angle (in degrees)

proc initLRotationd*(h: float64, p: float64, r: float64): LRotationd {.importcpp: "LRotationd(#, #, #)".} ## \
## Sets the rotation from the given Euler angles.

proc initLRotationd*(r: float64, i: float64, j: float64, k: float64): LRotationd {.importcpp: "LRotationd(#, #, #, #)".}

proc `*`*(this: LRotationd, other: LQuaterniond): LQuaterniond {.importcpp: "#.operator *(#)".}

proc `*`*(this: LRotationd, other: LRotationd): LRotationd {.importcpp: "#.operator *(#)".}

proc `*`*(this: LRotationd, scalar: float64): LRotationd {.importcpp: "#.operator *(#)".}

proc `/`*(this: LRotationd, scalar: float64): LRotationd {.importcpp: "#.operator /(#)".}

converter getClassType*(_: typedesc[LRotationd]): TypeHandle {.importcpp: "LRotationd::get_class_type()", header: "lrotation.h".}

proc initLOrientationf*(): LOrientationf {.importcpp: "LOrientationf()".}

converter initLOrientationf*(m: LMatrix3f): LOrientationf {.importcpp: "LOrientationf(#)".} ## \
## matrix3

converter initLOrientationf*(m: LMatrix4f): LOrientationf {.importcpp: "LOrientationf(#)".} ## \
## matrix4

proc initLOrientationf*(param0: LOrientationf): LOrientationf {.importcpp: "LOrientationf(#)".}

converter initLOrientationf*(c: LQuaternionf): LOrientationf {.importcpp: "LOrientationf(#)".}

proc initLOrientationf*(point_at: LVector3f, twist: float32): LOrientationf {.importcpp: "LOrientationf(#, #)".} ## \
## vector + twist

proc initLOrientationf*(r: float32, i: float32, j: float32, k: float32): LOrientationf {.importcpp: "LOrientationf(#, #, #, #)".}

proc `*`*(this: LOrientationf, other: LQuaternionf): LOrientationf {.importcpp: "#.operator *(#)".}

proc `*`*(this: LOrientationf, other: LRotationf): LOrientationf {.importcpp: "#.operator *(#)".}

converter getClassType*(_: typedesc[LOrientationf]): TypeHandle {.importcpp: "LOrientationf::get_class_type()", header: "lorientation.h".}

proc initLOrientationd*(): LOrientationd {.importcpp: "LOrientationd()".}

converter initLOrientationd*(m: LMatrix3d): LOrientationd {.importcpp: "LOrientationd(#)".} ## \
## matrix3

converter initLOrientationd*(m: LMatrix4d): LOrientationd {.importcpp: "LOrientationd(#)".} ## \
## matrix4

proc initLOrientationd*(param0: LOrientationd): LOrientationd {.importcpp: "LOrientationd(#)".}

converter initLOrientationd*(c: LQuaterniond): LOrientationd {.importcpp: "LOrientationd(#)".}

proc initLOrientationd*(point_at: LVector3d, twist: float64): LOrientationd {.importcpp: "LOrientationd(#, #)".} ## \
## vector + twist

proc initLOrientationd*(r: float64, i: float64, j: float64, k: float64): LOrientationd {.importcpp: "LOrientationd(#, #, #, #)".}

proc `*`*(this: LOrientationd, other: LQuaterniond): LOrientationd {.importcpp: "#.operator *(#)".}

proc `*`*(this: LOrientationd, other: LRotationd): LOrientationd {.importcpp: "#.operator *(#)".}

converter getClassType*(_: typedesc[LOrientationd]): TypeHandle {.importcpp: "LOrientationd::get_class_type()", header: "lorientation.h".}

proc initConfigVariableColor*(param0: ConfigVariableColor): ConfigVariableColor {.importcpp: "ConfigVariableColor(#)".}

proc initConfigVariableColor*(name: string): ConfigVariableColor {.importcpp: "ConfigVariableColor(nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableColor*(name: string, default_value: LColor, description: string, flags: int): ConfigVariableColor {.importcpp: "ConfigVariableColor(nimStringToStdString(#), #, nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableColor*(name: string, default_value: LColor, description: string): ConfigVariableColor {.importcpp: "ConfigVariableColor(nimStringToStdString(#), #, nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableColor*(name: string, default_value: LColor): ConfigVariableColor {.importcpp: "ConfigVariableColor(nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableColor*(name: string, default_value: string, description: string, flags: int): ConfigVariableColor {.importcpp: "ConfigVariableColor(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#), #)", header: stringConversionCode.}

proc initConfigVariableColor*(name: string, default_value: string, description: string): ConfigVariableColor {.importcpp: "ConfigVariableColor(nimStringToStdString(#), nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc initConfigVariableColor*(name: string, default_value: string): ConfigVariableColor {.importcpp: "ConfigVariableColor(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.}

proc `typecast`*(this: ConfigVariableColor): LColor {.importcpp: "#.operator typecast()".}

proc `[]`*(this: ConfigVariableColor, n: int): float32 {.importcpp: "#.operator [](#)".}

proc setValue*(this: ConfigVariableColor, value: LColor) {.importcpp: "#.set_value(#)".} ## \
## Reassigns the variable's local value.

proc getValue*(this: ConfigVariableColor): LColor {.importcpp: "#.get_value()".} ## \
## Returns the variable's value.

proc getDefaultValue*(this: ConfigVariableColor): LColor {.importcpp: "#.get_default_value()".} ## \
## Returns the variable's default value.

proc makeCopy*(this: BoundingVolume): BoundingVolume {.importcpp: "#->make_copy()".}

proc isEmpty*(this: BoundingVolume): bool {.importcpp: "#->is_empty()".} ## \
## Any kind of volume might be empty.  This is a degenerate volume that
## contains no points; it's not the same as, for instance, a sphere with
## radius zero, since that contains one point (the center).  It intersects
## with no other volumes.

proc isInfinite*(this: BoundingVolume): bool {.importcpp: "#->is_infinite()".} ## \
## The other side of the empty coin is an infinite volume.  This is a
## degenerate state of a normally finite volume that contains all points.
## (Note that some kinds of infinite bounding volumes, like binary separating
## planes, do not contain all points and thus correctly return is_infinite()
## == false, even though they are technically infinite.  This is a special
## case of the word 'infinite' meaning the volume covers all points in space.)
##
## It completely intersects with all other volumes except empty volumes.

proc setInfinite*(this: BoundingVolume) {.importcpp: "#->set_infinite()".} ## \
## Marks the volume as infinite, even if it is normally finite.  You can think
## of this as an infinite extend_by() operation.

proc extendBy*(this: BoundingVolume, vol: BoundingVolume): bool {.importcpp: "#->extend_by(#)".} ## \
## Increases the size of the volume to include the given volume.

proc contains*(this: BoundingVolume, vol: BoundingVolume): int {.importcpp: "#->contains(#)".} ## \
## Returns the appropriate set of IntersectionFlags to indicate the amount of
## intersection with the indicated volume.

proc output*(this: BoundingVolume, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: BoundingVolume, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: BoundingVolume, `out`: ostream) {.importcpp: "#->write(#)".}

converter getClassType*(_: typedesc[BoundingVolume]): TypeHandle {.importcpp: "BoundingVolume::get_class_type()", header: "boundingVolume.h".}

proc extendBy*(this: GeometricBoundingVolume, vol: GeometricBoundingVolume): bool {.importcpp: "#->extend_by(#)".} ## \
## Increases the size of the volume to include the given volume.

proc extendBy*(this: GeometricBoundingVolume, point: LPoint3): bool {.importcpp: "#->extend_by(#)".} ## \
## Increases the size of the volume to include the given point.

proc contains*(this: GeometricBoundingVolume, vol: GeometricBoundingVolume): int {.importcpp: "#->contains(#)".} ## \
## Returns the appropriate set of IntersectionFlags to indicate the amount of
## intersection with the indicated volume.

proc contains*(this: GeometricBoundingVolume, point: LPoint3): int {.importcpp: "#->contains(#)".} ## \
## Returns the appropriate set of IntersectionFlags to indicate the amount of
## intersection with the indicated point.

proc contains*(this: GeometricBoundingVolume, a: LPoint3, b: LPoint3): int {.importcpp: "#->contains(#, #)".} ## \
## Returns the appropriate set of IntersectionFlags to indicate the amount of
## intersection with the indicated line segment.

proc getApproxCenter*(this: GeometricBoundingVolume): LPoint3 {.importcpp: "#->get_approx_center()".}

proc xform*(this: GeometricBoundingVolume, mat: LMatrix4) {.importcpp: "#->xform(#)".}

converter getClassType*(_: typedesc[GeometricBoundingVolume]): TypeHandle {.importcpp: "GeometricBoundingVolume::get_class_type()", header: "geometricBoundingVolume.h".}

proc getMin*(this: FiniteBoundingVolume): LPoint3 {.importcpp: "#->get_min()".}

proc getMax*(this: FiniteBoundingVolume): LPoint3 {.importcpp: "#->get_max()".}

proc getVolume*(this: FiniteBoundingVolume): float32 {.importcpp: "#->get_volume()".}

converter getClassType*(_: typedesc[FiniteBoundingVolume]): TypeHandle {.importcpp: "FiniteBoundingVolume::get_class_type()", header: "finiteBoundingVolume.h".}

proc initLParabolaf*(): LParabolaf {.importcpp: "LParabolaf()".} ## \
## Constructs a meaningless degenerate parabola.

proc initLParabolaf*(copy: LParabolaf): LParabolaf {.importcpp: "LParabolaf(#)".}

proc initLParabolaf*(a: LVecBase3f, b: LVecBase3f, c: LVecBase3f): LParabolaf {.importcpp: "LParabolaf(#, #, #)".} ## \
## Constructs a parabola given the three points of the parametric equation:
## the acceleration, initial velocity, and start point.

proc xform*(this: LParabolaf, mat: LMatrix4f) {.importcpp: "#.xform(#)".} ## \
## Transforms the parabola by the indicated matrix.

proc getA*(this: LParabolaf): LVecBase3f {.importcpp: "#.get_a()".} ## \
## Returns the first point of the parabola's parametric equation: the
## acceleration.

proc getB*(this: LParabolaf): LVecBase3f {.importcpp: "#.get_b()".} ## \
## Returns the second point of the parabola's parametric equation: the initial
## velocity.

proc getC*(this: LParabolaf): LVecBase3f {.importcpp: "#.get_c()".} ## \
## Returns the third point of the parabola's parametric equation: the start
## point.

proc calcPoint*(this: LParabolaf, t: float32): LPoint3f {.importcpp: "#.calc_point(#)".} ## \
## Computes the point on the parabola at time t.

proc output*(this: LParabolaf, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: LParabolaf, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: LParabolaf, `out`: ostream) {.importcpp: "#.write(#)".}

proc writeDatagramFixed*(this: LParabolaf, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the parabola to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the parabola, regardless of the setting
## of Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc readDatagramFixed*(this: LParabolaf, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the parabola from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc writeDatagram*(this: LParabolaf, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the parabola to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc readDatagram*(this: LParabolaf, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the parabola from the Datagram using get_stdfloat().

proc initLParabolad*(): LParabolad {.importcpp: "LParabolad()".} ## \
## Constructs a meaningless degenerate parabola.

proc initLParabolad*(copy: LParabolad): LParabolad {.importcpp: "LParabolad(#)".}

proc initLParabolad*(a: LVecBase3d, b: LVecBase3d, c: LVecBase3d): LParabolad {.importcpp: "LParabolad(#, #, #)".} ## \
## Constructs a parabola given the three points of the parametric equation:
## the acceleration, initial velocity, and start point.

proc xform*(this: LParabolad, mat: LMatrix4d) {.importcpp: "#.xform(#)".} ## \
## Transforms the parabola by the indicated matrix.

proc getA*(this: LParabolad): LVecBase3d {.importcpp: "#.get_a()".} ## \
## Returns the first point of the parabola's parametric equation: the
## acceleration.

proc getB*(this: LParabolad): LVecBase3d {.importcpp: "#.get_b()".} ## \
## Returns the second point of the parabola's parametric equation: the initial
## velocity.

proc getC*(this: LParabolad): LVecBase3d {.importcpp: "#.get_c()".} ## \
## Returns the third point of the parabola's parametric equation: the start
## point.

proc calcPoint*(this: LParabolad, t: float64): LPoint3d {.importcpp: "#.calc_point(#)".} ## \
## Computes the point on the parabola at time t.

proc output*(this: LParabolad, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: LParabolad, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: LParabolad, `out`: ostream) {.importcpp: "#.write(#)".}

proc writeDatagramFixed*(this: LParabolad, destination: Datagram) {.importcpp: "#.write_datagram_fixed(#)".} ## \
## Writes the parabola to the Datagram using add_float32() or add_float64(),
## depending on the type of floats in the parabola, regardless of the setting
## of Datagram::set_stdfloat_double().  This is appropriate when you want to
## write a fixed-width value to the datagram, especially when you are not
## writing a bam file.

proc readDatagramFixed*(this: LParabolad, source: DatagramIterator) {.importcpp: "#.read_datagram_fixed(#)".} ## \
## Reads the parabola from the Datagram using get_float32() or get_float64().
## See write_datagram_fixed().

proc writeDatagram*(this: LParabolad, destination: Datagram) {.importcpp: "#.write_datagram(#)".} ## \
## Writes the parabola to the Datagram using add_stdfloat().  This is
## appropriate when you want to write the vector using the standard width
## setting, especially when you are writing a bam file.

proc readDatagram*(this: LParabolad, source: DatagramIterator) {.importcpp: "#.read_datagram(#)".} ## \
## Reads the parabola from the Datagram using get_stdfloat().

proc initLPlanef*(): LPlanef {.importcpp: "LPlanef()".} ## \
## Creates a default plane.  This plane happens to intersect the origin,
## perpendicular to the Z axis.  It's not clear how useful a default plane is.

proc initLPlanef*(param0: LPlanef): LPlanef {.importcpp: "LPlanef(#)".}

proc initLPlanef*(a: LPoint3f, b: LPoint3f, c: LPoint3f): LPlanef {.importcpp: "LPlanef(#, #, #)".} ## \
## Constructs a plane given three counter-clockwise points, as seen from the
## front of the plane (that is, viewed from the end of the normal vector,
## looking down).

converter initLPlanef*(copy: LVecBase4f): LPlanef {.importcpp: "LPlanef(#)".}

proc initLPlanef*(normal: LVector3f, point: LPoint3f): LPlanef {.importcpp: "LPlanef(#, #)".} ## \
## Constructs a plane given a surface normal vector and a point within the
## plane.

proc initLPlanef*(a: float32, b: float32, c: float32, d: float32): LPlanef {.importcpp: "LPlanef(#, #, #, #)".} ## \
## Constructs a plane given the four terms of the plane equation.

proc `*`*(this: LPlanef, mat: LMatrix3f): LPlanef {.importcpp: "#.operator *(#)".}

proc `*`*(this: LPlanef, mat: LMatrix4f): LPlanef {.importcpp: "#.operator *(#)".}

proc `*=`*(this: var LPlanef, mat: LMatrix4f): LPlanef {.importcpp: "#.operator *=(#)".}

proc xform*(this: LPlanef, mat: LMatrix4f) {.importcpp: "#.xform(#)".} ## \
## Transforms the plane by the indicated matrix.

proc `-`*(this: LPlanef): LPlanef {.importcpp: "#.operator -()".}

proc getReflectionMat*(this: LPlanef): LMatrix4f {.importcpp: "#.get_reflection_mat()".} ## \
## This computes a transform matrix that reflects the universe to the other
## side of the plane, as in a mirror.

proc getNormal*(this: LPlanef): LVector3f {.importcpp: "#.get_normal()".} ## \
## Returns the surface normal of the plane.

proc getPoint*(this: LPlanef): LPoint3f {.importcpp: "#.get_point()".} ## \
## Returns an arbitrary point in the plane.  This can be used along with the
## normal returned by get_normal() to reconstruct the plane.

proc distToPlane*(this: LPlanef, point: LPoint3f): float32 {.importcpp: "#.dist_to_plane(#)".} ## \
## Returns the straight-line shortest distance from the point to the plane.
## The returned value is positive if the point is in front of the plane (on
## the side with the normal), or negative in the point is behind the plane (on
## the opposite side from the normal). It's zero if the point is exactly in
## the plane.

proc normalize*(this: LPlanef): bool {.importcpp: "#.normalize()".} ## \
## Normalizes the plane in place.  Returns true if the plane was normalized,
## false if the plane had a zero-length normal vector.

proc normalized*(this: LPlanef): LPlanef {.importcpp: "#.normalized()".} ## \
## Normalizes the plane and returns the normalized plane as a copy.  If the
## plane's normal was a zero-length vector, the same plane is returned.

proc project*(this: LPlanef, point: LPoint3f): LPoint3f {.importcpp: "#.project(#)".} ## \
## Returns the point within the plane nearest to the indicated point in space.

proc flip*(this: LPlanef) {.importcpp: "#.flip()".} ## \
## Convenience method that flips the plane in-place.  This is done by simply
## flipping the normal vector.

proc intersectsLine*(this: LPlanef, intersection_point: LPoint3f, p1: LPoint3f, p2: LPoint3f): bool {.importcpp: "#.intersects_line(#, #, #)".} ## \
## Returns true if the plane intersects the infinite line passing through
## points p1 and p2, false if the line is parallel.  The points p1 and p2 are
## used only to define the Euclidean line; they have no other bearing on the
## intersection test.  If true, sets intersection_point to the point of
## intersection.

proc intersectsPlane*(this: LPlanef, `from`: LPoint3f, delta: LVector3f, other: LPlanef): bool {.importcpp: "#.intersects_plane(#, #, #)".} ## \
## Returns true if the two planes intersect, false if they do not.  If they do
## intersect, then from and delta are filled in with the parametric
## representation of the line of intersection: that is, from is a point on
## that line, and delta is a vector showing the direction of the line.

proc output*(this: LPlanef, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: LPlanef, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: LPlanef, `out`: ostream) {.importcpp: "#.write(#)".}

proc initLPlaned*(): LPlaned {.importcpp: "LPlaned()".} ## \
## Creates a default plane.  This plane happens to intersect the origin,
## perpendicular to the Z axis.  It's not clear how useful a default plane is.

proc initLPlaned*(param0: LPlaned): LPlaned {.importcpp: "LPlaned(#)".}

proc initLPlaned*(a: LPoint3d, b: LPoint3d, c: LPoint3d): LPlaned {.importcpp: "LPlaned(#, #, #)".} ## \
## Constructs a plane given three counter-clockwise points, as seen from the
## front of the plane (that is, viewed from the end of the normal vector,
## looking down).

converter initLPlaned*(copy: LVecBase4d): LPlaned {.importcpp: "LPlaned(#)".}

proc initLPlaned*(normal: LVector3d, point: LPoint3d): LPlaned {.importcpp: "LPlaned(#, #)".} ## \
## Constructs a plane given a surface normal vector and a point within the
## plane.

proc initLPlaned*(a: float64, b: float64, c: float64, d: float64): LPlaned {.importcpp: "LPlaned(#, #, #, #)".} ## \
## Constructs a plane given the four terms of the plane equation.

proc `*`*(this: LPlaned, mat: LMatrix3d): LPlaned {.importcpp: "#.operator *(#)".}

proc `*`*(this: LPlaned, mat: LMatrix4d): LPlaned {.importcpp: "#.operator *(#)".}

proc `*=`*(this: var LPlaned, mat: LMatrix4d): LPlaned {.importcpp: "#.operator *=(#)".}

proc xform*(this: LPlaned, mat: LMatrix4d) {.importcpp: "#.xform(#)".} ## \
## Transforms the plane by the indicated matrix.

proc `-`*(this: LPlaned): LPlaned {.importcpp: "#.operator -()".}

proc getReflectionMat*(this: LPlaned): LMatrix4d {.importcpp: "#.get_reflection_mat()".} ## \
## This computes a transform matrix that reflects the universe to the other
## side of the plane, as in a mirror.

proc getNormal*(this: LPlaned): LVector3d {.importcpp: "#.get_normal()".} ## \
## Returns the surface normal of the plane.

proc getPoint*(this: LPlaned): LPoint3d {.importcpp: "#.get_point()".} ## \
## Returns an arbitrary point in the plane.  This can be used along with the
## normal returned by get_normal() to reconstruct the plane.

proc distToPlane*(this: LPlaned, point: LPoint3d): float64 {.importcpp: "#.dist_to_plane(#)".} ## \
## Returns the straight-line shortest distance from the point to the plane.
## The returned value is positive if the point is in front of the plane (on
## the side with the normal), or negative in the point is behind the plane (on
## the opposite side from the normal). It's zero if the point is exactly in
## the plane.

proc normalize*(this: LPlaned): bool {.importcpp: "#.normalize()".} ## \
## Normalizes the plane in place.  Returns true if the plane was normalized,
## false if the plane had a zero-length normal vector.

proc normalized*(this: LPlaned): LPlaned {.importcpp: "#.normalized()".} ## \
## Normalizes the plane and returns the normalized plane as a copy.  If the
## plane's normal was a zero-length vector, the same plane is returned.

proc project*(this: LPlaned, point: LPoint3d): LPoint3d {.importcpp: "#.project(#)".} ## \
## Returns the point within the plane nearest to the indicated point in space.

proc flip*(this: LPlaned) {.importcpp: "#.flip()".} ## \
## Convenience method that flips the plane in-place.  This is done by simply
## flipping the normal vector.

proc intersectsLine*(this: LPlaned, intersection_point: LPoint3d, p1: LPoint3d, p2: LPoint3d): bool {.importcpp: "#.intersects_line(#, #, #)".} ## \
## Returns true if the plane intersects the infinite line passing through
## points p1 and p2, false if the line is parallel.  The points p1 and p2 are
## used only to define the Euclidean line; they have no other bearing on the
## intersection test.  If true, sets intersection_point to the point of
## intersection.

proc intersectsPlane*(this: LPlaned, `from`: LPoint3d, delta: LVector3d, other: LPlaned): bool {.importcpp: "#.intersects_plane(#, #, #)".} ## \
## Returns true if the two planes intersect, false if they do not.  If they do
## intersect, then from and delta are filled in with the parametric
## representation of the line of intersection: that is, from is a point on
## that line, and delta is a vector showing the direction of the line.

proc output*(this: LPlaned, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: LPlaned, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: LPlaned, `out`: ostream) {.importcpp: "#.write(#)".}

proc newBoundingBox*(): BoundingBox {.importcpp: "new BoundingBox()".} ## \
## Constructs an empty box object.

proc newBoundingBox*(min: LPoint3, max: LPoint3): BoundingBox {.importcpp: "new BoundingBox(#, #)".} ## \
## Constructs a specific box object.

proc getNumPoints*(this: BoundingBox): int {.importcpp: "#->get_num_points()".} ## \
## Returns 8: the number of vertices of a rectangular solid.

proc getPoint*(this: BoundingBox, n: int): LPoint3 {.importcpp: "#->get_point(#)".} ## \
## Returns the nth vertex of the rectangular solid.

proc getNumPlanes*(this: BoundingBox): int {.importcpp: "#->get_num_planes()".} ## \
## Returns 6: the number of faces of a rectangular solid.

proc getPlane*(this: BoundingBox, n: int): LPlane {.importcpp: "#->get_plane(#)".} ## \
## Returns the nth face of the rectangular solid.

proc setMinMax*(this: BoundingBox, min: LPoint3, max: LPoint3) {.importcpp: "#->set_min_max(#, #)".} ## \
## Sets the min and max point of the rectangular solid.

converter getClassType*(_: typedesc[BoundingBox]): TypeHandle {.importcpp: "BoundingBox::get_class_type()", header: "boundingBox.h".}

proc initLFrustumf*(): LFrustumf {.importcpp: "LFrustumf()".}

proc initLFrustumf*(param0: LFrustumf): LFrustumf {.importcpp: "LFrustumf(#)".}

proc makeOrtho2D*(this: LFrustumf) {.importcpp: "#.make_ortho_2D()".} ## \
## Sets up a two-dimensional orthographic frustum

proc makeOrtho2D*(this: LFrustumf, l: float32, r: float32, t: float32, b: float32) {.importcpp: "#.make_ortho_2D(#, #, #, #)".} ## \
## Sets up a two-dimensional orthographic frustum

proc makeOrtho*(this: LFrustumf, fnear: float32, ffar: float32) {.importcpp: "#.make_ortho(#, #)".} ## \
## Behaves like gluOrtho

proc makeOrtho*(this: LFrustumf, fnear: float32, ffar: float32, l: float32, r: float32, t: float32, b: float32) {.importcpp: "#.make_ortho(#, #, #, #, #, #)".} ## \
## Behaves like gluOrtho

proc makePerspectiveHfov*(this: LFrustumf, xfov: float32, aspect: float32, fnear: float32, ffar: float32) {.importcpp: "#.make_perspective_hfov(#, #, #, #)".}

proc makePerspectiveVfov*(this: LFrustumf, yfov: float32, aspect: float32, fnear: float32, ffar: float32) {.importcpp: "#.make_perspective_vfov(#, #, #, #)".}

proc makePerspective*(this: LFrustumf, xfov: float32, yfov: float32, fnear: float32, ffar: float32) {.importcpp: "#.make_perspective(#, #, #, #)".}

proc initLFrustumd*(): LFrustumd {.importcpp: "LFrustumd()".}

proc initLFrustumd*(param0: LFrustumd): LFrustumd {.importcpp: "LFrustumd(#)".}

proc makeOrtho2D*(this: LFrustumd) {.importcpp: "#.make_ortho_2D()".} ## \
## Sets up a two-dimensional orthographic frustum

proc makeOrtho2D*(this: LFrustumd, l: float64, r: float64, t: float64, b: float64) {.importcpp: "#.make_ortho_2D(#, #, #, #)".} ## \
## Sets up a two-dimensional orthographic frustum

proc makeOrtho*(this: LFrustumd, fnear: float64, ffar: float64) {.importcpp: "#.make_ortho(#, #)".} ## \
## Behaves like gluOrtho

proc makeOrtho*(this: LFrustumd, fnear: float64, ffar: float64, l: float64, r: float64, t: float64, b: float64) {.importcpp: "#.make_ortho(#, #, #, #, #, #)".} ## \
## Behaves like gluOrtho

proc makePerspectiveHfov*(this: LFrustumd, xfov: float64, aspect: float64, fnear: float64, ffar: float64) {.importcpp: "#.make_perspective_hfov(#, #, #, #)".}

proc makePerspectiveVfov*(this: LFrustumd, yfov: float64, aspect: float64, fnear: float64, ffar: float64) {.importcpp: "#.make_perspective_vfov(#, #, #, #)".}

proc makePerspective*(this: LFrustumd, xfov: float64, yfov: float64, fnear: float64, ffar: float64) {.importcpp: "#.make_perspective(#, #, #, #)".}

proc newBoundingHexahedron*(frustum: LFrustum, is_ortho: bool, cs: CoordinateSystem): BoundingHexahedron {.importcpp: "new BoundingHexahedron(#, #, #)".}

proc newBoundingHexahedron*(frustum: LFrustum, is_ortho: bool): BoundingHexahedron {.importcpp: "new BoundingHexahedron(#, #)".}

proc newBoundingHexahedron*(fll: LPoint3, flr: LPoint3, fur: LPoint3, ful: LPoint3, nll: LPoint3, nlr: LPoint3, nur: LPoint3, nul: LPoint3): BoundingHexahedron {.importcpp: "new BoundingHexahedron(#, #, #, #, #, #, #, #)".}

proc getNumPoints*(this: BoundingHexahedron): int {.importcpp: "#->get_num_points()".} ## \
## Returns 8: the number of vertices of a hexahedron.

proc getPoint*(this: BoundingHexahedron, n: int): LPoint3 {.importcpp: "#->get_point(#)".} ## \
## Returns the nth vertex of the hexahedron.

proc getNumPlanes*(this: BoundingHexahedron): int {.importcpp: "#->get_num_planes()".} ## \
## Returns 6: the number of faces of a hexahedron.

proc getPlane*(this: BoundingHexahedron, n: int): LPlane {.importcpp: "#->get_plane(#)".} ## \
## Returns the nth face of the hexahedron.

converter getClassType*(_: typedesc[BoundingHexahedron]): TypeHandle {.importcpp: "BoundingHexahedron::get_class_type()", header: "boundingHexahedron.h".}

proc newBoundingLine*(a: LPoint3, b: LPoint3): BoundingLine {.importcpp: "new BoundingLine(#, #)".}

proc getPointA*(this: BoundingLine): LPoint3 {.importcpp: "#->get_point_a()".} ## \
## Returns the first point that defines the line.

proc getPointB*(this: BoundingLine): LPoint3 {.importcpp: "#->get_point_b()".} ## \
## Returns the second point that defines the line.

converter getClassType*(_: typedesc[BoundingLine]): TypeHandle {.importcpp: "BoundingLine::get_class_type()", header: "boundingLine.h".}

proc newBoundingPlane*(): BoundingPlane {.importcpp: "new BoundingPlane()".} ## \
## Constructs an empty "plane" that has no intersections.

proc newBoundingPlane*(plane: LPlane): BoundingPlane {.importcpp: "new BoundingPlane(#)".}

proc getPlane*(this: BoundingPlane): LPlane {.importcpp: "#->get_plane()".}

converter getClassType*(_: typedesc[BoundingPlane]): TypeHandle {.importcpp: "BoundingPlane::get_class_type()", header: "boundingPlane.h".}

proc newBoundingSphere*(): BoundingSphere {.importcpp: "new BoundingSphere()".} ## \
## Constructs an empty sphere.

proc newBoundingSphere*(center: LPoint3, radius: float32): BoundingSphere {.importcpp: "new BoundingSphere(#, #)".} ## \
## Constructs a specific sphere.

proc getCenter*(this: BoundingSphere): LPoint3 {.importcpp: "#->get_center()".}

proc getRadius*(this: BoundingSphere): float32 {.importcpp: "#->get_radius()".}

proc setCenter*(this: BoundingSphere, center: LPoint3) {.importcpp: "#->set_center(#)".} ## \
## Sets the center point of the sphere.

proc setRadius*(this: BoundingSphere, radius: float32) {.importcpp: "#->set_radius(#)".} ## \
## Sets the radius of the sphere.

converter getClassType*(_: typedesc[BoundingSphere]): TypeHandle {.importcpp: "BoundingSphere::get_class_type()", header: "boundingSphere.h".}

proc newIntersectionBoundingVolume*(): IntersectionBoundingVolume {.importcpp: "new IntersectionBoundingVolume()".} ## \
## Constructs an empty intersection.

proc getNumComponents*(this: IntersectionBoundingVolume): int {.importcpp: "#->get_num_components()".} ## \
## Returns the number of components in the intersection.

proc getComponent*(this: IntersectionBoundingVolume, n: int): GeometricBoundingVolume {.importcpp: "deconstify(#->get_component(#))", header: deconstifyCode.} ## \
## Returns the nth component in the intersection.

proc clearComponents*(this: IntersectionBoundingVolume) {.importcpp: "#->clear_components()".} ## \
## Removes all components from the volume.

proc addComponent*(this: IntersectionBoundingVolume, component: GeometricBoundingVolume) {.importcpp: "#->add_component(#)".} ## \
## Adds a new component to the volume.  This does not necessarily increase the
## total number of components by one, and you may or may not be able to find
## this component in the volume by a subsequent call to get_component();
## certain optimizations may prevent the component from being added, or have
## other unexpected effects on the total set of components.

converter getClassType*(_: typedesc[IntersectionBoundingVolume]): TypeHandle {.importcpp: "IntersectionBoundingVolume::get_class_type()", header: "intersectionBoundingVolume.h".}

proc headsUp*(mat: LMatrix3d, fwd: LVector3d, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #)".}

proc headsUp*(mat: LMatrix3d, fwd: LVector3d, up: LVector3d, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #, #)".}

proc headsUp*(mat: LMatrix3d, fwd: LVector3d, up: LVector3d) {.importcpp: "heads_up(#, #, #)".}

proc headsUp*(mat: LMatrix3d, fwd: LVector3d) {.importcpp: "heads_up(#, #)".}

proc headsUp*(mat: LMatrix3f, fwd: LVector3f, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #)".}

proc headsUp*(mat: LMatrix3f, fwd: LVector3f, up: LVector3f, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #, #)".}

proc headsUp*(mat: LMatrix3f, fwd: LVector3f, up: LVector3f) {.importcpp: "heads_up(#, #, #)".}

proc headsUp*(mat: LMatrix3f, fwd: LVector3f) {.importcpp: "heads_up(#, #)".}

proc headsUp*(mat: LMatrix4d, fwd: LVector3d, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #)".}

proc headsUp*(mat: LMatrix4d, fwd: LVector3d, up: LVector3d, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #, #)".}

proc headsUp*(mat: LMatrix4d, fwd: LVector3d, up: LVector3d) {.importcpp: "heads_up(#, #, #)".}

proc headsUp*(mat: LMatrix4d, fwd: LVector3d) {.importcpp: "heads_up(#, #)".}

proc headsUp*(mat: LMatrix4f, fwd: LVector3f, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #)".}

proc headsUp*(mat: LMatrix4f, fwd: LVector3f, up: LVector3f, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #, #)".}

proc headsUp*(mat: LMatrix4f, fwd: LVector3f, up: LVector3f) {.importcpp: "heads_up(#, #, #)".}

proc headsUp*(mat: LMatrix4f, fwd: LVector3f) {.importcpp: "heads_up(#, #)".}

proc headsUp*(quat: LQuaterniond, fwd: LVector3d, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #)".}

proc headsUp*(quat: LQuaterniond, fwd: LVector3d, up: LVector3d, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #, #)".}

proc headsUp*(quat: LQuaterniond, fwd: LVector3d, up: LVector3d) {.importcpp: "heads_up(#, #, #)".}

proc headsUp*(quat: LQuaterniond, fwd: LVector3d) {.importcpp: "heads_up(#, #)".}

proc headsUp*(quat: LQuaternionf, fwd: LVector3f, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #)".}

proc headsUp*(quat: LQuaternionf, fwd: LVector3f, up: LVector3f, cs: CoordinateSystem) {.importcpp: "heads_up(#, #, #, #)".}

proc headsUp*(quat: LQuaternionf, fwd: LVector3f, up: LVector3f) {.importcpp: "heads_up(#, #, #)".}

proc headsUp*(quat: LQuaternionf, fwd: LVector3f) {.importcpp: "heads_up(#, #)".}

proc lookAt*(mat: LMatrix3d, fwd: LVector3d, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #)".}

proc lookAt*(mat: LMatrix3d, fwd: LVector3d, up: LVector3d, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #, #)".}

proc lookAt*(mat: LMatrix3d, fwd: LVector3d, up: LVector3d) {.importcpp: "look_at(#, #, #)".}

proc lookAt*(mat: LMatrix3d, fwd: LVector3d) {.importcpp: "look_at(#, #)".}

proc lookAt*(mat: LMatrix3f, fwd: LVector3f, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #)".}

proc lookAt*(mat: LMatrix3f, fwd: LVector3f, up: LVector3f, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #, #)".}

proc lookAt*(mat: LMatrix3f, fwd: LVector3f, up: LVector3f) {.importcpp: "look_at(#, #, #)".}

proc lookAt*(mat: LMatrix3f, fwd: LVector3f) {.importcpp: "look_at(#, #)".}

proc lookAt*(mat: LMatrix4d, fwd: LVector3d, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #)".}

proc lookAt*(mat: LMatrix4d, fwd: LVector3d, up: LVector3d, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #, #)".}

proc lookAt*(mat: LMatrix4d, fwd: LVector3d, up: LVector3d) {.importcpp: "look_at(#, #, #)".}

proc lookAt*(mat: LMatrix4d, fwd: LVector3d) {.importcpp: "look_at(#, #)".}

proc lookAt*(mat: LMatrix4f, fwd: LVector3f, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #)".}

proc lookAt*(mat: LMatrix4f, fwd: LVector3f, up: LVector3f, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #, #)".}

proc lookAt*(mat: LMatrix4f, fwd: LVector3f, up: LVector3f) {.importcpp: "look_at(#, #, #)".}

proc lookAt*(mat: LMatrix4f, fwd: LVector3f) {.importcpp: "look_at(#, #)".}

proc lookAt*(quat: LQuaterniond, fwd: LVector3d, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #)".}

proc lookAt*(quat: LQuaterniond, fwd: LVector3d, up: LVector3d, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #, #)".}

proc lookAt*(quat: LQuaterniond, fwd: LVector3d, up: LVector3d) {.importcpp: "look_at(#, #, #)".}

proc lookAt*(quat: LQuaterniond, fwd: LVector3d) {.importcpp: "look_at(#, #)".}

proc lookAt*(quat: LQuaternionf, fwd: LVector3f, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #)".}

proc lookAt*(quat: LQuaternionf, fwd: LVector3f, up: LVector3f, cs: CoordinateSystem) {.importcpp: "look_at(#, #, #, #)".}

proc lookAt*(quat: LQuaternionf, fwd: LVector3f, up: LVector3f) {.importcpp: "look_at(#, #, #)".}

proc lookAt*(quat: LQuaternionf, fwd: LVector3f) {.importcpp: "look_at(#, #)".}

proc initMersenne*(param0: Mersenne): Mersenne {.importcpp: "Mersenne(#)".}

proc initMersenne*(seed: int): Mersenne {.importcpp: "Mersenne(#)".} ## \
## initializes mt[N] with a seed

proc getUint31*(this: Mersenne): int {.importcpp: "#.get_uint31()".} ## \
## generates a random number on [0,0x7fffffff]-interval

proc newOmniBoundingVolume*(): OmniBoundingVolume {.importcpp: "new OmniBoundingVolume()".}

converter getClassType*(_: typedesc[OmniBoundingVolume]): TypeHandle {.importcpp: "OmniBoundingVolume::get_class_type()", header: "omniBoundingVolume.h".}

proc newUnionBoundingVolume*(): UnionBoundingVolume {.importcpp: "new UnionBoundingVolume()".} ## \
## Constructs an empty union.

proc getNumComponents*(this: UnionBoundingVolume): int {.importcpp: "#->get_num_components()".} ## \
## Returns the number of components in the union.

proc getComponent*(this: UnionBoundingVolume, n: int): GeometricBoundingVolume {.importcpp: "deconstify(#->get_component(#))", header: deconstifyCode.} ## \
## Returns the nth component in the union.

proc clearComponents*(this: UnionBoundingVolume) {.importcpp: "#->clear_components()".} ## \
## Removes all components from the volume.

proc addComponent*(this: UnionBoundingVolume, component: GeometricBoundingVolume) {.importcpp: "#->add_component(#)".} ## \
## Adds a new component to the volume.  This does not necessarily increase the
## total number of components by one, and you may or may not be able to find
## this component in the volume by a subsequent call to get_component();
## certain optimizations may prevent the component from being added, or have
## other unexpected effects on the total set of components.

proc filterIntersection*(this: UnionBoundingVolume, volume: BoundingVolume) {.importcpp: "#->filter_intersection(#)".} ## \
## Removes from the union any components that have no intersection with the
## indicated volume.

converter getClassType*(_: typedesc[UnionBoundingVolume]): TypeHandle {.importcpp: "UnionBoundingVolume::get_class_type()", header: "unionBoundingVolume.h".}

proc initRandomizer*(copy: Randomizer): Randomizer {.importcpp: "Randomizer(#)".}

proc initRandomizer*(seed: int): Randomizer {.importcpp: "Randomizer(#)".} ## \
## If seed is nonzero, it is used to define the tables; if it is zero a random
## seed is generated.

proc initRandomizer*(): Randomizer {.importcpp: "Randomizer()".} ## \
## If seed is nonzero, it is used to define the tables; if it is zero a random
## seed is generated.

proc randomInt*(this: Randomizer, range: int): int {.importcpp: "#.random_int(#)".} ## \
## Returns a random integer in the range [0, range).

proc randomReal*(this: Randomizer, range: float64): float64 {.importcpp: "#.random_real(#)".} ## \
## Returns a random double in the range [0, range).

proc randomRealUnit*(this: Randomizer): float64 {.importcpp: "#.random_real_unit()".} ## \
## Returns a random double in the range [-0.5, 0.5).

proc getNextSeed*(_: typedesc[Randomizer]): int {.importcpp: "Randomizer::get_next_seed()", header: "randomizer.h".} ## \
## Returns a random seed value for the next global Randomizer object.

proc getSeed*(this: Randomizer): int {.importcpp: "#.get_seed()".} ## \
## Returns a unique seed value based on the seed value passed to this
## Randomizer object (and on its current state).

proc getSeed*(this: PerlinNoise): int {.importcpp: "#.get_seed()".} ## \
## Returns a unique seed value based on the seed value passed to this
## PerlinNoise object (and on its current state).

proc initPerlinNoise2*(): PerlinNoise2 {.importcpp: "PerlinNoise2()".} ## \
## Randomizes the tables to make a unique noise function.  Uses a default
## scale (noise frequency), table size, and seed.

proc initPerlinNoise2*(copy: PerlinNoise2): PerlinNoise2 {.importcpp: "PerlinNoise2(#)".} ## \
## Makes an exact copy of the existing PerlinNoise object, including its
## random seed.

proc initPerlinNoise2*(sx: float64, sy: float64, table_size: int, seed: int): PerlinNoise2 {.importcpp: "PerlinNoise2(#, #, #, #)".} ## \
## Randomizes the tables to make a unique noise function.
##
## If seed is nonzero, it is used to define the tables; if it is zero a random
## seed is generated.

proc initPerlinNoise2*(sx: float64, sy: float64, table_size: int): PerlinNoise2 {.importcpp: "PerlinNoise2(#, #, #)".} ## \
## Randomizes the tables to make a unique noise function.
##
## If seed is nonzero, it is used to define the tables; if it is zero a random
## seed is generated.

proc initPerlinNoise2*(sx: float64, sy: float64): PerlinNoise2 {.importcpp: "PerlinNoise2(#, #)".} ## \
## Randomizes the tables to make a unique noise function.
##
## If seed is nonzero, it is used to define the tables; if it is zero a random
## seed is generated.

proc setScale*(this: PerlinNoise2, scale: LVecBase2d) {.importcpp: "#.set_scale(#)".} ## \
## Changes the scale (frequency) of the noise.

proc setScale*(this: PerlinNoise2, scale: LVecBase2f) {.importcpp: "#.set_scale(#)".} ## \
## Changes the scale (frequency) of the noise.

proc setScale*(this: PerlinNoise2, scale: float64) {.importcpp: "#.set_scale(#)".} ## \
## Changes the scale (frequency) of the noise.

proc setScale*(this: PerlinNoise2, sx: float64, sy: float64) {.importcpp: "#.set_scale(#, #)".} ## \
## Changes the scale (frequency) of the noise.

proc noise*(this: PerlinNoise2, value: LVecBase2d): float64 {.importcpp: "#.noise(#)".} ## \
## Returns the noise function of the three inputs.

proc noise*(this: PerlinNoise2, value: LVecBase2f): float32 {.importcpp: "#.noise(#)".} ## \
## Returns the noise function of the three inputs.

proc noise*(this: PerlinNoise2, x: float64, y: float64): float64 {.importcpp: "#.noise(#, #)".} ## \
## Returns the noise function of the three inputs.

proc initPerlinNoise3*(): PerlinNoise3 {.importcpp: "PerlinNoise3()".} ## \
## Randomizes the tables to make a unique noise function.  Uses a default
## scale (noise frequency), table size, and seed.

proc initPerlinNoise3*(copy: PerlinNoise3): PerlinNoise3 {.importcpp: "PerlinNoise3(#)".} ## \
## Makes an exact copy of the existing PerlinNoise object, including its
## random seed.

proc initPerlinNoise3*(sx: float64, sy: float64, sz: float64, table_size: int, seed: int): PerlinNoise3 {.importcpp: "PerlinNoise3(#, #, #, #, #)".} ## \
## Randomizes the tables to make a unique noise function.
##
## If seed is nonzero, it is used to define the tables; if it is zero a random
## seed is generated.

proc initPerlinNoise3*(sx: float64, sy: float64, sz: float64, table_size: int): PerlinNoise3 {.importcpp: "PerlinNoise3(#, #, #, #)".} ## \
## Randomizes the tables to make a unique noise function.
##
## If seed is nonzero, it is used to define the tables; if it is zero a random
## seed is generated.

proc initPerlinNoise3*(sx: float64, sy: float64, sz: float64): PerlinNoise3 {.importcpp: "PerlinNoise3(#, #, #)".} ## \
## Randomizes the tables to make a unique noise function.
##
## If seed is nonzero, it is used to define the tables; if it is zero a random
## seed is generated.

proc setScale*(this: PerlinNoise3, scale: LVecBase3d) {.importcpp: "#.set_scale(#)".} ## \
## Changes the scale (frequency) of the noise.

proc setScale*(this: PerlinNoise3, scale: LVecBase3f) {.importcpp: "#.set_scale(#)".} ## \
## Changes the scale (frequency) of the noise.

proc setScale*(this: PerlinNoise3, scale: float64) {.importcpp: "#.set_scale(#)".} ## \
## Changes the scale (frequency) of the noise.

proc setScale*(this: PerlinNoise3, sx: float64, sy: float64, sz: float64) {.importcpp: "#.set_scale(#, #, #)".} ## \
## Changes the scale (frequency) of the noise.

proc noise*(this: PerlinNoise3, value: LVecBase3d): float64 {.importcpp: "#.noise(#)".} ## \
## Returns the noise function of the three inputs.

proc noise*(this: PerlinNoise3, value: LVecBase3f): float32 {.importcpp: "#.noise(#)".} ## \
## Returns the noise function of the three inputs.

proc noise*(this: PerlinNoise3, x: float64, y: float64, z: float64): float64 {.importcpp: "#.noise(#, #, #)".} ## \
## Returns the noise function of the three inputs.

proc rotateTo*(mat: LMatrix3d, a: LVector3d, b: LVector3d) {.importcpp: "rotate_to(#, #, #)".}

proc rotateTo*(mat: LMatrix3f, a: LVector3f, b: LVector3f) {.importcpp: "rotate_to(#, #, #)".}

proc rotateTo*(mat: LMatrix4d, a: LVector3d, b: LVector3d) {.importcpp: "rotate_to(#, #, #)".}

proc rotateTo*(mat: LMatrix4f, a: LVector3f, b: LVector3f) {.importcpp: "rotate_to(#, #, #)".}

proc initStackedPerlinNoise2*(): StackedPerlinNoise2 {.importcpp: "StackedPerlinNoise2()".} ## \
## Creates a StackedPerlinNoise2 object with no levels.  You should call
## add_level() to add each level by hand.

proc initStackedPerlinNoise2*(copy: StackedPerlinNoise2): StackedPerlinNoise2 {.importcpp: "StackedPerlinNoise2(#)".} ## \
## Creates an exact duplicate of the existing StackedPerlinNoise2 object,
## including the random seed.

proc initStackedPerlinNoise2*(sx: float64, sy: float64, num_levels: int, scale_factor: float64, amp_scale: float64, table_size: int, seed: int): StackedPerlinNoise2 {.importcpp: "StackedPerlinNoise2(#, #, #, #, #, #, #)".} ## \
## Creates num_levels nested PerlinNoise2 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc initStackedPerlinNoise2*(sx: float64, sy: float64, num_levels: int, scale_factor: float64, amp_scale: float64, table_size: int): StackedPerlinNoise2 {.importcpp: "StackedPerlinNoise2(#, #, #, #, #, #)".} ## \
## Creates num_levels nested PerlinNoise2 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc initStackedPerlinNoise2*(sx: float64, sy: float64, num_levels: int, scale_factor: float64, amp_scale: float64): StackedPerlinNoise2 {.importcpp: "StackedPerlinNoise2(#, #, #, #, #)".} ## \
## Creates num_levels nested PerlinNoise2 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc initStackedPerlinNoise2*(sx: float64, sy: float64, num_levels: int, scale_factor: float64): StackedPerlinNoise2 {.importcpp: "StackedPerlinNoise2(#, #, #, #)".} ## \
## Creates num_levels nested PerlinNoise2 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc initStackedPerlinNoise2*(sx: float64, sy: float64, num_levels: int): StackedPerlinNoise2 {.importcpp: "StackedPerlinNoise2(#, #, #)".} ## \
## Creates num_levels nested PerlinNoise2 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc initStackedPerlinNoise2*(sx: float64, sy: float64): StackedPerlinNoise2 {.importcpp: "StackedPerlinNoise2(#, #)".} ## \
## Creates num_levels nested PerlinNoise2 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc addLevel*(this: StackedPerlinNoise2, level: PerlinNoise2, amp: float64) {.importcpp: "#.add_level(#, #)".} ## \
## Adds an arbitrary PerlinNoise2 object, and an associated amplitude, to the
## stack.

proc addLevel*(this: StackedPerlinNoise2, level: PerlinNoise2) {.importcpp: "#.add_level(#)".} ## \
## Adds an arbitrary PerlinNoise2 object, and an associated amplitude, to the
## stack.

proc clear*(this: StackedPerlinNoise2) {.importcpp: "#.clear()".} ## \
## Removes all levels from the stack.  You must call add_level() again to
## restore them.

proc noise*(this: StackedPerlinNoise2, value: LVecBase2d): float64 {.importcpp: "#.noise(#)".} ## \
## Returns the noise function of the three inputs.

proc noise*(this: StackedPerlinNoise2, value: LVecBase2f): float32 {.importcpp: "#.noise(#)".} ## \
## Returns the noise function of the three inputs.

proc noise*(this: StackedPerlinNoise2, x: float64, y: float64): float64 {.importcpp: "#.noise(#, #)".} ## \
## Returns the noise function of the three inputs.

proc initStackedPerlinNoise3*(): StackedPerlinNoise3 {.importcpp: "StackedPerlinNoise3()".} ## \
## Creates a StackedPerlinNoise3 object with no levels.  You should call
## add_level() to add each level by hand.

proc initStackedPerlinNoise3*(copy: StackedPerlinNoise3): StackedPerlinNoise3 {.importcpp: "StackedPerlinNoise3(#)".} ## \
## Creates an exact duplicate of the existing StackedPerlinNoise3 object,
## including the random seed.

proc initStackedPerlinNoise3*(sx: float64, sy: float64, sz: float64, num_levels: int, scale_factor: float64, amp_scale: float64, table_size: int, seed: int): StackedPerlinNoise3 {.importcpp: "StackedPerlinNoise3(#, #, #, #, #, #, #, #)".} ## \
## Creates num_levels nested PerlinNoise3 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc initStackedPerlinNoise3*(sx: float64, sy: float64, sz: float64, num_levels: int, scale_factor: float64, amp_scale: float64, table_size: int): StackedPerlinNoise3 {.importcpp: "StackedPerlinNoise3(#, #, #, #, #, #, #)".} ## \
## Creates num_levels nested PerlinNoise3 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc initStackedPerlinNoise3*(sx: float64, sy: float64, sz: float64, num_levels: int, scale_factor: float64, amp_scale: float64): StackedPerlinNoise3 {.importcpp: "StackedPerlinNoise3(#, #, #, #, #, #)".} ## \
## Creates num_levels nested PerlinNoise3 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc initStackedPerlinNoise3*(sx: float64, sy: float64, sz: float64, num_levels: int, scale_factor: float64): StackedPerlinNoise3 {.importcpp: "StackedPerlinNoise3(#, #, #, #, #)".} ## \
## Creates num_levels nested PerlinNoise3 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc initStackedPerlinNoise3*(sx: float64, sy: float64, sz: float64, num_levels: int): StackedPerlinNoise3 {.importcpp: "StackedPerlinNoise3(#, #, #, #)".} ## \
## Creates num_levels nested PerlinNoise3 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc initStackedPerlinNoise3*(sx: float64, sy: float64, sz: float64): StackedPerlinNoise3 {.importcpp: "StackedPerlinNoise3(#, #, #)".} ## \
## Creates num_levels nested PerlinNoise3 objects.  Each stacked Perlin object
## will have a scale of 1 scale_factor times the previous object (so that it
## is higher-frequency, if scale_factor > 1), and an amplitude of amp_scale
## times the previous object (so that it is less important, if amp_scale < 1).

proc addLevel*(this: StackedPerlinNoise3, level: PerlinNoise3, amp: float64) {.importcpp: "#.add_level(#, #)".} ## \
## Adds an arbitrary PerlinNoise3 object, and an associated amplitude, to the
## stack.

proc addLevel*(this: StackedPerlinNoise3, level: PerlinNoise3) {.importcpp: "#.add_level(#)".} ## \
## Adds an arbitrary PerlinNoise3 object, and an associated amplitude, to the
## stack.

proc clear*(this: StackedPerlinNoise3) {.importcpp: "#.clear()".} ## \
## Removes all levels from the stack.  You must call add_level() again to
## restore them.

proc noise*(this: StackedPerlinNoise3, value: LVecBase3d): float64 {.importcpp: "#.noise(#)".} ## \
## Returns the noise function of the three inputs.

proc noise*(this: StackedPerlinNoise3, value: LVecBase3f): float32 {.importcpp: "#.noise(#)".} ## \
## Returns the noise function of the three inputs.

proc noise*(this: StackedPerlinNoise3, x: float64, y: float64, z: float64): float64 {.importcpp: "#.noise(#, #, #)".} ## \
## Returns the noise function of the three inputs.

proc initTriangulator*(): Triangulator {.importcpp: "Triangulator()".}

proc initTriangulator*(param0: Triangulator): Triangulator {.importcpp: "Triangulator(#)".}

proc clear*(this: Triangulator) {.importcpp: "#.clear()".} ## \
## Removes all vertices and polygon specifications from the Triangulator, and
## prepares it to start over.

proc addVertex*(this: Triangulator, point: LPoint2d): int {.importcpp: "#.add_vertex(#)".} ## \
## Adds a new vertex to the vertex pool.  Returns the vertex index number.

proc addVertex*(this: Triangulator, x: float64, y: float64): int {.importcpp: "#.add_vertex(#, #)".} ## \
## Adds a new vertex to the vertex pool.  Returns the vertex index number.

proc getNumVertices*(this: Triangulator): int {.importcpp: "#.get_num_vertices()".} ## \
## Returns the number of vertices in the pool.  Note that the Triangulator
## might append new vertices, in addition to those added by the user, if any
## of the polygon is self-intersecting, or if any of the holes intersect some
## part of the polygon edges.

proc getVertex*(this: Triangulator, n: int): LPoint2d {.importcpp: "#.get_vertex(#)".} ## \
## Returns the nth vertex.

proc clearPolygon*(this: Triangulator) {.importcpp: "#.clear_polygon()".} ## \
## Removes the current polygon definition (and its set of holes), but does not
## clear the vertex pool.

proc addPolygonVertex*(this: Triangulator, index: int) {.importcpp: "#.add_polygon_vertex(#)".} ## \
## Adds the next consecutive vertex of the polygon.  This vertex should index
## into the vertex pool established by repeated calls to add_vertex().
##
## The vertices may be listed in either clockwise or counterclockwise order.
## Vertices should not be repeated.  In particular, do not repeat the first
## vertex at the end.

proc isLeftWinding*(this: Triangulator): bool {.importcpp: "#.is_left_winding()".} ## \
## Returns true if the polygon vertices are listed in counterclockwise order,
## or false if they appear to be listed in clockwise order.

proc beginHole*(this: Triangulator) {.importcpp: "#.begin_hole()".} ## \
## Finishes the previous hole, if any, and prepares to add a new hole.

proc addHoleVertex*(this: Triangulator, index: int) {.importcpp: "#.add_hole_vertex(#)".} ## \
## Adds the next consecutive vertex of the current hole.  This vertex should
## index into the vertex pool established by repeated calls to add_vertex().
##
## The vertices may be listed in either clockwise or counterclockwise order.
## Vertices should not be repeated.

proc triangulate*(this: Triangulator) {.importcpp: "#.triangulate()".} ## \
## Does the work of triangulating the specified polygon.  After this call, you
## may retrieve the new triangles one at a time by iterating through
## get_triangle_v0/1/2().

proc getNumTriangles*(this: Triangulator): int {.importcpp: "#.get_num_triangles()".} ## \
## Returns the number of triangles generated by the previous call to
## triangulate().

proc getTriangleV0*(this: Triangulator, n: int): int {.importcpp: "#.get_triangle_v0(#)".} ## \
## Returns vertex 0 of the nth triangle generated by the previous call to
## triangulate().
##
## This is a zero-based index into the vertices added by repeated calls to
## add_vertex().

proc getTriangleV1*(this: Triangulator, n: int): int {.importcpp: "#.get_triangle_v1(#)".} ## \
## Returns vertex 1 of the nth triangle generated by the previous call to
## triangulate().
##
## This is a zero-based index into the vertices added by repeated calls to
## add_vertex().

proc getTriangleV2*(this: Triangulator, n: int): int {.importcpp: "#.get_triangle_v2(#)".} ## \
## Returns vertex 2 of the nth triangle generated by the previous call to
## triangulate().
##
## This is a zero-based index into the vertices added by repeated calls to
## add_vertex().

proc initTriangulator3*(): Triangulator3 {.importcpp: "Triangulator3()".}

proc initTriangulator3*(param0: Triangulator3): Triangulator3 {.importcpp: "Triangulator3(#)".}

proc clear*(this: Triangulator3) {.importcpp: "#.clear()".} ## \
## Removes all vertices and polygon specifications from the Triangulator, and
## prepares it to start over.

proc addVertex*(this: Triangulator3, point: LPoint3d): int {.importcpp: "#.add_vertex(#)".} ## \
## Adds a new vertex to the vertex pool.  Returns the vertex index number.

proc addVertex*(this: Triangulator3, x: float64, y: float64, z: float64): int {.importcpp: "#.add_vertex(#, #, #)".} ## \
## Adds a new vertex to the vertex pool.  Returns the vertex index number.

proc getNumVertices*(this: Triangulator3): int {.importcpp: "#.get_num_vertices()".} ## \
## Returns the number of vertices in the pool.  Note that the Triangulator
## might append new vertices, in addition to those added by the user, if any
## of the polygon is self-intersecting, or if any of the holes intersect some
## part of the polygon edges.

proc getVertex*(this: Triangulator3, n: int): LPoint3d {.importcpp: "#.get_vertex(#)".} ## \
## Returns the nth vertex.

proc triangulate*(this: Triangulator3) {.importcpp: "#.triangulate()".} ## \
## Does the work of triangulating the specified polygon.  After this call, you
## may retrieve the new triangles one at a time by iterating through
## get_triangle_v0/1/2().

proc getPlane*(this: Triangulator3): LPlaned {.importcpp: "#.get_plane()".} ## \
## Returns the plane of the polygon.  This is only available after calling
## triangulate().

proc isValid*(this: ParametricCurve): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the curve is defined.  This base class function always
## returns true; derived classes might override this to sometimes return
## false.

proc getMaxT*(this: ParametricCurve): float32 {.importcpp: "#->get_max_t()".} ## \
## Returns the upper bound of t for the entire curve.  The curve is defined in
## the range 0.0f <= t <= get_max_t().  This base class function always
## returns 1.0f; derived classes might override this to return something else.

proc setCurveType*(this: ParametricCurve, `type`: int) {.importcpp: "#->set_curve_type(#)".} ## \
## Sets the flag indicating the use to which the curve is intended to be put.
## This flag is optional and only serves to provide a hint to the egg reader
## and writer code; it has no effect on the curve's behavior.
##
## Setting the curve type also sets the num_dimensions to 3 or 1 according to
## the type.
##
## THis flag may have one of the values PCT_XYZ, PCT_HPR, or PCT_T.

proc getCurveType*(this: ParametricCurve): int {.importcpp: "#->get_curve_type()".} ## \
## Returns the flag indicating the use to which the curve is intended to be
## put.

proc setNumDimensions*(this: ParametricCurve, num: int) {.importcpp: "#->set_num_dimensions(#)".} ## \
## Specifies the number of significant dimensions in the curve's vertices.
## This should be one of 1, 2, or 3. Normally, XYZ and HPR curves have three
## dimensions; time curves should always have one dimension.  This only serves
## as a hint to the mopath editor, and also controls how the curve is written
## out.

proc getNumDimensions*(this: ParametricCurve): int {.importcpp: "#->get_num_dimensions()".} ## \
## Returns the number of significant dimensions in the curve's vertices, as
## set by a previous call to set_num_dimensions().  This is only a hint as to
## how the curve is intended to be used; the actual number of dimensions of
## any curve is always three.

proc calcLength*(this: ParametricCurve): float32 {.importcpp: "#->calc_length()".} ## \
## Approximates the length of the entire curve to within a few decimal places.

proc calcLength*(this: ParametricCurve, `from`: float32, to: float32): float32 {.importcpp: "#->calc_length(#, #)".} ## \
## Approximates the length of the curve segment from parametric time 'from' to
## time 'to'.

proc findLength*(this: ParametricCurve, start_t: float32, length_offset: float32): float32 {.importcpp: "#->find_length(#, #)".} ## \
## Returns the parametric value corresponding to the indicated distance along
## the curve from the starting parametric value.
##
## This is the inverse of calc_length(): rather than determining the length
## along the curve between two parametric points, it determines the position
## in parametric time of a point n units along the curve.
##
## The search distance must not be negative.

proc getPoint*(this: ParametricCurve, t: float32, point: LVecBase3): bool {.importcpp: "#->get_point(#, #)".}

proc getTangent*(this: ParametricCurve, t: float32, tangent: LVecBase3): bool {.importcpp: "#->get_tangent(#, #)".}

proc getPt*(this: ParametricCurve, t: float32, point: LVecBase3, tangent: LVecBase3): bool {.importcpp: "#->get_pt(#, #, #)".}

proc get2ndtangent*(this: ParametricCurve, t: float32, tangent2: LVecBase3): bool {.importcpp: "#->get_2ndtangent(#, #)".}

proc adjustPoint*(this: ParametricCurve, t: float32, px: float32, py: float32, pz: float32): bool {.importcpp: "#->adjust_point(#, #, #, #)".} ## \
## Recomputes the curve such that it passes through the point (px, py, pz) at
## time t, but keeps the same tangent value at that point.

proc adjustTangent*(this: ParametricCurve, t: float32, tx: float32, ty: float32, tz: float32): bool {.importcpp: "#->adjust_tangent(#, #, #, #)".} ## \
## Recomputes the curve such that it has the tangent (tx, ty, tz) at time t,
## but keeps the same position at the point.

proc adjustPt*(this: ParametricCurve, t: float32, px: float32, py: float32, pz: float32, tx: float32, ty: float32, tz: float32): bool {.importcpp: "#->adjust_pt(#, #, #, #, #, #, #)".} ## \
## Recomputes the curve such that it passes through the point (px, py, pz)
## with the tangent (tx, ty, tz).

proc recompute*(this: ParametricCurve): bool {.importcpp: "#->recompute()".} ## \
## Recalculates the curve, if necessary.  Returns true if the resulting curve
## is valid, false otherwise.

proc stitch*(this: ParametricCurve, a: ParametricCurve, b: ParametricCurve): bool {.importcpp: "#->stitch(#, #)".} ## \
## Regenerates this curve as one long curve: the first curve connected end-to-
## end with the second one.  Either a or b may be the same as 'this'.
##
## Returns true if successful, false on failure or if the curve type does not
## support stitching.

proc writeEgg*(this: ParametricCurve, filename: Filename, cs: CoordinateSystem): bool {.importcpp: "#->write_egg(#, #)".} ## \
## Writes an egg description of the nurbs curve to the specified output file.
## Returns true if the file is successfully written.

proc writeEgg*(this: ParametricCurve, filename: Filename): bool {.importcpp: "#->write_egg(#)".} ## \
## Writes an egg description of the nurbs curve to the specified output file.
## Returns true if the file is successfully written.

proc writeEgg*(this: ParametricCurve, `out`: ostream, filename: Filename, cs: CoordinateSystem): bool {.importcpp: "#->write_egg(#, #, #)".} ## \
## Writes an egg description of the nurbs curve to the specified output
## stream.  Returns true if the file is successfully written.

converter getClassType*(_: typedesc[ParametricCurve]): TypeHandle {.importcpp: "ParametricCurve::get_class_type()", header: "parametricCurve.h".}

converter getClassType*(_: typedesc[CubicCurveseg]): TypeHandle {.importcpp: "CubicCurveseg::get_class_type()", header: "cubicCurveseg.h".}

proc newParametricCurveCollection*(): ParametricCurveCollection {.importcpp: "new ParametricCurveCollection()".}

proc newParametricCurveCollection*(param0: ParametricCurveCollection): ParametricCurveCollection {.importcpp: "new ParametricCurveCollection(#)".}

proc addCurve*(this: ParametricCurveCollection, curve: ParametricCurve) {.importcpp: "#->add_curve(#)".} ## \
## Adds a new ParametricCurve to the collection.

proc addCurve*(this: ParametricCurveCollection, curve: ParametricCurve, index: int) {.importcpp: "#->add_curve(#, #)".} ## \
## Adds a new ParametricCurve to the collection at the indicated index.
## @deprecated Use insert_curve(index, curve) instead.

proc insertCurve*(this: ParametricCurveCollection, index: clonglong, curve: ParametricCurve) {.importcpp: "#->insert_curve(#, #)".} ## \
## Adds a new ParametricCurve to the collection at the indicated index.

proc addCurves*(this: ParametricCurveCollection, node: PandaNode): int {.importcpp: "#->add_curves(#)".} ## \
## Adds all the curves found in the scene graph rooted at the given node.
## Returns the number of curves found.

proc removeCurve*(this: ParametricCurveCollection, curve: ParametricCurve): bool {.importcpp: "#->remove_curve(#)".} ## \
## Removes the indicated ParametricCurve from the collection.  Returns true if
## the curve was removed, false if it was not a member of the collection.

proc removeCurve*(this: ParametricCurveCollection, index: clonglong) {.importcpp: "#->remove_curve(#)".} ## \
## Removes the indicated ParametricCurve from the collection, by its index
## number.

proc setCurve*(this: ParametricCurveCollection, index: clonglong, curve: ParametricCurve) {.importcpp: "#->set_curve(#, #)".} ## \
## Replaces the indicated ParametricCurve from the collection, by its index
## number.

proc hasCurve*(this: ParametricCurveCollection, curve: ParametricCurve): bool {.importcpp: "#->has_curve(#)".} ## \
## Returns true if the indicated ParametricCurve appears in this collection,
## false otherwise.

proc clear*(this: ParametricCurveCollection) {.importcpp: "#->clear()".} ## \
## Removes all ParametricCurves from the collection.

proc clearTimewarps*(this: ParametricCurveCollection) {.importcpp: "#->clear_timewarps()".} ## \
## Removes all the timewarp curves from the collection.

proc getNumCurves*(this: ParametricCurveCollection): int {.importcpp: "#->get_num_curves()".} ## \
## Returns the number of ParametricCurves in the collection.

proc getCurve*(this: ParametricCurveCollection, index: int): ParametricCurve {.importcpp: "#->get_curve(#)".} ## \
## Returns the nth ParametricCurve in the collection.

proc getXyzCurve*(this: ParametricCurveCollection): ParametricCurve {.importcpp: "#->get_xyz_curve()".} ## \
## Returns the first XYZ curve in the collection, if any, or NULL if there are
## none.

proc getHprCurve*(this: ParametricCurveCollection): ParametricCurve {.importcpp: "#->get_hpr_curve()".} ## \
## Returns the first HPR curve in the collection, if any, or NULL if there are
## none.

proc getDefaultCurve*(this: ParametricCurveCollection): ParametricCurve {.importcpp: "#->get_default_curve()".} ## \
## If there is an XYZ curve in the collection, returns it; otherwise, returns
## the first curve whose type is unspecified.  Returns NULL if no curve meets
## the criteria.

proc getNumTimewarps*(this: ParametricCurveCollection): int {.importcpp: "#->get_num_timewarps()".} ## \
## Returns the number of timewarp curves in the collection.

proc getTimewarpCurve*(this: ParametricCurveCollection, n: int): ParametricCurve {.importcpp: "#->get_timewarp_curve(#)".} ## \
## Returns the nth timewarp curve in the collection.

proc getMaxT*(this: ParametricCurveCollection): float32 {.importcpp: "#->get_max_t()".} ## \
## Returns the maximum T value associated with the \*last\* curve in the
## collection.  Normally, this will be either the XYZ or HPR curve, or a
## timewarp curve.

proc makeEven*(this: ParametricCurveCollection, max_t: float32, segments_per_unit: float32) {.importcpp: "#->make_even(#, #)".} ## \
## Discards all existing timewarp curves and recomputes a new timewarp curve
## that maps distance along the curve to parametric time, so that the distance
## between any two points in parametric time is proportional to the
## approximate distance of those same two points along the XYZ curve.
##
## segments_per_unit represents the number of segments to take per each unit
## of parametric time of the original XYZ curve.
##
## The new timewarp curve (and thus, the apparent range of the collection)
## will range from 0 to max_t.

proc faceForward*(this: ParametricCurveCollection, segments_per_unit: float32) {.importcpp: "#->face_forward(#)".} ## \
## Discards the existing HPR curve and generates a new one that looks in the
## direction of travel along the XYZ curve, based on the XYZ curve's tangent
## at each point.

proc resetMaxT*(this: ParametricCurveCollection, max_t: float32) {.importcpp: "#->reset_max_t(#)".} ## \
## Adjusts the apparent length of the curve by applying a new timewarp that
## maps the range [0..max_t] to the range [0..get_max_t()].  After this call,
## the curve collection will contain one more timewarp curve, and get_max_t()
## will return the given max_t value.

proc evaluate*(this: ParametricCurveCollection, t: float32, result: LMatrix4, cs: CoordinateSystem): bool {.importcpp: "#->evaluate(#, #, #)".} ## \
## Computes the transform matrix representing translation to the position
## indicated by the first XYZ curve in the collection and the rotation
## indicated by the first HPR curve in the collection, after t has been
## modified by all the timewarp curves in the collection applied in sequence,
## from back to front.
##
## Returns true if the point is valid (i.e.  t is within the bounds indicated
## by all the timewarp curves and within the bounds of the curves themselves),
## or false otherwise.

proc evaluate*(this: ParametricCurveCollection, t: float32, result: LMatrix4): bool {.importcpp: "#->evaluate(#, #)".} ## \
## Computes the transform matrix representing translation to the position
## indicated by the first XYZ curve in the collection and the rotation
## indicated by the first HPR curve in the collection, after t has been
## modified by all the timewarp curves in the collection applied in sequence,
## from back to front.
##
## Returns true if the point is valid (i.e.  t is within the bounds indicated
## by all the timewarp curves and within the bounds of the curves themselves),
## or false otherwise.

proc evaluate*(this: ParametricCurveCollection, t: float32, xyz: LVecBase3, hpr: LVecBase3): bool {.importcpp: "#->evaluate(#, #, #)".} ## \
## Computes the position and rotation represented by the first XYZ and HPR
## curves in the collection at the given point t, after t has been modified by
## all the timewarp curves in the collection applied in sequence, from back to
## front.
##
## Returns true if the point is valid (i.e.  t is within the bounds indicated
## by all the timewarp curves and within the bounds of the curves themselves),
## or false otherwise.

proc evaluateT*(this: ParametricCurveCollection, t: float32): float32 {.importcpp: "#->evaluate_t(#)".} ## \
## Determines the value of t that should be passed to the XYZ and HPR curves,
## after applying the given value of t to all the timewarps.  Return -1.0f if
## the value of t exceeds one of the timewarps' ranges.

proc evaluateXyz*(this: ParametricCurveCollection, t: float32, xyz: LVecBase3): bool {.importcpp: "#->evaluate_xyz(#, #)".} ## \
## Computes only the XYZ part of the curves.  See evaluate().

proc evaluateHpr*(this: ParametricCurveCollection, t: float32, hpr: LVecBase3): bool {.importcpp: "#->evaluate_hpr(#, #)".} ## \
## Computes only the HPR part of the curves.  See evaluate().

proc adjustXyz*(this: ParametricCurveCollection, t: float32, xyz: LVecBase3): bool {.importcpp: "#->adjust_xyz(#, #)".} ## \
## Adjust the XYZ curve at the indicated time to the new value.  The curve
## shape will change correspondingly.  Returns true if successful, false if
## unable to make the adjustment for some reason.

proc adjustXyz*(this: ParametricCurveCollection, t: float32, x: float32, y: float32, z: float32): bool {.importcpp: "#->adjust_xyz(#, #, #, #)".} ## \
## Adjust the XYZ curve at the indicated time to the new value.  The curve
## shape will change correspondingly.  Returns true if successful, false if
## unable to make the adjustment for some reason.

proc adjustHpr*(this: ParametricCurveCollection, t: float32, xyz: LVecBase3): bool {.importcpp: "#->adjust_hpr(#, #)".} ## \
## Adjust the HPR curve at the indicated time to the new value.  The curve
## shape will change correspondingly.  Returns true if successful, false if
## unable to make the adjustment for some reason.

proc adjustHpr*(this: ParametricCurveCollection, t: float32, h: float32, p: float32, r: float32): bool {.importcpp: "#->adjust_hpr(#, #, #, #)".} ## \
## Adjust the HPR curve at the indicated time to the new value.  The curve
## shape will change correspondingly.  Returns true if successful, false if
## unable to make the adjustment for some reason.

proc recompute*(this: ParametricCurveCollection): bool {.importcpp: "#->recompute()".} ## \
## Ensures all the curves are freshly computed and up-to-date.  Returns true
## if everything is valid, false if at least one curve is incorrect.

proc stitch*(this: ParametricCurveCollection, a: ParametricCurveCollection, b: ParametricCurveCollection): bool {.importcpp: "#->stitch(#, #)".} ## \
## Regenerates this curve as one long curve: the first curve connected end-to-
## end with the second one.  Either a or b may be the same as 'this'.  This
## will lose any timewarps on the input curves.
##
## Returns true if successful, false on failure.

proc output*(this: ParametricCurveCollection, `out`: ostream) {.importcpp: "#->output(#)".} ## \
## Writes a brief one-line description of the ParametricCurveCollection to the
## indicated output stream.

proc write*(this: ParametricCurveCollection, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".} ## \
## Writes a complete multi-line description of the ParametricCurveCollection
## to the indicated output stream.

proc write*(this: ParametricCurveCollection, `out`: ostream) {.importcpp: "#->write(#)".} ## \
## Writes a complete multi-line description of the ParametricCurveCollection
## to the indicated output stream.

proc writeEgg*(this: ParametricCurveCollection, filename: Filename, cs: CoordinateSystem): bool {.importcpp: "#->write_egg(#, #)".} ## \
## Writes an egg description of all the nurbs curves in the collection to the
## specified output file.  Returns true if the file is successfully written.

proc writeEgg*(this: ParametricCurveCollection, filename: Filename): bool {.importcpp: "#->write_egg(#)".} ## \
## Writes an egg description of all the nurbs curves in the collection to the
## specified output file.  Returns true if the file is successfully written.

proc writeEgg*(this: ParametricCurveCollection, `out`: ostream, filename: Filename, cs: CoordinateSystem): bool {.importcpp: "#->write_egg(#, #, #)".} ## \
## Writes an egg description of all the nurbs curves in the collection to the
## specified output stream.  Returns true if the file is successfully written.

proc initCurveFitter*(): CurveFitter {.importcpp: "CurveFitter()".}

proc initCurveFitter*(param0: CurveFitter): CurveFitter {.importcpp: "CurveFitter(#)".}

proc reset*(this: CurveFitter) {.importcpp: "#.reset()".} ## \
## Removes all the data points previously added to the CurveFitter, and
## initializes it for a new curve.

proc addXyz*(this: CurveFitter, t: float32, xyz: LVecBase3) {.importcpp: "#.add_xyz(#, #)".} ## \
## Adds a single sample xyz.

proc addHpr*(this: CurveFitter, t: float32, hpr: LVecBase3) {.importcpp: "#.add_hpr(#, #)".} ## \
## Adds a single sample hpr.

proc addXyzHpr*(this: CurveFitter, t: float32, xyz: LVecBase3, hpr: LVecBase3) {.importcpp: "#.add_xyz_hpr(#, #, #)".} ## \
## Adds a single sample xyz & hpr simultaneously.

proc getNumSamples*(this: CurveFitter): int {.importcpp: "#.get_num_samples()".} ## \
## Returns the number of sample points that have been added.

proc getSampleT*(this: CurveFitter, n: int): float32 {.importcpp: "#.get_sample_t(#)".} ## \
## Returns the parametric value of the nth sample added.

proc getSampleXyz*(this: CurveFitter, n: int): LVecBase3 {.importcpp: "#.get_sample_xyz(#)".} ## \
## Returns the point in space of the nth sample added.

proc getSampleHpr*(this: CurveFitter, n: int): LVecBase3 {.importcpp: "#.get_sample_hpr(#)".} ## \
## Returns the orientation of the nth sample added.

proc getSampleTangent*(this: CurveFitter, n: int): LVecBase3 {.importcpp: "#.get_sample_tangent(#)".} ## \
## Returns the tangent associated with the nth sample added.  This is only
## meaningful if compute_tangents() has already been called.

proc removeSamples*(this: CurveFitter, begin: int, `end`: int) {.importcpp: "#.remove_samples(#, #)".} ## \
## Eliminates all samples from index begin, up to but not including index end,
## from the database.

proc sample*(this: CurveFitter, curves: ParametricCurveCollection, count: int) {.importcpp: "#.sample(#, #)".} ## \
## Generates a series of data points by sampling the given curve (or xyz/hpr
## curves) the indicated number of times.  The sampling is made evenly in
## parametric time, and then the timewarps, if any, are applied.

proc wrapHpr*(this: CurveFitter) {.importcpp: "#.wrap_hpr()".} ## \
## Resets each HPR data point so that the maximum delta between any two
## consecutive points is 180 degrees, which should prevent incorrect HPR
## wrapping.

proc sortPoints*(this: CurveFitter) {.importcpp: "#.sort_points()".} ## \
## Sorts all the data points in order by parametric time, in case they were
## added in an incorrect order.

proc desample*(this: CurveFitter, factor: float32) {.importcpp: "#.desample(#)".} ## \
## Removes sample points in order to reduce the complexity of a sampled curve.
## Keeps one out of every factor samples.  Also keeps the first and the last
## samples.

proc computeTangents*(this: CurveFitter, scale: float32) {.importcpp: "#.compute_tangents(#)".} ## \
## Once a set of points has been built, and prior to calling MakeHermite() or
## MakeNurbs(), ComputeTangents() must be called to set up the tangents
## correctly (unless the tangents were defined as the points were added).

proc makeHermite*(this: CurveFitter): ParametricCurveCollection {.importcpp: "#.make_hermite()".} ## \
## Converts the current set of data points into a Hermite curve.

proc makeNurbs*(this: CurveFitter): ParametricCurveCollection {.importcpp: "#.make_nurbs()".} ## \
## Converts the current set of data points into a NURBS curve.  This gives a
## smoother curve than produced by MakeHermite().

proc output*(this: CurveFitter, `out`: ostream) {.importcpp: "#.output(#)".}

proc write*(this: CurveFitter, `out`: ostream) {.importcpp: "#.write(#)".}

converter getClassType*(_: typedesc[CurveFitter]): TypeHandle {.importcpp: "CurveFitter::get_class_type()", header: "curveFitter.h".}

proc newPiecewiseCurve*(): PiecewiseCurve {.importcpp: "new PiecewiseCurve()".}

converter getClassType*(_: typedesc[PiecewiseCurve]): TypeHandle {.importcpp: "PiecewiseCurve::get_class_type()", header: "piecewiseCurve.h".}

proc newHermiteCurve*(): HermiteCurve {.importcpp: "new HermiteCurve()".}

proc newHermiteCurve*(pc: ParametricCurve): HermiteCurve {.importcpp: "new HermiteCurve(#)".} ## \
## Constructs a Hermite from the indicated (possibly non-hermite) curve.

proc getNumCvs*(this: HermiteCurve): int {.importcpp: "#->get_num_cvs()".} ## \
## Returns the number of CV's in the curve.

proc insertCv*(this: HermiteCurve, t: float32): int {.importcpp: "#->insert_cv(#)".} ## \
## Inserts a new CV at the given parametric point along the curve.  If this
## parametric point is already on the curve, the CV is assigned an index
## between its two neighbors and the indices of all following CV's are
## incremented by 1; its in and out tangents are chosen to keep the curve
## consistent.  If the new parametric point is beyond the end of the existing
## curve, the curve is extended to meet it and the new CV's position, in
## tangent, and out tangent are set to zero.
##
## The index number of the new CV is returned.

proc appendCv*(this: HermiteCurve, `type`: int, v: LVecBase3): int {.importcpp: "#->append_cv(#, #)".}

proc appendCv*(this: HermiteCurve, `type`: int, x: float32, y: float32, z: float32): int {.importcpp: "#->append_cv(#, #, #, #)".} ## \
## Adds a new CV to the end of the curve.  The new CV is given initial in/out
## tangents of 0.  The return value is the index of the new CV.

proc removeCv*(this: HermiteCurve, n: int): bool {.importcpp: "#->remove_cv(#)".} ## \
## Removes the given CV from the curve.  Returns true if the CV existed, false
## otherwise.

proc removeAllCvs*(this: HermiteCurve) {.importcpp: "#->remove_all_cvs()".} ## \
## Removes all CV's from the curve.

proc setCvType*(this: HermiteCurve, n: int, `type`: int): bool {.importcpp: "#->set_cv_type(#, #)".} ## \
## Changes the given CV's continuity type.  Legal values are HC_CUT, HC_FREE,
## HC_G1, or HC_SMOOTH.
##
## Other than HC_CUT, these have no effect on the actual curve; it remains up
## to user software to impose the constraints these imply.
##
## HC_CUT implies a disconnection of the curve; HC_FREE imposes no constraints
## on the tangents; HC_G1 forces the tangents to be collinear, and HC_SMOOTH
## forces the tangents to be identical.  Setting type type to HC_G1 or
## HC_SMOOTH may adjust the out tangent to match the in tangent.

proc setCvPoint*(this: HermiteCurve, n: int, v: LVecBase3): bool {.importcpp: "#->set_cv_point(#, #)".}

proc setCvPoint*(this: HermiteCurve, n: int, x: float32, y: float32, z: float32): bool {.importcpp: "#->set_cv_point(#, #, #, #)".} ## \
## Changes the given CV's position.

proc setCvIn*(this: HermiteCurve, n: int, v: LVecBase3): bool {.importcpp: "#->set_cv_in(#, #)".}

proc setCvIn*(this: HermiteCurve, n: int, x: float32, y: float32, z: float32): bool {.importcpp: "#->set_cv_in(#, #, #, #)".} ## \
## Changes the given CV's in tangent.  Depending on the continuity type, this
## may also adjust the out tangent.

proc setCvOut*(this: HermiteCurve, n: int, v: LVecBase3): bool {.importcpp: "#->set_cv_out(#, #)".}

proc setCvOut*(this: HermiteCurve, n: int, x: float32, y: float32, z: float32): bool {.importcpp: "#->set_cv_out(#, #, #, #)".} ## \
## Changes the given CV's out tangent.  Depending on the continuity type, this
## may also adjust the in tangent.

proc setCvTstart*(this: HermiteCurve, n: int, tstart: float32): bool {.importcpp: "#->set_cv_tstart(#, #)".} ## \
## Changes the given CV's parametric starting time.  This may affect the shape
## of the curve.

proc setCvName*(this: HermiteCurve, n: int, name: string): bool {.importcpp: "#->set_cv_name(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the name associated with a particular CV.

proc getCvType*(this: HermiteCurve, n: int): int {.importcpp: "#->get_cv_type(#)".} ## \
## Returns the given CV's continuity type, HC_CUT, HC_FREE, HC_G1, or
## HC_SMOOTH, or 0 if there is no such CV.

proc getCvPoint*(this: HermiteCurve, n: int): LVecBase3 {.importcpp: "#->get_cv_point(#)".} ## \
## Returns the position of the given CV.

proc getCvPoint*(this: HermiteCurve, n: int, v: LVecBase3) {.importcpp: "#->get_cv_point(#, #)".}

proc getCvIn*(this: HermiteCurve, n: int): LVecBase3 {.importcpp: "#->get_cv_in(#)".} ## \
## Returns the in tangent of the given CV.

proc getCvIn*(this: HermiteCurve, n: int, v: LVecBase3) {.importcpp: "#->get_cv_in(#, #)".}

proc getCvOut*(this: HermiteCurve, n: int): LVecBase3 {.importcpp: "#->get_cv_out(#)".} ## \
## Returns the out tangent of the given CV.

proc getCvOut*(this: HermiteCurve, n: int, v: LVecBase3) {.importcpp: "#->get_cv_out(#, #)".}

proc getCvTstart*(this: HermiteCurve, n: int): float32 {.importcpp: "#->get_cv_tstart(#)".} ## \
## Returns the starting point in parametric space of the given CV.

proc getCvName*(this: HermiteCurve, n: int): string {.importcpp: "nimStringFromStdString(#->get_cv_name(#))", header: stringConversionCode.} ## \
## Returns the name of the given CV, or NULL.

proc writeCv*(this: HermiteCurve, `out`: ostream, n: int) {.importcpp: "#->write_cv(#, #)".}

converter getClassType*(_: typedesc[HermiteCurve]): TypeHandle {.importcpp: "HermiteCurve::get_class_type()", header: "hermiteCurve.h".}

proc setOrder*(this: NurbsCurveInterface, order: int) {.importcpp: "#->set_order(#)".}

proc getOrder*(this: NurbsCurveInterface): int {.importcpp: "#->get_order()".}

proc getNumCvs*(this: NurbsCurveInterface): int {.importcpp: "#->get_num_cvs()".}

proc getNumKnots*(this: NurbsCurveInterface): int {.importcpp: "#->get_num_knots()".}

proc insertCv*(this: NurbsCurveInterface, t: float32): bool {.importcpp: "#->insert_cv(#)".}

proc appendCv*(this: NurbsCurveInterface, v: LVecBase3): int {.importcpp: "#->append_cv(#)".}

proc appendCv*(this: NurbsCurveInterface, v: LVecBase4): int {.importcpp: "#->append_cv(#)".}

proc appendCv*(this: NurbsCurveInterface, x: float32, y: float32, z: float32): int {.importcpp: "#->append_cv(#, #, #)".}

proc removeCv*(this: NurbsCurveInterface, n: int): bool {.importcpp: "#->remove_cv(#)".}

proc removeAllCvs*(this: NurbsCurveInterface) {.importcpp: "#->remove_all_cvs()".}

proc setCvPoint*(this: NurbsCurveInterface, n: int, v: LVecBase3): bool {.importcpp: "#->set_cv_point(#, #)".} ## \
## Repositions the indicated CV.  Returns true if successful, false otherwise.

proc setCvPoint*(this: NurbsCurveInterface, n: int, x: float32, y: float32, z: float32): bool {.importcpp: "#->set_cv_point(#, #, #, #)".} ## \
## Repositions the indicated CV.  Returns true if successful, false otherwise.

proc getCvPoint*(this: NurbsCurveInterface, n: int): LVecBase3 {.importcpp: "#->get_cv_point(#)".} ## \
## Returns the position of the indicated CV.

proc setCvWeight*(this: NurbsCurveInterface, n: int, w: float32): bool {.importcpp: "#->set_cv_weight(#, #)".} ## \
## Sets the weight of the indicated CV without affecting its position in 3-d
## space.

proc getCvWeight*(this: NurbsCurveInterface, n: int): float32 {.importcpp: "#->get_cv_weight(#)".} ## \
## Returns the weight of the indicated CV.

proc setCv*(this: NurbsCurveInterface, n: int, v: LVecBase4): bool {.importcpp: "#->set_cv(#, #)".}

proc getCv*(this: NurbsCurveInterface, n: int): LVecBase4 {.importcpp: "#->get_cv(#)".}

proc setKnot*(this: NurbsCurveInterface, n: int, t: float32): bool {.importcpp: "#->set_knot(#, #)".}

proc getKnot*(this: NurbsCurveInterface, n: int): float32 {.importcpp: "#->get_knot(#)".}

proc writeCv*(this: NurbsCurveInterface, `out`: ostream, n: int) {.importcpp: "#->write_cv(#, #)".}

converter getClassType*(_: typedesc[NurbsCurveInterface]): TypeHandle {.importcpp: "NurbsCurveInterface::get_class_type()", header: "nurbsCurveInterface.h".}

converter upcastToPiecewiseCurve*(this: NurbsCurve): PiecewiseCurve {.importcpp: "(PT(PiecewiseCurve)(#))".}

converter upcastToNurbsCurveInterface*(this: NurbsCurve): NurbsCurveInterface {.importcpp: "((NurbsCurveInterface *)(NurbsCurve *)(#))".}

proc newNurbsCurve*(): NurbsCurve {.importcpp: "new NurbsCurve()".}

proc newNurbsCurve*(pc: ParametricCurve): NurbsCurve {.importcpp: "new NurbsCurve(#)".} ## \
## Constructs a NURBS curve equivalent to the indicated (possibly non-NURBS)
## curve.

converter getClassType*(_: typedesc[NurbsCurve]): TypeHandle {.importcpp: "NurbsCurve::get_class_type()", header: "nurbsCurve.h".}

proc getStartT*(this: NurbsCurveResult): float32 {.importcpp: "#->get_start_t()".} ## \
## Returns the first legal value of t on the curve.  Usually this is 0.0.

proc getEndT*(this: NurbsCurveResult): float32 {.importcpp: "#->get_end_t()".} ## \
## Returns the last legal value of t on the curve.

proc evalPoint*(this: NurbsCurveResult, t: float32, point: LVecBase3): bool {.importcpp: "#->eval_point(#, #)".} ## \
## Computes the point on the curve corresponding to the indicated value in
## parametric time.  Returns true if the t value is valid, false otherwise.

proc evalTangent*(this: NurbsCurveResult, t: float32, tangent: LVecBase3): bool {.importcpp: "#->eval_tangent(#, #)".} ## \
## Computes the tangent to the curve at the indicated point in parametric
## time.  This tangent vector will not necessarily be normalized, and could be
## zero.  See also eval_point().

proc evalExtendedPoint*(this: NurbsCurveResult, t: float32, d: int): float32 {.importcpp: "#->eval_extended_point(#, #)".} ## \
## Evaluates the curve in n-dimensional space according to the extended
## vertices associated with the curve in the indicated dimension.

proc getNumSegments*(this: NurbsCurveResult): int {.importcpp: "#->get_num_segments()".} ## \
## Returns the number of piecewise continuous segments within the curve.  This
## number is usually not important unless you plan to call
## eval_segment_point().

proc evalSegmentPoint*(this: NurbsCurveResult, segment: int, t: float32, point: LVecBase3) {.importcpp: "#->eval_segment_point(#, #, #)".} ## \
## Evaluates the point on the curve corresponding to the indicated value in
## parametric time within the indicated curve segment.  t should be in the
## range [0, 1].
##
## The curve is internally represented as a number of connected (or possibly
## unconnected) piecewise continuous segments.  The exact number of segments
## for a particular curve depends on the knot vector, and is returned by
## get_num_segments().  Normally, eval_point() is used to evaluate a point
## along the continuous curve, but when you care more about local continuity,
## you can use eval_segment_point() to evaluate the points along each segment.

proc evalSegmentTangent*(this: NurbsCurveResult, segment: int, t: float32, tangent: LVecBase3) {.importcpp: "#->eval_segment_tangent(#, #, #)".} ## \
## As eval_segment_point, but computes the tangent to the curve at the
## indicated point.  The tangent vector will not necessarily be normalized,
## and could be zero, particularly at the endpoints.

proc evalSegmentExtendedPoint*(this: NurbsCurveResult, segment: int, t: float32, d: int): float32 {.importcpp: "#->eval_segment_extended_point(#, #, #)".} ## \
## Evaluates the curve in n-dimensional space according to the extended
## vertices associated with the curve in the indicated dimension.

proc getSegmentT*(this: NurbsCurveResult, segment: int, t: float32): float32 {.importcpp: "#->get_segment_t(#, #)".} ## \
## Accepts a t value in the range [0, 1], and assumed to be relative to the
## indicated segment (as in eval_segment_point()), and returns the
## corresponding t value in the entire curve (as in eval_point()).

proc adaptiveSample*(this: NurbsCurveResult, tolerance: float32) {.importcpp: "#->adaptive_sample(#)".} ## \
## Determines the set of subdivisions necessary to approximate the curve with
## a set of linear segments, no point of which is farther than tolerance units
## from the actual curve.
##
## After this call, you may walk through the resulting set of samples with
## get_num_samples(), get_sample_t(), and get_sample_point().

proc getNumSamples*(this: NurbsCurveResult): int {.importcpp: "#->get_num_samples()".} ## \
## Returns the number of sample points generated by the previous call to
## adaptive_sample().

proc getSampleT*(this: NurbsCurveResult, n: int): float32 {.importcpp: "#->get_sample_t(#)".} ## \
## Returns the t value of the nth sample point generated by the previous call
## to adaptive_sample().

proc getSamplePoint*(this: NurbsCurveResult, n: int): LPoint3 {.importcpp: "#->get_sample_point(#)".} ## \
## Returns the point on the curve of the nth sample point generated by the
## previous call to adaptive_sample().
##
## For tangents, or extended points, you should use get_sample_t() and pass it
## into eval_tangent() or eval_extended_point().

proc newNurbsCurveResult*(param0: NurbsCurveResult): NurbsCurveResult {.importcpp: "new NurbsCurveResult(#)".}

proc newNurbsCurveEvaluator*(): NurbsCurveEvaluator {.importcpp: "new NurbsCurveEvaluator()".}

proc newNurbsCurveEvaluator*(param0: NurbsCurveEvaluator): NurbsCurveEvaluator {.importcpp: "new NurbsCurveEvaluator(#)".}

proc setOrder*(this: NurbsCurveEvaluator, order: int) {.importcpp: "#->set_order(#)".} ## \
## Sets the order of the curve.  This resets the knot vector to the default
## knot vector for the number of vertices.
##
## The order must be 1, 2, 3, or 4, and the value is one more than the degree
## of the curve.

proc getOrder*(this: NurbsCurveEvaluator): int {.importcpp: "#->get_order()".} ## \
## Returns the order of the curve as set by a previous call to set_order().

proc reset*(this: NurbsCurveEvaluator, num_vertices: int) {.importcpp: "#->reset(#)".} ## \
## Resets all the vertices and knots to their default values, and sets the
## curve up with the indicated number of vertices.  You must then call
## set_vertex() repeatedly to fill in all of the vertex values appropriately.

proc getNumVertices*(this: NurbsCurveEvaluator): int {.importcpp: "#->get_num_vertices()".} ## \
## Returns the number of control vertices in the curve.  This is the number
## passed to the last call to reset().

proc setVertex*(this: NurbsCurveEvaluator, i: int, vertex: LVecBase3, weight: float32) {.importcpp: "#->set_vertex(#, #, #)".} ## \
## Sets the nth control vertex of the curve.  This flavor sets the vertex as a
## 3-d coordinate and a weight; the 3-d coordinate values are implicitly
## scaled up by the weight factor.

proc setVertex*(this: NurbsCurveEvaluator, i: int, vertex: LVecBase3) {.importcpp: "#->set_vertex(#, #)".} ## \
## Sets the nth control vertex of the curve.  This flavor sets the vertex as a
## 3-d coordinate and a weight; the 3-d coordinate values are implicitly
## scaled up by the weight factor.

proc setVertex*(this: NurbsCurveEvaluator, i: int, vertex: LVecBase4) {.importcpp: "#->set_vertex(#, #)".} ## \
## Sets the nth control vertex of the curve, as a vertex in 4-d homogeneous
## space.  In this form, the first three components of the vertex should
## already have been scaled by the fourth component, which is the homogeneous
## weight.

proc getVertex*(this: NurbsCurveEvaluator, i: int): LVecBase4 {.importcpp: "#->get_vertex(#)".} ## \
## Returns the nth control vertex of the curve, relative to its indicated
## coordinate space.

proc getVertex*(this: NurbsCurveEvaluator, i: int, rel_to: NodePath): LVecBase4 {.importcpp: "#->get_vertex(#, #)".} ## \
## Returns the nth control vertex of the curve, relative to the given
## coordinate space.

proc setVertexSpace*(this: NurbsCurveEvaluator, i: int, space: NodePath) {.importcpp: "#->set_vertex_space(#, #)".} ## \
## Sets the coordinate space of the nth control vertex.  If this is not
## specified, or is set to an empty NodePath, the nth control vertex is deemed
## to be in the coordinate space passed to evaluate().
##
## This specifies the space as a fixed NodePath, which is always the same
## NodePath.  Also see setting the space as a path string, which can specify a
## different NodePath for different instances of the curve.

proc setVertexSpace*(this: NurbsCurveEvaluator, i: int, space: string) {.importcpp: "#->set_vertex_space(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the coordinate space of the nth control vertex.  If this is not
## specified, or is set to an empty string, the nth control vertex is deemed
## to be in the coordinate space passed to evaluate().
##
## This specifies the space as a string, which describes the path to find the
## node relative to the rel_to NodePath when the curve is evaluated.

proc getVertexSpace*(this: NurbsCurveEvaluator, i: int, rel_to: NodePath): NodePath {.importcpp: "#->get_vertex_space(#, #)".} ## \
## Returns the coordinate space of the nth control vertex of the curve,
## expressed as a NodePath.

proc setExtendedVertex*(this: NurbsCurveEvaluator, i: int, d: int, value: float32) {.importcpp: "#->set_extended_vertex(#, #, #)".} ## \
## Sets an n-dimensional vertex value.  This allows definition of a NURBS
## surface or curve in a sparse n-dimensional space, typically used for
## associating additional properties (like color or joint membership) with
## each vertex of a surface.
##
## The value d is an arbitrary integer value and specifies the dimension of
## question for this particular vertex.  Any number of dimensions may be
## specified, and they need not be consecutive.  If a value for a given
## dimension is not specified, is it implicitly 0.0.
##
## The value is implicitly scaled by the homogenous weight value--that is, the
## fourth component of the value passed to set_vertex().  This means the
## ordinary vertex must be set first, before the extended vertices can be set.

proc getExtendedVertex*(this: NurbsCurveEvaluator, i: int, d: int): float32 {.importcpp: "#->get_extended_vertex(#, #)".} ## \
## Returns an n-dimensional vertex value.  See set_extended_vertex().  This
## returns the value set for the indicated dimension, or 0.0 if nothing has
## been set.

proc getNumKnots*(this: NurbsCurveEvaluator): int {.importcpp: "#->get_num_knots()".} ## \
## Returns the number of knot values in the curve.  This is based on the
## number of vertices and the order.

proc setKnot*(this: NurbsCurveEvaluator, i: int, knot: float32) {.importcpp: "#->set_knot(#, #)".} ## \
## Sets the value of the nth knot.  Each knot value should be greater than or
## equal to the preceding value.  If no knot values are set, a default knot
## vector is supplied.

proc getKnot*(this: NurbsCurveEvaluator, i: int): float32 {.importcpp: "#->get_knot(#)".} ## \
## Returns the value of the nth knot.

proc normalizeKnots*(this: NurbsCurveEvaluator) {.importcpp: "#->normalize_knots()".} ## \
## Normalizes the knot sequence so that the parametric range of the curve is 0
## .. 1.

proc getNumSegments*(this: NurbsCurveEvaluator): int {.importcpp: "#->get_num_segments()".} ## \
## Returns the number of piecewise continuous segments in the curve.  This is
## based on the knot vector.

proc evaluate*(this: NurbsCurveEvaluator, rel_to: NodePath): NurbsCurveResult {.importcpp: "#->evaluate(#)".} ## \
## Returns a NurbsCurveResult object that represents the result of applying
## the knots to all of the current values of the vertices, transformed into
## the indicated coordinate space.

proc evaluate*(this: NurbsCurveEvaluator): NurbsCurveResult {.importcpp: "#->evaluate()".} ## \
## Returns a NurbsCurveResult object that represents the result of applying
## the knots to all of the current values of the vertices, transformed into
## the indicated coordinate space.

proc evaluate*(this: NurbsCurveEvaluator, rel_to: NodePath, mat: LMatrix4): NurbsCurveResult {.importcpp: "#->evaluate(#, #)".} ## \
## Returns a NurbsCurveResult object that represents the result of applying
## the knots to all of the current values of the vertices, transformed into
## the indicated coordinate space, and then further transformed by the
## indicated matrix.

proc output*(this: NurbsCurveEvaluator, `out`: ostream) {.importcpp: "#->output(#)".}

proc getStartU*(this: NurbsSurfaceResult): float32 {.importcpp: "#->get_start_u()".} ## \
## Returns the first legal value of u on the surface.  Usually this is 0.0.

proc getEndU*(this: NurbsSurfaceResult): float32 {.importcpp: "#->get_end_u()".} ## \
## Returns the last legal value of u on the surface.

proc getStartV*(this: NurbsSurfaceResult): float32 {.importcpp: "#->get_start_v()".} ## \
## Returns the first legal value of v on the surface.  Usually this is 0.0.

proc getEndV*(this: NurbsSurfaceResult): float32 {.importcpp: "#->get_end_v()".} ## \
## Returns the last legal value of v on the surface.

proc evalPoint*(this: NurbsSurfaceResult, u: float32, v: float32, point: LVecBase3): bool {.importcpp: "#->eval_point(#, #, #)".} ## \
## Computes the point on the surface corresponding to the indicated value in
## parametric time.  Returns true if the u, v values are valid, false
## otherwise.

proc evalNormal*(this: NurbsSurfaceResult, u: float32, v: float32, normal: LVecBase3): bool {.importcpp: "#->eval_normal(#, #, #)".} ## \
## Computes the normal to the surface at the indicated point in parametric
## time.  This normal vector will not necessarily be normalized, and could be
## zero.  See also eval_point().

proc evalExtendedPoint*(this: NurbsSurfaceResult, u: float32, v: float32, d: int): float32 {.importcpp: "#->eval_extended_point(#, #, #)".} ## \
## Evaluates the surface in n-dimensional space according to the extended
## vertices associated with the surface in the indicated dimension.

proc getNumUSegments*(this: NurbsSurfaceResult): int {.importcpp: "#->get_num_u_segments()".} ## \
## Returns the number of piecewise continuous segments within the surface in
## the U direction.  This number is usually not important unless you plan to
## call eval_segment_point().

proc getNumVSegments*(this: NurbsSurfaceResult): int {.importcpp: "#->get_num_v_segments()".} ## \
## Returns the number of piecewise continuous segments within the surface in
## the V direction.  This number is usually not important unless you plan to
## call eval_segment_point().

proc evalSegmentPoint*(this: NurbsSurfaceResult, ui: int, vi: int, u: float32, v: float32, point: LVecBase3) {.importcpp: "#->eval_segment_point(#, #, #, #, #)".} ## \
## Evaluates the point on the surface corresponding to the indicated value in
## parametric time within the indicated surface segment.  u and v should be in
## the range [0, 1].
##
## The surface is internally represented as a number of connected (or possibly
## unconnected) piecewise continuous segments.  The exact number of segments
## for a particular surface depends on the knot vector, and is returned by
## get_num_segments().  Normally, eval_point() is used to evaluate a point
## along the continuous surface, but when you care more about local
## continuity, you can use eval_segment_point() to evaluate the points along
## each segment.

proc evalSegmentNormal*(this: NurbsSurfaceResult, ui: int, vi: int, u: float32, v: float32, normal: LVecBase3) {.importcpp: "#->eval_segment_normal(#, #, #, #, #)".} ## \
## As eval_segment_point, but computes the normal to the surface at the
## indicated point.  The normal vector will not necessarily be normalized, and
## could be zero.

proc evalSegmentExtendedPoint*(this: NurbsSurfaceResult, ui: int, vi: int, u: float32, v: float32, d: int): float32 {.importcpp: "#->eval_segment_extended_point(#, #, #, #, #)".} ## \
## Evaluates the surface in n-dimensional space according to the extended
## vertices associated with the surface in the indicated dimension.

proc getSegmentU*(this: NurbsSurfaceResult, ui: int, u: float32): float32 {.importcpp: "#->get_segment_u(#, #)".} ## \
## Accepts a u value in the range [0, 1], and assumed to be relative to the
## indicated segment (as in eval_segment_point()), and returns the
## corresponding u value in the entire surface (as in eval_point()).

proc getSegmentV*(this: NurbsSurfaceResult, vi: int, v: float32): float32 {.importcpp: "#->get_segment_v(#, #)".} ## \
## Accepts a v value in the range [0, 1], and assumed to be relative to the
## indicated segment (as in eval_segment_point()), and returns the
## corresponding v value in the entire surface (as in eval_point()).

proc newNurbsSurfaceResult*(param0: NurbsSurfaceResult): NurbsSurfaceResult {.importcpp: "new NurbsSurfaceResult(#)".}

proc newNurbsSurfaceEvaluator*(): NurbsSurfaceEvaluator {.importcpp: "new NurbsSurfaceEvaluator()".}

proc newNurbsSurfaceEvaluator*(param0: NurbsSurfaceEvaluator): NurbsSurfaceEvaluator {.importcpp: "new NurbsSurfaceEvaluator(#)".}

proc setUOrder*(this: NurbsSurfaceEvaluator, u_order: int) {.importcpp: "#->set_u_order(#)".} ## \
## Sets the order of the surface in the U direction.  This resets the knot
## vector to the default knot vector for the number of vertices.
##
## The order must be 1, 2, 3, or 4, and the value is one more than the degree
## of the surface.

proc getUOrder*(this: NurbsSurfaceEvaluator): int {.importcpp: "#->get_u_order()".} ## \
## Returns the order of the surface in the U direction as set by a previous
## call to set_u_order().

proc setVOrder*(this: NurbsSurfaceEvaluator, v_order: int) {.importcpp: "#->set_v_order(#)".} ## \
## Sets the order of the surface in the V direction.  This resets the knot
## vector to the default knot vector for the number of vertices.
##
## The order must be 1, 2, 3, or 4, and the value is one more than the degree
## of the surface.

proc getVOrder*(this: NurbsSurfaceEvaluator): int {.importcpp: "#->get_v_order()".} ## \
## Returns the order of the surface in the V direction as set by a previous
## call to set_v_order().

proc reset*(this: NurbsSurfaceEvaluator, num_u_vertices: int, num_v_vertices: int) {.importcpp: "#->reset(#, #)".} ## \
## Resets all the vertices and knots to their default values, and sets the
## surface up with the indicated number of vertices.  You must then call
## set_vertex() repeatedly to fill in all of the vertex values appropriately.

proc getNumUVertices*(this: NurbsSurfaceEvaluator): int {.importcpp: "#->get_num_u_vertices()".} ## \
## Returns the number of control vertices in the U direction on the surface.
## This is the number passed to the last call to reset().

proc getNumVVertices*(this: NurbsSurfaceEvaluator): int {.importcpp: "#->get_num_v_vertices()".} ## \
## Returns the number of control vertices in the V direction on the surface.
## This is the number passed to the last call to reset().

proc setVertex*(this: NurbsSurfaceEvaluator, ui: int, vi: int, vertex: LVecBase3, weight: float32) {.importcpp: "#->set_vertex(#, #, #, #)".} ## \
## Sets the nth control vertex of the surface.  This flavor sets the vertex as
## a 3-d coordinate and a weight; the 3-d coordinate values are implicitly
## scaled up by the weight factor.

proc setVertex*(this: NurbsSurfaceEvaluator, ui: int, vi: int, vertex: LVecBase3) {.importcpp: "#->set_vertex(#, #, #)".} ## \
## Sets the nth control vertex of the surface.  This flavor sets the vertex as
## a 3-d coordinate and a weight; the 3-d coordinate values are implicitly
## scaled up by the weight factor.

proc setVertex*(this: NurbsSurfaceEvaluator, ui: int, vi: int, vertex: LVecBase4) {.importcpp: "#->set_vertex(#, #, #)".} ## \
## Sets the nth control vertex of the surface, as a vertex in 4-d homogeneous
## space.  In this form, the first three components of the vertex should
## already have been scaled by the fourth component, which is the homogeneous
## weight.

proc getVertex*(this: NurbsSurfaceEvaluator, ui: int, vi: int): LVecBase4 {.importcpp: "#->get_vertex(#, #)".} ## \
## Returns the nth control vertex of the surface, relative to its indicated
## coordinate space.

proc getVertex*(this: NurbsSurfaceEvaluator, ui: int, vi: int, rel_to: NodePath): LVecBase4 {.importcpp: "#->get_vertex(#, #, #)".} ## \
## Returns the nth control vertex of the surface, relative to the given
## coordinate space.

proc setVertexSpace*(this: NurbsSurfaceEvaluator, ui: int, vi: int, space: NodePath) {.importcpp: "#->set_vertex_space(#, #, #)".} ## \
## Sets the coordinate space of the nth control vertex.  If this is not
## specified, or is set to an empty NodePath, the nth control vertex is deemed
## to be in the coordinate space passed to evaluate().
##
## This specifies the space as a fixed NodePath, which is always the same
## NodePath.  Also see setting the space as a path string, which can specify a
## different NodePath for different instances of the surface.

proc setVertexSpace*(this: NurbsSurfaceEvaluator, ui: int, vi: int, space: string) {.importcpp: "#->set_vertex_space(#, #, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the coordinate space of the nth control vertex.  If this is not
## specified, or is set to an empty string, the nth control vertex is deemed
## to be in the coordinate space passed to evaluate().
##
## This specifies the space as a string, which describes the path to find the
## node relative to the rel_to NodePath when the surface is evaluated.

proc getVertexSpace*(this: NurbsSurfaceEvaluator, ui: int, vi: int, rel_to: NodePath): NodePath {.importcpp: "#->get_vertex_space(#, #, #)".} ## \
## Returns the coordinate space of the nth control vertex of the surface,
## expressed as a NodePath.

proc setExtendedVertex*(this: NurbsSurfaceEvaluator, ui: int, vi: int, d: int, value: float32) {.importcpp: "#->set_extended_vertex(#, #, #, #)".} ## \
## Sets an n-dimensional vertex value.  This allows definition of a NURBS
## surface or surface in a sparse n-dimensional space, typically used for
## associating additional properties (like color or joint membership) with
## each vertex of a surface.
##
## The value d is an arbitrary integer value and specifies the dimension of
## question for this particular vertex.  Any number of dimensions may be
## specified, and they need not be consecutive.  If a value for a given
## dimension is not specified, is it implicitly 0.0.
##
## The value is implicitly scaled by the homogenous weight value--that is, the
## fourth component of the value passed to set_vertex().  This means the
## ordinary vertex must be set first, before the extended vertices can be set.

proc getExtendedVertex*(this: NurbsSurfaceEvaluator, ui: int, vi: int, d: int): float32 {.importcpp: "#->get_extended_vertex(#, #, #)".} ## \
## Returns an n-dimensional vertex value.  See set_extended_vertex().  This
## returns the value set for the indicated dimension, or 0.0 if nothing has
## been set.

proc getNumUKnots*(this: NurbsSurfaceEvaluator): int {.importcpp: "#->get_num_u_knots()".} ## \
## Returns the number of knot values in the surface in the U direction.  This
## is based on the number of vertices and the order.

proc setUKnot*(this: NurbsSurfaceEvaluator, i: int, knot: float32) {.importcpp: "#->set_u_knot(#, #)".} ## \
## Sets the value of the nth knot.  Each knot value should be greater than or
## equal to the preceding value.  If no knot values are set, a default knot
## vector is supplied.

proc getUKnot*(this: NurbsSurfaceEvaluator, i: int): float32 {.importcpp: "#->get_u_knot(#)".} ## \
## Returns the value of the nth knot.

proc normalizeUKnots*(this: NurbsSurfaceEvaluator) {.importcpp: "#->normalize_u_knots()".} ## \
## Normalizes the knot sequence so that the parametric range of the surface in
## the U direction is 0 .. 1.

proc getNumVKnots*(this: NurbsSurfaceEvaluator): int {.importcpp: "#->get_num_v_knots()".} ## \
## Returns the number of knot values in the surface in the V direction.  This
## is based on the number of vertices and the order.

proc setVKnot*(this: NurbsSurfaceEvaluator, i: int, knot: float32) {.importcpp: "#->set_v_knot(#, #)".} ## \
## Sets the value of the nth knot.  Each knot value should be greater than or
## equal to the preceding value.  If no knot values are set, a default knot
## vector is supplied.

proc getVKnot*(this: NurbsSurfaceEvaluator, i: int): float32 {.importcpp: "#->get_v_knot(#)".} ## \
## Returns the value of the nth knot.

proc normalizeVKnots*(this: NurbsSurfaceEvaluator) {.importcpp: "#->normalize_v_knots()".} ## \
## Normalizes the knot sequence so that the parametric range of the surface in
## the U direction is 0 .. 1.

proc getNumUSegments*(this: NurbsSurfaceEvaluator): int {.importcpp: "#->get_num_u_segments()".} ## \
## Returns the number of piecewise continuous segments in the surface in the U
## direction.  This is based on the knot vector.

proc getNumVSegments*(this: NurbsSurfaceEvaluator): int {.importcpp: "#->get_num_v_segments()".} ## \
## Returns the number of piecewise continuous segments in the surface in the V
## direction.  This is based on the knot vector.

proc evaluate*(this: NurbsSurfaceEvaluator, rel_to: NodePath): NurbsSurfaceResult {.importcpp: "#->evaluate(#)".} ## \
## Returns a NurbsSurfaceResult object that represents the result of applying
## the knots to all of the current values of the vertices, transformed into
## the indicated coordinate space.

proc evaluate*(this: NurbsSurfaceEvaluator): NurbsSurfaceResult {.importcpp: "#->evaluate()".} ## \
## Returns a NurbsSurfaceResult object that represents the result of applying
## the knots to all of the current values of the vertices, transformed into
## the indicated coordinate space.

proc output*(this: NurbsSurfaceEvaluator, `out`: ostream) {.importcpp: "#->output(#)".}

proc newRopeNode*(name: string): RopeNode {.importcpp: "new RopeNode(nimStringToStdString(#))", header: stringConversionCode.}

proc setCurve*(this: RopeNode, curve: NurbsCurveEvaluator) {.importcpp: "#->set_curve(#)".} ## \
## Sets the particular curve represented by the RopeNode.

proc getCurve*(this: RopeNode): NurbsCurveEvaluator {.importcpp: "#->get_curve()".} ## \
## Returns the curve represented by the RopeNode.

proc setUvDirection*(this: RopeNode, u_dominant: bool) {.importcpp: "#->set_uv_direction(#)".} ## \
## Specify true to vary the U coordinate down the length of the rope, or false
## to vary the V coordinate.

proc getUvDirection*(this: RopeNode): bool {.importcpp: "#->get_uv_direction()".} ## \
## Returns true if the rope runs down the U coordinate of the texture, or
## false if it runs down the V coordinate.

proc setUvScale*(this: RopeNode, scale: float32) {.importcpp: "#->set_uv_scale(#)".} ## \
## Specifies an additional scaling factor to apply to generated UV's along the
## rope.  This scale factor is applied in whichever direction is along the
## rope, as specified by set_uv_direction().

proc getUvScale*(this: RopeNode): float32 {.importcpp: "#->get_uv_scale()".} ## \
## Returns the scaling factor to apply to generated UV's for the rope.

proc setTubeUp*(this: RopeNode, tube_up: LVector3) {.importcpp: "#->set_tube_up(#)".} ## \
## Specifies a normal vector, generally perpendicular to the main axis of the
## starting point of the curve, that controls the "top" of the curve, when
## RenderMode is RM_tube.  This is used to orient the vertices that make up
## the tube.  If this vector is too nearly parallel with the starting
## direction of the curve, there may be a tendency for the whole tube to
## gimble-lock around its primary axis.

proc getTubeUp*(this: RopeNode): LVector3 {.importcpp: "#->get_tube_up()".} ## \
## Returns the normal vector used to control the "top" of the curve, when
## RenderMode is RM_tube.  See set_tube_up().

proc setUseVertexColor*(this: RopeNode, flag: bool) {.importcpp: "#->set_use_vertex_color(#)".} ## \
## Sets the "use vertex color" flag.  When this is true, the R, G, B, A vertex
## color is assumed to be stored as the dimensions n + 0, n + 1, n + 2, n + 3,
## respectively, of the extended vertex values, where n is the value returned
## by get_vertex_color_dimension().  Use
## NurbsCurveEvaluator::set_extended_vertex() to set these values.

proc getUseVertexColor*(this: RopeNode): bool {.importcpp: "#->get_use_vertex_color()".} ## \
## Returns the "use vertex color" flag.  See set_use_vertex_color().

proc getVertexColorDimension*(_: typedesc[RopeNode]): int {.importcpp: "RopeNode::get_vertex_color_dimension()", header: "ropeNode.h".} ## \
## Returns the numeric extended dimension in which the color components should
## be found.  See NurbsCurveEvaluator::set_extended_vertex().
##
## The color components will be expected at (n, n + 1, n + 2, n + 3).

proc setNumSubdiv*(this: RopeNode, num_subdiv: int) {.importcpp: "#->set_num_subdiv(#)".} ## \
## Specifies the number of subdivisions per cubic segment (that is, per unique
## knot value) to draw in a fixed uniform tesselation of the curve.

proc getNumSubdiv*(this: RopeNode): int {.importcpp: "#->get_num_subdiv()".} ## \
## Returns the number of subdivisions per cubic segment to draw.  See
## set_num_subdiv().

proc setNumSlices*(this: RopeNode, num_slices: int) {.importcpp: "#->set_num_slices(#)".} ## \
## Specifies the number of radial subdivisions to make if RenderMode is
## RM_tube.  It is ignored in the other render modes.
##
## Increasing this number increases the roundness of a cross-section of the
## tube.  The minimum value for a dimensional tube is 3; setting it to 2 will
## get you a thin piece of tape (which is similar to RM_billboard, except it
## won't rotate to face the camera).

proc getNumSlices*(this: RopeNode): int {.importcpp: "#->get_num_slices()".} ## \
## Returns the number of radial subdivisions to make if RenderMode is RM_tube.
## It is ignored in the other render modes.  See set_num_slices().

proc setUseVertexThickness*(this: RopeNode, flag: bool) {.importcpp: "#->set_use_vertex_thickness(#)".} ## \
## Sets the "use vertex thickness" flag.  When this is true, the vertex
## thickness is assumed to be stored as the dimension
## get_vertex_thickness_dimension(), of the extended vertex values.  Use
## NurbsCurveEvaluator::set_extended_vertex() to set these values.
##
## In this mode, the overall thickness is also applied as a scale to the
## vertex thickness.  Not all render modes support vertex thickness.

proc getUseVertexThickness*(this: RopeNode): bool {.importcpp: "#->get_use_vertex_thickness()".} ## \
## Returns the "use vertex thickness" flag.  See set_use_vertex_thickness().

proc getVertexThicknessDimension*(_: typedesc[RopeNode]): int {.importcpp: "RopeNode::get_vertex_thickness_dimension()", header: "ropeNode.h".} ## \
## Returns the numeric extended dimension in which the thickness component
## should be found.  See NurbsCurveEvaluator::set_extended_vertex().

proc setThickness*(this: RopeNode, thickness: float32) {.importcpp: "#->set_thickness(#)".} ## \
## Specifies the thickness of the rope, in pixels or in spatial units,
## depending on the render mode.  See set_render_mode().
##
## The thickness may also be specified on a per-vertex basis.  See
## set_use_vertex_thickness().

proc getThickness*(this: RopeNode): float32 {.importcpp: "#->get_thickness()".} ## \
## Returns the thickness of the rope.  See set_thickness().

proc setMatrix*(this: RopeNode, matrix: LMatrix4) {.importcpp: "#->set_matrix(#)".} ## \
## Specifies an optional matrix which is used to transform each control vertex
## after it has been transformed into the RopeNode's coordinate space, but
## before the polygon vertices are generated.

proc clearMatrix*(this: RopeNode) {.importcpp: "#->clear_matrix()".} ## \
## Resets the node's matrix to identity.  See set_matrix().

proc hasMatrix*(this: RopeNode): bool {.importcpp: "#->has_matrix()".} ## \
## Returns true if the node has a matrix set, false otherwise.  See
## set_matrix().

proc getMatrix*(this: RopeNode): LMatrix4 {.importcpp: "#->get_matrix()".} ## \
## Returns the optional matrix which is used to transform each control vertex
## after it has been transformed into the RopeNode's coordinate space, but
## before the polygon vertices are generated.

proc resetBound*(this: RopeNode, rel_to: NodePath) {.importcpp: "#->reset_bound(#)".} ## \
## Recomputes the bounding volume.  This is normally called automatically, but
## it must occasionally be called explicitly when the curve has changed
## properties outside of this node's knowledge.

converter getClassType*(_: typedesc[RopeNode]): TypeHandle {.importcpp: "RopeNode::get_class_type()", header: "ropeNode.h".}

proc newSheetNode*(name: string): SheetNode {.importcpp: "new SheetNode(nimStringToStdString(#))", header: stringConversionCode.}

proc setSurface*(this: SheetNode, surface: NurbsSurfaceEvaluator) {.importcpp: "#->set_surface(#)".} ## \
## Sets the particular surface represented by the SheetNode.

proc getSurface*(this: SheetNode): NurbsSurfaceEvaluator {.importcpp: "#->get_surface()".} ## \
## Returns the surface represented by the SheetNode.

proc setUseVertexColor*(this: SheetNode, flag: bool) {.importcpp: "#->set_use_vertex_color(#)".} ## \
## Sets the "use vertex color" flag.  When this is true, the R, G, B, A vertex
## color is assumed to be stored as the dimensions 0, 1, 2, 3, respectively,
## of the extended vertex values.  Use
## NurbsCurveEvaluator::set_extended_vertex() to set these values.

proc getUseVertexColor*(this: SheetNode): bool {.importcpp: "#->get_use_vertex_color()".} ## \
## Returns the "use vertex color" flag.  See set_use_vertex_color().

proc setNumUSubdiv*(this: SheetNode, num_u_subdiv: int) {.importcpp: "#->set_num_u_subdiv(#)".} ## \
## Specifies the number of subdivisions per cubic segment (that is, per unique
## knot value) to draw in a fixed uniform tesselation of the surface in the U
## direction.

proc getNumUSubdiv*(this: SheetNode): int {.importcpp: "#->get_num_u_subdiv()".} ## \
## Returns the number of subdivisions per cubic segment to draw in the U
## direction.  See set_num_u_subdiv().

proc setNumVSubdiv*(this: SheetNode, num_v_subdiv: int) {.importcpp: "#->set_num_v_subdiv(#)".} ## \
## Specifies the number of subdivisions per cubic segment (that is, per unique
## knot value) to draw in a fixed uniform tesselation of the surface in the V
## direction.

proc getNumVSubdiv*(this: SheetNode): int {.importcpp: "#->get_num_v_subdiv()".} ## \
## Returns the number of subdivisions per cubic segment to draw in the V
## direction.  See set_num_v_subdiv().

proc resetBound*(this: SheetNode, rel_to: NodePath) {.importcpp: "#->reset_bound(#)".} ## \
## Recomputes the bounding volume.  This is normally called automatically, but
## it must occasionally be called explicitly when the surface has changed
## properties outside of this node's knowledge.

converter getClassType*(_: typedesc[SheetNode]): TypeHandle {.importcpp: "SheetNode::get_class_type()", header: "sheetNode.h".}

proc initpixel*(): pixel {.importcpp: "pixel()".}

proc initpixel*(fill: int): pixel {.importcpp: "pixel(#)".}

proc initpixel*(r: int, g: int, b: int): pixel {.importcpp: "pixel(#, #, #)".}

proc initpixel*(param0: pixel): pixel {.importcpp: "pixel(#)".}

proc `[]`*(this: pixel, i: int, assign_val: int) {.importcpp: "#.operator [](#, #)".}

proc `+`*(this: pixel, other: pixel): pixel {.importcpp: "#.operator +(#)".}

proc `-`*(this: pixel, other: pixel): pixel {.importcpp: "#.operator -(#)".}

proc `*`*(this: pixel, mult: float64): pixel {.importcpp: "#.operator *(#)".}

proc `+=`*(this: var pixel, other: pixel): pixel {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: var pixel, other: pixel): pixel {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: var pixel, mult: float64): pixel {.importcpp: "#.operator *=(#)".}

proc `==`*(this: pixel, other: pixel): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: pixel, other: pixel): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: pixel, other: pixel): bool {.importcpp: "#.operator <(#)".}

proc size*(_: typedesc[pixel]): int {.importcpp: "pixel::size()", header: "pnmimage_base.h".}

proc output*(this: pixel, `out`: ostream) {.importcpp: "#.output(#)".}

proc decodeSRGBFloat*(val: float32): float32 {.importcpp: "decode_sRGB_float(#)".}

proc decodeSRGBFloat*(val: char): float32 {.importcpp: "decode_sRGB_float(#)".}

proc decodeSRGBUchar*(val: float32): char {.importcpp: "decode_sRGB_uchar(#)".}

proc decodeSRGBUchar*(val: char): char {.importcpp: "decode_sRGB_uchar(#)".}

proc encodeSRGBFloat*(val: float32): float32 {.importcpp: "encode_sRGB_float(#)".}

proc encodeSRGBFloat*(val: char): float32 {.importcpp: "encode_sRGB_float(#)".}

proc encodeSRGBUchar*(val: float32): char {.importcpp: "encode_sRGB_uchar(#)".}

proc encodeSRGBUchar*(val: char): char {.importcpp: "encode_sRGB_uchar(#)".}

proc getName*(this: PNMFileType): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.}

proc getNumExtensions*(this: PNMFileType): int {.importcpp: "#.get_num_extensions()".} ## \
## Returns the number of different possible filename extensions associated
## with this particular file type.

proc getExtension*(this: PNMFileType, n: int): string {.importcpp: "nimStringFromStdString(#.get_extension(#))", header: stringConversionCode.} ## \
## Returns the nth possible filename extension associated with this particular
## file type, without a leading dot.

proc getSuggestedExtension*(this: PNMFileType): string {.importcpp: "nimStringFromStdString(#.get_suggested_extension())", header: stringConversionCode.} ## \
## Returns a suitable filename extension (without a leading dot) to suggest
## for files of this type, or empty string if no suggestions are available.

converter getClassType*(_: typedesc[PNMFileType]): TypeHandle {.importcpp: "PNMFileType::get_class_type()", header: "pnmFileType.h".}

proc getNumTypes*(this: PNMFileTypeRegistry): int {.importcpp: "#.get_num_types()".} ## \
## Returns the total number of types registered.

proc getType*(this: PNMFileTypeRegistry, n: int): PNMFileType {.importcpp: "#.get_type(#)".} ## \
## Returns the nth type registered.

proc getTypeFromExtension*(this: PNMFileTypeRegistry, filename: string): PNMFileType {.importcpp: "#.get_type_from_extension(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Tries to determine what the PNMFileType is likely to be for a particular
## image file based on its extension.  Returns a suitable PNMFileType pointer,
## or NULL if no type can be determined.

proc getTypeFromMagicNumber*(this: PNMFileTypeRegistry, magic_number: string): PNMFileType {.importcpp: "#.get_type_from_magic_number(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Tries to determine what the PNMFileType is likely to be for a particular
## image file based on its magic number, the first two bytes read from the
## file.  Returns a suitable PNMFileType pointer, or NULL if no type can be
## determined.

proc getTypeByHandle*(this: PNMFileTypeRegistry, handle: TypeHandle): PNMFileType {.importcpp: "#.get_type_by_handle(#)".} ## \
## Returns the PNMFileType instance stored in the registry for the given
## TypeHandle, e.g.  as retrieved by a previous call to get_type() on the type
## instance.

proc write*(this: PNMFileTypeRegistry, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Writes a list of supported image file types to the indicated output stream,
## one per line.

proc write*(this: PNMFileTypeRegistry, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes a list of supported image file types to the indicated output stream,
## one per line.

proc getGlobalPtr*(_: typedesc[PNMFileTypeRegistry]): PNMFileTypeRegistry {.importcpp: "PNMFileTypeRegistry::get_global_ptr()", header: "pnmFileTypeRegistry.h".} ## \
## Returns a pointer to the global PNMFileTypeRegistry object.

proc initPNMFileTypeRegistry*(param0: PNMFileTypeRegistry): PNMFileTypeRegistry {.importcpp: "PNMFileTypeRegistry(#)".}

proc initPNMImageHeader*(): PNMImageHeader {.importcpp: "PNMImageHeader()".}

proc initPNMImageHeader*(copy: PNMImageHeader): PNMImageHeader {.importcpp: "PNMImageHeader(#)".}

proc getNumChannels*(this: PNMImageHeader): int {.importcpp: "#.get_num_channels()".} ## \
## Returns the number of channels in the image.

proc isGrayscale*(this: PNMImageHeader): bool {.importcpp: "#.is_grayscale()".} ## \
## Returns false if the image is a full-color image, and has red, green, and
## blue components; true if it is a grayscale image and has only a gray
## component.  (The gray color is actually stored in the blue channel, and the
## red and green channels are ignored.)

proc hasAlpha*(this: PNMImageHeader): bool {.importcpp: "#.has_alpha()".} ## \
## Returns true if the image includes an alpha channel, false otherwise.
## Unlike is_grayscale(), if this returns false it is an error to call any of
## the functions accessing the alpha channel.

proc getMaxval*(this: PNMImageHeader): int {.importcpp: "#.get_maxval()".} ## \
## Returns the maximum channel value allowable for any pixel in this image;
## for instance, 255 for a typical 8-bit-per-channel image.  A pixel with this
## value is full on.

proc getColorSpace*(this: PNMImageHeader): ColorSpace {.importcpp: "#.get_color_space()".} ## \
## Returns the color space that the image is encoded in, or CS_unspecified if
## unknown.

proc getXSize*(this: PNMImageHeader): int {.importcpp: "#.get_x_size()".} ## \
## Returns the number of pixels in the X direction.  This is one more than the
## largest allowable X coordinate.

proc getYSize*(this: PNMImageHeader): int {.importcpp: "#.get_y_size()".} ## \
## Returns the number of pixels in the Y direction.  This is one more than the
## largest allowable Y coordinate.

proc getSize*(this: PNMImageHeader): LVecBase2i {.importcpp: "#.get_size()".} ## \
## Returns the number of pixels in each direction.  This is one more than the
## largest allowable coordinates.

proc getComment*(this: PNMImageHeader): string {.importcpp: "nimStringFromStdString(#.get_comment())", header: stringConversionCode.} ## \
## Gets the user comment from the file.

proc setComment*(this: PNMImageHeader, comment: string) {.importcpp: "#.set_comment(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Writes a user comment string to the image (header).

proc hasType*(this: PNMImageHeader): bool {.importcpp: "#.has_type()".} ## \
## Returns true if the PNMImageHeader knows what type it is, false otherwise.

proc getType*(this: PNMImageHeader): PNMFileType {.importcpp: "#.get_type()".} ## \
## If the file type is known (e.g.  has_type() returns true), returns its
## PNMFileType pointer; otherwise, returns NULL.

proc setType*(this: PNMImageHeader, `type`: PNMFileType) {.importcpp: "#.set_type(#)".} ## \
## Sets the file type of this PNMImage.  This will be the default type used
## when an image is read, if the type cannot be determined by magic number or
## inferred by extension, or the type used when the image is written, if the
## type cannot be inferred from the filename extension.

proc readHeader*(this: PNMImageHeader, filename: Filename, `type`: PNMFileType, report_unknown_type: bool): bool {.importcpp: "#.read_header(#, #, #)".} ## \
## Opens up the image file and tries to read its header information to
## determine its size, number of channels, etc.  If successful, updates the
## header information and returns true; otherwise, returns false.

proc readHeader*(this: PNMImageHeader, filename: Filename, `type`: PNMFileType): bool {.importcpp: "#.read_header(#, #)".} ## \
## Opens up the image file and tries to read its header information to
## determine its size, number of channels, etc.  If successful, updates the
## header information and returns true; otherwise, returns false.

proc readHeader*(this: PNMImageHeader, filename: Filename): bool {.importcpp: "#.read_header(#)".} ## \
## Opens up the image file and tries to read its header information to
## determine its size, number of channels, etc.  If successful, updates the
## header information and returns true; otherwise, returns false.

proc readHeader*(this: PNMImageHeader, data: istream, filename: string, `type`: PNMFileType, report_unknown_type: bool): bool {.importcpp: "#.read_header(#, nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Reads the image header information only from the indicated stream.
##
## The filename is advisory only, and may be used to suggest a type if it has
## a known extension.
##
## If type is non-NULL, it is a suggestion for the type of file it is (and a
## non-NULL type will override any magic number test or filename extension
## lookup).
##
## Returns true if successful, false on error.

proc readHeader*(this: PNMImageHeader, data: istream, filename: string, `type`: PNMFileType): bool {.importcpp: "#.read_header(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Reads the image header information only from the indicated stream.
##
## The filename is advisory only, and may be used to suggest a type if it has
## a known extension.
##
## If type is non-NULL, it is a suggestion for the type of file it is (and a
## non-NULL type will override any magic number test or filename extension
## lookup).
##
## Returns true if successful, false on error.

proc readHeader*(this: PNMImageHeader, data: istream, filename: string): bool {.importcpp: "#.read_header(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Reads the image header information only from the indicated stream.
##
## The filename is advisory only, and may be used to suggest a type if it has
## a known extension.
##
## If type is non-NULL, it is a suggestion for the type of file it is (and a
## non-NULL type will override any magic number test or filename extension
## lookup).
##
## Returns true if successful, false on error.

proc readHeader*(this: PNMImageHeader, data: istream): bool {.importcpp: "#.read_header(#)".} ## \
## Reads the image header information only from the indicated stream.
##
## The filename is advisory only, and may be used to suggest a type if it has
## a known extension.
##
## If type is non-NULL, it is a suggestion for the type of file it is (and a
## non-NULL type will override any magic number test or filename extension
## lookup).
##
## Returns true if successful, false on error.

proc output*(this: PNMImageHeader, `out`: ostream) {.importcpp: "#.output(#)".}

proc initPfmFile*(): PfmFile {.importcpp: "PfmFile()".}

proc initPfmFile*(copy: PfmFile): PfmFile {.importcpp: "PfmFile(#)".}

proc clear*(this: PfmFile) {.importcpp: "#.clear()".} ## \
## Eliminates all data in the file.

proc clear*(this: PfmFile, x_size: int, y_size: int, num_channels: int) {.importcpp: "#.clear(#, #, #)".} ## \
## Resets to an empty table with a specific size.  The case of num_channels ==
## 0 is allowed only in the case that x_size and y_size are also == 0; and
## this makes an empty (and invalid) PfmFile.

proc read*(this: PfmFile, fullpath: Filename): bool {.importcpp: "#.read(#)".} ## \
## Reads the PFM data from the indicated file, returning true on success,
## false on failure.
##
## This can also handle reading a standard image file supported by PNMImage;
## it will be quietly converted to a floating-point type.

proc read*(this: PfmFile, `in`: istream, fullpath: Filename): bool {.importcpp: "#.read(#, #)".} ## \
## Reads the PFM data from the indicated stream, returning true on success,
## false on failure.
##
## This can also handle reading a standard image file supported by PNMImage;
## it will be quietly converted to a floating-point type.

proc read*(this: PfmFile, `in`: istream): bool {.importcpp: "#.read(#)".} ## \
## Reads the PFM data from the indicated stream, returning true on success,
## false on failure.
##
## This can also handle reading a standard image file supported by PNMImage;
## it will be quietly converted to a floating-point type.

proc write*(this: PfmFile, fullpath: Filename): bool {.importcpp: "#.write(#)".} ## \
## Writes the PFM data to the indicated file, returning true on success, false
## on failure.
##
## If the type implied by the filename extension supports floating-point, the
## data will be written directly; otherwise, the floating-point data will be
## quietly converted to the appropriate integer type.

proc write*(this: PfmFile, `out`: ostream, fullpath: Filename): bool {.importcpp: "#.write(#, #)".} ## \
## Writes the PFM data to the indicated stream, returning true on success,
## false on failure.

proc write*(this: PfmFile, `out`: ostream): bool {.importcpp: "#.write(#)".} ## \
## Writes the PFM data to the indicated stream, returning true on success,
## false on failure.

proc load*(this: PfmFile, pnmimage: PNMImage): bool {.importcpp: "#.load(#)".} ## \
## Fills the PfmFile with the data from the indicated PNMImage, converted to
## floating-point values.

proc store*(this: PfmFile, pnmimage: PNMImage): bool {.importcpp: "#.store(#)".} ## \
## Copies the data to the indicated PNMImage, converting to RGB values.

proc storeMask*(this: PfmFile, pnmimage: PNMImage): bool {.importcpp: "#.store_mask(#)".} ## \
## Stores 1 or 0 values into the indicated PNMImage, according to has_point()
## for each pixel.  Each valid point gets a 1 value; each nonexistent point
## gets a 0 value.

proc storeMask*(this: PfmFile, pnmimage: PNMImage, min_point: LVecBase4f, max_point: LVecBase4f): bool {.importcpp: "#.store_mask(#, #, #)".} ## \
## Stores 1 or 0 values into the indicated PNMImage, according to has_point()
## for each pixel.  Each valid point gets a 1 value; each nonexistent point
## gets a 0 value.
##
## This flavor of store_mask also checks whether the valid points are within
## the specified min/max range.  Any valid points without the condition
## min_point[c] <= value[c] <= max_point[c], for any c, are stored with a 0 in
## the mask.

proc isValid*(this: PfmFile): bool {.importcpp: "#.is_valid()".}

proc getScale*(this: PfmFile): float32 {.importcpp: "#.get_scale()".} ## \
## The "scale" is reported in the pfm header and is probably meaningless.

proc setScale*(this: PfmFile, scale: float32) {.importcpp: "#.set_scale(#)".} ## \
## The "scale" is reported in the pfm header and is probably meaningless.

proc hasPoint*(this: PfmFile, x: int, y: int): bool {.importcpp: "#.has_point(#, #)".} ## \
## Returns true if there is a valid point at x, y.  This always returns true
## unless a "no data" value has been set, in which case it returns false if
## the point at x, y is the "no data" value.

proc getChannel*(this: PfmFile, x: int, y: int, c: int): float32 {.importcpp: "#.get_channel(#, #, #)".} ## \
## Returns the cth channel of the point value at the indicated point.

proc setChannel*(this: PfmFile, x: int, y: int, c: int, value: float32) {.importcpp: "#.set_channel(#, #, #, #)".} ## \
## Replaces the cth channel of the point value at the indicated point.

proc getPoint1*(this: PfmFile, x: int, y: int): float32 {.importcpp: "#.get_point1(#, #)".} ## \
## Returns the 1-component point value at the indicated point.

proc setPoint1*(this: PfmFile, x: int, y: int, point: float32) {.importcpp: "#.set_point1(#, #, #)".} ## \
## Replaces the 1-component point value at the indicated point.

proc getPoint2*(this: PfmFile, x: int, y: int): LPoint2f {.importcpp: "#.get_point2(#, #)".} ## \
## Returns the 2-component point value at the indicated point.  In a 1-channel
## image, the channel value is in the x component.

proc setPoint2*(this: PfmFile, x: int, y: int, point: LVecBase2d) {.importcpp: "#.set_point2(#, #, #)".} ## \
## Replaces the 2-component point value at the indicated point.  In a
## 1-channel image, the channel value is in the x component.

proc setPoint2*(this: PfmFile, x: int, y: int, point: LVecBase2f) {.importcpp: "#.set_point2(#, #, #)".} ## \
## Replaces the 2-component point value at the indicated point.  In a
## 1-channel image, the channel value is in the x component.

proc modifyPoint2*(this: PfmFile, x: int, y: int): LPoint2f {.importcpp: "#.modify_point2(#, #)".} ## \
## Returns a modifiable 2-component point value at the indicated point.

proc getPoint*(this: PfmFile, x: int, y: int): LPoint3f {.importcpp: "#.get_point(#, #)".} ## \
## Returns the 3-component point value at the indicated point.  In a 1-channel
## image, the channel value is in the x component.

proc setPoint*(this: PfmFile, x: int, y: int, point: LVecBase3d) {.importcpp: "#.set_point(#, #, #)".} ## \
## Replaces the 3-component point value at the indicated point.  In a
## 1-channel image, the channel value is in the x component.

proc setPoint*(this: PfmFile, x: int, y: int, point: LVecBase3f) {.importcpp: "#.set_point(#, #, #)".} ## \
## Replaces the 3-component point value at the indicated point.  In a
## 1-channel image, the channel value is in the x component.

proc modifyPoint*(this: PfmFile, x: int, y: int): LPoint3f {.importcpp: "#.modify_point(#, #)".} ## \
## Returns a modifiable 3-component point value at the indicated point.

proc getPoint3*(this: PfmFile, x: int, y: int): LPoint3f {.importcpp: "#.get_point3(#, #)".} ## \
## Returns the 3-component point value at the indicated point.  In a 1-channel
## image, the channel value is in the x component.

proc setPoint3*(this: PfmFile, x: int, y: int, point: LVecBase3d) {.importcpp: "#.set_point3(#, #, #)".} ## \
## Replaces the 3-component point value at the indicated point.  In a
## 1-channel image, the channel value is in the x component.

proc setPoint3*(this: PfmFile, x: int, y: int, point: LVecBase3f) {.importcpp: "#.set_point3(#, #, #)".} ## \
## Replaces the 3-component point value at the indicated point.  In a
## 1-channel image, the channel value is in the x component.

proc modifyPoint3*(this: PfmFile, x: int, y: int): LPoint3f {.importcpp: "#.modify_point3(#, #)".} ## \
## Returns a modifiable 3-component point value at the indicated point.

proc getPoint4*(this: PfmFile, x: int, y: int): LPoint4f {.importcpp: "#.get_point4(#, #)".} ## \
## Returns the 4-component point value at the indicated point.  In a 1-channel
## image, the channel value is in the x component.

proc setPoint4*(this: PfmFile, x: int, y: int, point: LVecBase4d) {.importcpp: "#.set_point4(#, #, #)".} ## \
## Replaces the 4-component point value at the indicated point.  In a
## 1-channel image, the channel value is in the x component.

proc setPoint4*(this: PfmFile, x: int, y: int, point: LVecBase4f) {.importcpp: "#.set_point4(#, #, #)".} ## \
## Replaces the 4-component point value at the indicated point.  In a
## 1-channel image, the channel value is in the x component.

proc modifyPoint4*(this: PfmFile, x: int, y: int): LPoint4f {.importcpp: "#.modify_point4(#, #)".} ## \
## Returns a modifiable 4-component point value at the indicated point.

proc fill*(this: PfmFile, value: LPoint2f) {.importcpp: "#.fill(#)".} ## \
## Fills the table with all of the same value.

proc fill*(this: PfmFile, value: LPoint3f) {.importcpp: "#.fill(#)".} ## \
## Fills the table with all of the same value.

proc fill*(this: PfmFile, value: LPoint4f) {.importcpp: "#.fill(#)".} ## \
## Fills the table with all of the same value.

proc fill*(this: PfmFile, value: float32) {.importcpp: "#.fill(#)".} ## \
## Fills the table with all of the same value.

proc fillNan*(this: PfmFile) {.importcpp: "#.fill_nan()".} ## \
## Fills the table with all NaN.

proc fillNoDataValue*(this: PfmFile) {.importcpp: "#.fill_no_data_value()".} ## \
## Fills the table with the current no_data value, so that the table is empty.

proc fillChannel*(this: PfmFile, channel: int, value: float32) {.importcpp: "#.fill_channel(#, #)".} ## \
## Fills the indicated channel with all of the same value, leaving the other
## channels unchanged.

proc fillChannelNan*(this: PfmFile, channel: int) {.importcpp: "#.fill_channel_nan(#)".} ## \
## Fills the indicated channel with NaN, leaving the other channels unchanged.

proc fillChannelMasked*(this: PfmFile, channel: int, value: float32) {.importcpp: "#.fill_channel_masked(#, #)".} ## \
## Fills the indicated channel with all of the same value, but only where the
## table already has a data point.  Leaves empty points unchanged.

proc fillChannelMaskedNan*(this: PfmFile, channel: int) {.importcpp: "#.fill_channel_masked_nan(#)".} ## \
## Fills the indicated channel with NaN, but only where the table already has
## a data point.  Leaves empty points unchanged.

proc calcAveragePoint*(this: PfmFile, result: LPoint3f, x: float32, y: float32, radius: float32): bool {.importcpp: "#.calc_average_point(#, #, #, #)".} ## \
## Computes the unweighted average point of all points within the box centered
## at (x, y) with the indicated Manhattan-distance radius.  Missing points are
## assigned the value of their nearest neighbor.  Returns true if successful,
## or false if the point value cannot be determined.

proc calcBilinearPoint*(this: PfmFile, result: LPoint3f, x: float32, y: float32): bool {.importcpp: "#.calc_bilinear_point(#, #, #)".} ## \
## Computes the weighted average of the four nearest points to the floating-
## point index (x, y).  Returns true if the point has any contributors, false
## if the point is unknown.

proc calcMinMax*(this: PfmFile, min_points: LVecBase3f, max_points: LVecBase3f): bool {.importcpp: "#.calc_min_max(#, #)".} ## \
## Calculates the minimum and maximum x, y, and z depth component values,
## representing the bounding box of depth values, and places them in the
## indicated vectors.  Returns true if successful, false if the mesh contains
## no points.

proc calcAutocrop*(this: PfmFile, range: LVecBase4d): bool {.importcpp: "#.calc_autocrop(#)".} ## \
## Computes the minimum range of x and y across the PFM file that include all
## points.  If there are no points with no_data_value in the grid--that is,
## all points are included--then this will return (0, get_x_size(), 0,
## get_y_size()).

proc calcAutocrop*(this: PfmFile, range: LVecBase4f): bool {.importcpp: "#.calc_autocrop(#)".} ## \
## Computes the minimum range of x and y across the PFM file that include all
## points.  If there are no points with no_data_value in the grid--that is,
## all points are included--then this will return (0, get_x_size(), 0,
## get_y_size()).

proc isRowEmpty*(this: PfmFile, y: int, x_begin: int, x_end: int): bool {.importcpp: "#.is_row_empty(#, #, #)".} ## \
## Returns true if all of the points on row y, in the range [x_begin, x_end),
## are the no_data value, or false if any one of these points has a value.

proc isColumnEmpty*(this: PfmFile, x: int, y_begin: int, y_end: int): bool {.importcpp: "#.is_column_empty(#, #, #)".} ## \
## Returns true if all of the points on column x, from [y_begin, y_end), are
## the no_data value, or false if any one of these points has a value.

proc setZeroSpecial*(this: PfmFile, zero_special: bool) {.importcpp: "#.set_zero_special(#)".} ## \
## Sets the zero_special flag.  When this flag is true, values of (0, 0, 0) in
## the pfm file are treated as a special case, and are not processed.
##
## This is a special case of set_no_data_value().

proc setNoDataChan4*(this: PfmFile, chan4: bool) {.importcpp: "#.set_no_data_chan4(#)".} ## \
## Sets the no_data_chan4 flag.  When this flag is true, and the pfm file has
## 4 channels, then a negative value in the fourth channel indicates no data.
## When it is false, all points are valid.
##
## This is a special case of set_no_data_value().

proc setNoDataNan*(this: PfmFile, num_channels: int) {.importcpp: "#.set_no_data_nan(#)".} ## \
## Sets the no_data_nan flag.  When num_channels is nonzero, then a NaN value
## in any of the first num_channels channels indicates no data for that point.
## If num_channels is zero, then all points are valid.
##
## This is a special case of set_no_data_value().

proc setNoDataValue*(this: PfmFile, no_data_value: LPoint4d) {.importcpp: "#.set_no_data_value(#)".} ## \
## Sets the special value that means "no data" when it appears in the pfm
## file.

proc setNoDataValue*(this: PfmFile, no_data_value: LPoint4f) {.importcpp: "#.set_no_data_value(#)".} ## \
## Sets the special value that means "no data" when it appears in the pfm
## file.

proc setNoDataThreshold*(this: PfmFile, no_data_value: LPoint4d) {.importcpp: "#.set_no_data_threshold(#)".} ## \
## Sets the special threshold value.  Points that are below this value in all
## components are considered "no value".

proc setNoDataThreshold*(this: PfmFile, no_data_value: LPoint4f) {.importcpp: "#.set_no_data_threshold(#)".} ## \
## Sets the special threshold value.  Points that are below this value in all
## components are considered "no value".

proc clearNoDataValue*(this: PfmFile) {.importcpp: "#.clear_no_data_value()".} ## \
## Removes the special value that means "no data" when it appears in the pfm
## file.  All points will thus be considered valid.

proc hasNoDataValue*(this: PfmFile): bool {.importcpp: "#.has_no_data_value()".} ## \
## Returns whether a "no data" value has been established by
## set_no_data_value().

proc hasNoDataThreshold*(this: PfmFile): bool {.importcpp: "#.has_no_data_threshold()".} ## \
## Returns whether a "no data" threshold value has been established by
## set_no_data_threshold().

proc getNoDataValue*(this: PfmFile): LPoint4f {.importcpp: "#.get_no_data_value()".} ## \
## If has_no_data_value() returns true, this returns the particular "no data"
## value.

proc resize*(this: PfmFile, new_x_size: int, new_y_size: int) {.importcpp: "#.resize(#, #)".} ## \
## Applies a simple filter to resample the pfm file in-place to the indicated
## size.  Don't confuse this with applying a scale to all of the points via
## xform().

proc boxFilterFrom*(this: PfmFile, radius: float32, copy: PfmFile) {.importcpp: "#.box_filter_from(#, #)".} ## \
## Makes a resized copy of the indicated image into this one using the
## indicated filter.  The image to be copied is squashed and stretched to
## match the dimensions of the current image, applying the appropriate filter
## to perform the stretching.

proc gaussianFilterFrom*(this: PfmFile, radius: float32, copy: PfmFile) {.importcpp: "#.gaussian_filter_from(#, #)".} ## \
## Makes a resized copy of the indicated image into this one using the
## indicated filter.  The image to be copied is squashed and stretched to
## match the dimensions of the current image, applying the appropriate filter
## to perform the stretching.

proc quickFilterFrom*(this: PfmFile, copy: PfmFile) {.importcpp: "#.quick_filter_from(#)".} ## \
## Resizes from the given image, with a fixed radius of 0.5. This is a very
## specialized and simple algorithm that doesn't handle dropping below the
## Nyquist rate very well, but is quite a bit faster than the more general
## box_filter(), above.

proc reverseRows*(this: PfmFile) {.importcpp: "#.reverse_rows()".} ## \
## Performs an in-place reversal of the row (y) data.

proc flip*(this: PfmFile, flip_x: bool, flip_y: bool, transpose: bool) {.importcpp: "#.flip(#, #, #)".} ## \
## Reverses, transposes, and/or rotates the table in-place according to the
## specified parameters.  If flip_x is true, the x axis is reversed; if flip_y
## is true, the y axis is reversed.  Then, if transpose is true, the x and y
## axes are exchanged.  These parameters can be used to select any combination
## of 90-degree or 180-degree rotations and flips.

proc xform*(this: PfmFile, transform: LMatrix4d) {.importcpp: "#.xform(#)".} ## \
## Applies the indicated transform matrix to all points in-place.

proc xform*(this: PfmFile, transform: LMatrix4f) {.importcpp: "#.xform(#)".} ## \
## Applies the indicated transform matrix to all points in-place.

proc forwardDistort*(this: PfmFile, dist: PfmFile, scale_factor: float32) {.importcpp: "#.forward_distort(#, #)".} ## \
## Applies the distortion indicated in the supplied dist map to the current
## map.  The dist map is understood to be a mapping of points in the range
## 0..1 in the first two dimensions.
##
## The operation can be expressed symbolically as:
##
## this(u, v) = this(dist(u, v))
##
## If scale_factor is not 1, it should be a value > 1, and it specifies the
## factor to upscale the working table while processing, to reduce artifacts
## from integer truncation.
##
## By convention, the y axis is inverted in the distortion map relative to the
## coordinates here.  A y value of 0 in the distortion map corresponds with a
## v value of 1 in this file.

proc forwardDistort*(this: PfmFile, dist: PfmFile) {.importcpp: "#.forward_distort(#)".} ## \
## Applies the distortion indicated in the supplied dist map to the current
## map.  The dist map is understood to be a mapping of points in the range
## 0..1 in the first two dimensions.
##
## The operation can be expressed symbolically as:
##
## this(u, v) = this(dist(u, v))
##
## If scale_factor is not 1, it should be a value > 1, and it specifies the
## factor to upscale the working table while processing, to reduce artifacts
## from integer truncation.
##
## By convention, the y axis is inverted in the distortion map relative to the
## coordinates here.  A y value of 0 in the distortion map corresponds with a
## v value of 1 in this file.

proc reverseDistort*(this: PfmFile, dist: PfmFile, scale_factor: float32) {.importcpp: "#.reverse_distort(#, #)".} ## \
## Applies the distortion indicated in the supplied dist map to the current
## map.  The dist map is understood to be a mapping of points in the range
## 0..1 in the first two dimensions.
##
## The operation can be expressed symbolically as:
##
## this(u, v) = dist(this(u, v))
##
## If scale_factor is not 1, it should be a value > 1, and it specifies the
## factor to upscale the working table while processing, to reduce artifacts
## from integer truncation.
##
## By convention, the y axis in inverted in the distortion map relative to the
## coordinates here.  A y value of 0 in the distortion map corresponds with a
## v value of 1 in this file.

proc reverseDistort*(this: PfmFile, dist: PfmFile) {.importcpp: "#.reverse_distort(#)".} ## \
## Applies the distortion indicated in the supplied dist map to the current
## map.  The dist map is understood to be a mapping of points in the range
## 0..1 in the first two dimensions.
##
## The operation can be expressed symbolically as:
##
## this(u, v) = dist(this(u, v))
##
## If scale_factor is not 1, it should be a value > 1, and it specifies the
## factor to upscale the working table while processing, to reduce artifacts
## from integer truncation.
##
## By convention, the y axis in inverted in the distortion map relative to the
## coordinates here.  A y value of 0 in the distortion map corresponds with a
## v value of 1 in this file.

proc apply1dLut*(this: PfmFile, channel: int, lut: PfmFile, x_scale: float32) {.importcpp: "#.apply_1d_lut(#, #, #)".} ## \
## Assumes that lut is an X by 1, 1-component PfmFile whose X axis maps points
## to target points.  For each point in this pfm file, computes: p(u,
## v)[channel] = lut(p(u, v)[channel] \* x_scale, 0)[0]

proc apply1dLut*(this: PfmFile, channel: int, lut: PfmFile) {.importcpp: "#.apply_1d_lut(#, #)".} ## \
## Assumes that lut is an X by 1, 1-component PfmFile whose X axis maps points
## to target points.  For each point in this pfm file, computes: p(u,
## v)[channel] = lut(p(u, v)[channel] \* x_scale, 0)[0]

proc merge*(this: PfmFile, other: PfmFile) {.importcpp: "#.merge(#)".} ## \
## Wherever there is missing data in this PfmFile (that is, wherever
## has_point() returns false), copy data from the other PfmFile, which must be
## exactly the same dimensions as this one.

proc applyMask*(this: PfmFile, other: PfmFile) {.importcpp: "#.apply_mask(#)".} ## \
## Wherever there is missing data in the other PfmFile, set this the
## corresponding point in this PfmFile to missing as well, so that this
## PfmFile has only points where both files have points.
##
## The point is set to "missing" by setting it the no_data_value.

proc copyChannel*(this: PfmFile, to_channel: int, other: PfmFile, from_channel: int) {.importcpp: "#.copy_channel(#, #, #)".} ## \
## Copies just the specified channel values from the indicated PfmFile (which
## could be same as this PfmFile) into the specified channel of this one.

proc copyChannelMasked*(this: PfmFile, to_channel: int, other: PfmFile, from_channel: int) {.importcpp: "#.copy_channel_masked(#, #, #)".} ## \
## Copies just the specified channel values from the indicated PfmFile, but
## only where the other file has a data point.

proc applyCrop*(this: PfmFile, x_begin: int, x_end: int, y_begin: int, y_end: int) {.importcpp: "#.apply_crop(#, #, #, #)".} ## \
## Reduces the PFM file to the cells in the rectangle bounded by (x_begin,
## x_end, y_begin, y_end), where the _end cells are not included.

proc clearToTexcoords*(this: PfmFile, x_size: int, y_size: int) {.importcpp: "#.clear_to_texcoords(#, #)".} ## \
## Replaces this PfmFile with a new PfmFile of size x_size x y_size x 3,
## containing the x y 0 values in the range 0 .. 1 according to the x y index.

proc pullSpot*(this: PfmFile, delta: LPoint4f, xc: float32, yc: float32, xr: float32, yr: float32, exponent: float32): int {.importcpp: "#.pull_spot(#, #, #, #, #, #)".} ## \
## Applies delta \* t to the point values within radius (xr, yr) distance of
## (xc, yc).  The t value is scaled from 1.0 at the center to 0.0 at radius
## (xr, yr), and this scale follows the specified exponent.  Returns the
## number of points affected.

proc calcTightBounds*(this: PfmFile, min_point: LPoint3f, max_point: LPoint3f): bool {.importcpp: "#.calc_tight_bounds(#, #)".} ## \
## Calculates the minimum and maximum vertices of all points within the table.
## Assumes the table contains 3-D points.
##
## The return value is true if any points in the table, or false if none are.

proc computePlanarBounds*(this: PfmFile, center: LPoint2d, point_dist: float32, sample_radius: float32, points_only: bool): BoundingHexahedron {.importcpp: "#.compute_planar_bounds(#, #, #, #)".} ## \
## Computes the minmax bounding volume of the points in 3-D space, assuming
## the points represent a mostly-planar surface.
##
## This algorithm works by sampling the (square) sample_radius pixels at the
## four point_dist corners around the center (cx - pd, cx + pd) and so on, to
## approximate the plane of the surface.  Then all of the points are projected
## into that plane and the bounding volume of the entire mesh within that
## plane is determined.  If points_only is true, the bounding volume of only
## those four points is determined.
##
## center, point_dist and sample_radius are in UV space, i.e.  in the range
## 0..1.

proc computePlanarBounds*(this: PfmFile, center: LPoint2f, point_dist: float32, sample_radius: float32, points_only: bool): BoundingHexahedron {.importcpp: "#.compute_planar_bounds(#, #, #, #)".} ## \
## Computes the minmax bounding volume of the points in 3-D space, assuming
## the points represent a mostly-planar surface.
##
## This algorithm works by sampling the (square) sample_radius pixels at the
## four point_dist corners around the center (cx - pd, cx + pd) and so on, to
## approximate the plane of the surface.  Then all of the points are projected
## into that plane and the bounding volume of the entire mesh within that
## plane is determined.  If points_only is true, the bounding volume of only
## those four points is determined.
##
## center, point_dist and sample_radius are in UV space, i.e.  in the range
## 0..1.

proc computeSamplePoint*(this: PfmFile, result: LPoint3f, x: float32, y: float32, sample_radius: float32) {.importcpp: "#.compute_sample_point(#, #, #, #)".} ## \
## Computes the average of all the point within sample_radius (manhattan
## distance) and the indicated point.
##
## The point coordinates are given in UV space, in the range 0..1.

proc copySubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int) {.importcpp: "#.copy_sub_image(#, #, #, #, #, #, #)".} ## \
## Copies a rectangular area of another image into a rectangular area of this
## image.  Both images must already have been initialized.  The upper-left
## corner of the region in both images is specified, and the size of the area;
## if the size is omitted, it defaults to the entire other image, or the
## largest piece that will fit.

proc copySubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int) {.importcpp: "#.copy_sub_image(#, #, #, #, #, #)".} ## \
## Copies a rectangular area of another image into a rectangular area of this
## image.  Both images must already have been initialized.  The upper-left
## corner of the region in both images is specified, and the size of the area;
## if the size is omitted, it defaults to the entire other image, or the
## largest piece that will fit.

proc copySubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int) {.importcpp: "#.copy_sub_image(#, #, #, #, #)".} ## \
## Copies a rectangular area of another image into a rectangular area of this
## image.  Both images must already have been initialized.  The upper-left
## corner of the region in both images is specified, and the size of the area;
## if the size is omitted, it defaults to the entire other image, or the
## largest piece that will fit.

proc copySubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int) {.importcpp: "#.copy_sub_image(#, #, #, #)".} ## \
## Copies a rectangular area of another image into a rectangular area of this
## image.  Both images must already have been initialized.  The upper-left
## corner of the region in both images is specified, and the size of the area;
## if the size is omitted, it defaults to the entire other image, or the
## largest piece that will fit.

proc copySubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int) {.importcpp: "#.copy_sub_image(#, #, #)".} ## \
## Copies a rectangular area of another image into a rectangular area of this
## image.  Both images must already have been initialized.  The upper-left
## corner of the region in both images is specified, and the size of the area;
## if the size is omitted, it defaults to the entire other image, or the
## largest piece that will fit.

proc addSubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int, pixel_scale: float32) {.importcpp: "#.add_sub_image(#, #, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc addSubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int) {.importcpp: "#.add_sub_image(#, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc addSubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int) {.importcpp: "#.add_sub_image(#, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc addSubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int) {.importcpp: "#.add_sub_image(#, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc addSubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int) {.importcpp: "#.add_sub_image(#, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc addSubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int) {.importcpp: "#.add_sub_image(#, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc multSubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int, pixel_scale: float32) {.importcpp: "#.mult_sub_image(#, #, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc multSubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int) {.importcpp: "#.mult_sub_image(#, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc multSubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int) {.importcpp: "#.mult_sub_image(#, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc multSubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int) {.importcpp: "#.mult_sub_image(#, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc multSubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int) {.importcpp: "#.mult_sub_image(#, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc multSubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int) {.importcpp: "#.mult_sub_image(#, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.

proc divideSubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int, pixel_scale: float32) {.importcpp: "#.divide_sub_image(#, #, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are divided into the
## pixels of the destination, after scaling by the specified pixel_scale.
## dest(x, y) = dest(x, y) / (copy(x, y) \* pixel_scale).

proc divideSubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int) {.importcpp: "#.divide_sub_image(#, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are divided into the
## pixels of the destination, after scaling by the specified pixel_scale.
## dest(x, y) = dest(x, y) / (copy(x, y) \* pixel_scale).

proc divideSubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int) {.importcpp: "#.divide_sub_image(#, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are divided into the
## pixels of the destination, after scaling by the specified pixel_scale.
## dest(x, y) = dest(x, y) / (copy(x, y) \* pixel_scale).

proc divideSubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int, yfrom: int) {.importcpp: "#.divide_sub_image(#, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are divided into the
## pixels of the destination, after scaling by the specified pixel_scale.
## dest(x, y) = dest(x, y) / (copy(x, y) \* pixel_scale).

proc divideSubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int, xfrom: int) {.importcpp: "#.divide_sub_image(#, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are divided into the
## pixels of the destination, after scaling by the specified pixel_scale.
## dest(x, y) = dest(x, y) / (copy(x, y) \* pixel_scale).

proc divideSubImage*(this: PfmFile, copy: PfmFile, xto: int, yto: int) {.importcpp: "#.divide_sub_image(#, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are divided into the
## pixels of the destination, after scaling by the specified pixel_scale.
## dest(x, y) = dest(x, y) / (copy(x, y) \* pixel_scale).

proc `*=`*(this: var PfmFile, multiplier: float32): PfmFile {.importcpp: "#.operator *=(#)".}

proc indirect1dLookup*(this: PfmFile, index_image: PfmFile, channel: int, pixel_values: PfmFile) {.importcpp: "#.indirect_1d_lookup(#, #, #)".} ## \
## index_image is a WxH 1-channel image, while pixel_values is an Nx1
## image with any number of channels.  Typically pixel_values will be
## a 256x1 image.
##
## Fills the PfmFile with a new image the same width and height as
## index_image, with the same number of channels as pixel_values.
##
## Each pixel of the new image is computed with the formula:
##
## new_image(x, y) = pixel_values(index_image(x, y)[channel], 0)
##
## At present, no interpolation is performed; the nearest value in
## pixel_values is discovered.  This may change in the future.

proc gammaCorrect*(this: PfmFile, from_gamma: float32, to_gamma: float32) {.importcpp: "#.gamma_correct(#, #)".} ## \
## Assuming the image was constructed with a gamma curve of from_gamma in the
## RGB channels, converts it to an image with a gamma curve of to_gamma in the
## RGB channels.  Does not affect the alpha channel.

proc gammaCorrectAlpha*(this: PfmFile, from_gamma: float32, to_gamma: float32) {.importcpp: "#.gamma_correct_alpha(#, #)".} ## \
## Assuming the image was constructed with a gamma curve of from_gamma in the
## alpha channel, converts it to an image with a gamma curve of to_gamma in
## the alpha channel.  Does not affect the RGB channels.

proc applyExponent*(this: PfmFile, gray_exponent: float32) {.importcpp: "#.apply_exponent(#)".} ## \
## Adjusts each channel of the image by raising the corresponding component
## value to the indicated exponent, such that L' = L ^ exponent.

proc applyExponent*(this: PfmFile, gray_exponent: float32, alpha_exponent: float32) {.importcpp: "#.apply_exponent(#, #)".} ## \
## Adjusts each channel of the image by raising the corresponding component
## value to the indicated exponent, such that L' = L ^ exponent.

proc applyExponent*(this: PfmFile, c0_exponent: float32, c1_exponent: float32, c2_exponent: float32) {.importcpp: "#.apply_exponent(#, #, #)".} ## \
## Adjusts each channel of the image by raising the corresponding component
## value to the indicated exponent, such that L' = L ^ exponent.  For a
## grayscale image, the blue_exponent value is used for the grayscale value,
## and red_exponent and green_exponent are unused.

proc applyExponent*(this: PfmFile, c0_exponent: float32, c1_exponent: float32, c2_exponent: float32, c3_exponent: float32) {.importcpp: "#.apply_exponent(#, #, #, #)".} ## \
## Adjusts each channel of the image by raising the corresponding component
## value to the indicated exponent, such that L' = L ^ exponent.

proc output*(this: PfmFile, `out`: ostream) {.importcpp: "#.output(#)".}

proc makeTransparent*(_: typedesc[PNMBrush]): PNMBrush {.importcpp: "PNMBrush::make_transparent()", header: "pnmBrush.h".} ## \
## Returns a new brush that does not paint anything.  Can be used as either a
## pen or a fill brush to make borderless or unfilled shapes, respectively.

proc makePixel*(_: typedesc[PNMBrush], color: LColorf): PNMBrush {.importcpp: "#PNMBrush::make_pixel(#)", header: "pnmBrush.h".} ## \
## Returns a new brush that paints a single pixel of the indicated color on a
## border, or paints a solid color in an interior.

proc makeSpot*(_: typedesc[PNMBrush], color: LColorf, radius: float32, fuzzy: bool): PNMBrush {.importcpp: "#PNMBrush::make_spot(#, #, #)", header: "pnmBrush.h".} ## \
## Returns a new brush that paints a spot of the indicated color and radius.
## If fuzzy is true, the spot is fuzzy; otherwise, it is hard-edged.

proc makeImage*(_: typedesc[PNMBrush], image: PNMImage, xc: float32, yc: float32): PNMBrush {.importcpp: "#PNMBrush::make_image(#, #, #)", header: "pnmBrush.h".} ## \
## Returns a new brush that paints with the indicated image.  xc and yc
## indicate the pixel in the center of the brush.
##
## The brush makes a copy of the image; it is safe to deallocate or modify the
## image after making this call.

proc initPNMImage*(): PNMImage {.importcpp: "PNMImage()".}

proc initPNMImage*(filename: Filename, `type`: PNMFileType): PNMImage {.importcpp: "PNMImage(#, #)".}

proc initPNMImage*(filename: Filename): PNMImage {.importcpp: "PNMImage(#)".}

proc initPNMImage*(copy: PNMImage): PNMImage {.importcpp: "PNMImage(#)".}

proc initPNMImage*(x_size: int, y_size: int, num_channels: int, maxval: int, `type`: PNMFileType, color_space: ColorSpace): PNMImage {.importcpp: "PNMImage(#, #, #, #, #, #)".}

proc initPNMImage*(x_size: int, y_size: int, num_channels: int, maxval: int, `type`: PNMFileType): PNMImage {.importcpp: "PNMImage(#, #, #, #, #)".}

proc initPNMImage*(x_size: int, y_size: int, num_channels: int, maxval: int): PNMImage {.importcpp: "PNMImage(#, #, #, #)".}

proc initPNMImage*(x_size: int, y_size: int, num_channels: int): PNMImage {.importcpp: "PNMImage(#, #, #)".}

proc initPNMImage*(x_size: int, y_size: int): PNMImage {.importcpp: "PNMImage(#, #)".}

proc clampVal*(this: PNMImage, input_value: int): int {.importcpp: "#.clamp_val(#)".} ## \
## A handy function to clamp values to [0..get_maxval()].

proc toVal*(this: PNMImage, input_value: LRGBColorf): xel {.importcpp: "#.to_val(#)".} ## \
## A handy function to scale non-alpha values from [0..1] to
## [0..get_maxval()].  Do not use this for alpha values, see to_alpha_val.

proc toVal*(this: PNMImage, input_value: float32): int {.importcpp: "#.to_val(#)".} ## \
## A handy function to scale non-alpha values from [0..1] to
## [0..get_maxval()].  Do not use this for alpha values, see to_alpha_val.

proc toAlphaVal*(this: PNMImage, input_value: float32): int {.importcpp: "#.to_alpha_val(#)".} ## \
## A handy function to scale alpha values from [0..1] to [0..get_maxval()].

proc fromVal*(this: PNMImage, input_value: xel): LRGBColorf {.importcpp: "#.from_val(#)".} ## \
## A handy function to scale non-alpha values from [0..get_maxval()] to
## [0..1].  Do not use this for alpha values, see from_alpha_val.

proc fromVal*(this: PNMImage, input_value: int): float32 {.importcpp: "#.from_val(#)".} ## \
## A handy function to scale non-alpha values from [0..get_maxval()] to
## [0..1].  Do not use this for alpha values, see from_alpha_val.

proc fromAlphaVal*(this: PNMImage, input_value: int): float32 {.importcpp: "#.from_alpha_val(#)".} ## \
## A handy function to scale alpha values from [0..get_maxval()] to [0..1].

proc clear*(this: PNMImage) {.importcpp: "#.clear()".} ## \
## Frees all memory allocated for the image, and clears all its parameters
## (size, color, type, etc).

proc clear*(this: PNMImage, x_size: int, y_size: int, num_channels: int, maxval: int, `type`: PNMFileType, color_space: ColorSpace) {.importcpp: "#.clear(#, #, #, #, #, #)".} ## \
## This flavor of clear() reinitializes the image to an empty (black) image
## with the given dimensions.

proc clear*(this: PNMImage, x_size: int, y_size: int, num_channels: int, maxval: int, `type`: PNMFileType) {.importcpp: "#.clear(#, #, #, #, #)".} ## \
## This flavor of clear() reinitializes the image to an empty (black) image
## with the given dimensions.

proc clear*(this: PNMImage, x_size: int, y_size: int, num_channels: int, maxval: int) {.importcpp: "#.clear(#, #, #, #)".} ## \
## This flavor of clear() reinitializes the image to an empty (black) image
## with the given dimensions.

proc clear*(this: PNMImage, x_size: int, y_size: int, num_channels: int) {.importcpp: "#.clear(#, #, #)".} ## \
## This flavor of clear() reinitializes the image to an empty (black) image
## with the given dimensions.

proc clear*(this: PNMImage, x_size: int, y_size: int) {.importcpp: "#.clear(#, #)".} ## \
## This flavor of clear() reinitializes the image to an empty (black) image
## with the given dimensions.

proc copyFrom*(this: PNMImage, copy: PNMImage) {.importcpp: "#.copy_from(#)".} ## \
## Makes this image become a copy of the other image.

proc copyChannel*(this: PNMImage, copy: PNMImage, src_channel: int, dest_channel: int) {.importcpp: "#.copy_channel(#, #, #)".} ## \
## Copies a channel from one image into another.  Images must be the same size

proc copyChannel*(this: PNMImage, copy: PNMImage, xto: int, yto: int, cto: int, xfrom: int, yfrom: int, cfrom: int, x_size: int, y_size: int) {.importcpp: "#.copy_channel(#, #, #, #, #, #, #, #, #)".} ## \
## Copies just a single channel from the source image into a single channel of
## this image, leaving the remaining channels alone.

proc copyChannel*(this: PNMImage, copy: PNMImage, xto: int, yto: int, cto: int, xfrom: int, yfrom: int, cfrom: int, x_size: int) {.importcpp: "#.copy_channel(#, #, #, #, #, #, #, #)".} ## \
## Copies just a single channel from the source image into a single channel of
## this image, leaving the remaining channels alone.

proc copyChannel*(this: PNMImage, copy: PNMImage, xto: int, yto: int, cto: int, xfrom: int, yfrom: int, cfrom: int) {.importcpp: "#.copy_channel(#, #, #, #, #, #, #)".} ## \
## Copies just a single channel from the source image into a single channel of
## this image, leaving the remaining channels alone.

proc copyChannel*(this: PNMImage, copy: PNMImage, xto: int, yto: int, cto: int, xfrom: int, yfrom: int) {.importcpp: "#.copy_channel(#, #, #, #, #, #)".} ## \
## Copies just a single channel from the source image into a single channel of
## this image, leaving the remaining channels alone.

proc copyChannel*(this: PNMImage, copy: PNMImage, xto: int, yto: int, cto: int, xfrom: int) {.importcpp: "#.copy_channel(#, #, #, #, #)".} ## \
## Copies just a single channel from the source image into a single channel of
## this image, leaving the remaining channels alone.

proc copyChannel*(this: PNMImage, copy: PNMImage, xto: int, yto: int, cto: int) {.importcpp: "#.copy_channel(#, #, #, #)".} ## \
## Copies just a single channel from the source image into a single channel of
## this image, leaving the remaining channels alone.

proc copyChannelBits*(this: PNMImage, copy: PNMImage, src_channel: int, dest_channel: int, src_mask: int, right_shift: int) {.importcpp: "#.copy_channel_bits(#, #, #, #, #)".} ## \
## Copies some subset of the bits of the specified channel from one image into
## some subset of the bits of the specified channel in another image.  Images
## must be the same size.
##
## If right_shift is negative, it means a left shift.

proc copyHeaderFrom*(this: PNMImage, header: PNMImageHeader) {.importcpp: "#.copy_header_from(#)".} ## \
## Copies just the header information into this image.  This will blow away
## any image data stored in the image.  The new image data will be allocated,
## but left unitialized.

proc takeFrom*(this: PNMImage, orig: PNMImage) {.importcpp: "#.take_from(#)".} ## \
## Move the contents of the other image into this one, and empty the other
## image.

proc fill*(this: PNMImage, gray: float32) {.importcpp: "#.fill(#)".} ## \
## Sets the entire image (except the alpha channel) to the given grayscale
## level.

proc fill*(this: PNMImage) {.importcpp: "#.fill()".} ## \
## Sets the entire image (except the alpha channel) to the given grayscale
## level.

proc fill*(this: PNMImage, red: float32, green: float32, blue: float32) {.importcpp: "#.fill(#, #, #)".} ## \
## Sets the entire image (except the alpha channel) to the given color.

proc fillVal*(this: PNMImage, gray: int) {.importcpp: "#.fill_val(#)".} ## \
## Sets the entire image (except the alpha channel) to the given grayscale
## level.

proc fillVal*(this: PNMImage) {.importcpp: "#.fill_val()".} ## \
## Sets the entire image (except the alpha channel) to the given grayscale
## level.

proc fillVal*(this: PNMImage, red: int, green: int, blue: int) {.importcpp: "#.fill_val(#, #, #)".} ## \
## Sets the entire image (except the alpha channel) to the given color.

proc alphaFill*(this: PNMImage, alpha: float32) {.importcpp: "#.alpha_fill(#)".} ## \
## Sets the entire alpha channel to the given level.

proc alphaFill*(this: PNMImage) {.importcpp: "#.alpha_fill()".} ## \
## Sets the entire alpha channel to the given level.

proc alphaFillVal*(this: PNMImage, alpha: int) {.importcpp: "#.alpha_fill_val(#)".} ## \
## Sets the entire alpha channel to the given level.

proc alphaFillVal*(this: PNMImage) {.importcpp: "#.alpha_fill_val()".} ## \
## Sets the entire alpha channel to the given level.

proc setReadSize*(this: PNMImage, x_size: int, y_size: int) {.importcpp: "#.set_read_size(#, #)".} ## \
## Specifies the size to we'd like to scale the image upon reading it.  This
## will affect the next call to read().  This is usually used to reduce the
## image size, e.g.  for a thumbnail.
##
## If the file type reader supports it (e.g.  JPEG), then this will scale the
## image during the read operation, consequently reducing memory and CPU
## utilization.  If the file type reader does not support it, this will load
## the image normally, and them perform a linear scale after it has been
## loaded.

proc clearReadSize*(this: PNMImage) {.importcpp: "#.clear_read_size()".} ## \
## Undoes the effect of a previous call to set_read_size().

proc hasReadSize*(this: PNMImage): bool {.importcpp: "#.has_read_size()".} ## \
## Returns true if set_read_size() has been called.

proc getReadXSize*(this: PNMImage): int {.importcpp: "#.get_read_x_size()".} ## \
## Returns the requested x_size of the image if set_read_size() has been
## called, or the image x_size otherwise (if it is known).

proc getReadYSize*(this: PNMImage): int {.importcpp: "#.get_read_y_size()".} ## \
## Returns the requested y_size of the image if set_read_size() has been
## called, or the image y_size otherwise (if it is known).

proc getColorSpace*(this: PNMImage): ColorSpace {.importcpp: "#.get_color_space()".} ## \
## Returns the color space in which the image is encoded.

proc read*(this: PNMImage, filename: Filename, `type`: PNMFileType, report_unknown_type: bool): bool {.importcpp: "#.read(#, #, #)".} ## \
## Reads the indicated image filename.  If type is non-NULL, it is a
## suggestion for the type of file it is.  Returns true if successful, false
## on error.

proc read*(this: PNMImage, filename: Filename, `type`: PNMFileType): bool {.importcpp: "#.read(#, #)".} ## \
## Reads the indicated image filename.  If type is non-NULL, it is a
## suggestion for the type of file it is.  Returns true if successful, false
## on error.

proc read*(this: PNMImage, filename: Filename): bool {.importcpp: "#.read(#)".} ## \
## Reads the indicated image filename.  If type is non-NULL, it is a
## suggestion for the type of file it is.  Returns true if successful, false
## on error.

proc read*(this: PNMImage, data: istream, filename: string, `type`: PNMFileType, report_unknown_type: bool): bool {.importcpp: "#.read(#, nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Reads the image data from the indicated stream.
##
## The filename is advisory only, and may be used to suggest a type if it has
## a known extension.
##
## If type is non-NULL, it is a suggestion for the type of file it is (and a
## non-NULL type will override any magic number test or filename extension
## lookup).
##
## Returns true if successful, false on error.

proc read*(this: PNMImage, data: istream, filename: string, `type`: PNMFileType): bool {.importcpp: "#.read(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Reads the image data from the indicated stream.
##
## The filename is advisory only, and may be used to suggest a type if it has
## a known extension.
##
## If type is non-NULL, it is a suggestion for the type of file it is (and a
## non-NULL type will override any magic number test or filename extension
## lookup).
##
## Returns true if successful, false on error.

proc read*(this: PNMImage, data: istream, filename: string): bool {.importcpp: "#.read(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Reads the image data from the indicated stream.
##
## The filename is advisory only, and may be used to suggest a type if it has
## a known extension.
##
## If type is non-NULL, it is a suggestion for the type of file it is (and a
## non-NULL type will override any magic number test or filename extension
## lookup).
##
## Returns true if successful, false on error.

proc read*(this: PNMImage, data: istream): bool {.importcpp: "#.read(#)".} ## \
## Reads the image data from the indicated stream.
##
## The filename is advisory only, and may be used to suggest a type if it has
## a known extension.
##
## If type is non-NULL, it is a suggestion for the type of file it is (and a
## non-NULL type will override any magic number test or filename extension
## lookup).
##
## Returns true if successful, false on error.

proc write*(this: PNMImage, filename: Filename, `type`: PNMFileType): bool {.importcpp: "#.write(#, #)".} ## \
## Writes the image to the indicated filename.  If type is non-NULL, it is a
## suggestion for the type of image file to write.

proc write*(this: PNMImage, filename: Filename): bool {.importcpp: "#.write(#)".} ## \
## Writes the image to the indicated filename.  If type is non-NULL, it is a
## suggestion for the type of image file to write.

proc write*(this: PNMImage, data: ostream, filename: string, `type`: PNMFileType): bool {.importcpp: "#.write(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Writes the image to the indicated ostream.
##
## The filename is advisory only, and may be used suggest a type if it has a
## known extension.
##
## If type is non-NULL, it is a suggestion for the type of image file to
## write.

proc write*(this: PNMImage, data: ostream, filename: string): bool {.importcpp: "#.write(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Writes the image to the indicated ostream.
##
## The filename is advisory only, and may be used suggest a type if it has a
## known extension.
##
## If type is non-NULL, it is a suggestion for the type of image file to
## write.

proc write*(this: PNMImage, data: ostream): bool {.importcpp: "#.write(#)".} ## \
## Writes the image to the indicated ostream.
##
## The filename is advisory only, and may be used suggest a type if it has a
## known extension.
##
## If type is non-NULL, it is a suggestion for the type of image file to
## write.

proc isValid*(this: PNMImage): bool {.importcpp: "#.is_valid()".} ## \
## Returns true if the image has been read in or correctly initialized with a
## height and width.  If this returns false, virtually all member functions
## except clear() and read() are invalid function calls.

proc setNumChannels*(this: PNMImage, num_channels: int) {.importcpp: "#.set_num_channels(#)".} ## \
## Changes the number of channels associated with the image.  The new number
## of channels must be an integer in the range 1 through 4, inclusive.  This
## will allocate and/or deallocate memory as necessary to accommodate; see
## set_color_type().

proc setColorSpace*(this: PNMImage, color_space: ColorSpace) {.importcpp: "#.set_color_space(#)".} ## \
## Converts the colors in the image to the indicated color space.  This may be
## a lossy operation, in particular when going from sRGB to linear.  The alpha
## channel remains untouched.
##
## Note that, because functions like get_xel() and set_xel() work on
## linearized floating-point values, this conversion won't affect those values
## (aside from some minor discrepancies due to storage precision).  It does
## affect the values used by get_xel_val() and set_xel_val(), though, since
## those operate on encoded colors.
##
## Some color spaces, particularly scRGB, may enforce the use of a particular
## maxval setting.

proc addAlpha*(this: PNMImage) {.importcpp: "#.add_alpha()".} ## \
## Adds an alpha channel to the image, if it does not already have one.  The
## alpha channel is initialized to zeros.

proc removeAlpha*(this: PNMImage) {.importcpp: "#.remove_alpha()".} ## \
## Removes the image's alpha channel, if it exists.

proc makeGrayscale*(this: PNMImage) {.importcpp: "#.make_grayscale()".} ## \
## Converts the image from RGB to grayscale.  Any alpha channel, if present,
## is left undisturbed.

proc makeGrayscale*(this: PNMImage, rc: float32, gc: float32, bc: float32) {.importcpp: "#.make_grayscale(#, #, #)".} ## \
## Converts the image from RGB to grayscale.  Any alpha channel, if present,
## is left undisturbed.  The optional rc, gc, bc values represent the relative
## weights to apply to each channel to convert it to grayscale.

proc makeRgb*(this: PNMImage) {.importcpp: "#.make_rgb()".} ## \
## Converts the image from grayscale to RGB.  Any alpha channel, if present,
## is left undisturbed.

proc premultiplyAlpha*(this: PNMImage) {.importcpp: "#.premultiply_alpha()".} ## \
## Converts an image in-place to its "premultiplied" form, where, for every
## pixel in the image, the red, green, and blue components are multiplied by
## that pixel's alpha value.
##
## This does not modify any alpha values.

proc unpremultiplyAlpha*(this: PNMImage) {.importcpp: "#.unpremultiply_alpha()".} ## \
## Converts an image in-place to its "straight alpha" form (presumably from a
## "premultiplied" form), where, for every pixel in the image, the red, green,
## and blue components are divided by that pixel's alpha value.
##
## This does not modify any alpha values.

proc reverseRows*(this: PNMImage) {.importcpp: "#.reverse_rows()".} ## \
## Performs an in-place reversal of the row (y) data.

proc flip*(this: PNMImage, flip_x: bool, flip_y: bool, transpose: bool) {.importcpp: "#.flip(#, #, #)".} ## \
## Reverses, transposes, and/or rotates the image in-place according to the
## specified parameters.  If flip_x is true, the x axis is reversed; if flip_y
## is true, the y axis is reversed.  Then, if transpose is true, the x and y
## axes are exchanged.  These parameters can be used to select any combination
## of 90-degree or 180-degree rotations and flips.

proc setMaxval*(this: PNMImage, maxval: int) {.importcpp: "#.set_maxval(#)".} ## \
## Rescales the image to the indicated maxval.

proc getXelVal*(this: PNMImage, x: int, y: int): xel {.importcpp: "#.get_xel_val(#, #)".} ## \
## Returns the RGB color at the indicated pixel.  Each component is in the
## range 0..maxval.

proc setXelVal*(this: PNMImage, x: int, y: int, value: xel) {.importcpp: "#.set_xel_val(#, #, #)".} ## \
## Changes the RGB color at the indicated pixel.  Each component is in the
## range 0..maxval, encoded in the configured color space.  See set_xel if you
## instead have a linearized and normalized floating-point value.

proc setXelVal*(this: PNMImage, x: int, y: int, gray: int) {.importcpp: "#.set_xel_val(#, #, #)".} ## \
## Changes all three color components at the indicated pixel to the same
## value.  The value is in the range component is in the range 0..maxval,
## encoded in the configured color space.  See set_xel if you instead have a
## linearized and normalized floating-point value.

proc setXelVal*(this: PNMImage, x: int, y: int, r: int, g: int, b: int) {.importcpp: "#.set_xel_val(#, #, #, #, #)".} ## \
## Changes the RGB color at the indicated pixel.  Each component is in the
## range 0..maxval, encoded in the configured color space.  See set_xel if you
## instead have a linearized and normalized floating-point value.

proc getRedVal*(this: PNMImage, x: int, y: int): int {.importcpp: "#.get_red_val(#, #)".} ## \
## Returns the red component color at the indicated pixel.  The value returned
## is in the range 0..maxval and encoded in the configured color space.

proc getGreenVal*(this: PNMImage, x: int, y: int): int {.importcpp: "#.get_green_val(#, #)".} ## \
## Returns the green component color at the indicated pixel.  The value
## returned is in the range 0..maxval and encoded in the configured color
## space.

proc getBlueVal*(this: PNMImage, x: int, y: int): int {.importcpp: "#.get_blue_val(#, #)".} ## \
## Returns the blue component color at the indicated pixel.  The value
## returned is in the range 0..maxval and encoded in the configured color
## space.

proc getGrayVal*(this: PNMImage, x: int, y: int): int {.importcpp: "#.get_gray_val(#, #)".} ## \
## Returns the gray component color at the indicated pixel.  This only has a
## meaningful value for grayscale images; for other image types, this returns
## the value of the blue channel only.  However, also see the get_bright()
## function.  The value returned is in the range 0..maxval and encoded in the
## configured color space.

proc getAlphaVal*(this: PNMImage, x: int, y: int): int {.importcpp: "#.get_alpha_val(#, #)".} ## \
## Returns the alpha component color at the indicated pixel.  It is an error
## to call this unless has_alpha() is true.  The value returned is in the
## range 0..maxval and always linear.

proc setRedVal*(this: PNMImage, x: int, y: int, r: int) {.importcpp: "#.set_red_val(#, #, #)".} ## \
## Sets the red component color only at the indicated pixel.  The value given
## should be in the range 0..maxval, encoded in the configured color space.
## See set_red if you instead have a linearized and normalized floating-point
## value.

proc setGreenVal*(this: PNMImage, x: int, y: int, g: int) {.importcpp: "#.set_green_val(#, #, #)".} ## \
## Sets the green component color only at the indicated pixel.  The value
## given should be in the range 0..maxval, encoded in the configured color
## space.  See set_green if you instead have a linearized and normalized
## floating-point value.

proc setBlueVal*(this: PNMImage, x: int, y: int, b: int) {.importcpp: "#.set_blue_val(#, #, #)".} ## \
## Sets the blue component color only at the indicated pixel.  The value given
## should be in the range 0..maxval, encoded in the configured color space.
## See set_blue if you instead have a linearized and normalized floating-point
## value.

proc setGrayVal*(this: PNMImage, x: int, y: int, gray: int) {.importcpp: "#.set_gray_val(#, #, #)".} ## \
## Sets the gray component color at the indicated pixel.  This is only
## meaningful for grayscale images; for other image types, this simply sets
## the blue component color.  However, also see set_xel_val(), which can set
## all the component colors to the same grayscale level, and hence works
## correctly both for grayscale and color images.  The value given should be
## in the range 0..maxval, encoded in the configured color space.  See
## set_gray if you instead have a linearized normalized floating-point value.

proc setAlphaVal*(this: PNMImage, x: int, y: int, a: int) {.importcpp: "#.set_alpha_val(#, #, #)".} ## \
## Sets the alpha component color only at the indicated pixel.  It is an error
## to call this unless has_alpha() is true.  The value given should be in the
## range 0..maxval.
##
## This value is always linearly encoded, even if the image is set to the sRGB
## color space.

proc getChannelVal*(this: PNMImage, x: int, y: int, channel: int): int {.importcpp: "#.get_channel_val(#, #, #)".} ## \
## Returns the nth component color at the indicated pixel.  The channel index
## should be in the range 0..(get_num_channels()-1).  The channels are ordered
## B, G, R, A.  This is slightly less optimal than accessing the component
## values directly by named methods.  The value returned is in the range
## 0..maxval.

proc setChannelVal*(this: PNMImage, x: int, y: int, channel: int, value: int) {.importcpp: "#.set_channel_val(#, #, #, #)".} ## \
## Sets the nth component color at the indicated pixel.  The channel index
## should be in the range 0..(get_num_channels()-1).  The channels are ordered
## B, G, R, A.  This is slightly less optimal than setting the component
## values directly by named methods.  The value given should be in the range
## 0..maxval.

proc getChannel*(this: PNMImage, x: int, y: int, channel: int): float32 {.importcpp: "#.get_channel(#, #, #)".} ## \
## Returns the nth component color at the indicated pixel.  The channel index
## should be in the range 0..(get_num_channels()-1).  The channels are ordered
## B, G, R, A.  This is slightly less optimal than accessing the component
## values directly by named methods.  The value returned is a float in the
## range 0..1.

proc setChannel*(this: PNMImage, x: int, y: int, channel: int, value: float32) {.importcpp: "#.set_channel(#, #, #, #)".} ## \
## Sets the nth component color at the indicated pixel.  The channel index
## should be in the range 0..(get_num_channels()-1).  The channels are ordered
## B, G, R, A.  This is slightly less optimal than setting the component
## values directly by named methods.  The value given should be a float in the
## range 0..1.

proc getXel*(this: PNMImage, x: int, y: int): LRGBColorf {.importcpp: "#.get_xel(#, #)".} ## \
## Returns the RGB color at the indicated pixel.  Each component is a
## linearized float in the range 0..1.

proc setXel*(this: PNMImage, x: int, y: int, value: LRGBColorf) {.importcpp: "#.set_xel(#, #, #)".} ## \
## Changes the RGB color at the indicated pixel.  Each component is a
## linearized float in the range 0..1.

proc setXel*(this: PNMImage, x: int, y: int, gray: float32) {.importcpp: "#.set_xel(#, #, #)".} ## \
## Changes all three color components at the indicated pixel to the same
## value.  The value is a linearized float in the range 0..1.

proc setXel*(this: PNMImage, x: int, y: int, r: float32, g: float32, b: float32) {.importcpp: "#.set_xel(#, #, #, #, #)".} ## \
## Changes the RGB color at the indicated pixel.  Each component is a
## linearized float in the range 0..1.

proc getXelA*(this: PNMImage, x: int, y: int): LColorf {.importcpp: "#.get_xel_a(#, #)".} ## \
## Returns the RGBA color at the indicated pixel.  Each component is a
## linearized float in the range 0..1.

proc setXelA*(this: PNMImage, x: int, y: int, value: LColorf) {.importcpp: "#.set_xel_a(#, #, #)".} ## \
## Changes the RGBA color at the indicated pixel.  Each component is a
## linearized float in the range 0..1.

proc setXelA*(this: PNMImage, x: int, y: int, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_xel_a(#, #, #, #, #, #)".} ## \
## Changes the RGBA color at the indicated pixel.  Each component is a
## linearized float in the range 0..1.

proc getRed*(this: PNMImage, x: int, y: int): float32 {.importcpp: "#.get_red(#, #)".} ## \
## Returns the red component color at the indicated pixel.  The value returned
## is a linearized float in the range 0..1.

proc getGreen*(this: PNMImage, x: int, y: int): float32 {.importcpp: "#.get_green(#, #)".} ## \
## Returns the green component color at the indicated pixel.  The value
## returned is a linearized float in the range 0..1.

proc getBlue*(this: PNMImage, x: int, y: int): float32 {.importcpp: "#.get_blue(#, #)".} ## \
## Returns the blue component color at the indicated pixel.  The value
## returned is a linearized float in the range 0..1.

proc getGray*(this: PNMImage, x: int, y: int): float32 {.importcpp: "#.get_gray(#, #)".} ## \
## Returns the gray component color at the indicated pixel.  This only has a
## meaningful value for grayscale images; for other image types, this returns
## the value of the blue channel only.  However, also see the get_bright()
## function.  The value returned is a linearized float in the range 0..1.

proc getAlpha*(this: PNMImage, x: int, y: int): float32 {.importcpp: "#.get_alpha(#, #)".} ## \
## Returns the alpha component color at the indicated pixel.  It is an error
## to call this unless has_alpha() is true.  The value returned is a float in
## the range 0..1.

proc setRed*(this: PNMImage, x: int, y: int, r: float32) {.importcpp: "#.set_red(#, #, #)".} ## \
## Sets the red component color only at the indicated pixel.  The value given
## should be a linearized float in the range 0..1.

proc setGreen*(this: PNMImage, x: int, y: int, g: float32) {.importcpp: "#.set_green(#, #, #)".} ## \
## Sets the green component color only at the indicated pixel.  The value
## given should be a linearized float in the range 0..1.

proc setBlue*(this: PNMImage, x: int, y: int, b: float32) {.importcpp: "#.set_blue(#, #, #)".} ## \
## Sets the blue component color only at the indicated pixel.  The value given
## should be a linearized float in the range 0..1.

proc setGray*(this: PNMImage, x: int, y: int, gray: float32) {.importcpp: "#.set_gray(#, #, #)".} ## \
## Sets the gray component color at the indicated pixel.  This is only
## meaningful for grayscale images; for other image types, this simply sets
## the blue component color.  However, also see set_xel(), which can set all
## the component colors to the same grayscale level, and hence works correctly
## both for grayscale and color images.  The value given should be a
## linearized float in the range 0..1.

proc setAlpha*(this: PNMImage, x: int, y: int, a: float32) {.importcpp: "#.set_alpha(#, #, #)".} ## \
## Sets the alpha component color only at the indicated pixel.  It is an error
## to call this unless has_alpha() is true.  The value given should be in the
## range 0..1.

proc getBright*(this: PNMImage, x: int, y: int): float32 {.importcpp: "#.get_bright(#, #)".} ## \
## Returns the linear brightness of the given xel, as a linearized float in
## the range 0..1.  This flavor of get_bright() returns the correct grayscale
## brightness level for both full-color and grayscale images.

proc getBright*(this: PNMImage, x: int, y: int, rc: float32, gc: float32, bc: float32): float32 {.importcpp: "#.get_bright(#, #, #, #, #)".} ## \
## This flavor of get_bright() works correctly only for color images.  It
## returns a single brightness value for the RGB color at the indicated pixel,
## based on the supplied weights for each component.

proc getBright*(this: PNMImage, x: int, y: int, rc: float32, gc: float32, bc: float32, ac: float32): float32 {.importcpp: "#.get_bright(#, #, #, #, #, #)".} ## \
## This flavor of get_bright() works correctly only for four-channel images.
## It returns a single brightness value for the RGBA color at the indicated
## pixel, based on the supplied weights for each component.

proc blend*(this: PNMImage, x: int, y: int, val: LRGBColorf, alpha: float32) {.importcpp: "#.blend(#, #, #, #)".} ## \
## Smoothly blends the indicated pixel value in with whatever was already in
## the image, based on the given alpha value.  An alpha of 1.0 is fully opaque
## and completely replaces whatever was there previously; alpha of 0.0 is
## fully transparent and does nothing.

proc blend*(this: PNMImage, x: int, y: int, r: float32, g: float32, b: float32, alpha: float32) {.importcpp: "#.blend(#, #, #, #, #, #)".} ## \
## Smoothly blends the indicated pixel value in with whatever was already in
## the image, based on the given alpha value.  An alpha of 1.0 is fully opaque
## and completely replaces whatever was there previously; alpha of 0.0 is
## fully transparent and does nothing.

proc copySubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int) {.importcpp: "#.copy_sub_image(#, #, #, #, #, #, #)".} ## \
## Copies a rectangular area of another image into a rectangular area of this
## image.  Both images must already have been initialized.  The upper-left
## corner of the region in both images is specified, and the size of the area;
## if the size is omitted, it defaults to the entire other image, or the
## largest piece that will fit.

proc copySubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int) {.importcpp: "#.copy_sub_image(#, #, #, #, #, #)".} ## \
## Copies a rectangular area of another image into a rectangular area of this
## image.  Both images must already have been initialized.  The upper-left
## corner of the region in both images is specified, and the size of the area;
## if the size is omitted, it defaults to the entire other image, or the
## largest piece that will fit.

proc copySubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int) {.importcpp: "#.copy_sub_image(#, #, #, #, #)".} ## \
## Copies a rectangular area of another image into a rectangular area of this
## image.  Both images must already have been initialized.  The upper-left
## corner of the region in both images is specified, and the size of the area;
## if the size is omitted, it defaults to the entire other image, or the
## largest piece that will fit.

proc copySubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int) {.importcpp: "#.copy_sub_image(#, #, #, #)".} ## \
## Copies a rectangular area of another image into a rectangular area of this
## image.  Both images must already have been initialized.  The upper-left
## corner of the region in both images is specified, and the size of the area;
## if the size is omitted, it defaults to the entire other image, or the
## largest piece that will fit.

proc copySubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int) {.importcpp: "#.copy_sub_image(#, #, #)".} ## \
## Copies a rectangular area of another image into a rectangular area of this
## image.  Both images must already have been initialized.  The upper-left
## corner of the region in both images is specified, and the size of the area;
## if the size is omitted, it defaults to the entire other image, or the
## largest piece that will fit.

proc blendSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int, pixel_scale: float32) {.importcpp: "#.blend_sub_image(#, #, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the alpha channel of the copy is used
## to blend the copy into the destination image, instead of overwriting pixels
## unconditionally.
##
## If pixel_scale is not 1.0, it specifies an amount to scale each \*alpha\*
## value of the source image before applying it to the target image.
##
## If pixel_scale is 1.0 and the copy has no alpha channel, this degenerates
## into copy_sub_image().

proc blendSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int) {.importcpp: "#.blend_sub_image(#, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the alpha channel of the copy is used
## to blend the copy into the destination image, instead of overwriting pixels
## unconditionally.
##
## If pixel_scale is not 1.0, it specifies an amount to scale each \*alpha\*
## value of the source image before applying it to the target image.
##
## If pixel_scale is 1.0 and the copy has no alpha channel, this degenerates
## into copy_sub_image().

proc blendSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int) {.importcpp: "#.blend_sub_image(#, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the alpha channel of the copy is used
## to blend the copy into the destination image, instead of overwriting pixels
## unconditionally.
##
## If pixel_scale is not 1.0, it specifies an amount to scale each \*alpha\*
## value of the source image before applying it to the target image.
##
## If pixel_scale is 1.0 and the copy has no alpha channel, this degenerates
## into copy_sub_image().

proc blendSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int) {.importcpp: "#.blend_sub_image(#, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the alpha channel of the copy is used
## to blend the copy into the destination image, instead of overwriting pixels
## unconditionally.
##
## If pixel_scale is not 1.0, it specifies an amount to scale each \*alpha\*
## value of the source image before applying it to the target image.
##
## If pixel_scale is 1.0 and the copy has no alpha channel, this degenerates
## into copy_sub_image().

proc blendSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int) {.importcpp: "#.blend_sub_image(#, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the alpha channel of the copy is used
## to blend the copy into the destination image, instead of overwriting pixels
## unconditionally.
##
## If pixel_scale is not 1.0, it specifies an amount to scale each \*alpha\*
## value of the source image before applying it to the target image.
##
## If pixel_scale is 1.0 and the copy has no alpha channel, this degenerates
## into copy_sub_image().

proc blendSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int) {.importcpp: "#.blend_sub_image(#, #, #)".} ## \
## Behaves like copy_sub_image(), except the alpha channel of the copy is used
## to blend the copy into the destination image, instead of overwriting pixels
## unconditionally.
##
## If pixel_scale is not 1.0, it specifies an amount to scale each \*alpha\*
## value of the source image before applying it to the target image.
##
## If pixel_scale is 1.0 and the copy has no alpha channel, this degenerates
## into copy_sub_image().

proc addSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int, pixel_scale: float32) {.importcpp: "#.add_sub_image(#, #, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc addSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int) {.importcpp: "#.add_sub_image(#, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc addSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int) {.importcpp: "#.add_sub_image(#, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc addSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int) {.importcpp: "#.add_sub_image(#, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc addSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int) {.importcpp: "#.add_sub_image(#, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc addSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int) {.importcpp: "#.add_sub_image(#, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are added to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc multSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int, pixel_scale: float32) {.importcpp: "#.mult_sub_image(#, #, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc multSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int) {.importcpp: "#.mult_sub_image(#, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc multSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int) {.importcpp: "#.mult_sub_image(#, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc multSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int) {.importcpp: "#.mult_sub_image(#, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc multSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int) {.importcpp: "#.mult_sub_image(#, #, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc multSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int) {.importcpp: "#.mult_sub_image(#, #, #)".} ## \
## Behaves like copy_sub_image(), except the copy pixels are multiplied to the
## pixels of the destination, after scaling by the specified pixel_scale.
## Unlike blend_sub_image(), the alpha channel is not treated specially.

proc darkenSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int, pixel_scale: float32) {.importcpp: "#.darken_sub_image(#, #, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the darker
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.  The scale is
## applied with the center at 1.0: scaling the pixel value smaller brings it
## closer to 1.0.

proc darkenSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int) {.importcpp: "#.darken_sub_image(#, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the darker
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.  The scale is
## applied with the center at 1.0: scaling the pixel value smaller brings it
## closer to 1.0.

proc darkenSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int) {.importcpp: "#.darken_sub_image(#, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the darker
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.  The scale is
## applied with the center at 1.0: scaling the pixel value smaller brings it
## closer to 1.0.

proc darkenSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int) {.importcpp: "#.darken_sub_image(#, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the darker
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.  The scale is
## applied with the center at 1.0: scaling the pixel value smaller brings it
## closer to 1.0.

proc darkenSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int) {.importcpp: "#.darken_sub_image(#, #, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the darker
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.  The scale is
## applied with the center at 1.0: scaling the pixel value smaller brings it
## closer to 1.0.

proc darkenSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int) {.importcpp: "#.darken_sub_image(#, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the darker
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.  The scale is
## applied with the center at 1.0: scaling the pixel value smaller brings it
## closer to 1.0.

proc lightenSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int, pixel_scale: float32) {.importcpp: "#.lighten_sub_image(#, #, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the lighter
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.

proc lightenSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int, y_size: int) {.importcpp: "#.lighten_sub_image(#, #, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the lighter
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.

proc lightenSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int, x_size: int) {.importcpp: "#.lighten_sub_image(#, #, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the lighter
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.

proc lightenSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int, yfrom: int) {.importcpp: "#.lighten_sub_image(#, #, #, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the lighter
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.

proc lightenSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int, xfrom: int) {.importcpp: "#.lighten_sub_image(#, #, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the lighter
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.

proc lightenSubImage*(this: PNMImage, copy: PNMImage, xto: int, yto: int) {.importcpp: "#.lighten_sub_image(#, #, #)".} ## \
## Behaves like copy_sub_image(), but the resulting color will be the lighter
## of the source and destination colors at each pixel (and at each R, G, B, A
## component value).
##
## If pixel_scale is not 1.0, it specifies an amount to scale each pixel value
## of the source image before applying it to the target image.

proc threshold*(this: PNMImage, select_image: PNMImage, channel: int, threshold: float32, lt: PNMImage, ge: PNMImage) {.importcpp: "#.threshold(#, #, #, #, #)".} ## \
## Selectively copies each pixel from either one source or another source,
## depending on the pixel value of the indicated channel of select_image.
##
## For each pixel (x, y):
##
## s = select_image.get_channel(x, y, channel). Set this image's (x, y) to:
##
## lt.get_xel(x, y) if s < threshold, or
##
## ge.get_xel(x, y) if s >= threshold
##
## Any of select_image, lt, or ge may be the same PNMImge object as this
## image, or the same as each other; or they may all be different.  All images
## must be the same size.  As a special case, lt and ge may both be 1x1 images
## instead of the source image size.

proc fillDistanceInside*(this: PNMImage, mask: PNMImage, threshold: float32, radius: int, shrink_from_border: bool) {.importcpp: "#.fill_distance_inside(#, #, #, #)".} ## \
## Replaces this image with a grayscale image whose gray channel represents
## the linear Manhattan distance from the nearest dark pixel in the given mask
## image, up to the specified radius value (which also becomes the new
## maxval).  radius may range from 0 to maxmaxval; smaller values will compute
## faster.  A dark pixel is defined as one whose pixel value is < threshold.
##
## If shrink_from_border is true, then the mask image is considered to be
## surrounded by a border of dark pixels; otherwise, the border isn't
## considered.
##
## This can be used, in conjunction with threshold, to shrink a mask image
## inwards by a certain number of pixels.
##
## The mask image may be the same image as this one, in which case it is
## destructively modified by this process.

proc fillDistanceOutside*(this: PNMImage, mask: PNMImage, threshold: float32, radius: int) {.importcpp: "#.fill_distance_outside(#, #, #)".} ## \
## Replaces this image with a grayscale image whose gray channel represents
## the linear Manhattan distance from the nearest white pixel in the given
## mask image, up to the specified radius value (which also becomes the new
## maxval).  radius may range from 0 to maxmaxval; smaller values will compute
## faster.  A white pixel is defined as one whose pixel value is >= threshold.
##
## This can be used, in conjunction with threshold, to grow a mask image
## outwards by a certain number of pixels.
##
## The mask image may be the same image as this one, in which case it is
## destructively modified by this process.

proc indirect1dLookup*(this: PNMImage, index_image: PNMImage, channel: int, pixel_values: PNMImage) {.importcpp: "#.indirect_1d_lookup(#, #, #)".} ## \
## index_image is a WxH grayscale image, while pixel_values is an Nx1 color
## (or grayscale) image.  Typically pixel_values will be a 256x1 image.
##
## Fills the PNMImage with a new image the same width and height as
## index_image, with the same number of channels as pixel_values.
##
## Each pixel of the new image is computed with the formula:
##
## new_image(x, y) = pixel_values(index_image(x, y)[channel], 0)
##
## At present, no interpolation is performed; the nearest value in
## pixel_values is discovered.  This may change in the future.

proc rescale*(this: PNMImage, min_val: float32, max_val: float32) {.importcpp: "#.rescale(#, #)".} ## \
## Rescales the RGB channel values so that any values in the original image
## between min_val and max_val are expanded to the range 0 .. 1.  Values below
## min_val are set to 0, and values above max_val are set to 1. Does not
## affect the alpha channel, if any.

proc renderSpot*(this: PNMImage, fg: LColorf, bg: LColorf, min_radius: float32, max_radius: float32) {.importcpp: "#.render_spot(#, #, #, #)".} ## \
## Renders a solid-color circle, with a fuzzy edge, into the center of the
## PNMImage.  If the PNMImage is non-square, this actually renders an ellipse.
##
## The min_radius and max_radius are in the scale 0..1, where 1.0 means the
## full width of the image.  If min_radius == max_radius, the edge is sharp
## (but still antialiased); otherwise, the pixels between min_radius and
## max_radius are smoothly blended between fg and bg colors.

proc expandBorder*(this: PNMImage, left: int, right: int, bottom: int, top: int, color: LColorf) {.importcpp: "#.expand_border(#, #, #, #, #)".} ## \
## Expands the image by the indicated number of pixels on each edge.  The new
## pixels are set to the indicated color.
##
## If any of the values is negative, this actually crops the image.

proc boxFilter*(this: PNMImage, radius: float32) {.importcpp: "#.box_filter(#)".} ## \
## This flavor of box_filter() will apply the filter over the entire image
## without resizing or copying; the effect is that of a blur operation.

proc boxFilter*(this: PNMImage) {.importcpp: "#.box_filter()".} ## \
## This flavor of box_filter() will apply the filter over the entire image
## without resizing or copying; the effect is that of a blur operation.

proc gaussianFilter*(this: PNMImage, radius: float32) {.importcpp: "#.gaussian_filter(#)".} ## \
## This flavor of gaussian_filter() will apply the filter over the entire
## image without resizing or copying; the effect is that of a blur operation.

proc gaussianFilter*(this: PNMImage) {.importcpp: "#.gaussian_filter()".} ## \
## This flavor of gaussian_filter() will apply the filter over the entire
## image without resizing or copying; the effect is that of a blur operation.

proc unfilteredStretchFrom*(this: PNMImage, copy: PNMImage) {.importcpp: "#.unfiltered_stretch_from(#)".} ## \
## Resizes from the indicated image into this one by performing a nearest-
## point sample.

proc boxFilterFrom*(this: PNMImage, radius: float32, copy: PNMImage) {.importcpp: "#.box_filter_from(#, #)".} ## \
## Makes a resized copy of the indicated image into this one using the
## indicated filter.  The image to be copied is squashed and stretched to
## match the dimensions of the current image, applying the appropriate filter
## to perform the stretching.

proc gaussianFilterFrom*(this: PNMImage, radius: float32, copy: PNMImage) {.importcpp: "#.gaussian_filter_from(#, #)".} ## \
## Makes a resized copy of the indicated image into this one using the
## indicated filter.  The image to be copied is squashed and stretched to
## match the dimensions of the current image, applying the appropriate filter
## to perform the stretching.

proc quickFilterFrom*(this: PNMImage, copy: PNMImage, xborder: int, yborder: int) {.importcpp: "#.quick_filter_from(#, #, #)".} ## \
## Resizes from the given image, with a fixed radius of 0.5. This is a very
## specialized and simple algorithm that doesn't handle dropping below the
## Nyquist rate very well, but is quite a bit faster than the more general
## box_filter(), above.  If borders are specified, they will further restrict
## the size of the resulting image.  There's no point in using
## quick_box_filter() on a single image.

proc quickFilterFrom*(this: PNMImage, copy: PNMImage, xborder: int) {.importcpp: "#.quick_filter_from(#, #)".} ## \
## Resizes from the given image, with a fixed radius of 0.5. This is a very
## specialized and simple algorithm that doesn't handle dropping below the
## Nyquist rate very well, but is quite a bit faster than the more general
## box_filter(), above.  If borders are specified, they will further restrict
## the size of the resulting image.  There's no point in using
## quick_box_filter() on a single image.

proc quickFilterFrom*(this: PNMImage, copy: PNMImage) {.importcpp: "#.quick_filter_from(#)".} ## \
## Resizes from the given image, with a fixed radius of 0.5. This is a very
## specialized and simple algorithm that doesn't handle dropping below the
## Nyquist rate very well, but is quite a bit faster than the more general
## box_filter(), above.  If borders are specified, they will further restrict
## the size of the resulting image.  There's no point in using
## quick_box_filter() on a single image.

proc quantize*(this: PNMImage, max_colors: clonglong) {.importcpp: "#.quantize(#)".} ## \
## Reduces the number of unique colors in the image to (at most) the given
## count.  Fewer colors than requested may be left in the image after this
## operation, but never more.
##
## At present, this is only supported on images without an alpha channel.
##
## @since 1.10.5

proc perlinNoiseFill*(this: PNMImage, perlin: StackedPerlinNoise2) {.importcpp: "#.perlin_noise_fill(#)".} ## \
## Variant of perlin_noise_fill that uses an existing StackedPerlinNoise2
## object.

proc perlinNoiseFill*(this: PNMImage, sx: float32, sy: float32, table_size: int, seed: int) {.importcpp: "#.perlin_noise_fill(#, #, #, #)".} ## \
## Fills the image with a grayscale perlin noise pattern based on the
## indicated parameters.  Uses set_xel to set the grayscale values.  The sx
## and sy parameters are in multiples of the size of this image.  See also the
## PerlinNoise2 class in mathutil.

proc perlinNoiseFill*(this: PNMImage, sx: float32, sy: float32, table_size: int) {.importcpp: "#.perlin_noise_fill(#, #, #)".} ## \
## Fills the image with a grayscale perlin noise pattern based on the
## indicated parameters.  Uses set_xel to set the grayscale values.  The sx
## and sy parameters are in multiples of the size of this image.  See also the
## PerlinNoise2 class in mathutil.

proc perlinNoiseFill*(this: PNMImage, sx: float32, sy: float32) {.importcpp: "#.perlin_noise_fill(#, #)".} ## \
## Fills the image with a grayscale perlin noise pattern based on the
## indicated parameters.  Uses set_xel to set the grayscale values.  The sx
## and sy parameters are in multiples of the size of this image.  See also the
## PerlinNoise2 class in mathutil.

proc remixChannels*(this: PNMImage, conv: LMatrix4) {.importcpp: "#.remix_channels(#)".} ## \
## Transforms every pixel using the operation (Ro,Go,Bo) =
## conv.xform_point(Ri,Gi,Bi); Input must be a color image.

proc gammaCorrect*(this: PNMImage, from_gamma: float32, to_gamma: float32) {.importcpp: "#.gamma_correct(#, #)".} ## \
## Assuming the image was constructed with a gamma curve of from_gamma in the
## RGB channels, converts it to an image with a gamma curve of to_gamma in the
## RGB channels.  Does not affect the alpha channel.

proc gammaCorrectAlpha*(this: PNMImage, from_gamma: float32, to_gamma: float32) {.importcpp: "#.gamma_correct_alpha(#, #)".} ## \
## Assuming the image was constructed with a gamma curve of from_gamma in the
## alpha channel, converts it to an image with a gamma curve of to_gamma in
## the alpha channel.  Does not affect the RGB channels.

proc applyExponent*(this: PNMImage, gray_exponent: float32) {.importcpp: "#.apply_exponent(#)".} ## \
## Adjusts each channel of the image by raising the corresponding component
## value to the indicated exponent, such that L' = L ^ exponent.

proc applyExponent*(this: PNMImage, gray_exponent: float32, alpha_exponent: float32) {.importcpp: "#.apply_exponent(#, #)".} ## \
## Adjusts each channel of the image by raising the corresponding component
## value to the indicated exponent, such that L' = L ^ exponent.

proc applyExponent*(this: PNMImage, red_exponent: float32, green_exponent: float32, blue_exponent: float32) {.importcpp: "#.apply_exponent(#, #, #)".} ## \
## Adjusts each channel of the image by raising the corresponding component
## value to the indicated exponent, such that L' = L ^ exponent.  For a
## grayscale image, the blue_exponent value is used for the grayscale value,
## and red_exponent and green_exponent are unused.

proc applyExponent*(this: PNMImage, red_exponent: float32, green_exponent: float32, blue_exponent: float32, alpha_exponent: float32) {.importcpp: "#.apply_exponent(#, #, #, #)".} ## \
## Adjusts each channel of the image by raising the corresponding component
## value to the indicated exponent, such that L' = L ^ exponent.  For a
## grayscale image, the blue_exponent value is used for the grayscale value,
## and red_exponent and green_exponent are unused.

proc getAverageXel*(this: PNMImage): LRGBColorf {.importcpp: "#.get_average_xel()".} ## \
## Returns the average color of all of the pixels in the image.

proc getAverageXelA*(this: PNMImage): LColorf {.importcpp: "#.get_average_xel_a()".} ## \
## Returns the average color of all of the pixels in the image, including the
## alpha channel.

proc getAverageGray*(this: PNMImage): float32 {.importcpp: "#.get_average_gray()".} ## \
## Returns the average grayscale component of all of the pixels in the image.

proc doFillDistance*(this: PNMImage, xi: int, yi: int, d: int) {.importcpp: "#.do_fill_distance(#, #, #)".} ## \
## Recursively fills in the minimum distance measured from a certain set of
## points into the gray channel.

proc `~`*(this: PNMImage): PNMImage {.importcpp: "#.operator ~()".}

proc `+`*(this: PNMImage, other: LColorf): PNMImage {.importcpp: "#.operator +(#)".}

proc `+`*(this: PNMImage, other: PNMImage): PNMImage {.importcpp: "#.operator +(#)".}

proc `-`*(this: PNMImage, other: LColorf): PNMImage {.importcpp: "#.operator -(#)".}

proc `-`*(this: PNMImage, other: PNMImage): PNMImage {.importcpp: "#.operator -(#)".}

proc `*`*(this: PNMImage, other: LColorf): PNMImage {.importcpp: "#.operator *(#)".}

proc `*`*(this: PNMImage, other: PNMImage): PNMImage {.importcpp: "#.operator *(#)".}

proc `*`*(this: PNMImage, multiplier: float32): PNMImage {.importcpp: "#.operator *(#)".}

proc `+=`*(this: var PNMImage, other: LColorf): PNMImage {.importcpp: "#.operator +=(#)".}

proc `+=`*(this: var PNMImage, other: PNMImage): PNMImage {.importcpp: "#.operator +=(#)".}

proc `-=`*(this: var PNMImage, other: LColorf): PNMImage {.importcpp: "#.operator -=(#)".}

proc `-=`*(this: var PNMImage, other: PNMImage): PNMImage {.importcpp: "#.operator -=(#)".}

proc `*=`*(this: var PNMImage, other: LColorf): PNMImage {.importcpp: "#.operator *=(#)".}

proc `*=`*(this: var PNMImage, other: PNMImage): PNMImage {.importcpp: "#.operator *=(#)".}

proc `*=`*(this: var PNMImage, multiplier: float32): PNMImage {.importcpp: "#.operator *=(#)".}

proc initPNMPainter*(image: PNMImage, xo: int, yo: int): PNMPainter {.importcpp: "PNMPainter(#, #, #)".} ## \
## The constructor stores a pointer to the PNMImage you pass it, but it does
## not take ownership of the object; you are responsible for ensuring that the
## PNMImage does not destruct during the lifetime of the PNMPainter object.
##
## The xo, yo coordinates specify an optional offset for fill coordinates.  If
## you are painting with a pattern fill, these specify the virtual coordinates
## of the upper-left corner of the image, which can allow you to adjust the
## pattern to line up with nested images, if necessary.

proc initPNMPainter*(image: PNMImage, xo: int): PNMPainter {.importcpp: "PNMPainter(#, #)".} ## \
## The constructor stores a pointer to the PNMImage you pass it, but it does
## not take ownership of the object; you are responsible for ensuring that the
## PNMImage does not destruct during the lifetime of the PNMPainter object.
##
## The xo, yo coordinates specify an optional offset for fill coordinates.  If
## you are painting with a pattern fill, these specify the virtual coordinates
## of the upper-left corner of the image, which can allow you to adjust the
## pattern to line up with nested images, if necessary.

proc initPNMPainter*(image: PNMImage): PNMPainter {.importcpp: "PNMPainter(#)".} ## \
## The constructor stores a pointer to the PNMImage you pass it, but it does
## not take ownership of the object; you are responsible for ensuring that the
## PNMImage does not destruct during the lifetime of the PNMPainter object.
##
## The xo, yo coordinates specify an optional offset for fill coordinates.  If
## you are painting with a pattern fill, these specify the virtual coordinates
## of the upper-left corner of the image, which can allow you to adjust the
## pattern to line up with nested images, if necessary.

proc initPNMPainter*(param0: PNMPainter): PNMPainter {.importcpp: "PNMPainter(#)".}

proc setPen*(this: PNMPainter, pen: PNMBrush) {.importcpp: "#.set_pen(#)".} ## \
## Specifies a PNMBrush that will be used for drawing lines and edges.  If the
## brush is a bitmap brush, its image will be smeared pixelwise along the
## line.
##
## Unlike the PNMImage passed to the constructor, the PNMPainter will take
## ownership of the pen.  It is not necessary to keep a separate pointer to
## it.

proc getPen*(this: PNMPainter): PNMBrush {.importcpp: "#.get_pen()".} ## \
## Returns the current pen.  See set_pen().

proc setFill*(this: PNMPainter, fill: PNMBrush) {.importcpp: "#.set_fill(#)".} ## \
## Specifies a PNMBrush that will be used for filling in the interiors of
## objects.  If the brush is a bitmap brush, its image will be tiled
## throughout the space.
##
## Unlike the PNMImage passed to the constructor, the PNMPainter will take
## ownership of the fill brush.  It is not necessary to keep a separate
## pointer to it.

proc getFill*(this: PNMPainter): PNMBrush {.importcpp: "#.get_fill()".} ## \
## Returns the current fill brush.  See set_fill().

proc drawPoint*(this: PNMPainter, x: float32, y: float32) {.importcpp: "#.draw_point(#, #)".} ## \
## Draws an antialiased point on the PNMImage, using the current pen.

proc drawLine*(this: PNMPainter, xa: float32, ya: float32, xb: float32, yb: float32) {.importcpp: "#.draw_line(#, #, #, #)".} ## \
## Draws an antialiased line on the PNMImage, using the current pen.

proc drawRectangle*(this: PNMPainter, xa: float32, ya: float32, xb: float32, yb: float32) {.importcpp: "#.draw_rectangle(#, #, #, #)".} ## \
## Draws a filled rectangule on the PNMImage, using the current pen for the
## outline, and the current fill brush for the interior.
##
## The two coordinates specify any two diagonally opposite corners.

proc getCharacter*(this: TextGlyph): int {.importcpp: "#->get_character()".} ## \
## Returns the Unicode value that corresponds to the character this glyph
## represents.

proc hasQuad*(this: TextGlyph): bool {.importcpp: "#->has_quad()".} ## \
## Returns true if this glyph contains the definition for a simple quad,
## rather than a more complex piece of geometry.
##
## You may still call get_geom() even if this returns true, which will
## synthesize a Geom for this quad.

proc getQuad*(this: TextGlyph, dimensions: LVecBase4, texcoords: LVecBase4): bool {.importcpp: "#->get_quad(#, #)".} ## \
## Assuming that this glyph is representable as a textured quad, returns its
## dimensions and UV range.  Returns false if it is not representable as a
## quad, or if it is whitespace.
##
## The order of the components is left, bottom, right, top.

proc getState*(this: TextGlyph): RenderState {.importcpp: "deconstify(#->get_state())", header: deconstifyCode.} ## \
## Returns the state in which the glyph should be rendered.

proc getAdvance*(this: TextGlyph): float32 {.importcpp: "#->get_advance()".} ## \
## Returns the distance by which the character pointer should be advanced
## after placing this character; i.e.  the approximate width the character
## takes up on the line.

proc isWhitespace*(this: TextGlyph): bool {.importcpp: "#->is_whitespace()".} ## \
## Returns true if this glyph represents invisible whitespace, or false if it
## corresponds to some visible character.

converter getClassType*(_: typedesc[TextGlyph]): TypeHandle {.importcpp: "TextGlyph::get_class_type()", header: "textGlyph.h".}

converter upcastToTypedReferenceCount*(this: TextFont): TypedReferenceCount {.importcpp: "(PT(TypedReferenceCount)(#))".}

converter upcastToNamable*(this: TextFont): Namable {.importcpp: "((Namable *)(TextFont *)(#))".}

proc makeCopy*(this: TextFont): TextFont {.importcpp: "#->make_copy()".}

proc isValid*(this: TextFont): bool {.importcpp: "#->is_valid()".} ## \
## Returns true if the font is valid and ready to use, false otherwise.

proc `typecast bool`*(this: TextFont): bool {.importcpp: "#->operator typecast bool()".}

proc getLineHeight*(this: TextFont): float32 {.importcpp: "#->get_line_height()".} ## \
## Returns the number of units high each line of text is.

proc setLineHeight*(this: TextFont, line_height: float32) {.importcpp: "#->set_line_height(#)".} ## \
## Changes the number of units high each line of text is.

proc getSpaceAdvance*(this: TextFont): float32 {.importcpp: "#->get_space_advance()".} ## \
## Returns the number of units wide a space is.

proc setSpaceAdvance*(this: TextFont, space_advance: float32) {.importcpp: "#->set_space_advance(#)".} ## \
## Changes the number of units wide a space is.

proc getGlyph*(this: TextFont, character: int): TextGlyph {.importcpp: "deconstify(#->get_glyph(#))", header: deconstifyCode.} ## \
## Gets the glyph associated with the given character code, as well as an
## optional scaling parameter that should be applied to the glyph's geometry
## and advance parameters.  Returns the glyph on success.  On failure, it may
## still return a printable glyph, or it may return NULL.

proc getKerning*(this: TextFont, first: int, second: int): float32 {.importcpp: "#->get_kerning(#, #)".} ## \
## Returns the amount by which to offset the second glyph when it directly
## follows the first glyph.  This is an additional offset that is added on top
## of the advance.

proc write*(this: TextFont, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

converter getClassType*(_: typedesc[TextFont]): TypeHandle {.importcpp: "TextFont::get_class_type()", header: "textFont.h".}

proc getPage*(this: DynamicTextGlyph): DynamicTextPage {.importcpp: "#->get_page()".} ## \
## Returns the DynamicTextPage that this glyph is on.

proc getSize*(this: DynamicTextPage): LVecBase2i {.importcpp: "#->get_size()".} ## \
## Returns the size of the page (texture), in pixels.

proc getXSize*(this: DynamicTextPage): int {.importcpp: "#->get_x_size()".} ## \
## Returns the x size of the page (texture), in pixels.

proc getYSize*(this: DynamicTextPage): int {.importcpp: "#->get_y_size()".} ## \
## Returns the y size of the page (texture), in pixels.

proc isEmpty*(this: DynamicTextPage): bool {.importcpp: "#->is_empty()".} ## \
## Returns true if the page has no glyphs, false otherwise.

converter getClassType*(_: typedesc[DynamicTextPage]): TypeHandle {.importcpp: "DynamicTextPage::get_class_type()", header: "dynamicTextPage.h".}

proc newDynamicTextPage*(param0: DynamicTextPage): DynamicTextPage {.importcpp: "new DynamicTextPage(#)".}

proc intersects*(this: DynamicTextGlyph, x: int, y: int, x_size: int, y_size: int): bool {.importcpp: "#->intersects(#, #, #, #)".} ## \
## Returns true if the particular position this glyph has been assigned to
## overlaps the rectangle whose top left corner is at x, y and whose size is
## given by x_size, y_size, or false otherwise.

proc getLeft*(this: DynamicTextGlyph): float32 {.importcpp: "#->get_left()".} ## \
## Returns the vertex coordinates that can be used when creating a custom text
## renderer.

proc getBottom*(this: DynamicTextGlyph): float32 {.importcpp: "#->get_bottom()".} ## \
## Returns the vertex coordinates that can be used when creating a custom text
## renderer.

proc getRight*(this: DynamicTextGlyph): float32 {.importcpp: "#->get_right()".} ## \
## Returns the vertex coordinates that can be used when creating a custom text
## renderer.

proc getTop*(this: DynamicTextGlyph): float32 {.importcpp: "#->get_top()".} ## \
## Returns the vertex coordinates that can be used when creating a custom text
## renderer.

proc getUvLeft*(this: DynamicTextGlyph): float32 {.importcpp: "#->get_uv_left()".} ## \
## Returns the UV coordinates that can be used when creating a custom text
## renderer.

proc getUvBottom*(this: DynamicTextGlyph): float32 {.importcpp: "#->get_uv_bottom()".} ## \
## Returns the UV coordinates that can be used when creating a custom text
## renderer.

proc getUvRight*(this: DynamicTextGlyph): float32 {.importcpp: "#->get_uv_right()".} ## \
## Returns the UV coordinates that can be used when creating a custom text
## renderer.

proc getUvTop*(this: DynamicTextGlyph): float32 {.importcpp: "#->get_uv_top()".} ## \
## Returns the UV coordinates that can be used when creating a custom text
## renderer.

converter getClassType*(_: typedesc[DynamicTextGlyph]): TypeHandle {.importcpp: "DynamicTextGlyph::get_class_type()", header: "dynamicTextGlyph.h".}

converter upcastToTextFont*(this: DynamicTextFont): TextFont {.importcpp: "(PT(TextFont)(#))".}

converter upcastToFreetypeFont*(this: DynamicTextFont): FreetypeFont {.importcpp: "((FreetypeFont *)(DynamicTextFont *)(#))".}

proc newDynamicTextFont*(copy: DynamicTextFont): DynamicTextFont {.importcpp: "new DynamicTextFont(#)".}

proc newDynamicTextFont*(font_filename: Filename, face_index: int): DynamicTextFont {.importcpp: "new DynamicTextFont(#, #)".} ## \
## The constructor expects the name of some font file that FreeType can read,
## along with face_index, indicating which font within the file to load
## (usually 0).

proc newDynamicTextFont*(font_filename: Filename): DynamicTextFont {.importcpp: "new DynamicTextFont(#)".} ## \
## The constructor expects the name of some font file that FreeType can read,
## along with face_index, indicating which font within the file to load
## (usually 0).

proc newDynamicTextFont*(font_data: string, data_length: int, face_index: int): DynamicTextFont {.importcpp: "new DynamicTextFont(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## This constructor accepts a table of data representing the font file, loaded
## from some source other than a filename on disk.

proc makeCopy*(this: DynamicTextFont): TextFont {.importcpp: "#->make_copy()".} ## \
## Returns a new copy of the same font.

proc getName*(this: DynamicTextFont): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## Disambiguates the get_name() method between that inherited from TextFont
## and that inherited from FreetypeFont.

proc setPointSize*(this: DynamicTextFont, point_size: float32): bool {.importcpp: "#->set_point_size(#)".} ## \
## Sets the point size of the font.  This controls the apparent size of the
## font onscreen.  By convention, a 10 point font is about 1 screen unit high.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

proc getPointSize*(this: DynamicTextFont): float32 {.importcpp: "#->get_point_size()".} ## \
## Returns the point size of the font.

proc setPixelsPerUnit*(this: DynamicTextFont, pixels_per_unit: float32): bool {.importcpp: "#->set_pixels_per_unit(#)".} ## \
## Set the resolution of the texture map, and hence the clarity of the
## resulting font.  This sets the number of pixels in the texture map that are
## used for each onscreen unit.
##
## Setting this number larger results in an easier to read font, but at the
## cost of more texture memory.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

proc getPixelsPerUnit*(this: DynamicTextFont): float32 {.importcpp: "#->get_pixels_per_unit()".} ## \
## Returns the resolution of the texture map.  See set_pixels_per_unit().

proc setScaleFactor*(this: DynamicTextFont, scale_factor: float32): bool {.importcpp: "#->set_scale_factor(#)".} ## \
## Sets the factor by which the font is rendered larger by the FreeType
## library before being filtered down to its actual size in the texture as
## specified by set_pixels_per_unit().  This may be set to a number larger
## than 1.0 to improve the font's antialiasing (since FreeType doesn't really
## do a swell job of antialiasing by itself).  There is some performance
## implication for setting this different than 1.0, but it is probably small.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

proc getScaleFactor*(this: DynamicTextFont): float32 {.importcpp: "#->get_scale_factor()".} ## \
## Returns the antialiasing scale factor.  See set_scale_factor().

proc setNativeAntialias*(this: DynamicTextFont, native_antialias: bool) {.importcpp: "#->set_native_antialias(#)".} ## \
## Sets whether the Freetype library's built-in antialias mode is enabled.
## There are two unrelated ways to achieve antialiasing: with Freetype's
## native antialias mode, and with the use of a scale_factor greater than one.
## By default, both modes are enabled.
##
## At low resolutions, some fonts may do better with one mode or the other.
## In general, Freetype's native antialiasing will produce less blurry
## results, but may introduce more artifacts.

proc getNativeAntialias*(this: DynamicTextFont): bool {.importcpp: "#->get_native_antialias()".} ## \
## Returns whether Freetype's built-in antialias mode is enabled.  See
## set_native_antialias().

proc getFontPixelSize*(this: DynamicTextFont): int {.importcpp: "#->get_font_pixel_size()".} ## \
## This is used to report whether the requested pixel size is being only
## approximated by a fixed-pixel-size font.  This returns 0 in the normal
## case, in which a scalable font is used, or the fixed-pixel-size font has
## exactly the requested pixel size.
##
## If this returns non-zero, it is the pixel size of the font that we are
## using to approximate our desired size.

proc getLineHeight*(this: DynamicTextFont): float32 {.importcpp: "#->get_line_height()".} ## \
## Returns the number of units high each line of text is.

proc getSpaceAdvance*(this: DynamicTextFont): float32 {.importcpp: "#->get_space_advance()".} ## \
## Returns the number of units wide a space is.

proc setTextureMargin*(this: DynamicTextFont, texture_margin: int) {.importcpp: "#->set_texture_margin(#)".} ## \
## Sets the number of pixels of padding that is added around the border of
## each glyph before adding it to the texture map.  This reduces the bleed in
## from neighboring glyphs in the texture map.

proc getTextureMargin*(this: DynamicTextFont): int {.importcpp: "#->get_texture_margin()".} ## \
## Returns the number of pixels of padding that is added around the border of
## each glyph in the texture map.  See set_texture_margin().

proc setPolyMargin*(this: DynamicTextFont, poly_margin: float32) {.importcpp: "#->set_poly_margin(#)".} ## \
## Sets the number of pixels of padding that is included around each glyph in
## the generated polygons.  This helps prevent the edges of the glyphs from
## being cut off at small minifications.  It is not related to the amount of
## extra pixels reserved in the texture map (but it should be set somewhat
## smaller than this number, which is controlled by set_texture_margin(), to
## prevent bleed-in from neighboring letters in the texture).

proc getPolyMargin*(this: DynamicTextFont): float32 {.importcpp: "#->get_poly_margin()".} ## \
## Returns the number of pixels of padding that is included around each glyph
## in the generated polygons.  See set_poly_margin().

proc setPageSize*(this: DynamicTextFont, page_size: LVecBase2i) {.importcpp: "#->set_page_size(#)".} ## \
## Sets the x, y size of the textures that are created for the
## DynamicTextFont.

proc setPageSize*(this: DynamicTextFont, x_size: int, y_size: int) {.importcpp: "#->set_page_size(#, #)".} ## \
## Sets the x, y size of the textures that are created for the
## DynamicTextFont.

proc getPageSize*(this: DynamicTextFont): LVecBase2i {.importcpp: "#->get_page_size()".} ## \
## Returns the size of the textures that are created for the DynamicTextFont.
## See set_page_size().

proc getPageXSize*(this: DynamicTextFont): int {.importcpp: "#->get_page_x_size()".} ## \
## Returns the x size of the textures that are created for the
## DynamicTextFont.  See set_page_size().

proc getPageYSize*(this: DynamicTextFont): int {.importcpp: "#->get_page_y_size()".} ## \
## Returns the y size of the textures that are created for the
## DynamicTextFont.  See set_page_size().

proc setAnisotropicDegree*(this: DynamicTextFont, anisotropic_degree: int) {.importcpp: "#->set_anisotropic_degree(#)".} ## \
## Enables or disables anisotropic filtering on the textures created for this
## font.  The default value is specified by the text-anisotropic-degree
## variable.  See Texture::set_anisotropic_degree().

proc getAnisotropicDegree*(this: DynamicTextFont): int {.importcpp: "#->get_anisotropic_degree()".} ## \
## Returns the current anisotropic degree for textures created for this font.
## See set_anisotropic_degree().

proc setFg*(this: DynamicTextFont, fg: LColor) {.importcpp: "#->set_fg(#)".} ## \
## Changes the color of the foreground pixels of the font as they are rendered
## into the font texture.  The default is (1, 1, 1, 1), or opaque white, which
## allows text created with the font to be colored individually.  Normally,
## you would not change this unless you really need a particular color effect
## to appear in the font itself.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

proc getFg*(this: DynamicTextFont): LColor {.importcpp: "#->get_fg()".} ## \
## Returns the color of the foreground pixels of the font as they are rendered
## into the font texture.  See set_fg().

proc setBg*(this: DynamicTextFont, bg: LColor) {.importcpp: "#->set_bg(#)".} ## \
## Changes the color of the background pixels of the font as they are rendered
## into the font texture.  The default is (1, 1, 1, 0), or transparent white,
## which allows text created with the font to be colored individually.  (Note
## that it should not generally be (0, 0, 0, 0), which would tend to bleed
## into the foreground color, unless you have also specified a outline color
## of (0, 0, 0, 1)) .
##
## Normally, you would not change this unless you really need a particular
## color effect to appear in the font itself.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

proc getBg*(this: DynamicTextFont): LColor {.importcpp: "#->get_bg()".} ## \
## Returns the color of the background pixels of the font as they are rendered
## into the font texture.  See set_bg().

proc setOutline*(this: DynamicTextFont, outline_color: LColor, outline_width: float32, outline_feather: float32) {.importcpp: "#->set_outline(#, #, #)".} ## \
## Sets up the font to have an outline around each font letter.  This is
## achieved via a Gaussian post-process as each letter is generated; there is
## some runtime cost for this effect, but it is minimal as each letter is
## normally generated only once and then cached.
##
## The color is the desired color of the outline, width is the number of
## points beyond the letter that the outline extends (a typical font is 10
## points high), and feather is a number in the range 0.0 .. 1.0 that controls
## the softness of the outline.  Set the width to 0.0 to disable the outline.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

proc getOutlineColor*(this: DynamicTextFont): LColor {.importcpp: "#->get_outline_color()".} ## \
## Returns the color of the outline pixels of the font as they are rendered
## into the font texture.  See set_outline().

proc getOutlineWidth*(this: DynamicTextFont): float32 {.importcpp: "#->get_outline_width()".} ## \
## Returns the width of the outline pixels of the font, as the number of
## points beyond each letter.  See set_outline().

proc getOutlineFeather*(this: DynamicTextFont): float32 {.importcpp: "#->get_outline_feather()".} ## \
## Returns the softness of the outline pixels of the font, as a value in the
## range 0.0 to 1.0. See set_outline().

proc getNumPages*(this: DynamicTextFont): int {.importcpp: "#->get_num_pages()".} ## \
## Returns the number of pages associated with the font.  Initially, the font
## has zero pages; when the first piece of text is rendered with the font, it
## will add additional pages as needed.  Each page is a Texture object that
## contains the images for each of the glyphs currently in use somewhere.

proc getPage*(this: DynamicTextFont, n: int): DynamicTextPage {.importcpp: "#->get_page(#)".} ## \
## Returns the nth page associated with the font.  Initially, the font has
## zero pages; when the first piece of text is rendered with the font, it will
## add additional pages as needed.  Each page is a Texture object that
## contains the images for each of the glyphs currently in use somewhere.

proc garbageCollect*(this: DynamicTextFont): int {.importcpp: "#->garbage_collect()".} ## \
## Removes all of the glyphs from the font that are no longer being used by
## any Geoms.  Returns the number of glyphs removed.

proc clear*(this: DynamicTextFont) {.importcpp: "#->clear()".} ## \
## Drops all the glyphs out of the cache and frees any association with any
## previously-generated pages.
##
## Calling this frequently can result in wasted texture memory, as any
## previously rendered text will still keep a pointer to the old, previously-
## generated pages.  As long as the previously rendered text remains around,
## the old pages will also remain around.

proc write*(this: DynamicTextFont, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

converter getClassType*(_: typedesc[DynamicTextFont]): TypeHandle {.importcpp: "DynamicTextFont::get_class_type()", header: "dynamicTextFont.h".}

proc hasFont*(_: typedesc[FontPool], filename: string): bool {.importcpp: "#FontPool::has_font(nimStringToStdString(#))", header: "fontPool.h".} ## \
## Returns true if the font has ever been loaded, false otherwise.

proc verifyFont*(_: typedesc[FontPool], filename: string): bool {.importcpp: "#FontPool::verify_font(nimStringToStdString(#))", header: "fontPool.h".} ## \
## Loads the given filename up into a font, if it has not already been loaded,
## and returns true to indicate success, or false to indicate failure.  If
## this returns true, it is guaranteed that a subsequent call to load_font()
## with the same font name will return a valid Font pointer.

proc loadFont*(_: typedesc[FontPool], filename: string): TextFont {.importcpp: "#FontPool::load_font(nimStringToStdString(#))", header: "fontPool.h".} ## \
## Loads the given filename up into a font, if it has not already been loaded,
## and returns the new font.  If a font with the same filename was previously
## loaded, returns that one instead.  If the font file cannot be found,
## returns NULL.

proc addFont*(_: typedesc[FontPool], filename: string, font: TextFont) {.importcpp: "#FontPool::add_font(nimStringToStdString(#), #)", header: "fontPool.h".} ## \
## Adds the indicated already-loaded font to the pool.  The font will always
## replace any previously-loaded font in the pool that had the same filename.

proc releaseFont*(_: typedesc[FontPool], filename: string) {.importcpp: "#FontPool::release_font(nimStringToStdString(#))", header: "fontPool.h".} ## \
## Removes the indicated font from the pool, indicating it will never be
## loaded again; the font may then be freed.  If this function is never
## called, a reference count will be maintained on every font every loaded,
## and fonts will never be freed.

proc releaseAllFonts*(_: typedesc[FontPool]) {.importcpp: "FontPool::release_all_fonts()", header: "fontPool.h".} ## \
## Releases all fonts in the pool and restores the pool to the empty state.

proc garbageCollect*(_: typedesc[FontPool]): int {.importcpp: "FontPool::garbage_collect()", header: "fontPool.h".} ## \
## Releases only those fonts in the pool that have a reference count of
## exactly 1; i.e.  only those fonts that are not being used outside of the
## pool.  Returns the number of fonts released.

proc listContents*(_: typedesc[FontPool], `out`: ostream) {.importcpp: "#FontPool::list_contents(#)", header: "fontPool.h".} ## \
## Lists the contents of the font pool to the indicated output stream.

proc write*(_: typedesc[FontPool], `out`: ostream) {.importcpp: "#FontPool::write(#)", header: "fontPool.h".} ## \
## Lists the contents of the font pool to the indicated output stream.

converter getClassType*(_: typedesc[GeomTextGlyph]): TypeHandle {.importcpp: "GeomTextGlyph::get_class_type()", header: "geomTextGlyph.h".}

proc newStaticTextFont*(font_def: PandaNode, cs: CoordinateSystem): StaticTextFont {.importcpp: "new StaticTextFont(#, #)".} ## \
## The constructor expects the root node to a model generated via egg-mkfont,
## which consists of a set of models, one per each character in the font.
##
## If a CoordinateSystem value is specified, it informs the font of the
## coordinate system in which this model was generated.  "up" in this
## coordinate system will be the direction of the top of the letters.

proc newStaticTextFont*(font_def: PandaNode): StaticTextFont {.importcpp: "new StaticTextFont(#)".} ## \
## The constructor expects the root node to a model generated via egg-mkfont,
## which consists of a set of models, one per each character in the font.
##
## If a CoordinateSystem value is specified, it informs the font of the
## coordinate system in which this model was generated.  "up" in this
## coordinate system will be the direction of the top of the letters.

converter getClassType*(_: typedesc[StaticTextFont]): TypeHandle {.importcpp: "StaticTextFont::get_class_type()", header: "staticTextFont.h".}

proc initTextProperties*(): TextProperties {.importcpp: "TextProperties()".}

proc initTextProperties*(copy: TextProperties): TextProperties {.importcpp: "TextProperties(#)".}

proc `==`*(this: TextProperties, other: TextProperties): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: TextProperties, other: TextProperties): bool {.importcpp: "#.operator !=(#)".}

proc clear*(this: TextProperties) {.importcpp: "#.clear()".} ## \
## Unsets all properties that have been specified so far, and resets the
## TextProperties structure to its initial empty state.

proc isAnySpecified*(this: TextProperties): bool {.importcpp: "#.is_any_specified()".} ## \
## Returns true if any properties have been specified, false otherwise.

proc setDefaultFont*(_: typedesc[TextProperties], param0: TextFont) {.importcpp: "#TextProperties::set_default_font(#)", header: "textProperties.h".} ## \
## Specifies the default font to be used for any TextNode whose font is
## uninitialized or NULL.  See set_font().

proc getDefaultFont*(_: typedesc[TextProperties]): TextFont {.importcpp: "TextProperties::get_default_font()", header: "textProperties.h".} ## \
## Specifies the default font to be used for any TextNode whose font is
## uninitialized or NULL.  See set_font().

proc setFont*(this: TextProperties, font: TextFont) {.importcpp: "#.set_font(#)".} ## \
## Sets the font that will be used when making text.  If this is set to NULL,
## the default font will be used, which can be set via set_default_font().

proc clearFont*(this: TextProperties) {.importcpp: "#.clear_font()".} ## \
## Restores the default font to the text.

proc hasFont*(this: TextProperties): bool {.importcpp: "#.has_font()".}

proc getFont*(this: TextProperties): TextFont {.importcpp: "#.get_font()".} ## \
## Returns the font currently in use, if any.  If no font is in use, this
## returns the default font.

proc setSmallCaps*(this: TextProperties, small_caps: bool) {.importcpp: "#.set_small_caps(#)".} ## \
## Sets the small_caps flag.  When this is set, lowercase letters are
## generated as scaled-down versions of their uppercase equivalents.  This is
## particularly useful to set for fonts that do not have lowercase letters.
##
## It is also a good idea to set this for a (dynamic) font that has already
## implemented lowercase letters as scaled-down versions of their uppercase
## equivalents, since without this flag the texture memory may needlessly
## duplicate equivalent glyphs for upper and lowercase letters.  Setting this
## flag causes the texture memory to share the mixed-case letters.
##
## The amount by which the lowercase letters are scaled is specified by
## set_small_caps_scale().

proc clearSmallCaps*(this: TextProperties) {.importcpp: "#.clear_small_caps()".}

proc hasSmallCaps*(this: TextProperties): bool {.importcpp: "#.has_small_caps()".}

proc getSmallCaps*(this: TextProperties): bool {.importcpp: "#.get_small_caps()".} ## \
## Returns the small_caps flag.  See set_small_caps().

proc setSmallCapsScale*(this: TextProperties, small_caps_scale: float32) {.importcpp: "#.set_small_caps_scale(#)".} ## \
## Sets the scale factor applied to lowercase letters from their uppercase
## equivalents, when the small_caps flag is in effect.  See set_small_caps().
## Normally, this will be a number less than one.

proc clearSmallCapsScale*(this: TextProperties) {.importcpp: "#.clear_small_caps_scale()".}

proc hasSmallCapsScale*(this: TextProperties): bool {.importcpp: "#.has_small_caps_scale()".}

proc getSmallCapsScale*(this: TextProperties): float32 {.importcpp: "#.get_small_caps_scale()".} ## \
## Returns the scale factor applied to lowercase letters from their uppercase
## equivalents, when the small_caps flag is in effect.  See set_small_caps()
## and set_small_caps_scale().

proc setSlant*(this: TextProperties, slant: float32) {.importcpp: "#.set_slant(#)".} ## \
## Specifies the factor by which the text slants to the right.

proc clearSlant*(this: TextProperties) {.importcpp: "#.clear_slant()".}

proc hasSlant*(this: TextProperties): bool {.importcpp: "#.has_slant()".}

proc getSlant*(this: TextProperties): float32 {.importcpp: "#.get_slant()".} ## \
## Returns the factor by which the text is specified to slant to the right.

proc setUnderscore*(this: TextProperties, underscore: bool) {.importcpp: "#.set_underscore(#)".} ## \
## Sets the underscore flag.  When this is set, the text is underscored with a
## one-pixel line the same color as the text foreground, drawn at the
## baseline.

proc clearUnderscore*(this: TextProperties) {.importcpp: "#.clear_underscore()".}

proc hasUnderscore*(this: TextProperties): bool {.importcpp: "#.has_underscore()".}

proc getUnderscore*(this: TextProperties): bool {.importcpp: "#.get_underscore()".} ## \
## Returns the underscore flag.  See set_underscore().

proc setUnderscoreHeight*(this: TextProperties, underscore_height: float32) {.importcpp: "#.set_underscore_height(#)".} ## \
## Specifies the vertical height of the underscore, relative to the text
## baseline.  This only has meaning if the underscore mode is enabled with
## set_underscore().

proc clearUnderscoreHeight*(this: TextProperties) {.importcpp: "#.clear_underscore_height()".}

proc hasUnderscoreHeight*(this: TextProperties): bool {.importcpp: "#.has_underscore_height()".}

proc getUnderscoreHeight*(this: TextProperties): float32 {.importcpp: "#.get_underscore_height()".} ## \
## Returns the vertical height of the underscore; see set_underscore_height().

proc clearAlign*(this: TextProperties) {.importcpp: "#.clear_align()".} ## \
## Restores the default alignment of the text.

proc hasAlign*(this: TextProperties): bool {.importcpp: "#.has_align()".}

proc setIndent*(this: TextProperties, indent: float32) {.importcpp: "#.set_indent(#)".} ## \
## Specifies the amount of extra space that is inserted before the first
## character of each line.  This can be thought of as a left margin.

proc clearIndent*(this: TextProperties) {.importcpp: "#.clear_indent()".} ## \
## Removes the indent setting from the text.  Text will be as wide as it is.

proc hasIndent*(this: TextProperties): bool {.importcpp: "#.has_indent()".}

proc getIndent*(this: TextProperties): float32 {.importcpp: "#.get_indent()".}

proc setWordwrap*(this: TextProperties, wordwrap: float32) {.importcpp: "#.set_wordwrap(#)".} ## \
## Sets the text up to automatically wordwrap when it exceeds the indicated
## width.  This can be thought of as a right margin or margin width.

proc clearWordwrap*(this: TextProperties) {.importcpp: "#.clear_wordwrap()".} ## \
## Removes the wordwrap setting from the text.  Text will be as wide as it is.

proc hasWordwrap*(this: TextProperties): bool {.importcpp: "#.has_wordwrap()".}

proc getWordwrap*(this: TextProperties): float32 {.importcpp: "#.get_wordwrap()".}

proc setPreserveTrailingWhitespace*(this: TextProperties, preserve_trailing_whitespace: bool) {.importcpp: "#.set_preserve_trailing_whitespace(#)".} ## \
## Sets the preserve_trailing_whitespace flag.  When this is set, trailing
## whitespace at the end of the line is not stripped when the text is
## wordwrapped (it is stripped by default).  Since the trailing whitespace is
## invisible, this is important primarily for determining the proper width of
## a frame or card behind the text.

proc clearPreserveTrailingWhitespace*(this: TextProperties) {.importcpp: "#.clear_preserve_trailing_whitespace()".}

proc hasPreserveTrailingWhitespace*(this: TextProperties): bool {.importcpp: "#.has_preserve_trailing_whitespace()".}

proc getPreserveTrailingWhitespace*(this: TextProperties): bool {.importcpp: "#.get_preserve_trailing_whitespace()".} ## \
## Returns the preserve_trailing_whitespace flag.  See
## set_preserve_trailing_whitespace().

proc setTextColor*(this: TextProperties, text_color: LColor) {.importcpp: "#.set_text_color(#)".}

proc setTextColor*(this: TextProperties, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_text_color(#, #, #, #)".}

proc clearTextColor*(this: TextProperties) {.importcpp: "#.clear_text_color()".} ## \
## Removes the text color specification; the text will be colored whatever it
## was in the source font file.

proc hasTextColor*(this: TextProperties): bool {.importcpp: "#.has_text_color()".}

proc getTextColor*(this: TextProperties): LColor {.importcpp: "#.get_text_color()".}

proc setShadowColor*(this: TextProperties, shadow_color: LColor) {.importcpp: "#.set_shadow_color(#)".}

proc setShadowColor*(this: TextProperties, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_shadow_color(#, #, #, #)".}

proc clearShadowColor*(this: TextProperties) {.importcpp: "#.clear_shadow_color()".} ## \
## Removes the shadow color specification.

proc hasShadowColor*(this: TextProperties): bool {.importcpp: "#.has_shadow_color()".}

proc getShadowColor*(this: TextProperties): LColor {.importcpp: "#.get_shadow_color()".}

proc setShadow*(this: TextProperties, shadow_offset: LVecBase2) {.importcpp: "#.set_shadow(#)".} ## \
## Specifies that the text should be drawn with a shadow, by creating a second
## copy of the text and offsetting it slightly behind the first.

proc setShadow*(this: TextProperties, xoffset: float32, yoffset: float32) {.importcpp: "#.set_shadow(#, #)".} ## \
## Specifies that the text should be drawn with a shadow, by creating a second
## copy of the text and offsetting it slightly behind the first.

proc clearShadow*(this: TextProperties) {.importcpp: "#.clear_shadow()".} ## \
## Specifies that a shadow will not be drawn behind the text.

proc hasShadow*(this: TextProperties): bool {.importcpp: "#.has_shadow()".}

proc getShadow*(this: TextProperties): LVector2 {.importcpp: "#.get_shadow()".} ## \
## Returns the offset of the shadow as set by set_shadow().  It is an error to
## call this if has_shadow() is false.

proc setBin*(this: TextProperties, bin: string) {.importcpp: "#.set_bin(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Names the CullBin that the text geometry should be assigned to.  If this is
## set, then a CullBinAttrib will be created to explicitly place each
## component in the named bin.
##
## The draw_order value will also be passed to each CullBinAttrib as
## appropriate; this is particularly useful if this names a CullBinFixed, e.g.
## "fixed".

proc clearBin*(this: TextProperties) {.importcpp: "#.clear_bin()".} ## \
## Removes the effect of a previous call to set_bin().  Text will be drawn in
## whatever bin it would like to be drawn in, with no explicit ordering.

proc hasBin*(this: TextProperties): bool {.importcpp: "#.has_bin()".} ## \
## Returns true if an explicit drawing bin has been set via set_bin(), false
## otherwise.

proc getBin*(this: TextProperties): string {.importcpp: "nimStringFromStdString(#.get_bin())", header: stringConversionCode.} ## \
## Returns the drawing bin set with set_bin(), or empty string if no bin has
## been set.

proc setDrawOrder*(this: TextProperties, draw_order: int): int {.importcpp: "#.set_draw_order(#)".} ## \
## Sets the drawing order of text created by the TextNode.  This is actually
## the draw order of the card and frame.  The shadow is drawn at
## _draw_order+1, and the text at _draw_order+2.
##
## This affects the sorting order assigned to the nodes as they are created,
## and also is passed to whatever bin may be assigned via set_bin().
##
## The return value is the first unused draw_order number, e.g.  _draw_order +
## 3.

proc clearDrawOrder*(this: TextProperties) {.importcpp: "#.clear_draw_order()".}

proc hasDrawOrder*(this: TextProperties): bool {.importcpp: "#.has_draw_order()".}

proc getDrawOrder*(this: TextProperties): int {.importcpp: "#.get_draw_order()".} ## \
## Returns the drawing order set with set_draw_order().

proc setTabWidth*(this: TextProperties, tab_width: float32) {.importcpp: "#.set_tab_width(#)".} ## \
## Sets the width of each tab stop, in screen units.  A tab character embedded
## in the text will advance the horizontal position to the next tab stop.

proc clearTabWidth*(this: TextProperties) {.importcpp: "#.clear_tab_width()".}

proc hasTabWidth*(this: TextProperties): bool {.importcpp: "#.has_tab_width()".}

proc getTabWidth*(this: TextProperties): float32 {.importcpp: "#.get_tab_width()".} ## \
## Returns the width set via set_tab_width().

proc setGlyphScale*(this: TextProperties, glyph_scale: float32) {.importcpp: "#.set_glyph_scale(#)".} ## \
## Specifies the factor by which to scale each letter of the text as it is
## placed, in addition to any scales inherited from the node or from
## set_text_scale(). This can be used (possibly in conjunction with
## set_glyph_shift()) to implement superscripting or subscripting.
##
## The glyph scale is cumulative when applied to nested TextProperties.  It is
## intended primarily for implementing superscripts, not for scaling the text
## in general.  See also set_text_scale(), which is intended primarily for
## scaling the text in general, and is not cumulative.

proc clearGlyphScale*(this: TextProperties) {.importcpp: "#.clear_glyph_scale()".}

proc hasGlyphScale*(this: TextProperties): bool {.importcpp: "#.has_glyph_scale()".}

proc getGlyphScale*(this: TextProperties): float32 {.importcpp: "#.get_glyph_scale()".} ## \
## Returns the scale factor of each letter as specified by set_glyph_scale().

proc setGlyphShift*(this: TextProperties, glyph_shift: float32) {.importcpp: "#.set_glyph_shift(#)".} ## \
## Specifies a vertical amount to shift each letter of the text as it is
## placed.  This can be used (possibly in conjunction with set_glyph_scale())
## to implement superscripting or subscripting.

proc clearGlyphShift*(this: TextProperties) {.importcpp: "#.clear_glyph_shift()".}

proc hasGlyphShift*(this: TextProperties): bool {.importcpp: "#.has_glyph_shift()".}

proc getGlyphShift*(this: TextProperties): float32 {.importcpp: "#.get_glyph_shift()".} ## \
## Returns the vertical shift of each letter as specified by
## set_glyph_shift().

proc setTextScale*(this: TextProperties, text_scale: float32) {.importcpp: "#.set_text_scale(#)".} ## \
## Specifies the factor by which to scale the text, in addition to any
## scalings imposed by the node, as well as in addition to the glyph scale.
##
## The text scale is not cumulative when applied to nested TextProperties.
## See also set_glyph_scale(), which is cumulative.

proc clearTextScale*(this: TextProperties) {.importcpp: "#.clear_text_scale()".}

proc hasTextScale*(this: TextProperties): bool {.importcpp: "#.has_text_scale()".}

proc getTextScale*(this: TextProperties): float32 {.importcpp: "#.get_text_scale()".} ## \
## Returns the scale factor of the text as specified by set_text_scale().

proc clearDirection*(this: TextProperties) {.importcpp: "#.clear_direction()".} ## \
## Clears the text direction setting.  If no text direction is specified, it
## will be guessed based on the contents of the string.
##
## @since 1.10.0

proc hasDirection*(this: TextProperties): bool {.importcpp: "#.has_direction()".} ## \
## @since 1.10.0

proc addProperties*(this: TextProperties, other: TextProperties) {.importcpp: "#.add_properties(#)".} ## \
## Sets any properties that are explicitly specified in other on this object.
## Leaves other properties unchanged.

proc write*(this: TextProperties, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: TextProperties, `out`: ostream) {.importcpp: "#.write(#)".}

converter getClassType*(_: typedesc[TextProperties]): TypeHandle {.importcpp: "TextProperties::get_class_type()", header: "textProperties.h".}

proc initTextGraphic*(): TextGraphic {.importcpp: "TextGraphic()".}

proc initTextGraphic*(model: NodePath, frame: LVecBase4): TextGraphic {.importcpp: "TextGraphic(#, #)".}

proc initTextGraphic*(model: NodePath, left: float32, right: float32, bottom: float32, top: float32): TextGraphic {.importcpp: "TextGraphic(#, #, #, #, #)".}

proc initTextGraphic*(param0: TextGraphic): TextGraphic {.importcpp: "TextGraphic(#)".}

proc getModel*(this: TextGraphic): NodePath {.importcpp: "#.get_model()".} ## \
## Returns the NodePath associated with the graphic, that renders the desired
## image.

proc setModel*(this: TextGraphic, model: NodePath) {.importcpp: "#.set_model(#)".} ## \
## Changes the NodePath associated with the graphic.  This NodePath should
## contain geometry that will render the desired graphic image.

proc getFrame*(this: TextGraphic): LVecBase4 {.importcpp: "#.get_frame()".} ## \
## Returns the frame specified for the graphic.  This is the amount of space
## that will be reserved for the graphic when it is embedded in a text
## paragraph, in the form (left, right, bottom, top).
##
## The actual graphic, as rendered by the NodePath specified via set_model(),
## should more or less fit within this rectangle.  It is not required to fit
## completely within it, but if it does not, it may visually overlap with
## nearby text.

proc setFrame*(this: TextGraphic, frame: LVecBase4) {.importcpp: "#.set_frame(#)".} ## \
## Specifies the (left, right, bottom, top) bounding frame for the graphic.
## See get_frame().

proc setFrame*(this: TextGraphic, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#.set_frame(#, #, #, #)".} ## \
## Specifies the (left, right, bottom, top) bounding frame for the graphic.
## See get_frame().

proc getInstanceFlag*(this: TextGraphic): bool {.importcpp: "#.get_instance_flag()".} ## \
## Returns the instance_flag.  See set_instance_flag().

proc setInstanceFlag*(this: TextGraphic, instance_flag: bool) {.importcpp: "#.set_instance_flag(#)".} ## \
## Sets the instance_flag.  When this is true, the graphic is directly
## instanced to the scene graph whenever it appears; when it is false, the
## graphic is copied.  The default is false, which is best for most
## applications.  You might need to set it true for special kinds of
## "graphics" like interactive elements, for instance a PGEntry.

proc setProperties*(this: TextPropertiesManager, name: string, properties: TextProperties) {.importcpp: "#.set_properties(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Defines the TextProperties associated with the indicated name.  When the
## name is subsequently encountered in text embedded between \1 characters in
## a TextNode string, the following text will be rendered with these
## properties.
##
## If there was already a TextProperties structure associated with this name,
## it is quietly replaced with the new definition.

proc getProperties*(this: TextPropertiesManager, name: string): TextProperties {.importcpp: "#.get_properties(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the TextProperties associated with the indicated name.  If there
## was not previously a TextProperties associated with this name, a warning is
## printed and then a default TextProperties structure is associated with the
## name, and returned.
##
## Call has_properties() instead to check whether a particular name has been
## defined.

proc hasProperties*(this: TextPropertiesManager, name: string): bool {.importcpp: "#.has_properties(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if a TextProperties structure has been associated with the
## indicated name, false otherwise.  Normally this means set_properties() has
## been called with this name, but because get_properties() will implicitly
## create a default TextProperties structure, it may also mean simply that
## get_properties() has been called with the indicated name.

proc clearProperties*(this: TextPropertiesManager, name: string) {.importcpp: "#.clear_properties(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes the named TextProperties structure from the manager.

proc setGraphic*(this: TextPropertiesManager, name: string, model: NodePath) {.importcpp: "#.set_graphic(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## This flavor of set_graphic implicitly creates a frame for the model using
## the model's actual computed bounding volume, as derived from
## NodePath::calc_tight_bounds().  Create a TextGraphic object first if you
## want to have explicit control of the frame.

proc setGraphic*(this: TextPropertiesManager, name: string, graphic: TextGraphic) {.importcpp: "#.set_graphic(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Defines the TextGraphic associated with the indicated name.  When the name
## is subsequently encountered in text embedded between \5 characters in a
## TextNode string, the specified graphic will be embedded in the text at that
## point.
##
## If there was already a TextGraphic structure associated with this name, it
## is quietly replaced with the new definition.

proc getGraphic*(this: TextPropertiesManager, name: string): TextGraphic {.importcpp: "#.get_graphic(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the TextGraphic associated with the indicated name.  If there was
## not previously a TextGraphic associated with this name, a warning is
## printed and then a default TextGraphic structure is associated with the
## name, and returned.
##
## Call has_graphic() instead to check whether a particular name has been
## defined.

proc hasGraphic*(this: TextPropertiesManager, name: string): bool {.importcpp: "#.has_graphic(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if a TextGraphic structure has been associated with the
## indicated name, false otherwise.  Normally this means set_graphic() has
## been called with this name, but because get_graphic() will implicitly
## create a default TextGraphic structure, it may also mean simply that
## get_graphic() has been called with the indicated name.

proc clearGraphic*(this: TextPropertiesManager, name: string) {.importcpp: "#.clear_graphic(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes the named TextGraphic structure from the manager.

proc write*(this: TextPropertiesManager, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: TextPropertiesManager, `out`: ostream) {.importcpp: "#.write(#)".}

proc getGlobalPtr*(_: typedesc[TextPropertiesManager]): TextPropertiesManager {.importcpp: "TextPropertiesManager::get_global_ptr()", header: "textPropertiesManager.h".} ## \
## Returns the pointer to the global TextPropertiesManager object.

proc initTextAssembler*(copy: TextAssembler): TextAssembler {.importcpp: "TextAssembler(#)".}

proc initTextAssembler*(encoder: TextEncoder): TextAssembler {.importcpp: "TextAssembler(#)".}

proc clear*(this: TextAssembler) {.importcpp: "#.clear()".} ## \
## Reinitializes the contents of the TextAssembler.

proc setMaxRows*(this: TextAssembler, max_rows: int) {.importcpp: "#.set_max_rows(#)".} ## \
## If max_rows is greater than zero, no more than max_rows will be accepted.
## Text beyond that will be truncated.
##
## Setting this will not truncate text immediately.  You must follow this up
## with a call to set_wtext() to truncate the existing text.

proc getMaxRows*(this: TextAssembler): int {.importcpp: "#.get_max_rows()".} ## \
## If max_rows is greater than zero, no more than max_rows will be accepted.
## Text beyond that will be truncated.

proc setDynamicMerge*(this: TextAssembler, dynamic_merge: bool) {.importcpp: "#.set_dynamic_merge(#)".} ## \
## Sets the dynamic_merge flag.  See TextNode::set_flatten_flags().

proc getDynamicMerge*(this: TextAssembler): bool {.importcpp: "#.get_dynamic_merge()".} ## \
## Returns the dynamic_merge flag.  See TextNode::set_flatten_flags().

proc setMultilineMode*(this: TextAssembler, flag: bool) {.importcpp: "#.set_multiline_mode(#)".} ## \
## Sets the multiline mode flag.  Set the multiline mode to allow text to
## wrap.  It defaults to true.

proc getMultilineMode*(this: TextAssembler): bool {.importcpp: "#.get_multiline_mode()".} ## \
## Returns the multline_mode flag.  See TextNode::set_multiline_mode().

proc setProperties*(this: TextAssembler, properties: TextProperties) {.importcpp: "#.set_properties(#)".} ## \
## Specifies the default TextProperties that are applied to the text in the
## absence of any nested property change sequences.

proc getProperties*(this: TextAssembler): TextProperties {.importcpp: "#.get_properties()".} ## \
## Returns the default TextProperties that are applied to the text in the
## absence of any nested property change sequences.

proc getProperties*(this: TextAssembler, n: int): TextProperties {.importcpp: "#.get_properties(#)".} ## \
## Returns the TextProperties in effect for the object at the indicated
## position in the pre-wordwrapped string.

proc getProperties*(this: TextAssembler, r: int, c: int): TextProperties {.importcpp: "#.get_properties(#, #)".} ## \
## Returns the TextProperties in effect for the object at the indicated
## position in the indicated row.

proc setWtext*(this: TextAssembler, wtext: string): bool {.importcpp: "#.set_wtext(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Accepts a new text string and associated properties structure, and
## precomputes the wordwrapping layout appropriately.  After this call,
## get_wordwrapped_wtext() and get_num_rows() can be called.
##
## The return value is true if all the text is accepted, or false if some was
## truncated (see set_max_rows()).

proc setWsubstr*(this: TextAssembler, wtext: string, start: int, count: int): bool {.importcpp: "#.set_wsubstr(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Replaces the 'count' characters from 'start' of the current text with the
## indicated replacement text.  If the replacement text does not have count
## characters, the length of the string will be changed accordingly.
##
## The substring may include nested formatting characters, but they must be
## self-contained and self-closed.  The formatting characters are not
## literally saved in the internal string; they are parsed at the time of the
## set_wsubstr() call.
##
## The return value is true if all the text is accepted, or false if some was
## truncated (see set_max_rows()).

proc getPlainWtext*(this: TextAssembler): string {.importcpp: "nimStringFromStdString(#.get_plain_wtext())", header: stringConversionCode.} ## \
## Returns a wstring that represents the contents of the text, without any
## embedded properties characters.  If there is an embedded graphic object, a
## zero value is inserted in that position.
##
## This string has the same length as get_num_characters(), and the characters
## in this string correspond one-to-one with the characters returned by
## get_character(n).

proc getWordwrappedPlainWtext*(this: TextAssembler): string {.importcpp: "nimStringFromStdString(#.get_wordwrapped_plain_wtext())", header: stringConversionCode.} ## \
## Returns a wstring that represents the contents of the text, with newlines
## inserted according to the wordwrapping.  The string will contain no
## embedded properties characters.  If there is an embedded graphic object, a
## zero value is inserted in that position.
##
## This string has the same number of newline characters as get_num_rows(),
## and the characters in this string correspond one-to-one with the characters
## returned by get_character(r, c).

proc getWtext*(this: TextAssembler): string {.importcpp: "nimStringFromStdString(#.get_wtext())", header: stringConversionCode.} ## \
## Returns a wstring that represents the contents of the text.
##
## The string will contain embedded properties characters, which may not
## exactly match the embedded properties characters of the original string,
## but it will encode the same way.

proc getWordwrappedWtext*(this: TextAssembler): string {.importcpp: "nimStringFromStdString(#.get_wordwrapped_wtext())", header: stringConversionCode.} ## \
## Returns a wstring that represents the contents of the text, with newlines
## inserted according to the wordwrapping.
##
## The string will contain embedded properties characters, which may not
## exactly match the embedded properties characters of the original string,
## but it will encode the same way.
##
## Embedded properties characters will be closed before every newline, then
## reopened (if necessary) on the subsequent character following the newline.
## This means it will be safe to divide the text up at the newline characters
## and treat each line as an independent piece.

proc calcR*(this: TextAssembler, n: int): int {.importcpp: "#.calc_r(#)".} ## \
## Computes the row index of the nth character or graphic object in the text
## and returns it.
##
## If the nth character is not a normal printable character with a position in
## the wordwrapped string, returns -1 (for instance, a soft-hyphen character,
## or a newline character, may not have a corresponding position).

proc calcC*(this: TextAssembler, n: int): int {.importcpp: "#.calc_c(#)".} ## \
## Computes the column index of the nth character or graphic object in the
## text and returns it.
##
## If the nth character is not a normal printable character with a position in
## the wordwrapped string, returns -1 (for instance, a soft-hyphen character,
## or a newline character, may not have a corresponding position).

proc calcIndex*(this: TextAssembler, r: int, c: int): int {.importcpp: "#.calc_index(#, #)".} ## \
## Computes the character index of the character at the rth row and cth column
## position.  This is the inverse of calc_r_c().
##
## It is legal for c to exceed the index number of the last column by 1, and
## it is legal for r to exceed the index number of the last row by 1, if c is
## 0.

proc getNumCharacters*(this: TextAssembler): int {.importcpp: "#.get_num_characters()".} ## \
## Returns the number of characters of text, before wordwrapping.

proc getCharacter*(this: TextAssembler, n: int): int {.importcpp: "#.get_character(#)".} ## \
## Returns the character at the indicated position in the pre-wordwrapped
## string.  If the object at this position is a graphic object instead of a
## character, returns 0.

proc getCharacter*(this: TextAssembler, r: int, c: int): int {.importcpp: "#.get_character(#, #)".} ## \
## Returns the character at the indicated position in the indicated row.  If
## the object at this position is a graphic object instead of a character,
## returns 0.

proc getGraphic*(this: TextAssembler, n: int): TextGraphic {.importcpp: "#.get_graphic(#)".} ## \
## Returns the graphic object at the indicated position in the pre-wordwrapped
## string.  If the object at this position is a character instead of a graphic
## object, returns NULL.

proc getGraphic*(this: TextAssembler, r: int, c: int): TextGraphic {.importcpp: "#.get_graphic(#, #)".} ## \
## Returns the graphic object at the indicated position in the indicated row.
## If the object at this position is a character instead of a graphic object,
## returns NULL.

proc getWidth*(this: TextAssembler, n: int): float32 {.importcpp: "#.get_width(#)".} ## \
## Returns the width of the character or object at the indicated position in
## the pre-wordwrapped string.

proc getWidth*(this: TextAssembler, r: int, c: int): float32 {.importcpp: "#.get_width(#, #)".} ## \
## Returns the width of the character or object at the indicated position in
## the indicated row.

proc getNumRows*(this: TextAssembler): int {.importcpp: "#.get_num_rows()".} ## \
## Returns the number of rows of text after it has all been wordwrapped and
## assembled.

proc getNumCols*(this: TextAssembler, r: int): int {.importcpp: "#.get_num_cols(#)".} ## \
## Returns the number of characters and/or graphic objects in the nth row.

proc getXpos*(this: TextAssembler, r: int, c: int): float32 {.importcpp: "#.get_xpos(#, #)".} ## \
## Returns the x position of the origin of the character or graphic object at
## the indicated position in the indicated row.
##
## It is legal for c to exceed the index number of the last column by 1, and
## it is legal for r to exceed the index number of the last row by 1, if c is
## 0.

proc getYpos*(this: TextAssembler, r: int, c: int): float32 {.importcpp: "#.get_ypos(#, #)".} ## \
## Returns the y position of the origin of all of the characters or graphic
## objects in the indicated row.
##
## It is legal for r to exceed the index number of the last row by 1.  The
## value of c is presently ignored.

proc assembleText*(this: TextAssembler): PandaNode {.importcpp: "#.assemble_text()".} ## \
## Actually assembles all of the text into a GeomNode, and returns the node
## (or possibly a parent of the node, to keep the shadow separate).  Once this
## has been called, you may query the extents of the text via get_ul(),
## get_lr().

proc getUl*(this: TextAssembler): LVector2 {.importcpp: "#.get_ul()".} ## \
## Returns the upper-left corner of the assembled text, in 2-d text
## coordinates.

proc getLr*(this: TextAssembler): LVector2 {.importcpp: "#.get_lr()".} ## \
## Returns the lower-right corner of the assembled text, in 2-d text
## coordinates.

proc calcWidth*(_: typedesc[TextAssembler], graphic: TextGraphic, properties: TextProperties): float32 {.importcpp: "#TextAssembler::calc_width(#, #)", header: "textAssembler.h".} ## \
## Returns the width of a single TextGraphic image.

proc calcWidth*(_: typedesc[TextAssembler], character: int, properties: TextProperties): float32 {.importcpp: "#TextAssembler::calc_width(#, #)", header: "textAssembler.h".} ## \
## Returns the width of a single character, according to its associated font.
## This also correctly calculates the width of cheesy ligatures and accented
## characters, which may not exist in the font as such.
##
## This does not take kerning into account, however.

proc hasExactCharacter*(_: typedesc[TextAssembler], character: int, properties: TextProperties): bool {.importcpp: "#TextAssembler::has_exact_character(#, #)", header: "textAssembler.h".} ## \
## Returns true if the named character exists in the font exactly as named,
## false otherwise.  Note that because Panda can assemble glyphs together
## automatically using cheesy accent marks, this is not a reliable indicator
## of whether a suitable glyph can be rendered for the character.  For that,
## use has_character() instead.
##
## This returns true for whitespace and Unicode whitespace characters (if they
## exist in the font), but returns false for characters that would render with
## the "invalid glyph".  It also returns false for characters that would be
## synthesized within Panda, but see has_character().

proc hasCharacter*(_: typedesc[TextAssembler], character: int, properties: TextProperties): bool {.importcpp: "#TextAssembler::has_character(#, #)", header: "textAssembler.h".} ## \
## Returns true if the named character exists in the font or can be
## synthesized by Panda, false otherwise.  (Panda can synthesize some accented
## characters by combining similar-looking glyphs from the font.)
##
## This returns true for whitespace and Unicode whitespace characters (if they
## exist in the font), but returns false for characters that would render with
## the "invalid glyph".

proc isWhitespace*(_: typedesc[TextAssembler], character: int, properties: TextProperties): bool {.importcpp: "#TextAssembler::is_whitespace(#, #)", header: "textAssembler.h".} ## \
## Returns true if the indicated character represents whitespace in the font,
## or false if anything visible will be rendered for it.
##
## This returns true for whitespace and Unicode whitespace characters (if they
## exist in the font), and returns false for any other characters, including
## characters that do not exist in the font (these would be rendered with the
## "invalid glyph", which is visible).
##
## Note that this function can be reliably used to identify Unicode whitespace
## characters only if the font has all of the whitespace characters defined.
## It will return false for any character not in the font, even if it is an
## official Unicode whitespace character.

converter upcastToPandaNode*(this: TextNode): PandaNode {.importcpp: "(PT(PandaNode)(#))".}

converter upcastToTextEncoder*(this: TextNode): TextEncoder {.importcpp: "((TextEncoder *)(TextNode *)(#))".}

converter upcastToTextProperties*(this: TextNode): TextProperties {.importcpp: "((TextProperties *)(TextNode *)(#))".}

proc newTextNode*(name: string): TextNode {.importcpp: "new TextNode(nimStringToStdString(#))", header: stringConversionCode.}

proc newTextNode*(name: string, copy: TextProperties): TextNode {.importcpp: "new TextNode(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## It's sort of a copy constructor: it copies the indicated TextProperties,
## without copying a complete TextNode.

proc getLineHeight*(this: TextNode): float32 {.importcpp: "#->get_line_height()".} ## \
## Returns the number of units high each line of text is.  This is based on
## the font.  Note that it is possible for the text to include nested font
## change commands, in which case the value of this method is questionable.

proc setMaxRows*(this: TextNode, max_rows: int) {.importcpp: "#->set_max_rows(#)".} ## \
## Sets the maximum number of rows that may be formatted by the TextNode.  If
## more text than this is attempted, it will be truncated and has_overflow()
## will return true.

proc clearMaxRows*(this: TextNode) {.importcpp: "#->clear_max_rows()".} ## \
## Resets the TextNode's default behavior of not limiting the number of rows
## of text.

proc hasMaxRows*(this: TextNode): bool {.importcpp: "#->has_max_rows()".} ## \
## Returns true if a limit on the height of the TextNode has been set via
## set_max_rows(), false otherwise.

proc getMaxRows*(this: TextNode): int {.importcpp: "#->get_max_rows()".} ## \
## Returns the limit on the height of the TextNode specified by
## set_max_rows().

proc hasOverflow*(this: TextNode): bool {.importcpp: "#->has_overflow()".} ## \
## Returns true if the last text set on the text node exceeded the max_rows
## constraint, or false if it all fit.

proc setFrameColor*(this: TextNode, frame_color: LColor) {.importcpp: "#->set_frame_color(#)".}

proc setFrameColor*(this: TextNode, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#->set_frame_color(#, #, #, #)".}

proc getFrameColor*(this: TextNode): LColor {.importcpp: "#->get_frame_color()".}

proc setCardBorder*(this: TextNode, size: float32, uv_portion: float32) {.importcpp: "#->set_card_border(#, #)".}

proc clearCardBorder*(this: TextNode) {.importcpp: "#->clear_card_border()".}

proc getCardBorderSize*(this: TextNode): float32 {.importcpp: "#->get_card_border_size()".}

proc getCardBorderUvPortion*(this: TextNode): float32 {.importcpp: "#->get_card_border_uv_portion()".}

proc hasCardBorder*(this: TextNode): bool {.importcpp: "#->has_card_border()".}

proc setCardColor*(this: TextNode, card_color: LColor) {.importcpp: "#->set_card_color(#)".}

proc setCardColor*(this: TextNode, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#->set_card_color(#, #, #, #)".}

proc getCardColor*(this: TextNode): LColor {.importcpp: "#->get_card_color()".}

proc setCardTexture*(this: TextNode, card_texture: Texture) {.importcpp: "#->set_card_texture(#)".}

proc clearCardTexture*(this: TextNode) {.importcpp: "#->clear_card_texture()".}

proc hasCardTexture*(this: TextNode): bool {.importcpp: "#->has_card_texture()".}

proc getCardTexture*(this: TextNode): Texture {.importcpp: "#->get_card_texture()".}

proc setFrameAsMargin*(this: TextNode, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#->set_frame_as_margin(#, #, #, #)".} ## \
## Specifies that a border will be drawn around the text when it is next
## created.  The parameters are the amount of additional padding to insert
## between the frame and the text in each dimension, and all should generally
## be positive.

proc setFrameActual*(this: TextNode, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#->set_frame_actual(#, #, #, #)".} ## \
## Similar to set_frame_as_margin, except the frame is specified in actual
## coordinate units (relative to the text's origin), irrespective of the size
## of the text.  The left and bottom coordinates should generally be negative,
## while the right and top coordinates should generally be positive.

proc clearFrame*(this: TextNode) {.importcpp: "#->clear_frame()".} ## \
## Specifies that a border will not be drawn around the text.

proc hasFrame*(this: TextNode): bool {.importcpp: "#->has_frame()".}

proc isFrameAsMargin*(this: TextNode): bool {.importcpp: "#->is_frame_as_margin()".} ## \
## If this is true, the frame was set via a call to set_frame_as_margin(), and
## the dimension of the frame as returned by get_frame_as_set() represent a
## margin all around the text.  If false, then the frame was set via a call to
## set_frame_actual(), and the dimensions of the frame as returned by
## get_frame_as_set() are relative to the text's origin.

proc getFrameAsSet*(this: TextNode): LVecBase4 {.importcpp: "#->get_frame_as_set()".} ## \
## Returns the dimensions of the frame as set by set_frame_as_margin() or
## set_frame_actual().  Use is_frame_actual() to determine how to interpret
## the values returned by this function.  It is an error to call this if
## has_frame() is false.

proc getFrameActual*(this: TextNode): LVecBase4 {.importcpp: "#->get_frame_actual()".} ## \
## Returns the actual dimensions of the frame around the text.  If the frame
## was set via set_frame_as_margin(), the result returned by this function
## reflects the size of the current text; if the frame was set via
## set_frame_actual(), this returns the values actually set.
##
## If the text has no frame at all, this returns the dimensions of the text
## itself, as if the frame were set with a margin of 0, 0, 0, 0.

proc setFrameLineWidth*(this: TextNode, line_width: float32) {.importcpp: "#->set_frame_line_width(#)".} ## \
## Specifies the thickness of the lines that will be used to draw the frame.

proc getFrameLineWidth*(this: TextNode): float32 {.importcpp: "#->get_frame_line_width()".} ## \
## Returns the thickness of the lines that will be used to draw the frame.

proc setFrameCorners*(this: TextNode, corners: bool) {.importcpp: "#->set_frame_corners(#)".} ## \
## Enables or disables the drawing of corners for the frame.  These are extra
## points drawn at each of the four corners, to soften the ugly edges
## generated when the line width is greater than one.

proc getFrameCorners*(this: TextNode): bool {.importcpp: "#->get_frame_corners()".}

proc setCardAsMargin*(this: TextNode, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#->set_card_as_margin(#, #, #, #)".} ## \
## Specifies that a (possibly opaque or semitransparent) card will be held
## behind the text when it is next created.  Like set_frame_as_margin, the
## parameters are the amount of additional padding to insert around the text
## in each dimension, and all should generally be positive.

proc setCardActual*(this: TextNode, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#->set_card_actual(#, #, #, #)".} ## \
## Similar to set_card_as_margin, except the card is specified in actual
## coordinate units (relative to the text's origin), irrespective of the size
## of the text.  The left and bottom coordinates should generally be negative,
## while the right and top coordinates should generally be positive.

proc setCardDecal*(this: TextNode, card_decal: bool) {.importcpp: "#->set_card_decal(#)".} ## \
## Sets the card_decal flag.  When this is true, the text is decalled onto the
## card, which is necessary if the TextNode is to be rendered in the 3-d world
## without putting it in a bin.

proc clearCard*(this: TextNode) {.importcpp: "#->clear_card()".} ## \
## Specifies that a card will not be drawn behind the text.

proc hasCard*(this: TextNode): bool {.importcpp: "#->has_card()".}

proc getCardDecal*(this: TextNode): bool {.importcpp: "#->get_card_decal()".} ## \
## Returns the card_decal flag.  See set_card_decal().

proc isCardAsMargin*(this: TextNode): bool {.importcpp: "#->is_card_as_margin()".} ## \
## If this is true, the card was set via a call to set_card_as_margin(), and
## the dimension of the card as returned by get_card_as_set() represent a
## margin all around the text.  If false, then the card was set via a call to
## set_card_actual(), and the dimensions of the card as returned by
## get_card_as_set() are relative to the text's origin.

proc getCardAsSet*(this: TextNode): LVecBase4 {.importcpp: "#->get_card_as_set()".} ## \
## Returns the dimensions of the card as set by set_card_as_margin() or
## set_card_actual().  Use is_card_actual() to determine how to interpret the
## values returned by this function.  It is an error to call this if
## has_card() is false.

proc getCardActual*(this: TextNode): LVecBase4 {.importcpp: "#->get_card_actual()".} ## \
## Returns the actual dimensions of the card around the text.  If the card was
## set via set_card_as_margin(), the result returned by this function reflects
## the size of the current text; if the card was set via set_card_actual(),
## this returns the values actually set.
##
## If the text has no card at all, this returns the dimensions of the text
## itself, as if the card were set with a margin of 0, 0, 0, 0.

proc getCardTransformed*(this: TextNode): LVecBase4 {.importcpp: "#->get_card_transformed()".} ## \
## Returns the actual card dimensions, transformed by the matrix set by
## set_transform().  This returns the card dimensions in actual coordinates as
## seen by the rest of the world.  Also see get_upper_left_3d() and
## get_lower_right_3d().

proc setTransform*(this: TextNode, transform: LMatrix4) {.importcpp: "#->set_transform(#)".} ## \
## Sets an additional transform that is applied to the entire text paragraph.

proc getTransform*(this: TextNode): LMatrix4 {.importcpp: "#->get_transform()".}

proc setCoordinateSystem*(this: TextNode, cs: CoordinateSystem) {.importcpp: "#->set_coordinate_system(#)".} ## \
## Specifies the coordinate system in which the text will be generated.

proc getCoordinateSystem*(this: TextNode): CoordinateSystem {.importcpp: "#->get_coordinate_system()".}

proc setFlattenFlags*(this: TextNode, flatten_flags: int) {.importcpp: "#->set_flatten_flags(#)".} ## \
## Sets the flatten flags.  This should be a union of the
## TextNode::FlattenFlags options.  This controls the degree of flattening
## performed on the TextNode's internal geometry (i.e.  the scene graph
## returned by generate()) each time the text is changed.  In general, more
## flattening means a more optimal result, but it will take more time to
## generate.
##
## The choice may be any of these three:
##
## FF_none - No flatten operation is called.  The letters are left as
## independent Geoms.
##
## FF_light - A flatten_light() operation is called.  The attributes are
## applied to the vertices, but no nodes are removed.
##
## FF_medium - A flatten_medium() operation is called.  The attributes are
## applied to the vertices, and a few trivial nodes are removed.
##
## FF_strong - A flatten_strong() operation is called.  The attributes are
## applied to the vertices, and the resulting nodes are aggressively combined
## into as few nodes as possible.
##
## In addition to the above choices, you may optionally include the following
## flag:
##
## FF_dynamic_merge - Copy the geoms into a single GeomVertexData as we go,
## instead of relying on the flatten operation at the end.  This pre-flattens
## the text considerably, and may obviate the need for flatten altogether; it
## also tends to improve performance considerably even if you do call flatten.
## However, it is not as fast as not calling flatten at all.
##
## The default is taken from the text-flatten and text-dynamic-merge config
## variables.

proc getFlattenFlags*(this: TextNode): int {.importcpp: "#->get_flatten_flags()".} ## \
## Returns the flatten flags.  See set_flatten_flags().

proc setFont*(this: TextNode, font: TextFont) {.importcpp: "#->set_font(#)".} ## \
## Sets the font that will be used when making text.  If this is set to NULL,
## the default font will be used, which can be set via set_default_font().

proc clearFont*(this: TextNode) {.importcpp: "#->clear_font()".} ## \
## Resets the font to the default font.

proc setSmallCaps*(this: TextNode, small_caps: bool) {.importcpp: "#->set_small_caps(#)".} ## \
## Sets the small_caps flag.  When this is set, lowercase letters are
## generated as scaled-down versions of their uppercase equivalents.  This is
## particularly useful to set for fonts that do not have lowercase letters.
##
## It is also a good idea to set this for a (dynamic) font that has already
## implemented lowercase letters as scaled-down versions of their uppercase
## equivalents, since without this flag the texture memory may needlessly
## duplicate equivalent glyphs for upper and lowercase letters.  Setting this
## flag causes the texture memory to share the mixed-case letters.
##
## The amount by which the lowercase letters are scaled is specified by
## set_small_caps_scale().

proc clearSmallCaps*(this: TextNode) {.importcpp: "#->clear_small_caps()".}

proc setSmallCapsScale*(this: TextNode, small_caps_scale: float32) {.importcpp: "#->set_small_caps_scale(#)".} ## \
## Sets the scale factor applied to lowercase letters from their uppercase
## equivalents, when the small_caps flag is in effect.  See set_small_caps().
## Normally, this will be a number less than one.

proc clearSmallCapsScale*(this: TextNode) {.importcpp: "#->clear_small_caps_scale()".}

proc setSlant*(this: TextNode, slant: float32) {.importcpp: "#->set_slant(#)".}

proc clearSlant*(this: TextNode) {.importcpp: "#->clear_slant()".}

proc clearAlign*(this: TextNode) {.importcpp: "#->clear_align()".}

proc setIndent*(this: TextNode, indent: float32) {.importcpp: "#->set_indent(#)".} ## \
## Specifies the amount of extra space that is inserted before the first
## character of each line.  This can be thought of as a left margin.

proc clearIndent*(this: TextNode) {.importcpp: "#->clear_indent()".}

proc setWordwrap*(this: TextNode, wordwrap: float32) {.importcpp: "#->set_wordwrap(#)".} ## \
## Sets the text up to automatically wordwrap when it exceeds the indicated
## width.  This can be thought of as a right margin or margin width.

proc clearWordwrap*(this: TextNode) {.importcpp: "#->clear_wordwrap()".} ## \
## Removes the wordwrap setting from the TextNode.  Text will be as wide as it
## is.

proc setTextColor*(this: TextNode, text_color: LColor) {.importcpp: "#->set_text_color(#)".}

proc setTextColor*(this: TextNode, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#->set_text_color(#, #, #, #)".}

proc clearTextColor*(this: TextNode) {.importcpp: "#->clear_text_color()".} ## \
## Removes the text color specification; the text will be colored whatever it
## was in the source font file.

proc setShadowColor*(this: TextNode, shadow_color: LColor) {.importcpp: "#->set_shadow_color(#)".}

proc setShadowColor*(this: TextNode, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#->set_shadow_color(#, #, #, #)".}

proc clearShadowColor*(this: TextNode) {.importcpp: "#->clear_shadow_color()".}

proc setShadow*(this: TextNode, shadow_offset: LVecBase2) {.importcpp: "#->set_shadow(#)".} ## \
## Specifies that the text should be drawn with a shadow, by creating a second
## copy of the text and offsetting it slightly behind the first.

proc setShadow*(this: TextNode, xoffset: float32, yoffset: float32) {.importcpp: "#->set_shadow(#, #)".} ## \
## Specifies that the text should be drawn with a shadow, by creating a second
## copy of the text and offsetting it slightly behind the first.

proc clearShadow*(this: TextNode) {.importcpp: "#->clear_shadow()".} ## \
## Specifies that a shadow will not be drawn behind the text.

proc setBin*(this: TextNode, bin: string) {.importcpp: "#->set_bin(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Names the GeomBin that the TextNode geometry should be assigned to.  If
## this is set, then a GeomBinTransition will be created to explicitly place
## each component in the named bin.
##
## The draw_order value will also be passed to each GeomBinTransition as
## appropriate; this is particularly useful if this names a GeomBinFixed, e.g.
## "fixed".

proc clearBin*(this: TextNode) {.importcpp: "#->clear_bin()".} ## \
## Removes the effect of a previous call to set_bin().  Text will be drawn in
## whatever bin it would like to be drawn in, with no explicit ordering.

proc setDrawOrder*(this: TextNode, draw_order: int): int {.importcpp: "#->set_draw_order(#)".} ## \
## Sets the drawing order of text created by the TextMaker.  This is actually
## the draw order of the card and frame.  The shadow is drawn at
## _draw_order+1, and the text at _draw_order+2.
##
## This affects the sorting order assigned to the arcs as they are created,
## and also is passed to whatever bin may be assigned via set_bin().
##
## The return value is the first unused draw_order number, e.g.  _draw_order +
## 3.

proc clearDrawOrder*(this: TextNode) {.importcpp: "#->clear_draw_order()".}

proc setTabWidth*(this: TextNode, tab_width: float32) {.importcpp: "#->set_tab_width(#)".} ## \
## Sets the width of each tab stop, in screen units.  A tab character embedded
## in the text will advance the horizontal position to the next tab stop.

proc clearTabWidth*(this: TextNode) {.importcpp: "#->clear_tab_width()".}

proc setGlyphScale*(this: TextNode, glyph_scale: float32) {.importcpp: "#->set_glyph_scale(#)".} ## \
## Specifies the factor by which to scale each letter of the text as it is
## placed.  This can be used (possibly in conjunction with set_glyph_shift())
## to implement superscripting or subscripting.

proc clearGlyphScale*(this: TextNode) {.importcpp: "#->clear_glyph_scale()".}

proc setGlyphShift*(this: TextNode, glyph_shift: float32) {.importcpp: "#->set_glyph_shift(#)".} ## \
## Specifies a vertical amount to shift each letter of the text as it is
## placed.  This can be used (possibly in conjunction with set_glyph_scale())
## to implement superscripting or subscripting.

proc clearGlyphShift*(this: TextNode) {.importcpp: "#->clear_glyph_shift()".}

proc getWordwrappedText*(this: TextNode): string {.importcpp: "nimStringFromStdString(#->get_wordwrapped_text())", header: stringConversionCode.} ## \
## Returns a string that represents the contents of the text, as it has been
## formatted by wordwrap rules.
##
## In earlier versions, this did not contain any embedded special characters
## like \1 or \3; now it does.

proc calcWidth*(this: TextNode, line: string): float32 {.importcpp: "#->calc_width(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the width of a line of text of arbitrary characters.  The line
## should not include the newline character.

proc calcWidth*(this: TextNode, character: int): float32 {.importcpp: "#->calc_width(#)".} ## \
## Returns the width of a single character of the font, or 0.0 if the
## character is not known.  This may be a wide character (greater than 255).

proc hasExactCharacter*(this: TextNode, character: int): bool {.importcpp: "#->has_exact_character(#)".} ## \
## Returns true if the named character exists in the font exactly as named,
## false otherwise.  Note that because Panda can assemble glyphs together
## automatically using cheesy accent marks, this is not a reliable indicator
## of whether a suitable glyph can be rendered for the character.  For that,
## use has_character() instead.
##
## This returns true for whitespace and Unicode whitespace characters (if they
## exist in the font), but returns false for characters that would render with
## the "invalid glyph".  It also returns false for characters that would be
## synthesized within Panda, but see has_character().

proc hasCharacter*(this: TextNode, character: int): bool {.importcpp: "#->has_character(#)".} ## \
## Returns true if the named character exists in the font or can be
## synthesized by Panda, false otherwise.  (Panda can synthesize some accented
## characters by combining similar-looking glyphs from the font.)
##
## This returns true for whitespace and Unicode whitespace characters (if they
## exist in the font), but returns false for characters that would render with
## the "invalid glyph".

proc isWhitespace*(this: TextNode, character: int): bool {.importcpp: "#->is_whitespace(#)".} ## \
## Returns true if the indicated character represents whitespace in the font,
## or false if anything visible will be rendered for it.
##
## This returns true for whitespace and Unicode whitespace characters (if they
## exist in the font), and returns false for any other characters, including
## characters that do not exist in the font (these would be rendered with the
## "invalid glyph", which is visible).
##
## Note that this function can be reliably used to identify Unicode whitespace
## characters only if the font has all of the whitespace characters defined.
## It will return false for any character not in the font, even if it is an
## official Unicode whitespace character.

proc getWordwrappedWtext*(this: TextNode): string {.importcpp: "nimStringFromStdString(#->get_wordwrapped_wtext())", header: stringConversionCode.} ## \
## Returns a wstring that represents the contents of the text, as it has been
## formatted by wordwrap rules.
##
## In earlier versions, this did not contain any embedded special characters
## like \1 or \3; now it does.

proc output*(this: TextNode, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: TextNode, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: TextNode, `out`: ostream) {.importcpp: "#->write(#)".}

proc getLeft*(this: TextNode): float32 {.importcpp: "#->get_left()".} ## \
## Returns the leftmost extent of the text in local 2-d coordinates,
## unmodified by the set_transform() matrix.

proc getRight*(this: TextNode): float32 {.importcpp: "#->get_right()".} ## \
## Returns the rightmost extent of the text in local 2-d coordinates,
## unmodified by the set_transform() matrix.

proc getBottom*(this: TextNode): float32 {.importcpp: "#->get_bottom()".} ## \
## Returns the bottommost extent of the text in local 2-d coordinates,
## unmodified by the set_transform() matrix.

proc getTop*(this: TextNode): float32 {.importcpp: "#->get_top()".} ## \
## Returns the topmost extent of the text in local 2-d coordinates, unmodified
## by the set_transform() matrix.

proc getHeight*(this: TextNode): float32 {.importcpp: "#->get_height()".} ## \
## Returns the net height of the text in local 2-d coordinates.

proc getWidth*(this: TextNode): float32 {.importcpp: "#->get_width()".} ## \
## Returns the net width of the text in local 2-d coordinates.

proc getUpperLeft3d*(this: TextNode): LPoint3 {.importcpp: "#->get_upper_left_3d()".} ## \
## Returns the upper-left extent of the text object, after it has been
## transformed into 3-d space by applying the set_transform() matrix.

proc getLowerRight3d*(this: TextNode): LPoint3 {.importcpp: "#->get_lower_right_3d()".} ## \
## Returns the lower-right extent of the text object, after it has been
## transformed into 3-d space by applying the set_transform() matrix.

proc getNumRows*(this: TextNode): int {.importcpp: "#->get_num_rows()".} ## \
## Returns the number of rows of text that were generated.  This counts word-
## wrapped rows as well as rows generated due to embedded newlines.

proc generate*(this: TextNode): PandaNode {.importcpp: "#->generate()".} ## \
## Generates the text, according to the parameters indicated within the
## TextNode, and returns a Node that may be parented within the tree to
## represent it.

proc update*(this: TextNode) {.importcpp: "#->update()".} ## \
## Can be called after the TextNode has been fully configured, to force the
## node to recompute its text immediately, rather than waiting for it to be
## drawn.  This call is optional.

proc forceUpdate*(this: TextNode) {.importcpp: "#->force_update()".} ## \
## Forces the TextNode to recompute itself now, even if it believes nothing
## has changed.  Normally, this should not need to be called, but it may be
## useful if some properties change outside of the TextNode's knowledge (for
## instance, within the font).

proc getInternalGeom*(this: TextNode): PandaNode {.importcpp: "#->get_internal_geom()".} ## \
## Returns the actual node that is used internally to render the text, if the
## TextNode is parented within the scene graph.
##
## In general, you should not call this method.  Call generate() instead if
## you want to get a handle to geometry that represents the text.  This method
## is provided as a debugging aid only.

proc hasFont*(this: TextNode): bool {.importcpp: "#->has_font()".}

proc hasSmallCaps*(this: TextNode): bool {.importcpp: "#->has_small_caps()".}

proc hasSmallCapsScale*(this: TextNode): bool {.importcpp: "#->has_small_caps_scale()".}

proc hasSlant*(this: TextNode): bool {.importcpp: "#->has_slant()".}

proc hasUnderscore*(this: TextNode): bool {.importcpp: "#->has_underscore()".}

proc clearUnderscore*(this: TextNode) {.importcpp: "#->clear_underscore()".}

proc hasUnderscoreHeight*(this: TextNode): bool {.importcpp: "#->has_underscore_height()".}

proc clearUnderscoreHeight*(this: TextNode) {.importcpp: "#->clear_underscore_height()".}

proc hasAlign*(this: TextNode): bool {.importcpp: "#->has_align()".}

proc hasIndent*(this: TextNode): bool {.importcpp: "#->has_indent()".}

proc hasWordwrap*(this: TextNode): bool {.importcpp: "#->has_wordwrap()".}

proc hasPreserveTrailingWhitespace*(this: TextNode): bool {.importcpp: "#->has_preserve_trailing_whitespace()".}

proc clearPreserveTrailingWhitespace*(this: TextNode) {.importcpp: "#->clear_preserve_trailing_whitespace()".}

proc hasTextColor*(this: TextNode): bool {.importcpp: "#->has_text_color()".}

proc hasShadowColor*(this: TextNode): bool {.importcpp: "#->has_shadow_color()".}

proc hasShadow*(this: TextNode): bool {.importcpp: "#->has_shadow()".}

proc hasBin*(this: TextNode): bool {.importcpp: "#->has_bin()".} ## \
## Returns true if an explicit drawing bin has been set via set_bin(), false
## otherwise.

proc hasDrawOrder*(this: TextNode): bool {.importcpp: "#->has_draw_order()".}

proc hasTabWidth*(this: TextNode): bool {.importcpp: "#->has_tab_width()".}

proc hasGlyphScale*(this: TextNode): bool {.importcpp: "#->has_glyph_scale()".}

proc hasGlyphShift*(this: TextNode): bool {.importcpp: "#->has_glyph_shift()".}

proc hasTextScale*(this: TextNode): bool {.importcpp: "#->has_text_scale()".}

proc clearTextScale*(this: TextNode) {.importcpp: "#->clear_text_scale()".}

converter getClassType*(_: typedesc[TextNode]): TypeHandle {.importcpp: "TextNode::get_class_type()", header: "textNode.h".}

proc newButtonThrower*(param0: ButtonThrower): ButtonThrower {.importcpp: "new ButtonThrower(#)".}

proc newButtonThrower*(name: string): ButtonThrower {.importcpp: "new ButtonThrower(nimStringToStdString(#))", header: stringConversionCode.}

proc setButtonDownEvent*(this: ButtonThrower, button_down_event: string) {.importcpp: "#->set_button_down_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the generic event that is generated (if any) each time a key or
## button is depressed.  Unlike the specific events that are unique to each
## key, this same event name is used for \*all\* button events, and the name of
## the button pressed (possibly with modifier prefixes) will be sent as a
## parameter.
##
## If this string is empty, no event is generated.  It is possible to generate
## both generic events and specific events for the same button.
##
## See also set_keystroke_event().

proc getButtonDownEvent*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_button_down_event())", header: stringConversionCode.} ## \
## Returns the button_down_event that has been set on this ButtonThrower.  See
## set_button_down_event().

proc setButtonUpEvent*(this: ButtonThrower, button_up_event: string) {.importcpp: "#->set_button_up_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the generic event that is generated (if any) each time a key or
## button is released.  See set_button_down_event().

proc getButtonUpEvent*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_button_up_event())", header: stringConversionCode.} ## \
## Returns the button_up_event that has been set on this ButtonThrower.  See
## set_button_up_event().

proc setButtonRepeatEvent*(this: ButtonThrower, button_repeat_event: string) {.importcpp: "#->set_button_repeat_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the generic event that is generated (if any) repeatedly while a
## key or button is held down.  Unlike the specific events that are unique to
## each key, this same event name is used for \*all\* button events, and the
## name of the button pressed (possibly with modifier prefixes) will be sent
## as a parameter.
##
## If this string is empty, no event is generated.  It is possible to generate
## both generic events and specific events for the same button.
##
## See also set_keystroke_event().

proc getButtonRepeatEvent*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_button_repeat_event())", header: stringConversionCode.} ## \
## Returns the button_repeat_event that has been set on this ButtonThrower.
## See set_button_repeat_event().

proc setKeystrokeEvent*(this: ButtonThrower, keystroke_event: string) {.importcpp: "#->set_keystroke_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the event that is generated (if any) for each keystroke that is
## received.  A keystroke is different than a button event: it represents the
## semantic meaning of the sequence of keys that have been pressed.  For
## instance, pressing shift and 4 together will generate the button event
## "shift-4", but it will generate the keystroke "$".
##
## If a key is held down, keyrepeat will cause the same keystroke event to be
## generated repeatedly.  This is different from the corresponding down event,
## which will only be generated once, followed by a number of button repeat
## events.
##
## This event is generated with a single wstring parameter, which is a one-
## character string that contains the keystroke generated.  If this event
## string is empty, no event is generated.
##
## See also set_button_down_event().

proc getKeystrokeEvent*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_keystroke_event())", header: stringConversionCode.} ## \
## Returns the keystroke_event that has been set on this ButtonThrower.  See
## set_keystroke_event().

proc setCandidateEvent*(this: ButtonThrower, candidate_event: string) {.importcpp: "#->set_candidate_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the event that is generated (if any) for each IME candidate
## string event received.  Events of this nature are received only when the
## user is entering data using a Microsoft Input Method Editor, typically used
## for Asian languages such as Japanese or Korean.
##
## If you are designing a typing user interface, you should track this event
## to support the use of the IME.  In response to this event, you should
## display the candidate string in the entry box, with the appropriate
## sections highlighted, so the user can scroll through the available choices.
##
## This event is generated with four parameters, in order: the candidate
## string, the character at which to start the highlight, the character at
## which to end the highlight, and the current cursor position.

proc getCandidateEvent*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_candidate_event())", header: stringConversionCode.} ## \
## Returns the candidate_event that has been set on this ButtonThrower.  See
## set_candidate_event().

proc setMoveEvent*(this: ButtonThrower, move_event: string) {.importcpp: "#->set_move_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the event that is generated (if any) each time the mouse is moved
## within the window.

proc getMoveEvent*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_move_event())", header: stringConversionCode.} ## \
## Returns the move_event that has been set on this ButtonThrower.  See
## set_move_event().

proc setRawButtonDownEvent*(this: ButtonThrower, raw_button_down_event: string) {.importcpp: "#->set_raw_button_down_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Like set_button_down_event, but uses the raw, untransformed scan key from
## the operating system.  This uses buttons that are independent of the user's
## selected keyboard layout.

proc getRawButtonDownEvent*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_raw_button_down_event())", header: stringConversionCode.} ## \
## Returns the raw_button_down_event that has been set on this ButtonThrower.
## See set_raw_button_down_event().

proc setRawButtonUpEvent*(this: ButtonThrower, raw_button_up_event: string) {.importcpp: "#->set_raw_button_up_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the generic event that is generated (if any) each time a key or
## button is released.  See set_raw_button_down_event().

proc getRawButtonUpEvent*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_raw_button_up_event())", header: stringConversionCode.} ## \
## Returns the raw_button_up_event that has been set on this ButtonThrower.
## See set_raw_button_up_event().

proc setPrefix*(this: ButtonThrower, prefix: string) {.importcpp: "#->set_prefix(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the prefix which is prepended to all specific event names (that is,
## event names generated from the button name itself, as opposed to the
## generic event names like set_button_down_event) thrown by this object.

proc getPrefix*(this: ButtonThrower): string {.importcpp: "nimStringFromStdString(#->get_prefix())", header: stringConversionCode.} ## \
## Returns the prefix that has been set on this ButtonThrower.  See
## set_prefix().

proc setSpecificFlag*(this: ButtonThrower, specific_flag: bool) {.importcpp: "#->set_specific_flag(#)".} ## \
## Sets the flag that indicates whether specific events (events prefixed by
## set_prefix, and based on the event name) should be generated at all.  This
## is true by default, but may be disabled if you are only interested in the
## generic events (for instance, events like set_button_down_event).

proc getSpecificFlag*(this: ButtonThrower): bool {.importcpp: "#->get_specific_flag()".} ## \
## Returns the flag that indicates whether specific events should be
## generated.  See set_specific_flag().

proc setTimeFlag*(this: ButtonThrower, time_flag: bool) {.importcpp: "#->set_time_flag(#)".} ## \
## Sets the flag that indicates whether the time of the button event should be
## passed as a parameter or not.  When this is true, an additional parameter
## is generated on each event (before all the parameters named by
## add_parameter) that consists of a single double value, and reflects the
## time the button was pressed or released, as a value from
## ClockObject::get_global_clock().

proc getTimeFlag*(this: ButtonThrower): bool {.importcpp: "#->get_time_flag()".} ## \
## Returns the flag that indicates whether the time of the button event should
## be passed as a parameter.

proc addParameter*(this: ButtonThrower, obj: EventParameter) {.importcpp: "#->add_parameter(#)".} ## \
## Adds the indicated parameter to the list of parameters that will be passed
## with each event generated by this ButtonThrower.

proc getNumParameters*(this: ButtonThrower): int {.importcpp: "#->get_num_parameters()".} ## \
## Returns the number of parameters that have been added to the list of
## parameters to be passed with each event generated by this ButtonThrower.

proc getParameter*(this: ButtonThrower, n: int): EventParameter {.importcpp: "#->get_parameter(#)".} ## \
## Returns the nth parameter that has been added to the list of parameters
## passed with each event generated by this ButtonThrower.

proc getModifierButtons*(this: ButtonThrower): ModifierButtons {.importcpp: "#->get_modifier_buttons()".} ## \
## Returns the set of ModifierButtons that the ButtonThrower will consider
## important enough to prepend the event name with.  Normally, this set will
## be empty, and the ButtonThrower will therefore ignore all ModifierButtons
## attached to the key events, but if one or more buttons have been added to
## this set, and those modifier buttons are set on the button event, then the
## event name will be prepended with the names of the modifier buttons.

proc setModifierButtons*(this: ButtonThrower, mods: ModifierButtons) {.importcpp: "#->set_modifier_buttons(#)".} ## \
## Changes the set of ModifierButtons that the ButtonThrower will consider
## important enough to prepend the event name with.  Normally, this set will
## be empty, and the ButtonThrower will therefore ignore all ModifierButtons
## attached to the key events, but if one or more buttons have been added to
## this set, then the event name will be prepended with the names of the
## modifier buttons.
##
## It is recommended that you change this setting by first calling
## get_modifier_buttons(), making adjustments, and passing the new value to
## set_modifier_buttons().  This way the current state of the modifier buttons
## will not be lost.

proc setThrowButtonsActive*(this: ButtonThrower, flag: bool) {.importcpp: "#->set_throw_buttons_active(#)".} ## \
## Sets the flag that indicates whether the ButtonThrower will only process
## events for the explicitly named buttons or not.  Normally this is false,
## meaning all buttons are processed; set it true to indicate that only some
## buttons should be processed.  See add_throw_button().

proc getThrowButtonsActive*(this: ButtonThrower): bool {.importcpp: "#->get_throw_buttons_active()".} ## \
## Returns the flag that indicates whether the ButtonThrower will only process
## events for the explicitly named buttons or not.  See
## set_throw_buttons_active().

proc addThrowButton*(this: ButtonThrower, mods: ModifierButtons, button: ButtonHandle): bool {.importcpp: "#->add_throw_button(#, #)".} ## \
## Adds a new button to the set of buttons that the ButtonThrower explicitly
## processes.
##
## If set_throw_buttons_active is false (which is the default), the
## ButtonThrower will process all buttons.  Otherwise, the ButtonThrower will
## only process events for the button(s) explicitly named by this function;
## buttons not on the list will be ignored by this object and passed on
## downstream to the child node(s) in the data graph.  A button that \*is\* on
## the list will be processed by the ButtonThrower and not passed on to the
## child node(s).
##
## The return value is true if the button is added, or false if it was already
## in the set.

proc removeThrowButton*(this: ButtonThrower, mods: ModifierButtons, button: ButtonHandle): bool {.importcpp: "#->remove_throw_button(#, #)".} ## \
## Removes the indicated button from the set of buttons that the ButtonThrower
## explicitly processes.  See add_throw_button().
##
## The return value is true if the button is removed, or false if it was not
## on the set.

proc hasThrowButton*(this: ButtonThrower, button: ButtonHandle): bool {.importcpp: "#->has_throw_button(#)".} ## \
## Returns true if the indicated button, in conjunction with any nonspecified
## modifier buttons, is on the set of buttons that will be processed by the
## ButtonThrower.  That is to say, returns true if this button was ever passed
## as the second parameter add_throw_button(), regardless of what the first
## parameter was.

proc hasThrowButton*(this: ButtonThrower, mods: ModifierButtons, button: ButtonHandle): bool {.importcpp: "#->has_throw_button(#, #)".} ## \
## Returns true if the indicated button is on the set of buttons that will be
## processed by the ButtonThrower, false otherwise.  See add_throw_button().

proc clearThrowButtons*(this: ButtonThrower) {.importcpp: "#->clear_throw_buttons()".} ## \
## Empties the set of buttons that were added via add_throw_button().  See
## add_throw_button().

converter getClassType*(_: typedesc[ButtonThrower]): TypeHandle {.importcpp: "ButtonThrower::get_class_type()", header: "buttonThrower.h".}

proc requireButton*(this: MouseInterfaceNode, button: ButtonHandle, is_down: bool) {.importcpp: "#->require_button(#, #)".} ## \
## Indicates that the indicated button must be in the required state (either
## up or down) in order for this particular MouseInterfaceNode to do anything.
## For instance, this may be called to make a Trackball object respect mouse
## input only when the control key is held down.

proc clearButton*(this: MouseInterfaceNode, button: ButtonHandle) {.importcpp: "#->clear_button(#)".} ## \
## Removes any requirement on the indicated button set by an earlier call to
## require_button().

proc clearAllButtons*(this: MouseInterfaceNode) {.importcpp: "#->clear_all_buttons()".} ## \
## Removes all requirements on buttons set by an earlier call to
## require_button().

converter getClassType*(_: typedesc[MouseInterfaceNode]): TypeHandle {.importcpp: "MouseInterfaceNode::get_class_type()", header: "mouseInterfaceNode.h".}

proc newMouseInterfaceNode*(param0: MouseInterfaceNode): MouseInterfaceNode {.importcpp: "new MouseInterfaceNode(#)".}

proc newDriveInterface*(param0: DriveInterface): DriveInterface {.importcpp: "new DriveInterface(#)".}

proc newDriveInterface*(name: string): DriveInterface {.importcpp: "new DriveInterface(nimStringToStdString(#))", header: stringConversionCode.}

proc newDriveInterface*(): DriveInterface {.importcpp: "new DriveInterface()".}

proc setForwardSpeed*(this: DriveInterface, speed: float32) {.importcpp: "#->set_forward_speed(#)".} ## \
## Sets the speed of full forward motion, when the mouse is at the very top of
## the window.  This is in units (e.g.  feet) per second.

proc getForwardSpeed*(this: DriveInterface): float32 {.importcpp: "#->get_forward_speed()".} ## \
## Returns the speed of full forward motion, when the mouse is at the very top
## of the window.  This is in units (e.g.  feet) per second.

proc setReverseSpeed*(this: DriveInterface, speed: float32) {.importcpp: "#->set_reverse_speed(#)".} ## \
## Sets the speed of full reverse motion, when the mouse is at the very bottom
## of the window.  This is in units (e.g.  feet) per second.

proc getReverseSpeed*(this: DriveInterface): float32 {.importcpp: "#->get_reverse_speed()".} ## \
## Returns the speed of full reverse motion, when the mouse is at the very
## bottom of the window.  This is in units (e.g.  feet) per second.

proc setRotateSpeed*(this: DriveInterface, speed: float32) {.importcpp: "#->set_rotate_speed(#)".} ## \
## Sets the maximum rate at which the user can rotate left or right, when the
## mouse is at the very edge of the window.  This is in degrees per second.

proc getRotateSpeed*(this: DriveInterface): float32 {.importcpp: "#->get_rotate_speed()".} ## \
## Returns the maximum rate at which the user can rotate left or right, when
## the mouse is at the very edge of the window.  This is in degrees per
## second.

proc setVerticalDeadZone*(this: DriveInterface, zone: float32) {.importcpp: "#->set_vertical_dead_zone(#)".} ## \
## Sets the size of the horizontal bar in the center of the screen that
## represents the "dead zone" of vertical motion: the region in which the
## mouse does not report vertical motion.  This is in a fraction of the window
## height, so 0.5 will set a dead zone as large as half the screen.

proc getVerticalDeadZone*(this: DriveInterface): float32 {.importcpp: "#->get_vertical_dead_zone()".} ## \
## Returns the size of the horizontal bar in the center of the screen that
## represents the "dead zone" of vertical motion: the region in which the
## mouse does not report vertical motion.  This is in a fraction of the window
## height, so 0.5 will set a dead zone as large as half the screen.

proc setHorizontalDeadZone*(this: DriveInterface, zone: float32) {.importcpp: "#->set_horizontal_dead_zone(#)".} ## \
## Sets the size of the vertical bar in the center of the screen that
## represents the "dead zone" of horizontal motion: the region in which the
## mouse does not report horizontal motion.  This is in a fraction of the
## window width, so 0.5 will set a dead zone as large as half the screen.

proc getHorizontalDeadZone*(this: DriveInterface): float32 {.importcpp: "#->get_horizontal_dead_zone()".} ## \
## Returns the size of the vertical bar in the center of the screen that
## represents the "dead zone" of horizontal motion: the region in which the
## mouse does not report horizontal motion.  This is in a fraction of the
## window width, so 0.5 will set a dead zone as large as half the screen.

proc setVerticalRampUpTime*(this: DriveInterface, ramp_up_time: float32) {.importcpp: "#->set_vertical_ramp_up_time(#)".} ## \
## Sets the amount of time, in seconds, it takes between the time an up or
## down arrow key is pressed and the time it registers full forward or
## backward motion.

proc getVerticalRampUpTime*(this: DriveInterface): float32 {.importcpp: "#->get_vertical_ramp_up_time()".} ## \
## Returns the amount of time, in seconds, it takes between the time an up or
## down arrow key is pressed and the time it registers full forward or
## backward motion.

proc setVerticalRampDownTime*(this: DriveInterface, ramp_down_time: float32) {.importcpp: "#->set_vertical_ramp_down_time(#)".} ## \
## Sets the amount of time, in seconds, it takes between the time an up or
## down arrow key is released and the time it registers no motion.

proc getVerticalRampDownTime*(this: DriveInterface): float32 {.importcpp: "#->get_vertical_ramp_down_time()".} ## \
## Returns the amount of time, in seconds, it takes between the time an up or
## down arrow key is released and the time it registers no motion.

proc setHorizontalRampUpTime*(this: DriveInterface, ramp_up_time: float32) {.importcpp: "#->set_horizontal_ramp_up_time(#)".} ## \
## Sets the amount of time, in seconds, it takes between the time a left or
## right arrow key is pressed and the time it registers full rotation.

proc getHorizontalRampUpTime*(this: DriveInterface): float32 {.importcpp: "#->get_horizontal_ramp_up_time()".} ## \
## Returns the amount of time, in seconds, it takes between the time a left or
## right arrow key is pressed and the time it registers full rotation.

proc setHorizontalRampDownTime*(this: DriveInterface, ramp_down_time: float32) {.importcpp: "#->set_horizontal_ramp_down_time(#)".} ## \
## Sets the amount of time, in seconds, it takes between the time a left or
## right arrow key is released and the time it registers no motion.

proc getHorizontalRampDownTime*(this: DriveInterface): float32 {.importcpp: "#->get_horizontal_ramp_down_time()".} ## \
## Returns the amount of time, in seconds, it takes between the time a left or
## right arrow key is released and the time it registers no motion.

proc getSpeed*(this: DriveInterface): float32 {.importcpp: "#->get_speed()".} ## \
## Returns the speed of the previous update in units/sec

proc getRotSpeed*(this: DriveInterface): float32 {.importcpp: "#->get_rot_speed()".} ## \
## Returns the rot_speed of the previous update in units/sec

proc reset*(this: DriveInterface) {.importcpp: "#->reset()".} ## \
## Reinitializes the driver to the origin and resets any knowledge about
## buttons being held down.

proc getPos*(this: DriveInterface): LPoint3 {.importcpp: "#->get_pos()".} ## \
## Returns the driver's position.

proc getX*(this: DriveInterface): float32 {.importcpp: "#->get_x()".}

proc getY*(this: DriveInterface): float32 {.importcpp: "#->get_y()".}

proc getZ*(this: DriveInterface): float32 {.importcpp: "#->get_z()".}

proc setPos*(this: DriveInterface, vec: LVecBase3) {.importcpp: "#->set_pos(#)".} ## \
## Directly sets the driver's position.

proc setPos*(this: DriveInterface, x: float32, y: float32, z: float32) {.importcpp: "#->set_pos(#, #, #)".}

proc setX*(this: DriveInterface, x: float32) {.importcpp: "#->set_x(#)".}

proc setY*(this: DriveInterface, y: float32) {.importcpp: "#->set_y(#)".}

proc setZ*(this: DriveInterface, z: float32) {.importcpp: "#->set_z(#)".}

proc getHpr*(this: DriveInterface): LVecBase3 {.importcpp: "#->get_hpr()".} ## \
## Returns the driver's orientation.

proc getH*(this: DriveInterface): float32 {.importcpp: "#->get_h()".}

proc getP*(this: DriveInterface): float32 {.importcpp: "#->get_p()".}

proc getR*(this: DriveInterface): float32 {.importcpp: "#->get_r()".}

proc setHpr*(this: DriveInterface, hpr: LVecBase3) {.importcpp: "#->set_hpr(#)".} ## \
## Directly sets the driver's orientation.

proc setHpr*(this: DriveInterface, h: float32, p: float32, r: float32) {.importcpp: "#->set_hpr(#, #, #)".}

proc setH*(this: DriveInterface, h: float32) {.importcpp: "#->set_h(#)".}

proc setP*(this: DriveInterface, p: float32) {.importcpp: "#->set_p(#)".}

proc setR*(this: DriveInterface, r: float32) {.importcpp: "#->set_r(#)".}

proc setForceRoll*(this: DriveInterface, force_roll: float32) {.importcpp: "#->set_force_roll(#)".} ## \
## This function is no longer used and does nothing.  It will be removed soon.

proc setIgnoreMouse*(this: DriveInterface, ignore_mouse: bool) {.importcpp: "#->set_ignore_mouse(#)".} ## \
## Changes the state of the ignore_mouse flag.  If this flag is true, the
## DriveInterface will ignore mouse down button events (but still recognize
## mouse up button events); the user will not be able to start the
## DriveInterface going again if it is stopped, but if the user is currently
## holding down a mouse button it will not stop immediately until the user
## eventually releases the button.

proc getIgnoreMouse*(this: DriveInterface): bool {.importcpp: "#->get_ignore_mouse()".} ## \
## Returns the current setting of the ignore_mouse flag.  See
## set_ignore_mouse().

proc setForceMouse*(this: DriveInterface, force_mouse: bool) {.importcpp: "#->set_force_mouse(#)".} ## \
## Changes the state of the force_mouse flag.  If this flag is true, the mouse
## button need not be held down in order to drive the avatar around.

proc getForceMouse*(this: DriveInterface): bool {.importcpp: "#->get_force_mouse()".} ## \
## Returns the current setting of the force_mouse flag.  See
## set_force_mouse().

proc setStopThisFrame*(this: DriveInterface, stop_this_frame: bool) {.importcpp: "#->set_stop_this_frame(#)".} ## \
## If stop_this_frame is true, the next time the frame is computed no motion
## will be allowed, and then the flag is reset to false.  This can be used to
## prevent too much movement when we know a long time has artificially
## elapsed, for instance when we take a screenshot, without munging the clock
## for everything else.

proc getStopThisFrame*(this: DriveInterface): bool {.importcpp: "#->get_stop_this_frame()".} ## \
## Returns the current setting of the stop_this_frame flag.  See
## set_stop_this_frame().

proc setMat*(this: DriveInterface, mat: LMatrix4) {.importcpp: "#->set_mat(#)".} ## \
## Stores the indicated transform in the DriveInterface.

proc getMat*(this: DriveInterface): LMatrix4 {.importcpp: "#->get_mat()".} ## \
## Returns the current transform.

proc forceDgraph*(this: DriveInterface) {.importcpp: "#->force_dgraph()".} ## \
## This is a special kludge for DriveInterface to allow us to avoid the one-
## frame latency after a collision.  It forces an immediate partial data flow
## for all data graph nodes below this node, causing all data nodes that
## depend on this matrix to be updated immediately.

converter getClassType*(_: typedesc[DriveInterface]): TypeHandle {.importcpp: "DriveInterface::get_class_type()", header: "driveInterface.h".}

proc newMouseSubregion*(param0: MouseSubregion): MouseSubregion {.importcpp: "new MouseSubregion(#)".}

proc newMouseSubregion*(name: string): MouseSubregion {.importcpp: "new MouseSubregion(nimStringToStdString(#))", header: stringConversionCode.}

proc getLeft*(this: MouseSubregion): float32 {.importcpp: "#->get_left()".} ## \
## Retrieves the x coordinate of the left edge of the rectangle within the
## window.  This number will be in the range [0..1].

proc getRight*(this: MouseSubregion): float32 {.importcpp: "#->get_right()".} ## \
## Retrieves the x coordinate of the right edge of the rectangle within the
## window.  This number will be in the range [0..1].

proc getBottom*(this: MouseSubregion): float32 {.importcpp: "#->get_bottom()".} ## \
## Retrieves the y coordinate of the bottom edge of the rectangle within the
## window.  This number will be in the range [0..1].

proc getTop*(this: MouseSubregion): float32 {.importcpp: "#->get_top()".} ## \
## Retrieves the y coordinate of the top edge of the rectangle within the
## window.  This number will be in the range [0..1].

proc setDimensions*(this: MouseSubregion, l: float32, r: float32, b: float32, t: float32) {.importcpp: "#->set_dimensions(#, #, #, #)".} ## \
## Changes the region of the window in which the mouse is considered to be
## active.  The parameters are identical to those for a DisplayRegion: they
## range from 0 to 1, where 0,0 is the lower left corner and 1,1 is the upper
## right; (0, 1, 0, 1) represents the whole window.

converter getClassType*(_: typedesc[MouseSubregion]): TypeHandle {.importcpp: "MouseSubregion::get_class_type()", header: "mouseSubregion.h".}

converter upcastToTypedWritableReferenceCount*(this: MouseWatcherRegion): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcastToNamable*(this: MouseWatcherRegion): Namable {.importcpp: "((Namable *)(MouseWatcherRegion *)(#))".}

proc newMouseWatcherRegion*(param0: MouseWatcherRegion): MouseWatcherRegion {.importcpp: "new MouseWatcherRegion(#)".}

proc newMouseWatcherRegion*(name: string, frame: LVecBase4): MouseWatcherRegion {.importcpp: "new MouseWatcherRegion(nimStringToStdString(#), #)", header: stringConversionCode.}

proc newMouseWatcherRegion*(name: string, left: float32, right: float32, bottom: float32, top: float32): MouseWatcherRegion {.importcpp: "new MouseWatcherRegion(nimStringToStdString(#), #, #, #, #)", header: stringConversionCode.}

proc setFrame*(this: MouseWatcherRegion, frame: LVecBase4) {.importcpp: "#->set_frame(#)".}

proc setFrame*(this: MouseWatcherRegion, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#->set_frame(#, #, #, #)".}

proc getFrame*(this: MouseWatcherRegion): LVecBase4 {.importcpp: "#->get_frame()".}

proc getArea*(this: MouseWatcherRegion): float32 {.importcpp: "#->get_area()".} ## \
## Returns the area of the rectangular region.

proc setSort*(this: MouseWatcherRegion, sort: int) {.importcpp: "#->set_sort(#)".} ## \
## Changes the sorting order of this particular region.  The sorting order is
## used to resolve conflicts in the case of overlapping region; the region
## with the highest sort value will be preferred, and between regions of the
## same sort value, the smallest region will be preferred.  The default
## sorting order, if none is explicitly specified, is 0.

proc getSort*(this: MouseWatcherRegion): int {.importcpp: "#->get_sort()".} ## \
## Returns the current sorting order of this region.  See set_sort().

proc setActive*(this: MouseWatcherRegion, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets whether the region is active or not.  If it is not active, the
## MouseWatcher will never consider the mouse to be over the region.  The
## region might still receive keypress events if its set_keyboard() flag is
## true.

proc getActive*(this: MouseWatcherRegion): bool {.importcpp: "#->get_active()".} ## \
## Returns whether the region is active or not.  See set_active().

proc setKeyboard*(this: MouseWatcherRegion, keyboard: bool) {.importcpp: "#->set_keyboard(#)".} ## \
## Sets whether the region is interested in global keyboard events.  If this
## is true, then any keyboard button events will be passed to press() and
## release() regardless of the position of the mouse onscreen; otherwise,
## these events will only be passed if the mouse is over the region.

proc getKeyboard*(this: MouseWatcherRegion): bool {.importcpp: "#->get_keyboard()".} ## \
## Returns whether the region is interested in global keyboard events; see
## set_keyboard().

proc setSuppressFlags*(this: MouseWatcherRegion, suppress_flags: int) {.importcpp: "#->set_suppress_flags(#)".} ## \
## Sets which events are suppressed when the mouse is over the region.  This
## is the union of zero or more various SF_\* values.  Normally, this is 0,
## indicating that no events are suppressed.
##
## If you set this to a non-zero value, for instance SF_mouse_position, then
## the mouse position will not be sent along the data graph when the mouse is
## over this particular region.

proc getSuppressFlags*(this: MouseWatcherRegion): int {.importcpp: "#->get_suppress_flags()".} ## \
## Returns the current suppress_flags.  See set_suppress_flags().

proc output*(this: MouseWatcherRegion, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: MouseWatcherRegion, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: MouseWatcherRegion, `out`: ostream) {.importcpp: "#->write(#)".}

converter getClassType*(_: typedesc[MouseWatcherRegion]): TypeHandle {.importcpp: "MouseWatcherRegion::get_class_type()", header: "mouseWatcherRegion.h".}

proc addRegion*(this: MouseWatcherBase, region: MouseWatcherRegion) {.importcpp: "#->add_region(#)".} ## \
## Adds the indicated region to the set of regions in the group.  It is no
## longer an error to call this for the same region more than once.

proc hasRegion*(this: MouseWatcherBase, region: MouseWatcherRegion): bool {.importcpp: "#->has_region(#)".} ## \
## Returns true if the indicated region has already been added to the
## MouseWatcherBase, false otherwise.

proc removeRegion*(this: MouseWatcherBase, region: MouseWatcherRegion): bool {.importcpp: "#->remove_region(#)".} ## \
## Removes the indicated region from the group.  Returns true if it was
## successfully removed, or false if it wasn't there in the first place.

proc findRegion*(this: MouseWatcherBase, name: string): MouseWatcherRegion {.importcpp: "#->find_region(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns a pointer to the first region found with the indicated name.  If
## multiple regions share the same name, the one that is returned is
## indeterminate.

proc clearRegions*(this: MouseWatcherBase) {.importcpp: "#->clear_regions()".} ## \
## Removes all the regions from the group.

proc sortRegions*(this: MouseWatcherBase) {.importcpp: "#->sort_regions()".} ## \
## Sorts all the regions in this group into pointer order.

proc isSorted*(this: MouseWatcherBase): bool {.importcpp: "#->is_sorted()".} ## \
## Returns true if the group has already been sorted, false otherwise.

proc getNumRegions*(this: MouseWatcherBase): clonglong {.importcpp: "#->get_num_regions()".} ## \
## Returns the number of regions in the group.

proc getRegion*(this: MouseWatcherBase, n: clonglong): MouseWatcherRegion {.importcpp: "#->get_region(#)".} ## \
## Returns the nth region of the group; returns NULL if there is no nth
## region.  Note that this is not thread-safe; another thread might have
## removed the nth region before you called this method.

proc output*(this: MouseWatcherBase, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: MouseWatcherBase, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: MouseWatcherBase, `out`: ostream) {.importcpp: "#->write(#)".}

proc showRegions*(this: MouseWatcherBase, render2d: NodePath, bin_name: string, draw_order: int) {.importcpp: "#->show_regions(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Enables the visualization of all of the regions handled by this
## MouseWatcherBase.  The supplied NodePath should be the root of the 2-d
## scene graph for the window.

proc setColor*(this: MouseWatcherBase, color: LColor) {.importcpp: "#->set_color(#)".} ## \
## Specifies the color used to draw the region rectangles for the regions
## visualized by show_regions().

proc hideRegions*(this: MouseWatcherBase) {.importcpp: "#->hide_regions()".} ## \
## Stops the visualization created by a previous call to show_regions().

proc updateRegions*(this: MouseWatcherBase) {.importcpp: "#->update_regions()".} ## \
## Refreshes the visualization created by show_regions().

converter getClassType*(_: typedesc[MouseWatcherBase]): TypeHandle {.importcpp: "MouseWatcherBase::get_class_type()", header: "mouseWatcherBase.h".}

converter upcastToMouseWatcherBase*(this: MouseWatcherGroup): MouseWatcherBase {.importcpp: "((MouseWatcherBase *)(MouseWatcherGroup *)(#))".}

converter upcastToReferenceCount*(this: MouseWatcherGroup): ReferenceCount {.importcpp: "(PT(ReferenceCount)(#))".}

converter getClassType*(_: typedesc[MouseWatcherGroup]): TypeHandle {.importcpp: "MouseWatcherGroup::get_class_type()", header: "mouseWatcherGroup.h".}

converter upcastToDataNode*(this: MouseWatcher): DataNode {.importcpp: "(PT(DataNode)(#))".}

converter upcastToMouseWatcherBase*(this: MouseWatcher): MouseWatcherBase {.importcpp: "((MouseWatcherBase *)(MouseWatcher *)(#))".}

proc newMouseWatcher*(name: string): MouseWatcher {.importcpp: "new MouseWatcher(nimStringToStdString(#))", header: stringConversionCode.}

proc newMouseWatcher*(): MouseWatcher {.importcpp: "new MouseWatcher()".}

proc removeRegion*(this: MouseWatcher, region: MouseWatcherRegion): bool {.importcpp: "#->remove_region(#)".} ## \
## Removes the indicated region from the group.  Returns true if it was
## successfully removed, or false if it wasn't there in the first place.

proc hasMouse*(this: MouseWatcher): bool {.importcpp: "#->has_mouse()".} ## \
## Returns true if the mouse is anywhere within the window, false otherwise.
## Also see is_mouse_open().

proc isMouseOpen*(this: MouseWatcher): bool {.importcpp: "#->is_mouse_open()".} ## \
## Returns true if the mouse is within the window and not over some particular
## MouseWatcherRegion that is marked to suppress mouse events; that is, that
## the mouse is in open space within the window.

proc getMouse*(this: MouseWatcher): LPoint2 {.importcpp: "#->get_mouse()".} ## \
## It is only valid to call this if has_mouse() returns true.  If so, this
## returns the current position of the mouse within the window.

proc getMouseX*(this: MouseWatcher): float32 {.importcpp: "#->get_mouse_x()".} ## \
## It is only valid to call this if has_mouse() returns true.  If so, this
## returns the current X position of the mouse within the window.

proc getMouseY*(this: MouseWatcher): float32 {.importcpp: "#->get_mouse_y()".} ## \
## It is only valid to call this if has_mouse() returns true.  If so, this
## returns the current Y position of the mouse within the window.

proc setFrame*(this: MouseWatcher, frame: LVecBase4) {.importcpp: "#->set_frame(#)".} ## \
## Sets the frame of the MouseWatcher.  This determines the coordinate space
## in which the MouseWatcherRegions should be expected to live.  Normally,
## this is left at -1, 1, -1, 1, which is the default setting, and matches the
## mouse coordinate range.
##
## Whatever values you specify here indicate the shape of the full screen, and
## the MouseWatcherRegions will be given in coordinate space matching it.  For
## instance, if you specify (0, 1, 0, 1), then a MouseWatcherRegion with the
## frame (0, 1, 0, .5) will cover the lower half of the screen.

proc setFrame*(this: MouseWatcher, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#->set_frame(#, #, #, #)".} ## \
## Sets the frame of the MouseWatcher.  See the next flavor of this method for
## a more verbose explanation.

proc getFrame*(this: MouseWatcher): LVecBase4 {.importcpp: "#->get_frame()".} ## \
## Returns the frame of the MouseWatcher.  See set_frame().

proc isOverRegion*(this: MouseWatcher): bool {.importcpp: "#->is_over_region()".} ## \
## Returns true if the mouse is over any rectangular region, false otherwise.

proc isOverRegion*(this: MouseWatcher, pos: LPoint2): bool {.importcpp: "#->is_over_region(#)".} ## \
## Returns true if the mouse is over any rectangular region, false otherwise.

proc isOverRegion*(this: MouseWatcher, x: float32, y: float32): bool {.importcpp: "#->is_over_region(#, #)".} ## \
## Returns true if the mouse is over any rectangular region, false otherwise.

proc getOverRegion*(this: MouseWatcher): MouseWatcherRegion {.importcpp: "#->get_over_region()".} ## \
## Returns the smallest region the mouse is currently over, or NULL if it is
## over no region.

proc getOverRegion*(this: MouseWatcher, pos: LPoint2): MouseWatcherRegion {.importcpp: "#->get_over_region(#)".} ## \
## Returns the preferred region the mouse is over.  In the case of overlapping
## regions, the region with the largest sort order is preferred; if two
## regions have the same sort order, then the smaller region is preferred.

proc getOverRegion*(this: MouseWatcher, x: float32, y: float32): MouseWatcherRegion {.importcpp: "#->get_over_region(#, #)".} ## \
## Returns the smallest region the indicated point is over, or NULL if it is
## over no region.

proc isButtonDown*(this: MouseWatcher, button: ButtonHandle): bool {.importcpp: "#->is_button_down(#)".} ## \
## Returns true if the indicated button is currently being held down, false
## otherwise.

proc setButtonDownPattern*(this: MouseWatcher, pattern: string) {.importcpp: "#->set_button_down_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the pattern string that indicates how the event names are generated
## when a button is depressed.  This is a string that may contain any of the
## following:
##
## %r  - the name of the region the mouse is over %b  - the name of the button
## pressed.
##
## The event name will be based on the in_pattern string specified here, with
## all occurrences of the above strings replaced with the corresponding
## values.

proc getButtonDownPattern*(this: MouseWatcher): string {.importcpp: "nimStringFromStdString(#->get_button_down_pattern())", header: stringConversionCode.} ## \
## Returns the string that indicates how event names are generated when a
## button is depressed.  See set_button_down_pattern().

proc setButtonUpPattern*(this: MouseWatcher, pattern: string) {.importcpp: "#->set_button_up_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the pattern string that indicates how the event names are generated
## when a button is released.  See set_button_down_pattern().

proc getButtonUpPattern*(this: MouseWatcher): string {.importcpp: "nimStringFromStdString(#->get_button_up_pattern())", header: stringConversionCode.} ## \
## Returns the string that indicates how event names are generated when a
## button is released.  See set_button_down_pattern().

proc setButtonRepeatPattern*(this: MouseWatcher, pattern: string) {.importcpp: "#->set_button_repeat_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the pattern string that indicates how the event names are generated
## when a button is continuously held and generates keyrepeat "down" events.
## This is a string that may contain any of the following:
##
## %r  - the name of the region the mouse is over %b  - the name of the button
## pressed.
##
## The event name will be based on the in_pattern string specified here, with
## all occurrences of the above strings replaced with the corresponding
## values.

proc getButtonRepeatPattern*(this: MouseWatcher): string {.importcpp: "nimStringFromStdString(#->get_button_repeat_pattern())", header: stringConversionCode.} ## \
## Returns the string that indicates how event names are names are generated
## when a button is continuously held and generates keyrepeat "down" events.
## See set_button_repeat_pattern().

proc setEnterPattern*(this: MouseWatcher, pattern: string) {.importcpp: "#->set_enter_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the pattern string that indicates how the event names are generated
## when the mouse enters a region.  This is different from within_pattern, in
## that a mouse is only "entered" in the topmost region at a given time, while
## it might be "within" multiple nested regions.

proc getEnterPattern*(this: MouseWatcher): string {.importcpp: "nimStringFromStdString(#->get_enter_pattern())", header: stringConversionCode.} ## \
## Returns the string that indicates how event names are generated when the
## mouse enters a region.  This is different from within_pattern, in that a
## mouse is only "entered" in the topmost region at a given time, while it
## might be "within" multiple nested regions.

proc setLeavePattern*(this: MouseWatcher, pattern: string) {.importcpp: "#->set_leave_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the pattern string that indicates how the event names are generated
## when the mouse leaves a region.  This is different from without_pattern, in
## that a mouse is only "entered" in the topmost region at a given time, while
## it might be "within" multiple nested regions.

proc getLeavePattern*(this: MouseWatcher): string {.importcpp: "nimStringFromStdString(#->get_leave_pattern())", header: stringConversionCode.} ## \
## Returns the string that indicates how event names are generated when the
## mouse leaves a region.  This is different from without_pattern, in that a
## mouse is only "entered" in the topmost region at a given time, while it
## might be "within" multiple nested regions.

proc setWithinPattern*(this: MouseWatcher, pattern: string) {.importcpp: "#->set_within_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the pattern string that indicates how the event names are generated
## when the mouse wanders over a region.  This is different from
## enter_pattern, in that a mouse is only "entered" in the topmost region at a
## given time, while it might be "within" multiple nested regions.

proc getWithinPattern*(this: MouseWatcher): string {.importcpp: "nimStringFromStdString(#->get_within_pattern())", header: stringConversionCode.} ## \
## Returns the string that indicates how event names are generated when the
## mouse wanders over a region.  This is different from enter_pattern, in that
## a mouse is only "entered" in the topmost region at a given time, while it
## might be "within" multiple nested regions.

proc setWithoutPattern*(this: MouseWatcher, pattern: string) {.importcpp: "#->set_without_pattern(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets the pattern string that indicates how the event names are generated
## when the mouse wanders out of a region.  This is different from
## leave_pattern, in that a mouse is only "entered" in the topmost region at a
## given time, while it might be "within" multiple nested regions.

proc getWithoutPattern*(this: MouseWatcher): string {.importcpp: "nimStringFromStdString(#->get_without_pattern())", header: stringConversionCode.} ## \
## Returns the string that indicates how event names are generated when the
## mouse wanders out of a region.  This is different from leave_pattern, in
## that a mouse is only "entered" in the topmost region at a given time, while
## it might be "within" multiple nested regions.

proc setGeometry*(this: MouseWatcher, node: PandaNode) {.importcpp: "#->set_geometry(#)".} ## \
## Sets the node that will be transformed each frame by the mouse's
## coordinates.  It will also be hidden when the mouse goes outside the
## window.  This can be used to implement a software mouse pointer for when a
## hardware (or system) mouse pointer is unavailable.

proc hasGeometry*(this: MouseWatcher): bool {.importcpp: "#->has_geometry()".} ## \
## Returns true if a software mouse pointer has been setup via set_geometry(),
## or false otherwise.  See set_geometry().

proc getGeometry*(this: MouseWatcher): PandaNode {.importcpp: "#->get_geometry()".} ## \
## Returns the node that has been set as the software mouse pointer, or NULL
## if no node has been set.  See has_geometry() and set_geometry().

proc clearGeometry*(this: MouseWatcher) {.importcpp: "#->clear_geometry()".} ## \
## Stops the use of the software cursor set up via set_geometry().

proc setExtraHandler*(this: MouseWatcher, eh: EventHandler) {.importcpp: "#->set_extra_handler(#)".} ## \
## As an optimization for the C++ Gui, an extra handler can be registered with
## a mouseWatcher so that events can be dealt with much sooner.

proc getExtraHandler*(this: MouseWatcher): EventHandler {.importcpp: "#->get_extra_handler()".} ## \
## As an optimization for the C++ Gui, an extra handler can be registered with
## a mouseWatcher so that events can be dealt with much sooner.

proc setModifierButtons*(this: MouseWatcher, mods: ModifierButtons) {.importcpp: "#->set_modifier_buttons(#)".} ## \
## Sets the buttons that should be monitored as modifier buttons for
## generating events to the MouseWatcherRegions.

proc getModifierButtons*(this: MouseWatcher): ModifierButtons {.importcpp: "#->get_modifier_buttons()".} ## \
## Returns the set of buttons that are being monitored as modifier buttons, as
## well as their current state.

proc setDisplayRegion*(this: MouseWatcher, dr: DisplayRegion) {.importcpp: "#->set_display_region(#)".} ## \
## Constrains the MouseWatcher to watching the mouse within a particular
## indicated region of the screen.  DataNodes parented under the MouseWatcher
## will observe the mouse and keyboard events only when the mouse is within
## the indicated region, and the observed range will be from -1 .. 1 across
## the region.
##
## Do not delete the DisplayRegion while it is owned by the MouseWatcher.

proc clearDisplayRegion*(this: MouseWatcher) {.importcpp: "#->clear_display_region()".} ## \
## Removes the display region constraint from the MouseWatcher, and restores
## it to the default behavior of watching the whole window.

proc getDisplayRegion*(this: MouseWatcher): DisplayRegion {.importcpp: "#->get_display_region()".} ## \
## Returns the display region the MouseWatcher is constrained to by
## set_display_region(), or NULL if it is not constrained.

proc hasDisplayRegion*(this: MouseWatcher): bool {.importcpp: "#->has_display_region()".} ## \
## Returns true if the MouseWatcher has been constrained to a particular
## region of the screen via set_display_region(), or false otherwise.  If this
## returns true, get_display_region() may be used to return the particular
## region.

proc addGroup*(this: MouseWatcher, group: MouseWatcherGroup): bool {.importcpp: "#->add_group(#)".} ## \
## Adds the indicated group of regions to the set of regions the MouseWatcher
## will monitor each frame.
##
## Since the MouseWatcher itself inherits from MouseWatcherBase, this
## operation is normally not necessary--you can simply add the Regions you
## care about one at a time.  Adding a complete group is useful when you may
## want to explicitly remove the regions as a group later.
##
## Returns true if the group was successfully added, or false if it was
## already on the list.

proc removeGroup*(this: MouseWatcher, group: MouseWatcherGroup): bool {.importcpp: "#->remove_group(#)".} ## \
## Removes the indicated group from the set of extra groups associated with
## the MouseWatcher.  Returns true if successful, or false if the group was
## already removed or was never added via add_group().

proc replaceGroup*(this: MouseWatcher, old_group: MouseWatcherGroup, new_group: MouseWatcherGroup): bool {.importcpp: "#->replace_group(#, #)".} ## \
## Atomically removes old_group from the MouseWatcher, and replaces it with
## new_group.  Presumably old_group and new_group might have some regions in
## common; these are handled properly.
##
## If old_group is not already present, simply adds new_group and returns
## false.  Otherwise, removes old_group and adds new_group, and then returns
## true.

proc getNumGroups*(this: MouseWatcher): int {.importcpp: "#->get_num_groups()".} ## \
## Returns the number of separate groups added to the MouseWatcher via
## add_group().

proc getGroup*(this: MouseWatcher, n: int): MouseWatcherGroup {.importcpp: "#->get_group(#)".} ## \
## Returns the nth group added to the MouseWatcher via add_group().

proc setInactivityTimeout*(this: MouseWatcher, timeout: float64) {.importcpp: "#->set_inactivity_timeout(#)".} ## \
## Sets an inactivity timeout on the mouse activity.  When this timeout (in
## seconds) is exceeded with no keyboard or mouse activity, all currently-held
## buttons are automatically released.  This is intended to help protect
## against people who inadvertently (or intentionally) leave a keyboard key
## stuck down and then wander away from the keyboard.
##
## Also, when this timeout expires, the event specified by
## set_inactivity_timeout_event() will be generated.

proc hasInactivityTimeout*(this: MouseWatcher): bool {.importcpp: "#->has_inactivity_timeout()".} ## \
## Returns true if an inactivity timeout has been set, false otherwise.

proc getInactivityTimeout*(this: MouseWatcher): float64 {.importcpp: "#->get_inactivity_timeout()".} ## \
## Returns the inactivity timeout that has been set.  It is an error to call
## this if has_inactivity_timeout() returns false.

proc clearInactivityTimeout*(this: MouseWatcher) {.importcpp: "#->clear_inactivity_timeout()".} ## \
## Removes the inactivity timeout and restores the MouseWatcher to its default
## behavior of allowing a key to be held indefinitely.

proc setInactivityTimeoutEvent*(this: MouseWatcher, event: string) {.importcpp: "#->set_inactivity_timeout_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the event string that will be generated when the inactivity
## timeout counter expires.  See set_inactivity_timeout().

proc getInactivityTimeoutEvent*(this: MouseWatcher): string {.importcpp: "nimStringFromStdString(#->get_inactivity_timeout_event())", header: stringConversionCode.} ## \
## Returns the event string that will be generated when the inactivity timeout
## counter expires.  See set_inactivity_timeout().

proc getTrailLog*(this: MouseWatcher): PointerEventList {.importcpp: "deconstify(#->get_trail_log())", header: deconstifyCode.} ## \
## Obtain the mouse trail log.  This is a PointerEventList.  Does not make a
## copy, therefore, this PointerEventList will be updated each time
## process_events gets called.
##
## To use trail logging, you need to enable the generation of pointer events
## in the GraphicsWindowInputDevice and set the trail log duration in the
## MouseWatcher.  Otherwise, the trail log will be empty.

proc numTrailRecent*(this: MouseWatcher): clonglong {.importcpp: "#->num_trail_recent()".} ## \
## This counter indicates how many events were added to the trail log this
## frame.  The trail log is updated once per frame, during the process_events
## operation.

proc setTrailLogDuration*(this: MouseWatcher, duration: float64) {.importcpp: "#->set_trail_log_duration(#)".} ## \
## If the duration is nonzero, causes the MouseWatcher to log the mouse's
## trail.  Events older than the specified duration are discarded.  If the
## duration is zero, logging is disabled.

proc getTrailNode*(this: MouseWatcher): GeomNode {.importcpp: "#->get_trail_node()".} ## \
## Returns a GeomNode that represents the mouse trail.  The intent is that you
## should reparent this GeomNode to Render2D, and then forget about it.  The
## MouseWatcher will continually update the trail node.  There is only one
## trail node, it does not create a new one each time you call get_trail_node.
##
## This is not a particularly beautiful way to render a mouse trail.  It is
## intended more for debugging purposes than for finished applications.  Even
## so, It is suggested that you might want to apply a line thickness and
## antialias mode to the line --- doing so makes it look a lot better.

proc clearTrailNode*(this: MouseWatcher) {.importcpp: "#->clear_trail_node()".} ## \
## If you have previously fetched the trail node using get_trail_node, then
## the MouseWatcher is continually updating the trail node every frame.  Using
## clear_trail_node causes the MouseWatcher to forget the trail node and stop
## updating it.

proc clearTrailLog*(this: MouseWatcher) {.importcpp: "#->clear_trail_log()".} ## \
## Clears the mouse trail log.  This does not prevent further accumulation of
## the log given future events.

proc noteActivity*(this: MouseWatcher) {.importcpp: "#->note_activity()".} ## \
## Can be used in conjunction with the inactivity timeout to inform the
## MouseWatcher that the user has just performed some action which proves
## he/she is present.  It may be necessary to call this for external events,
## such as joystick action, that the MouseWatcher might otherwise not know
## about.  This will reset the current inactivity timer.  When the inactivity
## timer reaches the length of time specified by set_inactivity_timeout(),
## with no keyboard or mouse activity and no calls to note_activity(), then
## any buttons held will be automatically released.

converter getClassType*(_: typedesc[MouseWatcher]): TypeHandle {.importcpp: "MouseWatcher::get_class_type()", header: "mouseWatcher.h".}

proc hasButton*(this: MouseWatcherParameter): bool {.importcpp: "#.has_button()".} ## \
## Returns true if this parameter has an associated mouse or keyboard button,
## false otherwise.

proc getButton*(this: MouseWatcherParameter): ButtonHandle {.importcpp: "#.get_button()".} ## \
## Returns the mouse or keyboard button associated with this event.  If
## has_button(), above, returns false, this returns ButtonHandle::none().

proc isKeyrepeat*(this: MouseWatcherParameter): bool {.importcpp: "#.is_keyrepeat()".} ## \
## Returns true if the button-down even was generated due to keyrepeat, or
## false if it was an original button down.

proc hasKeycode*(this: MouseWatcherParameter): bool {.importcpp: "#.has_keycode()".} ## \
## Returns true if this parameter has an associated keycode, false otherwise.

proc getKeycode*(this: MouseWatcherParameter): int {.importcpp: "#.get_keycode()".} ## \
## Returns the keycode associated with this event.  If has_keycode(), above,
## returns false, this returns 0.

proc hasCandidate*(this: MouseWatcherParameter): bool {.importcpp: "#.has_candidate()".} ## \
## Returns true if this parameter has an associated candidate string, false
## otherwise.

proc getCandidateStringEncoded*(this: MouseWatcherParameter): string {.importcpp: "nimStringFromStdString(#.get_candidate_string_encoded())", header: stringConversionCode.} ## \
## Returns the candidate string associated with this event.  If
## has_candidate(), above, returns false, this returns the empty string.

proc getHighlightStart*(this: MouseWatcherParameter): clonglong {.importcpp: "#.get_highlight_start()".} ## \
## Returns the first highlighted character in the candidate string.

proc getHighlightEnd*(this: MouseWatcherParameter): clonglong {.importcpp: "#.get_highlight_end()".} ## \
## Returns one more than the last highlighted character in the candidate
## string.

proc getCursorPos*(this: MouseWatcherParameter): clonglong {.importcpp: "#.get_cursor_pos()".} ## \
## Returns the position of the user's edit cursor within the candidate string.

proc getModifierButtons*(this: MouseWatcherParameter): ModifierButtons {.importcpp: "#.get_modifier_buttons()".} ## \
## Returns the set of modifier buttons that were being held down while the
## event was generated.

proc hasMouse*(this: MouseWatcherParameter): bool {.importcpp: "#.has_mouse()".} ## \
## Returns true if this parameter has an associated mouse position, false
## otherwise.

proc getMouse*(this: MouseWatcherParameter): LPoint2 {.importcpp: "#.get_mouse()".} ## \
## Returns the mouse position at the time the event was generated, in the
## normalized range (-1 .. 1).  It is valid to call this only if has_mouse()
## returned true.

proc isOutside*(this: MouseWatcherParameter): bool {.importcpp: "#.is_outside()".} ## \
## Returns true if the mouse was outside the region at the time the event was
## generated, false otherwise.  This is only valid for "release" type events.

proc output*(this: MouseWatcherParameter, `out`: ostream) {.importcpp: "#.output(#)".}

proc newTrackball*(param0: Trackball): Trackball {.importcpp: "new Trackball(#)".}

proc newTrackball*(name: string): Trackball {.importcpp: "new Trackball(nimStringToStdString(#))", header: stringConversionCode.}

proc reset*(this: Trackball) {.importcpp: "#->reset()".} ## \
## Reinitializes all transforms to identity.

proc getForwardScale*(this: Trackball): float32 {.importcpp: "#->get_forward_scale()".} ## \
## Returns the scale factor applied to forward and backward motion.  See
## set_forward_scale().

proc setForwardScale*(this: Trackball, fwdscale: float32) {.importcpp: "#->set_forward_scale(#)".} ## \
## Changes the scale factor applied to forward and backward motion.  The
## larger this number, the faster the model will move in response to dollying
## in and out.

proc getPos*(this: Trackball): LPoint3 {.importcpp: "#->get_pos()".} ## \
## Return the offset from the center of rotation.

proc getX*(this: Trackball): float32 {.importcpp: "#->get_x()".}

proc getY*(this: Trackball): float32 {.importcpp: "#->get_y()".}

proc getZ*(this: Trackball): float32 {.importcpp: "#->get_z()".}

proc setPos*(this: Trackball, vec: LVecBase3) {.importcpp: "#->set_pos(#)".} ## \
## Directly set the offset from the rotational origin.

proc setPos*(this: Trackball, x: float32, y: float32, z: float32) {.importcpp: "#->set_pos(#, #, #)".}

proc setX*(this: Trackball, x: float32) {.importcpp: "#->set_x(#)".}

proc setY*(this: Trackball, y: float32) {.importcpp: "#->set_y(#)".}

proc setZ*(this: Trackball, z: float32) {.importcpp: "#->set_z(#)".}

proc getHpr*(this: Trackball): LVecBase3 {.importcpp: "#->get_hpr()".} ## \
## Return the trackball's orientation.

proc getH*(this: Trackball): float32 {.importcpp: "#->get_h()".}

proc getP*(this: Trackball): float32 {.importcpp: "#->get_p()".}

proc getR*(this: Trackball): float32 {.importcpp: "#->get_r()".}

proc setHpr*(this: Trackball, hpr: LVecBase3) {.importcpp: "#->set_hpr(#)".} ## \
## Directly set the mover's orientation.

proc setHpr*(this: Trackball, h: float32, p: float32, r: float32) {.importcpp: "#->set_hpr(#, #, #)".}

proc setH*(this: Trackball, h: float32) {.importcpp: "#->set_h(#)".}

proc setP*(this: Trackball, p: float32) {.importcpp: "#->set_p(#)".}

proc setR*(this: Trackball, r: float32) {.importcpp: "#->set_r(#)".}

proc resetOriginHere*(this: Trackball) {.importcpp: "#->reset_origin_here()".} ## \
## Reposition the center of rotation to coincide with the current translation
## offset.  Future rotations will be about the current origin.

proc moveOrigin*(this: Trackball, x: float32, y: float32, z: float32) {.importcpp: "#->move_origin(#, #, #)".} ## \
## Moves the center of rotation by the given amount.

proc getOrigin*(this: Trackball): LPoint3 {.importcpp: "#->get_origin()".} ## \
## Returns the current center of rotation.

proc setOrigin*(this: Trackball, origin: LVecBase3) {.importcpp: "#->set_origin(#)".} ## \
## Directly sets the center of rotation.

proc setInvert*(this: Trackball, flag: bool) {.importcpp: "#->set_invert(#)".} ## \
## Sets the invert flag.  When this is set, the inverse matrix is generated,
## suitable for joining to a camera, instead of parenting the scene under it.

proc getInvert*(this: Trackball): bool {.importcpp: "#->get_invert()".} ## \
## Returns the invert flag.  When this is set, the inverse matrix is
## generated, suitable for joining to a camera, instead of parenting the scene
## under it.

proc setRelTo*(this: Trackball, rel_to: NodePath) {.importcpp: "#->set_rel_to(#)".} ## \
## Sets the NodePath that all trackball manipulations are to be assumed to be
## relative to.  For instance, set your camera node here to make the trackball
## motion camera relative.  The default is the empty path, which means
## trackball motion is in global space.

proc getRelTo*(this: Trackball): NodePath {.importcpp: "#->get_rel_to()".} ## \
## Returns the NodePath that all trackball manipulations are relative to, or
## the empty path.

proc setCoordinateSystem*(this: Trackball, cs: CoordinateSystem) {.importcpp: "#->set_coordinate_system(#)".} ## \
## Sets the coordinate system of the Trackball.  Normally, this is the default
## coordinate system.  This changes the axes the Trackball manipulates so that
## the user interface remains consistent across different coordinate systems.

proc getCoordinateSystem*(this: Trackball): CoordinateSystem {.importcpp: "#->get_coordinate_system()".} ## \
## Returns the coordinate system of the Trackball.  See
## set_coordinate_system().

proc setMat*(this: Trackball, mat: LMatrix4) {.importcpp: "#->set_mat(#)".} ## \
## Stores the indicated transform in the trackball.  This is a transform in
## global space, regardless of the rel_to node.

proc getMat*(this: Trackball): LMatrix4 {.importcpp: "#->get_mat()".} ## \
## Returns the matrix represented by the trackball rotation.

proc getTransMat*(this: Trackball): LMatrix4 {.importcpp: "#->get_trans_mat()".} ## \
## Returns the actual transform that will be applied to the scene graph.  This
## is the same as get_mat(), unless invert is in effect.

converter getClassType*(_: typedesc[Trackball]): TypeHandle {.importcpp: "Trackball::get_class_type()", header: "trackball.h".}

proc newTransform2SG*(param0: Transform2SG): Transform2SG {.importcpp: "new Transform2SG(#)".}

proc newTransform2SG*(name: string): Transform2SG {.importcpp: "new Transform2SG(nimStringToStdString(#))", header: stringConversionCode.}

proc setNode*(this: Transform2SG, node: PandaNode) {.importcpp: "#->set_node(#)".} ## \
## Sets the node that this object will adjust.

proc getNode*(this: Transform2SG): PandaNode {.importcpp: "#->get_node()".} ## \
## Returns the node that this object will adjust, or NULL if the node has not
## yet been set.

converter getClassType*(_: typedesc[Transform2SG]): TypeHandle {.importcpp: "Transform2SG::get_class_type()", header: "transform2sg.h".}

proc play*(this: AnimInterface) {.importcpp: "#->play()".} ## \
## Runs the entire animation from beginning to end and stops.

proc play*(this: AnimInterface, `from`: float64, to: float64) {.importcpp: "#->play(#, #)".} ## \
## Runs the animation from the frame "from" to and including the frame "to",
## at which point the animation is stopped.  Both "from" and "to" frame
## numbers may be outside the range (0, get_num_frames()) and the animation
## will follow the range correctly, reporting numbers modulo get_num_frames().
## For instance, play(0, get_num_frames() \* 2) will play the animation twice
## and then stop.

proc loop*(this: AnimInterface, restart: bool) {.importcpp: "#->loop(#)".} ## \
## Starts the entire animation looping.  If restart is true, the animation is
## restarted from the beginning; otherwise, it continues from the current
## frame.

proc loop*(this: AnimInterface, restart: bool, `from`: float64, to: float64) {.importcpp: "#->loop(#, #, #)".} ## \
## Loops the animation from the frame "from" to and including the frame "to",
## indefinitely.  If restart is true, the animation is restarted from the
## beginning; otherwise, it continues from the current frame.

proc pingpong*(this: AnimInterface, restart: bool) {.importcpp: "#->pingpong(#)".} ## \
## Starts the entire animation bouncing back and forth between its first frame
## and last frame.  If restart is true, the animation is restarted from the
## beginning; otherwise, it continues from the current frame.

proc pingpong*(this: AnimInterface, restart: bool, `from`: float64, to: float64) {.importcpp: "#->pingpong(#, #, #)".} ## \
## Loops the animation from the frame "from" to and including the frame "to",
## and then back in the opposite direction, indefinitely.

proc stop*(this: AnimInterface) {.importcpp: "#->stop()".} ## \
## Stops a currently playing or looping animation right where it is.  The
## animation remains posed at the current frame.

proc pose*(this: AnimInterface, frame: float64) {.importcpp: "#->pose(#)".} ## \
## Sets the animation to the indicated frame and holds it there.

proc setPlayRate*(this: AnimInterface, play_rate: float64) {.importcpp: "#->set_play_rate(#)".} ## \
## Changes the rate at which the animation plays.  1.0 is the normal speed,
## 2.0 is twice normal speed, and 0.5 is half normal speed.  0.0 is legal to
## pause the animation, and a negative value will play the animation
## backwards.

proc getPlayRate*(this: AnimInterface): float64 {.importcpp: "#->get_play_rate()".} ## \
## Returns the rate at which the animation plays.  See set_play_rate().

proc getFrameRate*(this: AnimInterface): float64 {.importcpp: "#->get_frame_rate()".} ## \
## Returns the native frame rate of the animation.  This is the number of
## frames per second that will elapse when the play_rate is set to 1.0.  It is
## a fixed property of the animation and may not be adjusted by the user.

proc getNumFrames*(this: AnimInterface): int {.importcpp: "#->get_num_frames()".} ## \
## Returns the number of frames in the animation.  This is a property of the
## animation and may not be directly adjusted by the user (although it may
## change without warning with certain kinds of animations, since this is a
## virtual method that may be overridden).

proc getFrame*(this: AnimInterface): int {.importcpp: "#->get_frame()".} ## \
## Returns the current integer frame number.  This number will be in the range
## 0 <= f < get_num_frames().

proc getNextFrame*(this: AnimInterface): int {.importcpp: "#->get_next_frame()".} ## \
## Returns the current integer frame number + 1, constrained to the range 0 <=
## f < get_num_frames().
##
## If the play mode is PM_play, this will clamp to the same value as
## get_frame() at the end of the animation.  If the play mode is any other
## value, this will wrap around to frame 0 at the end of the animation.

proc getFrac*(this: AnimInterface): float64 {.importcpp: "#->get_frac()".} ## \
## Returns the fractional part of the current frame.  Normally, this is in the
## range 0.0 <= f < 1.0, but in the one special case of an animation playing
## to its end frame and stopping, it might exactly equal 1.0.
##
## It will always be true that get_full_frame() + get_frac() ==
## get_full_fframe().

proc getFullFrame*(this: AnimInterface): int {.importcpp: "#->get_full_frame()".} ## \
## Returns the current integer frame number.
##
## Unlike the value returned by get_frame(), this frame number may extend
## beyond the range of get_num_frames() if the frame range passed to play(),
## loop(), etc.  did.
##
## Unlike the value returned by get_full_fframe(), this return value will
## never exceed the value passed to to_frame in the play() method.

proc getFullFframe*(this: AnimInterface): float64 {.importcpp: "#->get_full_fframe()".} ## \
## Returns the current floating-point frame number.
##
## Unlike the value returned by get_frame(), this frame number may extend
## beyond the range of get_num_frames() if the frame range passed to play(),
## loop(), etc.  did.
##
## Unlike the value returned by get_full_frame(), this return value may equal
## (to_frame + 1.0), when the animation has played to its natural end.
## However, in this case the return value of get_full_frame() will be
## to_frame, not (to_frame + 1).

proc isPlaying*(this: AnimInterface): bool {.importcpp: "#->is_playing()".} ## \
## Returns true if the animation is currently playing, false if it is stopped
## (e.g.  because stop() or pose() was called, or because it reached the end
## of the animation after play() was called).

proc output*(this: AnimInterface, `out`: ostream) {.importcpp: "#->output(#)".}

converter getClassType*(_: typedesc[AnimInterface]): TypeHandle {.importcpp: "AnimInterface::get_class_type()", header: "animInterface.h".}

proc initUpdateSeq*(): UpdateSeq {.importcpp: "UpdateSeq()".} ## \
## Creates an UpdateSeq in the 'initial' state.

proc initUpdateSeq*(copy: UpdateSeq): UpdateSeq {.importcpp: "UpdateSeq(#)".}

proc initial*(_: typedesc[UpdateSeq]): UpdateSeq {.importcpp: "UpdateSeq::initial()", header: "updateSeq.h".}

proc old*(_: typedesc[UpdateSeq]): UpdateSeq {.importcpp: "UpdateSeq::old()", header: "updateSeq.h".}

proc fresh*(_: typedesc[UpdateSeq]): UpdateSeq {.importcpp: "UpdateSeq::fresh()", header: "updateSeq.h".}

proc clear*(this: UpdateSeq) {.importcpp: "#.clear()".} ## \
## Resets the UpdateSeq to the 'initial' state.

proc isInitial*(this: UpdateSeq): bool {.importcpp: "#.is_initial()".} ## \
## Returns true if the UpdateSeq is in the 'initial' state.

proc isOld*(this: UpdateSeq): bool {.importcpp: "#.is_old()".} ## \
## Returns true if the UpdateSeq is in the 'old' state.

proc isFresh*(this: UpdateSeq): bool {.importcpp: "#.is_fresh()".} ## \
## Returns true if the UpdateSeq is in the 'fresh' state.

proc isSpecial*(this: UpdateSeq): bool {.importcpp: "#.is_special()".} ## \
## Returns true if the UpdateSeq is in any special states, i.e.  'initial',
## 'old', or 'fresh'.

proc `==`*(this: UpdateSeq, other: UpdateSeq): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: UpdateSeq, other: UpdateSeq): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: UpdateSeq, other: UpdateSeq): bool {.importcpp: "#.operator <(#)".}

proc `<=`*(this: UpdateSeq, other: UpdateSeq): bool {.importcpp: "#.operator <=(#)".}

proc `>`*(this: UpdateSeq, other: UpdateSeq): bool {.importcpp: "#.operator >(#)".}

proc `>=`*(this: UpdateSeq, other: UpdateSeq): bool {.importcpp: "#.operator >=(#)".}

proc `++`*(this: UpdateSeq): UpdateSeq {.importcpp: "#.operator ++()".}

proc `++`*(this: UpdateSeq, param0: int): UpdateSeq {.importcpp: "#.operator ++(#)".}

proc getSeq*(this: UpdateSeq): int {.importcpp: "#.get_seq()".} ## \
## Returns the internal integer value associated with the UpdateSeq.  Useful
## for debugging only.

proc output*(this: UpdateSeq, `out`: ostream) {.importcpp: "#.output(#)".}

proc fillin*(this: TypedWritable, scan: DatagramIterator, manager: BamReader) {.importcpp: "#->fillin(#, #)".} ## \
## This internal function is intended to be called by each class's
## make_from_bam() method to read in all of the relevant data from the BamFile
## for the new object.  It is also called directly by the BamReader to re-read
## the data for an object that has been placed on the stream for an update.

proc markBamModified*(this: TypedWritable) {.importcpp: "#->mark_bam_modified()".} ## \
## Increments the bam_modified counter, so that this object will be
## invalidated and retransmitted on any open bam streams.  This should
## normally not need to be called by user code; it should be called internally
## when the object has been changed in a way that legitimately requires its
## retransmission to any connected clients.

proc getBamModified*(this: TypedWritable): UpdateSeq {.importcpp: "#->get_bam_modified()".} ## \
## Returns the current bam_modified counter.  This counter is normally
## incremented automatically whenever the object is modified.

converter getClassType*(_: typedesc[TypedWritable]): TypeHandle {.importcpp: "TypedWritable::get_class_type()", header: "typedWritable.h".}

converter upcastToTypedWritable*(this: TypedWritableReferenceCount): TypedWritable {.importcpp: "((TypedWritable *)(TypedWritableReferenceCount *)(#))".}

converter upcastToReferenceCount*(this: TypedWritableReferenceCount): ReferenceCount {.importcpp: "(PT(ReferenceCount)(#))".}

converter getClassType*(_: typedesc[TypedWritableReferenceCount]): TypeHandle {.importcpp: "TypedWritableReferenceCount::get_class_type()", header: "typedWritableReferenceCount.h".}

converter upcastToTypedWritableReferenceCount*(this: BamCacheRecord): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

proc makeCopy*(this: BamCacheRecord): BamCacheRecord {.importcpp: "#->make_copy()".} ## \
## Returns a duplicate of the BamCacheRecord.  The duplicate will not have a
## data pointer set, even though one may have been assigned to the original
## via set_data().

proc `==`*(this: BamCacheRecord, other: BamCacheRecord): bool {.importcpp: "#->operator ==(#)".}

proc getSourcePathname*(this: BamCacheRecord): Filename {.importcpp: "#->get_source_pathname()".} ## \
## Returns the full pathname to the source file that originally generated this
## cache request.  In some cases, for instance in the case of a of a multipage
## texture like "cube_#.png", this may not not a true filename on disk.

proc getCacheFilename*(this: BamCacheRecord): Filename {.importcpp: "#->get_cache_filename()".} ## \
## Returns the name of the cache file as hashed from the source_pathname.
## This will be relative to the root of the cache directory, and it will not
## include any suffixes that may be appended to resolve hash conflicts.

proc getSourceTimestamp*(this: BamCacheRecord): time_t.Time {.importcpp: "#->get_source_timestamp()".} ## \
## Returns the file timestamp of the original source file that generated this
## cache record, if available.  In some cases the original file timestamp is
## not available, and this will return 0.

proc getRecordedTime*(this: BamCacheRecord): time_t.Time {.importcpp: "#->get_recorded_time()".} ## \
## Returns the time at which this particular record was recorded or updated.

proc getNumDependentFiles*(this: BamCacheRecord): int {.importcpp: "#->get_num_dependent_files()".} ## \
## Returns the number of source files that contribute to the cache.

proc getDependentPathname*(this: BamCacheRecord, n: int): Filename {.importcpp: "#->get_dependent_pathname(#)".} ## \
## Returns the full pathname of the nth source files that contributes to the
## cache.

proc dependentsUnchanged*(this: BamCacheRecord): bool {.importcpp: "#->dependents_unchanged()".} ## \
## Returns true if all of the dependent files are still the same as when the
## cache was recorded, false otherwise.

proc clearDependentFiles*(this: BamCacheRecord) {.importcpp: "#->clear_dependent_files()".} ## \
## Empties the list of files that contribute to the data in this record.

proc addDependentFile*(this: BamCacheRecord, pathname: Filename) {.importcpp: "#->add_dependent_file(#)".} ## \
## Adds the indicated file to the list of files that will be loaded to
## generate the data in this record.  This should be called once for the
## primary source file, and again for each secondary source file, if any.

proc addDependentFile*(this: BamCacheRecord, file: VirtualFile) {.importcpp: "#->add_dependent_file(#)".} ## \
## Variant of add_dependent_file that takes an already opened VirtualFile.

proc hasData*(this: BamCacheRecord): bool {.importcpp: "#->has_data()".} ## \
## Returns true if this cache record has an in-memory data object associated--
## that is, the object stored in the cache.

proc clearData*(this: BamCacheRecord) {.importcpp: "#->clear_data()".} ## \
## Removes the in-memory data object associated with this record, if any.
## This does not affect the on-disk representation of the record.

proc getData*(this: BamCacheRecord): TypedWritable {.importcpp: "#->get_data()".} ## \
## Returns a pointer to the data stored in the record, or NULL if there is no
## data.  The pointer is not removed from the record.

proc setData*(this: BamCacheRecord, `ptr`: TypedWritable) {.importcpp: "#->set_data(#)".} ## \
## This variant on set_data() is provided to easily pass objects deriving from
## TypedWritable.

proc setData*(this: BamCacheRecord, `ptr`: TypedWritable, ref_ptr: ReferenceCount) {.importcpp: "#->set_data(#, #)".} ## \
## Stores a new data object on the record.  You should pass the same pointer
## twice, to both parameters; this allows the C++ typecasting to automatically
## convert the pointer into both a TypedWritable and a ReferenceCount pointer,
## so that the BamCacheRecord object can reliably manage the reference counts.
##
## You may pass 0 or NULL as the second parameter.  If you do this, the
## BamCacheRecord will not manage the object's reference count; it will be up
## to you to ensure the object is not deleted during the lifetime of the
## BamCacheRecord object.

proc setData*(this: BamCacheRecord, `ptr`: TypedWritable, dummy: int) {.importcpp: "#->set_data(#, #)".} ## \
## This variant on set_data() is provided just to allow Python code to pass a
## 0 as the second parameter.

proc setData*(this: BamCacheRecord, `ptr`: TypedWritableReferenceCount) {.importcpp: "#->set_data(#)".} ## \
## This variant on set_data() is provided to easily pass objects deriving from
## TypedWritableReferenceCount.

proc output*(this: BamCacheRecord, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: BamCacheRecord, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: BamCacheRecord, `out`: ostream) {.importcpp: "#->write(#)".}

converter getClassType*(_: typedesc[BamCacheRecord]): TypeHandle {.importcpp: "BamCacheRecord::get_class_type()", header: "bamCacheRecord.h".}

proc initBamCache*(): BamCache {.importcpp: "BamCache()".}

proc setActive*(this: BamCache, flag: bool) {.importcpp: "#.set_active(#)".} ## \
## Changes the state of the active flag.  "active" means that the cache should
## be consulted automatically on loads, "not active" means that objects should
## be loaded directly without consulting the cache.
##
## This represents the global flag.  Also see the individual cache_models,
## cache_textures, cache_compressed_textures flags.

proc getActive*(this: BamCache): bool {.importcpp: "#.get_active()".} ## \
## Returns true if the BamCache is currently active, false if it is not.
## "active" means that the cache should be consulted automatically on loads,
## "not active" means that objects should be loaded directly without
## consulting the cache.
##
## This represents the global flag.  Also see the individual cache_models,
## cache_textures, cache_compressed_textures flags.

proc setCacheModels*(this: BamCache, flag: bool) {.importcpp: "#.set_cache_models(#)".} ## \
## Indicates whether model files (e.g.  egg files and bam files) will be
## stored in the cache, as bam files.

proc getCacheModels*(this: BamCache): bool {.importcpp: "#.get_cache_models()".} ## \
## Returns whether model files (e.g.  egg files and bam files) will be stored
## in the cache, as bam files.
##
## This also returns false if get_active() is false.

proc setCacheTextures*(this: BamCache, flag: bool) {.importcpp: "#.set_cache_textures(#)".} ## \
## Indicates whether texture files will be stored in the cache, as
## uncompressed txo files.

proc getCacheTextures*(this: BamCache): bool {.importcpp: "#.get_cache_textures()".} ## \
## Returns whether texture files (e.g.  egg files and bam files) will be
## stored in the cache, as txo files.
##
## This also returns false if get_active() is false.

proc setCacheCompressedTextures*(this: BamCache, flag: bool) {.importcpp: "#.set_cache_compressed_textures(#)".} ## \
## Indicates whether compressed texture files will be stored in the cache, as
## compressed txo files.  The compressed data may either be generated in-CPU,
## via the squish library, or it may be extracted from the GSG after the
## texture has been loaded.
##
## This may be set in conjunction with set_cache_textures(), or independently
## of it.  If set_cache_textures() is true and this is false, all textures
## will be cached in their uncompressed form.  If set_cache_textures() is
## false and this is true, only compressed textures will be cached, and they
## will be cached in their compressed form.  If both are true, all textures
## will be cached, in their uncompressed or compressed form appropriately.

proc getCacheCompressedTextures*(this: BamCache): bool {.importcpp: "#.get_cache_compressed_textures()".} ## \
## Returns whether compressed texture files will be stored in the cache, as
## compressed txo files.  See set_cache_compressed_textures().
##
## This also returns false if get_active() is false.

proc setCacheCompiledShaders*(this: BamCache, flag: bool) {.importcpp: "#.set_cache_compiled_shaders(#)".} ## \
## Indicates whether compiled shader programs will be stored in the cache, as
## binary .sho files.  This may not be supported by all shader languages or
## graphics renderers.

proc getCacheCompiledShaders*(this: BamCache): bool {.importcpp: "#.get_cache_compiled_shaders()".} ## \
## Returns whether compiled shader programs will be stored in the cache, as
## binary .txo files.  See set_cache_compiled_shaders().
##
## This also returns false if get_active() is false.

proc setRoot*(this: BamCache, root: Filename) {.importcpp: "#.set_root(#)".} ## \
## Changes the current root pathname of the cache.  This specifies where the
## cache files are stored on disk.  This should name a directory that is on a
## disk local to the machine (not on a network-mounted disk), for instance,
## tmp/panda-cache or /c/panda-cache.
##
## If the directory does not already exist, it will be created as a result of
## this call.

proc getRoot*(this: BamCache): Filename {.importcpp: "#.get_root()".} ## \
## Returns the current root pathname of the cache.  See set_root().

proc setFlushTime*(this: BamCache, flush_time: int) {.importcpp: "#.set_flush_time(#)".} ## \
## Specifies the time in seconds between automatic flushes of the cache index.

proc getFlushTime*(this: BamCache): int {.importcpp: "#.get_flush_time()".} ## \
## Returns the time in seconds between automatic flushes of the cache index.

proc setCacheMaxKbytes*(this: BamCache, max_kbytes: int) {.importcpp: "#.set_cache_max_kbytes(#)".} ## \
## Specifies the maximum size, in kilobytes, which the cache is allowed to
## grow to.  If a newly cached file would exceed this size, an older file is
## removed from the cache.
##
## Note that in the case of multiple different processes simultaneously
## operating on the same cache directory, the actual cache size may slightly
## exceed this value from time to time due to latency in checking between the
## processes.

proc getCacheMaxKbytes*(this: BamCache): int {.importcpp: "#.get_cache_max_kbytes()".} ## \
## Returns the maximum size, in kilobytes, which the cache is allowed to grow
## to.  See set_cache_max_kbytes().

proc setReadOnly*(this: BamCache, ro: bool) {.importcpp: "#.set_read_only(#)".} ## \
## Can be used to put the cache in read-only mode, or take it out of read-only
## mode.  Note that if you put it into read-write mode, and it discovers that
## it does not have write access, it will put itself right back into read-only
## mode.

proc getReadOnly*(this: BamCache): bool {.importcpp: "#.get_read_only()".} ## \
## Returns true if the cache is in read-only mode.  Normally, the cache starts
## in read-write mode.  It can put itself into read-only mode automatically if
## it discovers that it does not have write access to the cache.

proc lookup*(this: BamCache, source_filename: Filename, cache_extension: string): BamCacheRecord {.importcpp: "#.lookup(#, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Looks up a file in the cache.
##
## If the file is cacheable, then regardless of whether the file is found in
## the cache or not, this returns a BamCacheRecord.  On the other hand, if the
## file cannot be cached, returns NULL.
##
## If record->has_data() returns true, then the file was found in the cache,
## and you may call record->extract_data() to get the object.  If
## record->has_data() returns false, then the file was not found in the cache
## or the cache was stale; and you should reload the source file (calling
## record->add_dependent_file() for each file loaded, including the original
## source file), and then call record->set_data() to record the resulting
## loaded object; and finally, you should call store() to write the cached
## record to disk.

proc store*(this: BamCache, record: BamCacheRecord): bool {.importcpp: "#.store(#)".} ## \
## Flushes a cache entry to disk.  You must have retrieved the cache record
## via a prior call to lookup(), and then stored the data via
## record->set_data().  Returns true on success, false on failure.

proc considerFlushIndex*(this: BamCache) {.importcpp: "#.consider_flush_index()".} ## \
## Flushes the index if enough time has elapsed since the index was last
## flushed.

proc flushIndex*(this: BamCache) {.importcpp: "#.flush_index()".} ## \
## Ensures the index is written to disk.

proc listIndex*(this: BamCache, `out`: ostream, indent_level: int) {.importcpp: "#.list_index(#, #)".} ## \
## Writes the contents of the index to standard output.

proc listIndex*(this: BamCache, `out`: ostream) {.importcpp: "#.list_index(#)".} ## \
## Writes the contents of the index to standard output.

proc getGlobalPtr*(_: typedesc[BamCache]): BamCache {.importcpp: "BamCache::get_global_ptr()", header: "bamCache.h".} ## \
## Returns a pointer to the global BamCache object, which is used
## automatically by the ModelPool and TexturePool.

proc considerFlushGlobalIndex*(_: typedesc[BamCache]) {.importcpp: "BamCache::consider_flush_global_index()", header: "bamCache.h".} ## \
## If there is a global BamCache object, calls consider_flush_index() on it.

proc flushGlobalIndex*(_: typedesc[BamCache]) {.importcpp: "BamCache::flush_global_index()", header: "bamCache.h".} ## \
## If there is a global BamCache object, calls flush_index() on it.

proc initBamEnums*(): BamEnums {.importcpp: "BamEnums()".}

proc initBamEnums*(param0: BamEnums): BamEnums {.importcpp: "BamEnums(#)".}

proc initLoaderOptions*(param0: LoaderOptions): LoaderOptions {.importcpp: "LoaderOptions(#)".}

proc initLoaderOptions*(flags: int): LoaderOptions {.importcpp: "LoaderOptions(#)".}

proc initLoaderOptions*(): LoaderOptions {.importcpp: "LoaderOptions()".}

proc initLoaderOptions*(flags: int, texture_flags: int): LoaderOptions {.importcpp: "LoaderOptions(#, #)".}

proc setFlags*(this: LoaderOptions, flags: int) {.importcpp: "#.set_flags(#)".}

proc getFlags*(this: LoaderOptions): int {.importcpp: "#.get_flags()".}

proc setTextureFlags*(this: LoaderOptions, flags: int) {.importcpp: "#.set_texture_flags(#)".}

proc getTextureFlags*(this: LoaderOptions): int {.importcpp: "#.get_texture_flags()".}

proc setTextureNumViews*(this: LoaderOptions, num_views: int) {.importcpp: "#.set_texture_num_views(#)".} ## \
## Specifies the expected number of views to load for the texture.  This is
## ignored unless TF_multiview is included in texture_flags.  This must be
## specified when loading a 3-d multiview texture or 2-d texture array, in
## which case it is used to differentiate z levels from separate views; it
## may be zero in the case of 2-d textures or cube maps, in which case the
## number of views can be inferred from the number of images found on disk.

proc getTextureNumViews*(this: LoaderOptions): int {.importcpp: "#.get_texture_num_views()".} ## \
## See set_texture_num_views().

proc setAutoTextureScale*(this: LoaderOptions, scale: AutoTextureScale) {.importcpp: "#.set_auto_texture_scale(#)".} ## \
## Set this flag to ATS_none, ATS_up, ATS_down, or ATS_pad to control how a
## texture is scaled from disk when it is subsequently loaded.  Set it to
## ATS_unspecified to restore the default behavior.

proc getAutoTextureScale*(this: LoaderOptions): AutoTextureScale {.importcpp: "#.get_auto_texture_scale()".} ## \
## See set_auto_texture_scale().

proc output*(this: LoaderOptions, `out`: ostream) {.importcpp: "#.output(#)".}

proc initBamReader*(source: DatagramGenerator): BamReader {.importcpp: "BamReader(#)".} ## \
## The primary interface for a caller.

proc initBamReader*(): BamReader {.importcpp: "BamReader()".} ## \
## The primary interface for a caller.

proc setSource*(this: BamReader, source: DatagramGenerator) {.importcpp: "#.set_source(#)".} ## \
## Changes the source of future datagrams for this BamReader.  This also
## implicitly calls init() if it has not already been called.

proc getSource*(this: BamReader): DatagramGenerator {.importcpp: "#.get_source()".} ## \
## Returns the current source of the BamReader as set by set_source() or the
## constructor.

proc init*(this: BamReader): bool {.importcpp: "#.init()".} ## \
## Initializes the BamReader prior to reading any objects from its source.
## This includes reading the Bam header.
##
## This returns true if the BamReader successfully initialized, false
## otherwise.

proc getFilename*(this: BamReader): Filename {.importcpp: "#.get_filename()".} ## \
## If a BAM is a file, then the BamReader should contain the name of the file.
## This enables the reader to interpret pathnames in the BAM as relative to
## the directory containing the BAM.

proc getLoaderOptions*(this: BamReader): LoaderOptions {.importcpp: "#.get_loader_options()".} ## \
## Returns the LoaderOptions passed to the loader when the model was
## requested, if any.

proc setLoaderOptions*(this: BamReader, options: LoaderOptions) {.importcpp: "#.set_loader_options(#)".} ## \
## Specifies the LoaderOptions for this BamReader.

proc readObject*(this: BamReader): TypedWritable {.importcpp: "#.read_object()".} ## \
## Reads a single object from the Bam file.  If the object type is known, a
## new object of the appropriate type is created and returned; otherwise, NULL
## is returned.  NULL is also returned when the end of the file is reached.
## is_eof() may be called to differentiate between these two cases.
##
## This may be called repeatedly to extract out all the objects in the Bam
## file, but typically (especially for scene graph files, indicated with the
## .bam extension), only one object is retrieved directly from the Bam file:
## the root of the scene graph.  The remaining objects will all be retrieved
## recursively by the first object.
##
## Note that the object returned may not yet be complete.  In particular, some
## of its pointers may not be filled in; you must call resolve() to fill in
## all the available pointers before you can safely use any objects returned
## by read_object().
##
## This flavor of read_object() requires the caller to know what type of
## object it has received in order to properly manage the reference counts.

proc isEof*(this: BamReader): bool {.importcpp: "#.is_eof()".} ## \
## Returns true if the reader has reached end-of-file, false otherwise.  This
## call is only valid after a call to read_object().

proc resolve*(this: BamReader): bool {.importcpp: "#.resolve()".} ## \
## This may be called at any time during processing of the Bam file to resolve
## all the known pointers so far.  It is usually called at the end of the
## processing, after all objects have been read, which is generally the best
## time to call it.
##
## This must be called at least once after reading a particular object via
## get_object() in order to validate that object.
##
## The return value is true if all objects have been resolved, or false if
## some objects are still outstanding (in which case you will need to call
## resolve() again later).

proc changePointer*(this: BamReader, orig_pointer: TypedWritable, new_pointer: TypedWritable): bool {.importcpp: "#.change_pointer(#, #)".} ## \
## Indicates that an object recently read from the bam stream should be
## replaced with a new object.  Any future occurrences of the original object
## in the stream will henceforth return the new object instead.
##
## The return value is true if the replacement was successfully made, or false
## if the object was not read from the stream (or if change_pointer had
## already been called on it).

proc getFileMajorVer*(this: BamReader): int {.importcpp: "#.get_file_major_ver()".} ## \
## Returns the major version number of the Bam file currently being read.

proc getFileMinorVer*(this: BamReader): int {.importcpp: "#.get_file_minor_ver()".} ## \
## Returns the minor version number of the Bam file currently being read.

proc getFileStdfloatDouble*(this: BamReader): bool {.importcpp: "#.get_file_stdfloat_double()".} ## \
## Returns true if the file stores all "standard" floats as 64-bit doubles, or
## false if they are 32-bit floats.  This is determined by the compilation
## flags of the version of Panda that generated this file.

proc getCurrentMajorVer*(this: BamReader): int {.importcpp: "#.get_current_major_ver()".} ## \
## Returns the major version number of Bam files supported by the current code
## base.  This must match get_file_major_ver() in order to successfully read a
## file.

proc getCurrentMinorVer*(this: BamReader): int {.importcpp: "#.get_current_minor_ver()".} ## \
## Returns the minor version number of Bam files supported by the current code
## base.  This must match or exceed get_file_minor_ver() in order to
## successfully read a file.

proc initBamWriter*(param0: BamWriter): BamWriter {.importcpp: "BamWriter(#)".}

proc initBamWriter*(target: DatagramSink): BamWriter {.importcpp: "BamWriter(#)".}

proc initBamWriter*(): BamWriter {.importcpp: "BamWriter()".}

proc setTarget*(this: BamWriter, target: DatagramSink) {.importcpp: "#.set_target(#)".} ## \
## Changes the destination of future datagrams written by the BamWriter.  This
## also implicitly calls init() if it has not already been called.

proc getTarget*(this: BamWriter): DatagramSink {.importcpp: "#.get_target()".} ## \
## Returns the current target of the BamWriter as set by set_target() or the
## constructor.

proc init*(this: BamWriter): bool {.importcpp: "#.init()".} ## \
## Initializes the BamWriter prior to writing any objects to its output
## stream.  This includes writing out the Bam header.
##
## This returns true if the BamWriter successfully initialized, false
## otherwise.

proc getFilename*(this: BamWriter): Filename {.importcpp: "#.get_filename()".} ## \
## If a BAM is a file, then the BamWriter should contain the name of the file.
## This enables the writer to convert pathnames in the BAM to relative to the
## directory containing the BAM.

proc writeObject*(this: BamWriter, obj: TypedWritable): bool {.importcpp: "#.write_object(#)".} ## \
## Writes a single object to the Bam file, so that the
## BamReader::read_object() can later correctly restore the object and all its
## pointers.
##
## This implicitly also writes any additional objects this object references
## (if they haven't already been written), so that pointers may be fully
## resolved.
##
## This may be called repeatedly to write a sequence of objects to the Bam
## file, but typically (especially for scene graph files, indicated with the
## .bam extension), only one object is written directly from the Bam file: the
## root of the scene graph.  The remaining objects will all be written
## recursively by the first object.
##
## Returns true if the object is successfully written, false otherwise.

proc hasObject*(this: BamWriter, obj: TypedWritable): bool {.importcpp: "#.has_object(#)".} ## \
## Returns true if the object has previously been written (or at least
## requested to be written) to the bam file, or false if we've never heard of
## it before.

proc flush*(this: BamWriter) {.importcpp: "#.flush()".} ## \
## Ensures that all data written thus far is manifested on the output stream.

proc getFileMajorVer*(this: BamWriter): int {.importcpp: "#.get_file_major_ver()".} ## \
## Returns the major version number of the Bam file currently being written.

proc getFileMinorVer*(this: BamWriter): int {.importcpp: "#.get_file_minor_ver()".} ## \
## Returns the minor version number of the Bam file currently being written.

proc setFileMinorVer*(this: BamWriter, minor_ver: int) {.importcpp: "#.set_file_minor_ver(#)".} ## \
## Changes the minor .bam version to write.  This should be called before
## init().  Each Panda version has only a fairly narrow range of versions it
## is able to write; consult the .bam documentation for more information.

proc getFileStdfloatDouble*(this: BamWriter): bool {.importcpp: "#.get_file_stdfloat_double()".} ## \
## Returns true if the file will store all "standard" floats as 64-bit
## doubles, or false if they are 32-bit floats.  This isn't runtime settable;
## it's based on the compilation flags of the version of Panda that generated
## this file.

proc getRootNode*(this: BamWriter): TypedWritable {.importcpp: "#.get_root_node()".} ## \
## Returns the root node of the part of the scene graph we are currently
## writing out.  This is used for determining what to make NodePaths relative
## to.

proc setRootNode*(this: BamWriter, root_node: TypedWritable) {.importcpp: "#.set_root_node(#)".} ## \
## Sets the root node of the part of the scene graph we are currently writing
## out.  NodePaths written to this bam file will be relative to this node.

proc initBitMask16*(): BitMask16 {.importcpp: "BitMask16()".}

proc initBitMask16*(param0: BitMask[uint16, 16]): BitMask16 {.importcpp: "BitMask16(#)".}

converter initBitMask16*(init_value: int): BitMask16 {.importcpp: "BitMask16(#)".}

proc allOn*(_: typedesc[BitMask[uint16, 16]]): BitMask16 {.importcpp: "BitMask< uint16_t, 16 >::all_on()", header: "bitMask.h".}

proc allOff*(_: typedesc[BitMask[uint16, 16]]): BitMask16 {.importcpp: "BitMask< uint16_t, 16 >::all_off()", header: "bitMask.h".}

proc lowerOn*(_: typedesc[BitMask[uint16, 16]], on_bits: int): BitMask16 {.importcpp: "#BitMask< uint16_t, 16 >::lower_on(#)", header: "bitMask.h".}

proc bit*(_: typedesc[BitMask[uint16, 16]], index: int): BitMask16 {.importcpp: "#BitMask< uint16_t, 16 >::bit(#)", header: "bitMask.h".}

proc range*(_: typedesc[BitMask[uint16, 16]], low_bit: int, size: int): BitMask16 {.importcpp: "#BitMask< uint16_t, 16 >::range(#, #)", header: "bitMask.h".}

proc hasMaxNumBits*(_: typedesc[BitMask[uint16, 16]]): bool {.importcpp: "BitMask< uint16_t, 16 >::has_max_num_bits()", header: "bitMask.h".}

proc getMaxNumBits*(_: typedesc[BitMask[uint16, 16]]): int {.importcpp: "BitMask< uint16_t, 16 >::get_max_num_bits()", header: "bitMask.h".}

proc getNumBits*(this: BitMask[uint16, 16]): int {.importcpp: "#.get_num_bits()".}

proc getBit*(this: BitMask[uint16, 16], index: int): bool {.importcpp: "#.get_bit(#)".}

proc setBit*(this: BitMask[uint16, 16], index: int) {.importcpp: "#.set_bit(#)".}

proc clearBit*(this: BitMask[uint16, 16], index: int) {.importcpp: "#.clear_bit(#)".}

proc setBitTo*(this: BitMask[uint16, 16], index: int, value: bool) {.importcpp: "#.set_bit_to(#, #)".}

proc isZero*(this: BitMask[uint16, 16]): bool {.importcpp: "#.is_zero()".}

proc isAllOn*(this: BitMask[uint16, 16]): bool {.importcpp: "#.is_all_on()".}

proc extract*(this: BitMask[uint16, 16], low_bit: int, size: int): int {.importcpp: "#.extract(#, #)".}

proc store*(this: BitMask[uint16, 16], value: int, low_bit: int, size: int) {.importcpp: "#.store(#, #, #)".}

proc hasAnyOf*(this: BitMask[uint16, 16], low_bit: int, size: int): bool {.importcpp: "#.has_any_of(#, #)".}

proc hasAllOf*(this: BitMask[uint16, 16], low_bit: int, size: int): bool {.importcpp: "#.has_all_of(#, #)".}

proc setRange*(this: BitMask[uint16, 16], low_bit: int, size: int) {.importcpp: "#.set_range(#, #)".}

proc clearRange*(this: BitMask[uint16, 16], low_bit: int, size: int) {.importcpp: "#.clear_range(#, #)".}

proc setRangeTo*(this: BitMask[uint16, 16], value: bool, low_bit: int, size: int) {.importcpp: "#.set_range_to(#, #, #)".}

proc getWord*(this: BitMask[uint16, 16]): int {.importcpp: "#.get_word()".}

proc setWord*(this: BitMask[uint16, 16], value: int) {.importcpp: "#.set_word(#)".}

proc getNumOnBits*(this: BitMask[uint16, 16]): int {.importcpp: "#.get_num_on_bits()".}

proc getNumOffBits*(this: BitMask[uint16, 16]): int {.importcpp: "#.get_num_off_bits()".}

proc getLowestOnBit*(this: BitMask[uint16, 16]): int {.importcpp: "#.get_lowest_on_bit()".}

proc getLowestOffBit*(this: BitMask[uint16, 16]): int {.importcpp: "#.get_lowest_off_bit()".}

proc getHighestOnBit*(this: BitMask[uint16, 16]): int {.importcpp: "#.get_highest_on_bit()".}

proc getHighestOffBit*(this: BitMask[uint16, 16]): int {.importcpp: "#.get_highest_off_bit()".}

proc getNextHigherDifferentBit*(this: BitMask[uint16, 16], low_bit: int): int {.importcpp: "#.get_next_higher_different_bit(#)".}

proc invertInPlace*(this: BitMask[uint16, 16]) {.importcpp: "#.invert_in_place()".}

proc hasBitsInCommon*(this: BitMask[uint16, 16], other: BitMask[uint16, 16]): bool {.importcpp: "#.has_bits_in_common(#)".}

proc clear*(this: BitMask[uint16, 16]) {.importcpp: "#.clear()".}

proc output*(this: BitMask[uint16, 16], `out`: ostream) {.importcpp: "#.output(#)".}

proc outputBinary*(this: BitMask[uint16, 16], `out`: ostream, spaces_every: int) {.importcpp: "#.output_binary(#, #)".}

proc outputBinary*(this: BitMask[uint16, 16], `out`: ostream) {.importcpp: "#.output_binary(#)".}

proc outputHex*(this: BitMask[uint16, 16], `out`: ostream, spaces_every: int) {.importcpp: "#.output_hex(#, #)".}

proc outputHex*(this: BitMask[uint16, 16], `out`: ostream) {.importcpp: "#.output_hex(#)".}

proc write*(this: BitMask[uint16, 16], `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: BitMask[uint16, 16], `out`: ostream) {.importcpp: "#.write(#)".}

proc `==`*(this: BitMask[uint16, 16], other: BitMask[uint16, 16]): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: BitMask[uint16, 16], other: BitMask[uint16, 16]): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: BitMask[uint16, 16], other: BitMask[uint16, 16]): bool {.importcpp: "#.operator <(#)".}

proc compareTo*(this: BitMask[uint16, 16], other: BitMask[uint16, 16]): int {.importcpp: "#.compare_to(#)".}

proc `&`*(this: BitMask[uint16, 16], other: BitMask[uint16, 16]): BitMask16 {.importcpp: "#.operator &(#)".}

proc `|`*(this: BitMask[uint16, 16], other: BitMask[uint16, 16]): BitMask16 {.importcpp: "#.operator |(#)".}

proc `^`*(this: BitMask[uint16, 16], other: BitMask[uint16, 16]): BitMask16 {.importcpp: "#.operator ^(#)".}

proc `~`*(this: BitMask[uint16, 16]): BitMask16 {.importcpp: "#.operator ~()".}

proc `<<`*(this: BitMask[uint16, 16], shift: int): BitMask16 {.importcpp: "#.operator <<(#)".}

proc `>>`*(this: BitMask[uint16, 16], shift: int): BitMask16 {.importcpp: "#.operator >>(#)".}

proc `&=`*(this: var BitMask[uint16, 16], other: BitMask[uint16, 16]): BitMask16 {.importcpp: "#.operator &=(#)".}

proc `|=`*(this: var BitMask[uint16, 16], other: BitMask[uint16, 16]): BitMask16 {.importcpp: "#.operator |=(#)".}

proc `^=`*(this: var BitMask[uint16, 16], other: BitMask[uint16, 16]): BitMask16 {.importcpp: "#.operator ^=(#)".}

proc `<<=`*(this: var BitMask[uint16, 16], shift: int): BitMask16 {.importcpp: "#.operator <<=(#)".}

proc `>>=`*(this: var BitMask[uint16, 16], shift: int): BitMask16 {.importcpp: "#.operator >>=(#)".}

proc floodDownInPlace*(this: BitMask[uint16, 16]) {.importcpp: "#.flood_down_in_place()".}

proc floodUpInPlace*(this: BitMask[uint16, 16]) {.importcpp: "#.flood_up_in_place()".}

proc floodBitsDown*(this: BitMask[uint16, 16]): BitMask16 {.importcpp: "#.flood_bits_down()".}

proc floodBitsUp*(this: BitMask[uint16, 16]): BitMask16 {.importcpp: "#.flood_bits_up()".}

proc keepNextHighestBit*(this: BitMask[uint16, 16]): BitMask16 {.importcpp: "#.keep_next_highest_bit()".}

proc keepNextHighestBit*(this: BitMask[uint16, 16], other: BitMask[uint16, 16]): BitMask16 {.importcpp: "#.keep_next_highest_bit(#)".}

proc keepNextHighestBit*(this: BitMask[uint16, 16], index: int): BitMask16 {.importcpp: "#.keep_next_highest_bit(#)".}

proc keepNextLowestBit*(this: BitMask[uint16, 16]): BitMask16 {.importcpp: "#.keep_next_lowest_bit()".}

proc keepNextLowestBit*(this: BitMask[uint16, 16], other: BitMask[uint16, 16]): BitMask16 {.importcpp: "#.keep_next_lowest_bit(#)".}

proc keepNextLowestBit*(this: BitMask[uint16, 16], index: int): BitMask16 {.importcpp: "#.keep_next_lowest_bit(#)".}

proc getKey*(this: BitMask[uint16, 16]): int {.importcpp: "#.get_key()".}

converter getClassType*(_: typedesc[BitMask[uint16, 16]]): TypeHandle {.importcpp: "BitMask< uint16_t, 16 >::get_class_type()", header: "bitMask.h".}

proc initBitMask32*(): BitMask32 {.importcpp: "BitMask32()".}

proc initBitMask32*(param0: BitMask[uint32, 32]): BitMask32 {.importcpp: "BitMask32(#)".}

converter initBitMask32*(init_value: int): BitMask32 {.importcpp: "BitMask32(#)".}

proc allOn*(_: typedesc[BitMask[uint32, 32]]): BitMask32 {.importcpp: "BitMask< uint32_t, 32 >::all_on()", header: "bitMask.h".}

proc allOff*(_: typedesc[BitMask[uint32, 32]]): BitMask32 {.importcpp: "BitMask< uint32_t, 32 >::all_off()", header: "bitMask.h".}

proc lowerOn*(_: typedesc[BitMask[uint32, 32]], on_bits: int): BitMask32 {.importcpp: "#BitMask< uint32_t, 32 >::lower_on(#)", header: "bitMask.h".}

proc bit*(_: typedesc[BitMask[uint32, 32]], index: int): BitMask32 {.importcpp: "#BitMask< uint32_t, 32 >::bit(#)", header: "bitMask.h".}

proc range*(_: typedesc[BitMask[uint32, 32]], low_bit: int, size: int): BitMask32 {.importcpp: "#BitMask< uint32_t, 32 >::range(#, #)", header: "bitMask.h".}

proc hasMaxNumBits*(_: typedesc[BitMask[uint32, 32]]): bool {.importcpp: "BitMask< uint32_t, 32 >::has_max_num_bits()", header: "bitMask.h".}

proc getMaxNumBits*(_: typedesc[BitMask[uint32, 32]]): int {.importcpp: "BitMask< uint32_t, 32 >::get_max_num_bits()", header: "bitMask.h".}

proc getNumBits*(this: BitMask[uint32, 32]): int {.importcpp: "#.get_num_bits()".}

proc getBit*(this: BitMask[uint32, 32], index: int): bool {.importcpp: "#.get_bit(#)".}

proc setBit*(this: BitMask[uint32, 32], index: int) {.importcpp: "#.set_bit(#)".}

proc clearBit*(this: BitMask[uint32, 32], index: int) {.importcpp: "#.clear_bit(#)".}

proc setBitTo*(this: BitMask[uint32, 32], index: int, value: bool) {.importcpp: "#.set_bit_to(#, #)".}

proc isZero*(this: BitMask[uint32, 32]): bool {.importcpp: "#.is_zero()".}

proc isAllOn*(this: BitMask[uint32, 32]): bool {.importcpp: "#.is_all_on()".}

proc extract*(this: BitMask[uint32, 32], low_bit: int, size: int): int {.importcpp: "#.extract(#, #)".}

proc store*(this: BitMask[uint32, 32], value: int, low_bit: int, size: int) {.importcpp: "#.store(#, #, #)".}

proc hasAnyOf*(this: BitMask[uint32, 32], low_bit: int, size: int): bool {.importcpp: "#.has_any_of(#, #)".}

proc hasAllOf*(this: BitMask[uint32, 32], low_bit: int, size: int): bool {.importcpp: "#.has_all_of(#, #)".}

proc setRange*(this: BitMask[uint32, 32], low_bit: int, size: int) {.importcpp: "#.set_range(#, #)".}

proc clearRange*(this: BitMask[uint32, 32], low_bit: int, size: int) {.importcpp: "#.clear_range(#, #)".}

proc setRangeTo*(this: BitMask[uint32, 32], value: bool, low_bit: int, size: int) {.importcpp: "#.set_range_to(#, #, #)".}

proc getWord*(this: BitMask[uint32, 32]): int {.importcpp: "#.get_word()".}

proc setWord*(this: BitMask[uint32, 32], value: int) {.importcpp: "#.set_word(#)".}

proc getNumOnBits*(this: BitMask[uint32, 32]): int {.importcpp: "#.get_num_on_bits()".}

proc getNumOffBits*(this: BitMask[uint32, 32]): int {.importcpp: "#.get_num_off_bits()".}

proc getLowestOnBit*(this: BitMask[uint32, 32]): int {.importcpp: "#.get_lowest_on_bit()".}

proc getLowestOffBit*(this: BitMask[uint32, 32]): int {.importcpp: "#.get_lowest_off_bit()".}

proc getHighestOnBit*(this: BitMask[uint32, 32]): int {.importcpp: "#.get_highest_on_bit()".}

proc getHighestOffBit*(this: BitMask[uint32, 32]): int {.importcpp: "#.get_highest_off_bit()".}

proc getNextHigherDifferentBit*(this: BitMask[uint32, 32], low_bit: int): int {.importcpp: "#.get_next_higher_different_bit(#)".}

proc invertInPlace*(this: BitMask[uint32, 32]) {.importcpp: "#.invert_in_place()".}

proc hasBitsInCommon*(this: BitMask[uint32, 32], other: BitMask[uint32, 32]): bool {.importcpp: "#.has_bits_in_common(#)".}

proc clear*(this: BitMask[uint32, 32]) {.importcpp: "#.clear()".}

proc output*(this: BitMask[uint32, 32], `out`: ostream) {.importcpp: "#.output(#)".}

proc outputBinary*(this: BitMask[uint32, 32], `out`: ostream, spaces_every: int) {.importcpp: "#.output_binary(#, #)".}

proc outputBinary*(this: BitMask[uint32, 32], `out`: ostream) {.importcpp: "#.output_binary(#)".}

proc outputHex*(this: BitMask[uint32, 32], `out`: ostream, spaces_every: int) {.importcpp: "#.output_hex(#, #)".}

proc outputHex*(this: BitMask[uint32, 32], `out`: ostream) {.importcpp: "#.output_hex(#)".}

proc write*(this: BitMask[uint32, 32], `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: BitMask[uint32, 32], `out`: ostream) {.importcpp: "#.write(#)".}

proc `==`*(this: BitMask[uint32, 32], other: BitMask[uint32, 32]): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: BitMask[uint32, 32], other: BitMask[uint32, 32]): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: BitMask[uint32, 32], other: BitMask[uint32, 32]): bool {.importcpp: "#.operator <(#)".}

proc compareTo*(this: BitMask[uint32, 32], other: BitMask[uint32, 32]): int {.importcpp: "#.compare_to(#)".}

proc `&`*(this: BitMask[uint32, 32], other: BitMask[uint32, 32]): BitMask32 {.importcpp: "#.operator &(#)".}

proc `|`*(this: BitMask[uint32, 32], other: BitMask[uint32, 32]): BitMask32 {.importcpp: "#.operator |(#)".}

proc `^`*(this: BitMask[uint32, 32], other: BitMask[uint32, 32]): BitMask32 {.importcpp: "#.operator ^(#)".}

proc `~`*(this: BitMask[uint32, 32]): BitMask32 {.importcpp: "#.operator ~()".}

proc `<<`*(this: BitMask[uint32, 32], shift: int): BitMask32 {.importcpp: "#.operator <<(#)".}

proc `>>`*(this: BitMask[uint32, 32], shift: int): BitMask32 {.importcpp: "#.operator >>(#)".}

proc `&=`*(this: var BitMask[uint32, 32], other: BitMask[uint32, 32]): BitMask32 {.importcpp: "#.operator &=(#)".}

proc `|=`*(this: var BitMask[uint32, 32], other: BitMask[uint32, 32]): BitMask32 {.importcpp: "#.operator |=(#)".}

proc `^=`*(this: var BitMask[uint32, 32], other: BitMask[uint32, 32]): BitMask32 {.importcpp: "#.operator ^=(#)".}

proc `<<=`*(this: var BitMask[uint32, 32], shift: int): BitMask32 {.importcpp: "#.operator <<=(#)".}

proc `>>=`*(this: var BitMask[uint32, 32], shift: int): BitMask32 {.importcpp: "#.operator >>=(#)".}

proc floodDownInPlace*(this: BitMask[uint32, 32]) {.importcpp: "#.flood_down_in_place()".}

proc floodUpInPlace*(this: BitMask[uint32, 32]) {.importcpp: "#.flood_up_in_place()".}

proc floodBitsDown*(this: BitMask[uint32, 32]): BitMask32 {.importcpp: "#.flood_bits_down()".}

proc floodBitsUp*(this: BitMask[uint32, 32]): BitMask32 {.importcpp: "#.flood_bits_up()".}

proc keepNextHighestBit*(this: BitMask[uint32, 32]): BitMask32 {.importcpp: "#.keep_next_highest_bit()".}

proc keepNextHighestBit*(this: BitMask[uint32, 32], other: BitMask[uint32, 32]): BitMask32 {.importcpp: "#.keep_next_highest_bit(#)".}

proc keepNextHighestBit*(this: BitMask[uint32, 32], index: int): BitMask32 {.importcpp: "#.keep_next_highest_bit(#)".}

proc keepNextLowestBit*(this: BitMask[uint32, 32]): BitMask32 {.importcpp: "#.keep_next_lowest_bit()".}

proc keepNextLowestBit*(this: BitMask[uint32, 32], other: BitMask[uint32, 32]): BitMask32 {.importcpp: "#.keep_next_lowest_bit(#)".}

proc keepNextLowestBit*(this: BitMask[uint32, 32], index: int): BitMask32 {.importcpp: "#.keep_next_lowest_bit(#)".}

proc getKey*(this: BitMask[uint32, 32]): int {.importcpp: "#.get_key()".}

converter getClassType*(_: typedesc[BitMask[uint32, 32]]): TypeHandle {.importcpp: "BitMask< uint32_t, 32 >::get_class_type()", header: "bitMask.h".}

proc initBitMask64*(): BitMask64 {.importcpp: "BitMask64()".}

proc initBitMask64*(param0: BitMask[uint64, 64]): BitMask64 {.importcpp: "BitMask64(#)".}

converter initBitMask64*(init_value: clonglong): BitMask64 {.importcpp: "BitMask64(#)".}

proc allOn*(_: typedesc[BitMask[uint64, 64]]): BitMask64 {.importcpp: "BitMask< uint64_t, 64 >::all_on()", header: "bitMask.h".}

proc allOff*(_: typedesc[BitMask[uint64, 64]]): BitMask64 {.importcpp: "BitMask< uint64_t, 64 >::all_off()", header: "bitMask.h".}

proc lowerOn*(_: typedesc[BitMask[uint64, 64]], on_bits: int): BitMask64 {.importcpp: "#BitMask< uint64_t, 64 >::lower_on(#)", header: "bitMask.h".}

proc bit*(_: typedesc[BitMask[uint64, 64]], index: int): BitMask64 {.importcpp: "#BitMask< uint64_t, 64 >::bit(#)", header: "bitMask.h".}

proc range*(_: typedesc[BitMask[uint64, 64]], low_bit: int, size: int): BitMask64 {.importcpp: "#BitMask< uint64_t, 64 >::range(#, #)", header: "bitMask.h".}

proc hasMaxNumBits*(_: typedesc[BitMask[uint64, 64]]): bool {.importcpp: "BitMask< uint64_t, 64 >::has_max_num_bits()", header: "bitMask.h".}

proc getMaxNumBits*(_: typedesc[BitMask[uint64, 64]]): int {.importcpp: "BitMask< uint64_t, 64 >::get_max_num_bits()", header: "bitMask.h".}

proc getNumBits*(this: BitMask[uint64, 64]): int {.importcpp: "#.get_num_bits()".}

proc getBit*(this: BitMask[uint64, 64], index: int): bool {.importcpp: "#.get_bit(#)".}

proc setBit*(this: BitMask[uint64, 64], index: int) {.importcpp: "#.set_bit(#)".}

proc clearBit*(this: BitMask[uint64, 64], index: int) {.importcpp: "#.clear_bit(#)".}

proc setBitTo*(this: BitMask[uint64, 64], index: int, value: bool) {.importcpp: "#.set_bit_to(#, #)".}

proc isZero*(this: BitMask[uint64, 64]): bool {.importcpp: "#.is_zero()".}

proc isAllOn*(this: BitMask[uint64, 64]): bool {.importcpp: "#.is_all_on()".}

proc extract*(this: BitMask[uint64, 64], low_bit: int, size: int): clonglong {.importcpp: "#.extract(#, #)".}

proc store*(this: BitMask[uint64, 64], value: clonglong, low_bit: int, size: int) {.importcpp: "#.store(#, #, #)".}

proc hasAnyOf*(this: BitMask[uint64, 64], low_bit: int, size: int): bool {.importcpp: "#.has_any_of(#, #)".}

proc hasAllOf*(this: BitMask[uint64, 64], low_bit: int, size: int): bool {.importcpp: "#.has_all_of(#, #)".}

proc setRange*(this: BitMask[uint64, 64], low_bit: int, size: int) {.importcpp: "#.set_range(#, #)".}

proc clearRange*(this: BitMask[uint64, 64], low_bit: int, size: int) {.importcpp: "#.clear_range(#, #)".}

proc setRangeTo*(this: BitMask[uint64, 64], value: bool, low_bit: int, size: int) {.importcpp: "#.set_range_to(#, #, #)".}

proc getWord*(this: BitMask[uint64, 64]): clonglong {.importcpp: "#.get_word()".}

proc setWord*(this: BitMask[uint64, 64], value: clonglong) {.importcpp: "#.set_word(#)".}

proc getNumOnBits*(this: BitMask[uint64, 64]): int {.importcpp: "#.get_num_on_bits()".}

proc getNumOffBits*(this: BitMask[uint64, 64]): int {.importcpp: "#.get_num_off_bits()".}

proc getLowestOnBit*(this: BitMask[uint64, 64]): int {.importcpp: "#.get_lowest_on_bit()".}

proc getLowestOffBit*(this: BitMask[uint64, 64]): int {.importcpp: "#.get_lowest_off_bit()".}

proc getHighestOnBit*(this: BitMask[uint64, 64]): int {.importcpp: "#.get_highest_on_bit()".}

proc getHighestOffBit*(this: BitMask[uint64, 64]): int {.importcpp: "#.get_highest_off_bit()".}

proc getNextHigherDifferentBit*(this: BitMask[uint64, 64], low_bit: int): int {.importcpp: "#.get_next_higher_different_bit(#)".}

proc invertInPlace*(this: BitMask[uint64, 64]) {.importcpp: "#.invert_in_place()".}

proc hasBitsInCommon*(this: BitMask[uint64, 64], other: BitMask[uint64, 64]): bool {.importcpp: "#.has_bits_in_common(#)".}

proc clear*(this: BitMask[uint64, 64]) {.importcpp: "#.clear()".}

proc output*(this: BitMask[uint64, 64], `out`: ostream) {.importcpp: "#.output(#)".}

proc outputBinary*(this: BitMask[uint64, 64], `out`: ostream, spaces_every: int) {.importcpp: "#.output_binary(#, #)".}

proc outputBinary*(this: BitMask[uint64, 64], `out`: ostream) {.importcpp: "#.output_binary(#)".}

proc outputHex*(this: BitMask[uint64, 64], `out`: ostream, spaces_every: int) {.importcpp: "#.output_hex(#, #)".}

proc outputHex*(this: BitMask[uint64, 64], `out`: ostream) {.importcpp: "#.output_hex(#)".}

proc write*(this: BitMask[uint64, 64], `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".}

proc write*(this: BitMask[uint64, 64], `out`: ostream) {.importcpp: "#.write(#)".}

proc `==`*(this: BitMask[uint64, 64], other: BitMask[uint64, 64]): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: BitMask[uint64, 64], other: BitMask[uint64, 64]): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: BitMask[uint64, 64], other: BitMask[uint64, 64]): bool {.importcpp: "#.operator <(#)".}

proc compareTo*(this: BitMask[uint64, 64], other: BitMask[uint64, 64]): int {.importcpp: "#.compare_to(#)".}

proc `&`*(this: BitMask[uint64, 64], other: BitMask[uint64, 64]): BitMask64 {.importcpp: "#.operator &(#)".}

proc `|`*(this: BitMask[uint64, 64], other: BitMask[uint64, 64]): BitMask64 {.importcpp: "#.operator |(#)".}

proc `^`*(this: BitMask[uint64, 64], other: BitMask[uint64, 64]): BitMask64 {.importcpp: "#.operator ^(#)".}

proc `~`*(this: BitMask[uint64, 64]): BitMask64 {.importcpp: "#.operator ~()".}

proc `<<`*(this: BitMask[uint64, 64], shift: int): BitMask64 {.importcpp: "#.operator <<(#)".}

proc `>>`*(this: BitMask[uint64, 64], shift: int): BitMask64 {.importcpp: "#.operator >>(#)".}

proc `&=`*(this: var BitMask[uint64, 64], other: BitMask[uint64, 64]): BitMask64 {.importcpp: "#.operator &=(#)".}

proc `|=`*(this: var BitMask[uint64, 64], other: BitMask[uint64, 64]): BitMask64 {.importcpp: "#.operator |=(#)".}

proc `^=`*(this: var BitMask[uint64, 64], other: BitMask[uint64, 64]): BitMask64 {.importcpp: "#.operator ^=(#)".}

proc `<<=`*(this: var BitMask[uint64, 64], shift: int): BitMask64 {.importcpp: "#.operator <<=(#)".}

proc `>>=`*(this: var BitMask[uint64, 64], shift: int): BitMask64 {.importcpp: "#.operator >>=(#)".}

proc floodDownInPlace*(this: BitMask[uint64, 64]) {.importcpp: "#.flood_down_in_place()".}

proc floodUpInPlace*(this: BitMask[uint64, 64]) {.importcpp: "#.flood_up_in_place()".}

proc floodBitsDown*(this: BitMask[uint64, 64]): BitMask64 {.importcpp: "#.flood_bits_down()".}

proc floodBitsUp*(this: BitMask[uint64, 64]): BitMask64 {.importcpp: "#.flood_bits_up()".}

proc keepNextHighestBit*(this: BitMask[uint64, 64]): BitMask64 {.importcpp: "#.keep_next_highest_bit()".}

proc keepNextHighestBit*(this: BitMask[uint64, 64], other: BitMask[uint64, 64]): BitMask64 {.importcpp: "#.keep_next_highest_bit(#)".}

proc keepNextHighestBit*(this: BitMask[uint64, 64], index: int): BitMask64 {.importcpp: "#.keep_next_highest_bit(#)".}

proc keepNextLowestBit*(this: BitMask[uint64, 64]): BitMask64 {.importcpp: "#.keep_next_lowest_bit()".}

proc keepNextLowestBit*(this: BitMask[uint64, 64], other: BitMask[uint64, 64]): BitMask64 {.importcpp: "#.keep_next_lowest_bit(#)".}

proc keepNextLowestBit*(this: BitMask[uint64, 64], index: int): BitMask64 {.importcpp: "#.keep_next_lowest_bit(#)".}

proc getKey*(this: BitMask[uint64, 64]): int {.importcpp: "#.get_key()".}

converter getClassType*(_: typedesc[BitMask[uint64, 64]]): TypeHandle {.importcpp: "BitMask< uint64_t, 64 >::get_class_type()", header: "bitMask.h".}

proc initBitArray*(): BitArray {.importcpp: "BitArray()".}

proc initBitArray*(param0: BitArray): BitArray {.importcpp: "BitArray(#)".}

converter initBitArray*(init_value: clonglong): BitArray {.importcpp: "BitArray(#)".}

converter initBitArray*(`from`: SparseArray): BitArray {.importcpp: "BitArray(#)".}

proc allOn*(_: typedesc[BitArray]): BitArray {.importcpp: "BitArray::all_on()", header: "bitArray.h".} ## \
## Returns a BitArray with an infinite array of bits, all on.

proc allOff*(_: typedesc[BitArray]): BitArray {.importcpp: "BitArray::all_off()", header: "bitArray.h".} ## \
## Returns a BitArray whose bits are all off.

proc lowerOn*(_: typedesc[BitArray], on_bits: int): BitArray {.importcpp: "#BitArray::lower_on(#)", header: "bitArray.h".} ## \
## Returns a BitArray whose lower on_bits bits are on.

proc bit*(_: typedesc[BitArray], index: int): BitArray {.importcpp: "#BitArray::bit(#)", header: "bitArray.h".} ## \
## Returns a BitArray with only the indicated bit on.

proc range*(_: typedesc[BitArray], low_bit: int, size: int): BitArray {.importcpp: "#BitArray::range(#, #)", header: "bitArray.h".} ## \
## Returns a BitArray whose size bits, beginning at low_bit, are on.

proc hasMaxNumBits*(_: typedesc[BitArray]): bool {.importcpp: "BitArray::has_max_num_bits()", header: "bitArray.h".}

proc getMaxNumBits*(_: typedesc[BitArray]): int {.importcpp: "BitArray::get_max_num_bits()", header: "bitArray.h".}

proc getNumBitsPerWord*(_: typedesc[BitArray]): int {.importcpp: "BitArray::get_num_bits_per_word()", header: "bitArray.h".}

proc getNumBits*(this: BitArray): clonglong {.importcpp: "#.get_num_bits()".} ## \
## Returns the current number of possibly different bits in this array.  There
## are actually an infinite number of bits, but every bit higher than this bit
## will have the same value, either 0 or 1 (see get_highest_bits()).
##
## This number may grow and/or shrink automatically as needed.

proc getBit*(this: BitArray, index: int): bool {.importcpp: "#.get_bit(#)".} ## \
## Returns true if the nth bit is set, false if it is cleared.  It is valid
## for n to increase beyond get_num_bits(), but the return value
## get_num_bits() will always be the same.

proc setBit*(this: BitArray, index: int) {.importcpp: "#.set_bit(#)".} ## \
## Sets the nth bit on.  If n >= get_num_bits(), this automatically extends
## the array.

proc clearBit*(this: BitArray, index: int) {.importcpp: "#.clear_bit(#)".} ## \
## Sets the nth bit off.  If n >= get_num_bits(), this automatically extends
## the array.

proc setBitTo*(this: BitArray, index: int, value: bool) {.importcpp: "#.set_bit_to(#, #)".} ## \
## Sets the nth bit either on or off, according to the indicated bool value.

proc getHighestBits*(this: BitArray): bool {.importcpp: "#.get_highest_bits()".} ## \
## Returns true if the infinite set of bits beyond get_num_bits() are all on,
## or false of they are all off.

proc isZero*(this: BitArray): bool {.importcpp: "#.is_zero()".} ## \
## Returns true if the entire bitmask is zero, false otherwise.

proc isAllOn*(this: BitArray): bool {.importcpp: "#.is_all_on()".} ## \
## Returns true if the entire bitmask is one, false otherwise.

proc extract*(this: BitArray, low_bit: int, size: int): clonglong {.importcpp: "#.extract(#, #)".} ## \
## Returns a word that represents only the indicated range of bits within this
## BitArray, shifted to the least-significant position.  size must be <=
## get_num_bits_per_word().

proc store*(this: BitArray, value: clonglong, low_bit: int, size: int) {.importcpp: "#.store(#, #, #)".} ## \
## Stores the indicated word into the indicated range of bits with this
## BitArray.

proc hasAnyOf*(this: BitArray, low_bit: int, size: int): bool {.importcpp: "#.has_any_of(#, #)".} ## \
## Returns true if any bit in the indicated range is set, false otherwise.

proc hasAllOf*(this: BitArray, low_bit: int, size: int): bool {.importcpp: "#.has_all_of(#, #)".} ## \
## Returns true if all bits in the indicated range are set, false otherwise.

proc setRange*(this: BitArray, low_bit: int, size: int) {.importcpp: "#.set_range(#, #)".} ## \
## Sets the indicated range of bits on.

proc clearRange*(this: BitArray, low_bit: int, size: int) {.importcpp: "#.clear_range(#, #)".} ## \
## Sets the indicated range of bits off.

proc setRangeTo*(this: BitArray, value: bool, low_bit: int, size: int) {.importcpp: "#.set_range_to(#, #, #)".} ## \
## Sets the indicated range of bits to either on or off.

proc getNumOnBits*(this: BitArray): int {.importcpp: "#.get_num_on_bits()".} ## \
## Returns the number of bits that are set to 1 in the array.  Returns -1 if
## there are an infinite number of 1 bits.

proc getNumOffBits*(this: BitArray): int {.importcpp: "#.get_num_off_bits()".} ## \
## Returns the number of bits that are set to 0 in the array.  Returns -1 if
## there are an infinite number of 0 bits.

proc getLowestOnBit*(this: BitArray): int {.importcpp: "#.get_lowest_on_bit()".} ## \
## Returns the index of the lowest 1 bit in the array.  Returns -1 if there
## are no 1 bits.

proc getLowestOffBit*(this: BitArray): int {.importcpp: "#.get_lowest_off_bit()".} ## \
## Returns the index of the lowest 0 bit in the array.  Returns -1 if there
## are no 0 bits.

proc getHighestOnBit*(this: BitArray): int {.importcpp: "#.get_highest_on_bit()".} ## \
## Returns the index of the highest 1 bit in the array.  Returns -1 if there
## are no 1 bits or if there an infinite number of 1 bits.

proc getHighestOffBit*(this: BitArray): int {.importcpp: "#.get_highest_off_bit()".} ## \
## Returns the index of the highest 0 bit in the array.  Returns -1 if there
## are no 0 bits or if there an infinite number of 1 bits.

proc getNextHigherDifferentBit*(this: BitArray, low_bit: int): int {.importcpp: "#.get_next_higher_different_bit(#)".} ## \
## Returns the index of the next bit in the array, above low_bit, whose value
## is different that the value of low_bit.  Returns low_bit again if all bits
## higher than low_bit have the same value.
##
## This can be used to quickly iterate through all of the bits in the array.

proc getNumWords*(this: BitArray): clonglong {.importcpp: "#.get_num_words()".} ## \
## Returns the number of possibly-unique words stored in the array.

proc getWord*(this: BitArray, n: clonglong): BitMaskNative {.importcpp: "#.get_word(#)".} ## \
## Returns the nth word in the array.  It is valid for n to be greater than
## get_num_words(), but the return value beyond get_num_words() will always be
## the same.

proc setWord*(this: BitArray, n: clonglong, value: clonglong) {.importcpp: "#.set_word(#, #)".} ## \
## Replaces the nth word in the array.  If n >= get_num_words(), this
## automatically extends the array.

proc invertInPlace*(this: BitArray) {.importcpp: "#.invert_in_place()".} ## \
## Inverts all the bits in the BitArray.  This is equivalent to array =
## ~array.

proc hasBitsInCommon*(this: BitArray, other: BitArray): bool {.importcpp: "#.has_bits_in_common(#)".} ## \
## Returns true if this BitArray has any "one" bits in common with the other
## one, false otherwise.
##
## This is equivalent to (array & other) != 0, but may be faster.

proc clear*(this: BitArray) {.importcpp: "#.clear()".} ## \
## Sets all the bits in the BitArray off.

proc output*(this: BitArray, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Writes the BitArray out as a hex number.  For a BitArray, this is always
## the same as output_hex(); it's too confusing for the output format to
## change back and forth at runtime.

proc outputBinary*(this: BitArray, `out`: ostream, spaces_every: int) {.importcpp: "#.output_binary(#, #)".} ## \
## Writes the BitArray out as a binary number, with spaces every four bits.

proc outputBinary*(this: BitArray, `out`: ostream) {.importcpp: "#.output_binary(#)".} ## \
## Writes the BitArray out as a binary number, with spaces every four bits.

proc outputHex*(this: BitArray, `out`: ostream, spaces_every: int) {.importcpp: "#.output_hex(#, #)".} ## \
## Writes the BitArray out as a hexadecimal number, with spaces every four
## digits.

proc outputHex*(this: BitArray, `out`: ostream) {.importcpp: "#.output_hex(#)".} ## \
## Writes the BitArray out as a hexadecimal number, with spaces every four
## digits.

proc write*(this: BitArray, `out`: ostream, indent_level: int) {.importcpp: "#.write(#, #)".} ## \
## Writes the BitArray out as a binary or a hex number, according to the
## number of bits.

proc write*(this: BitArray, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes the BitArray out as a binary or a hex number, according to the
## number of bits.

proc `==`*(this: BitArray, other: BitArray): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: BitArray, other: BitArray): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: BitArray, other: BitArray): bool {.importcpp: "#.operator <(#)".}

proc compareTo*(this: BitArray, other: BitArray): int {.importcpp: "#.compare_to(#)".} ## \
## Returns a number less than zero if this BitArray sorts before the indicated
## other BitArray, greater than zero if it sorts after, or 0 if they are
## equivalent.  This is based on the same ordering defined by operator <.

proc `&`*(this: BitArray, other: BitArray): BitArray {.importcpp: "#.operator &(#)".}

proc `|`*(this: BitArray, other: BitArray): BitArray {.importcpp: "#.operator |(#)".}

proc `^`*(this: BitArray, other: BitArray): BitArray {.importcpp: "#.operator ^(#)".}

proc `~`*(this: BitArray): BitArray {.importcpp: "#.operator ~()".}

proc `<<`*(this: BitArray, shift: int): BitArray {.importcpp: "#.operator <<(#)".}

proc `>>`*(this: BitArray, shift: int): BitArray {.importcpp: "#.operator >>(#)".}

proc `&=`*(this: var BitArray, other: BitArray): BitArray {.importcpp: "#.operator &=(#)".}

proc `|=`*(this: var BitArray, other: BitArray): BitArray {.importcpp: "#.operator |=(#)".}

proc `^=`*(this: var BitArray, other: BitArray): BitArray {.importcpp: "#.operator ^=(#)".}

proc `<<=`*(this: var BitArray, shift: int): BitArray {.importcpp: "#.operator <<=(#)".}

proc `>>=`*(this: var BitArray, shift: int): BitArray {.importcpp: "#.operator >>=(#)".}

converter getClassType*(_: typedesc[BitArray]): TypeHandle {.importcpp: "BitArray::get_class_type()", header: "bitArray.h".}

proc initButtonHandle*(): ButtonHandle {.importcpp: "ButtonHandle()".} ## \
## The default constructor must do nothing, because we can't guarantee
## ordering of static initializers.  If the constructor tried to initialize
## its value, it  might happen after the value had already been set
## previously by another static initializer!

proc initButtonHandle*(param0: ButtonHandle): ButtonHandle {.importcpp: "ButtonHandle(#)".}

proc initButtonHandle*(index: int): ButtonHandle {.importcpp: "ButtonHandle(#)".} ## \
## Constructs a ButtonHandle with the corresponding index number, which may
## have been returned by an earlier call to ButtonHandle::get_index().

converter initButtonHandle*(name: string): ButtonHandle {.importcpp: "ButtonHandle(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Constructs a ButtonHandle with the corresponding name, which is looked up
## in the ButtonRegistry.  This exists for the purpose of being able to
## automatically coerce a string into a ButtonHandle; for most purposes, you
## should use either the static KeyboardButton/MouseButton getters or
## ButtonRegistry::register_button().

proc `==`*(this: ButtonHandle, other: ButtonHandle): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: ButtonHandle, other: ButtonHandle): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: ButtonHandle, other: ButtonHandle): bool {.importcpp: "#.operator <(#)".}

proc `<=`*(this: ButtonHandle, other: ButtonHandle): bool {.importcpp: "#.operator <=(#)".}

proc `>`*(this: ButtonHandle, other: ButtonHandle): bool {.importcpp: "#.operator >(#)".}

proc `>=`*(this: ButtonHandle, other: ButtonHandle): bool {.importcpp: "#.operator >=(#)".}

proc compareTo*(this: ButtonHandle, other: ButtonHandle): int {.importcpp: "#.compare_to(#)".} ## \
## Sorts ButtonHandles arbitrarily (according to <, >, etc.).  Returns a
## number less than 0 if this type sorts before the other one, greater than
## zero if it sorts after, 0 if they are equivalent.

proc getHash*(this: ButtonHandle): clonglong {.importcpp: "#.get_hash()".} ## \
## Returns a hash code suitable for phash_map.

proc getName*(this: ButtonHandle): string {.importcpp: "nimStringFromStdString(#.get_name())", header: stringConversionCode.} ## \
## Returns the name of the button.

proc hasAsciiEquivalent*(this: ButtonHandle): bool {.importcpp: "#.has_ascii_equivalent()".} ## \
## Returns true if the button was created with an ASCII equivalent code (e.g.
## for a standard keyboard button).

proc getAsciiEquivalent*(this: ButtonHandle): char {.importcpp: "#.get_ascii_equivalent()".} ## \
## Returns the character code associated with the button, or '\0' if no ASCII
## code was associated.

proc getAlias*(this: ButtonHandle): ButtonHandle {.importcpp: "#.get_alias()".} ## \
## Returns the alias (alternate name) associated with the button, if any, or
## ButtonHandle::none() if the button has no alias.
##
## Each button is allowed to have one alias, and multiple different buttons
## can refer to the same alias.  The alias should be the more general name for
## the button, for instance, shift is an alias for lshift, but not vice-versa.

proc matches*(this: ButtonHandle, other: ButtonHandle): bool {.importcpp: "#.matches(#)".} ## \
## Returns true if this ButtonHandle is the same as the other one, or if the
## other one is an alias for this one.  (Does not return true if this button
## is an alias for the other one, however.)
##
## This is a more general comparison than operator ==.

proc getIndex*(this: ButtonHandle): int {.importcpp: "#.get_index()".} ## \
## Returns the integer index associated with this ButtonHandle.  Each
## different ButtonHandle will have a different index.  However, you probably
## shouldn't be using this method; you should just treat the ButtonHandles as
## opaque classes.  This is provided for the convenience of non-C++ scripting
## languages to build a hashtable of ButtonHandles.

proc output*(this: ButtonHandle, `out`: ostream) {.importcpp: "#.output(#)".}

proc none*(_: typedesc[ButtonHandle]): ButtonHandle {.importcpp: "ButtonHandle::none()", header: "buttonHandle.h".}

proc `typecast bool`*(this: ButtonHandle): bool {.importcpp: "#.operator typecast bool()".}

converter getClassType*(_: typedesc[ButtonHandle]): TypeHandle {.importcpp: "ButtonHandle::get_class_type()", header: "buttonHandle.h".}

proc getButton*(this: ButtonRegistry, name: string): ButtonHandle {.importcpp: "#.get_button(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Finds a ButtonHandle in the registry matching the indicated name.  If there
## is no such ButtonHandle, registers a new one and returns it.

proc findButton*(this: ButtonRegistry, name: string): ButtonHandle {.importcpp: "#.find_button(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Finds a ButtonHandle in the registry matching the indicated name.  If there
## is no such ButtonHandle, returns ButtonHandle::none().

proc findAsciiButton*(this: ButtonRegistry, ascii_equivalent: char): ButtonHandle {.importcpp: "#.find_ascii_button(#)".} ## \
## Finds a ButtonHandle in the registry matching the indicated ASCII
## equivalent character.  If there is no such ButtonHandle, returns
## ButtonHandle::none().

proc write*(this: ButtonRegistry, `out`: ostream) {.importcpp: "#.write(#)".}

proc initButtonRegistry*(param0: ButtonRegistry): ButtonRegistry {.importcpp: "ButtonRegistry(#)".}

proc getNumButtons*(this: ButtonMap): clonglong {.importcpp: "#->get_num_buttons()".} ## \
## Returns the number of buttons that this button mapping specifies.

proc getRawButton*(this: ButtonMap, i: clonglong): ButtonHandle {.importcpp: "#->get_raw_button(#)".} ## \
## Returns the underlying raw button associated with the nth button.

proc getMappedButton*(this: ButtonMap, raw: ButtonHandle): ButtonHandle {.importcpp: "#->get_mapped_button(#)".} ## \
## Returns the button that the given button is mapped to, or
## ButtonHandle::none() if this map does not specify a mapped button for the
## given raw button.

proc getMappedButton*(this: ButtonMap, i: clonglong): ButtonHandle {.importcpp: "#->get_mapped_button(#)".} ## \
## Returns the nth mapped button, meaning the button that the nth raw button
## is mapped to.

proc getMappedButton*(this: ButtonMap, raw_name: string): ButtonHandle {.importcpp: "#->get_mapped_button(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the button that the given button is mapped to, or
## ButtonHandle::none() if this map does not specify a mapped button for the
## given raw button.

proc getMappedButtonLabel*(this: ButtonMap, raw: ButtonHandle): string {.importcpp: "nimStringFromStdString(#->get_mapped_button_label(#))", header: stringConversionCode.} ## \
## If the button map specifies a special name for the button (eg.  if the
## operating system or keyboard device has a localized name describing the
## key), returns it, or the empty string otherwise.
##
## Note that this is not the same as get_mapped_button().get_name(), which
## returns the name of the Panda event associated with the button.

proc getMappedButtonLabel*(this: ButtonMap, i: clonglong): string {.importcpp: "nimStringFromStdString(#->get_mapped_button_label(#))", header: stringConversionCode.} ## \
## Returns the label associated with the nth mapped button, meaning the button
## that the nth raw button is mapped to.

proc getMappedButtonLabel*(this: ButtonMap, raw_name: string): string {.importcpp: "nimStringFromStdString(#->get_mapped_button_label(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## If the button map specifies a special name for the button (eg.  if the
## operating system or keyboard device has a localized name describing the
## key), returns it, or the empty string otherwise.
##
## Note that this is not the same as get_mapped_button().get_name(), which
## returns the name of the Panda event associated with the button.

proc output*(this: ButtonMap, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: ButtonMap, `out`: ostream, indent_level: int) {.importcpp: "#->write(#, #)".}

proc write*(this: ButtonMap, `out`: ostream) {.importcpp: "#->write(#)".}

converter getClassType*(_: typedesc[ButtonMap]): TypeHandle {.importcpp: "ButtonMap::get_class_type()", header: "buttonMap.h".}

proc newButtonMap*(): ButtonMap {.importcpp: "new ButtonMap()".}

proc newButtonMap*(param0: ButtonMap): ButtonMap {.importcpp: "new ButtonMap(#)".}

proc output*(this: CallbackObject, `out`: ostream) {.importcpp: "#->output(#)".}

converter getClassType*(_: typedesc[CallbackObject]): TypeHandle {.importcpp: "CallbackObject::get_class_type()", header: "callbackObject.h".}

proc newCallbackObject*(param0: CallbackObject): CallbackObject {.importcpp: "new CallbackObject(#)".}

proc getCacheRefCount*(this: CachedTypedWritableReferenceCount): int {.importcpp: "#->get_cache_ref_count()".} ## \
## Returns the current reference count.

proc cacheRef*(this: CachedTypedWritableReferenceCount) {.importcpp: "#->cache_ref()".} ## \
## Explicitly increments the cache reference count and the normal reference
## count simultaneously.

proc cacheUnref*(this: CachedTypedWritableReferenceCount): bool {.importcpp: "#->cache_unref()".} ## \
## Explicitly decrements the cache reference count and the normal reference
## count simultaneously.
##
## The return value is true if the new reference count is nonzero, false if it
## is zero.

proc testRefCountIntegrity*(this: CachedTypedWritableReferenceCount): bool {.importcpp: "#->test_ref_count_integrity()".} ## \
## Does some easy checks to make sure that the reference count isn't
## completely bogus.

converter getClassType*(_: typedesc[CachedTypedWritableReferenceCount]): TypeHandle {.importcpp: "CachedTypedWritableReferenceCount::get_class_type()", header: "cachedTypedWritableReferenceCount.h".}

proc output*(this: CallbackData, `out`: ostream) {.importcpp: "#.output(#)".}

proc upcall*(this: CallbackData) {.importcpp: "#.upcall()".} ## \
## You should make this call during the callback if you want to continue the
## normal function that would have been done in the absence of a callback.

converter getClassType*(_: typedesc[CallbackData]): TypeHandle {.importcpp: "CallbackData::get_class_type()", header: "callbackData.h".}

proc newPythonCallbackObject*(): PythonCallbackObject {.importcpp: "new PythonCallbackObject()".}

proc newPythonCallbackObject*(param0: PythonCallbackObject): PythonCallbackObject {.importcpp: "new PythonCallbackObject(#)".}

converter getClassType*(_: typedesc[PythonCallbackObject]): TypeHandle {.importcpp: "PythonCallbackObject::get_class_type()", header: "pythonCallbackObject.h".}

proc initTimeVal*(): TimeVal {.importcpp: "TimeVal()".}

proc initTimeVal*(param0: TimeVal): TimeVal {.importcpp: "TimeVal(#)".}

proc getSec*(this: TimeVal): int {.importcpp: "#.get_sec()".}

proc getUsec*(this: TimeVal): int {.importcpp: "#.get_usec()".}

proc newClockObject*(copy: ClockObject): ClockObject {.importcpp: "new ClockObject(#)".}

proc newClockObject*(): ClockObject {.importcpp: "new ClockObject()".}

proc getFrameTime*(this: ClockObject, current_thread: Thread): float64 {.importcpp: "#->get_frame_time(#)".} ## \
## Returns the time in seconds as of the last time tick() was called
## (typically, this will be as of the start of the current frame).
##
## This is generally the kind of time you want to ask for in most rendering
## and animation contexts, since it's important that all of the animation for
## a given frame remains in sync with each other.

proc getFrameTime*(this: ClockObject): float64 {.importcpp: "#->get_frame_time()".} ## \
## Returns the time in seconds as of the last time tick() was called
## (typically, this will be as of the start of the current frame).
##
## This is generally the kind of time you want to ask for in most rendering
## and animation contexts, since it's important that all of the animation for
## a given frame remains in sync with each other.

proc getRealTime*(this: ClockObject): float64 {.importcpp: "#->get_real_time()".} ## \
## Returns the actual number of seconds elapsed since the ClockObject was
## created, or since it was last reset.  This is useful for doing real timing
## measurements, e.g.  for performance statistics.
##
## This returns the most precise timer we have for short time intervals, but
## it may tend to drift over the long haul.  If more accurate timekeeping is
## needed over a long period of time, use get_long_time() instead.

proc getLongTime*(this: ClockObject): float64 {.importcpp: "#->get_long_time()".} ## \
## Returns the actual number of seconds elapsed since the ClockObject was
## created, or since it was last reset.
##
## This is similar to get_real_time(), except that it uses the most accurate
## counter we have over a long period of time, and so it is less likely to
## drift.  However, it may not be very precise for measuring short intervals.
## On Windows, for instace, this is only accurate to within about 55
## milliseconds.

proc reset*(this: ClockObject) {.importcpp: "#->reset()".} ## \
## Simultaneously resets both the time and the frame count to zero.

proc setRealTime*(this: ClockObject, time: float64) {.importcpp: "#->set_real_time(#)".} ## \
## Resets the clock to the indicated time.  This changes only the real time of
## the clock as reported by get_real_time(), but does not immediately change
## the time reported by get_frame_time()--that will change after the next call
## to tick().  Also see reset(), set_frame_time(), and set_frame_count().

proc setFrameTime*(this: ClockObject, time: float64, current_thread: Thread) {.importcpp: "#->set_frame_time(#, #)".} ## \
## Changes the time as reported for the current frame to the indicated time.
## Normally, the way to adjust the frame time is via tick(); this function is
## provided only for occasional special adjustments.

proc setFrameTime*(this: ClockObject, time: float64) {.importcpp: "#->set_frame_time(#)".} ## \
## Changes the time as reported for the current frame to the indicated time.
## Normally, the way to adjust the frame time is via tick(); this function is
## provided only for occasional special adjustments.

proc setFrameCount*(this: ClockObject, frame_count: int, current_thread: Thread) {.importcpp: "#->set_frame_count(#, #)".} ## \
## Resets the number of frames counted to the indicated number.  Also see
## reset(), set_real_time(), and set_frame_time().

proc setFrameCount*(this: ClockObject, frame_count: int) {.importcpp: "#->set_frame_count(#)".} ## \
## Resets the number of frames counted to the indicated number.  Also see
## reset(), set_real_time(), and set_frame_time().

proc getFrameCount*(this: ClockObject, current_thread: Thread): int {.importcpp: "#->get_frame_count(#)".} ## \
## Returns the number of times tick() has been called since the ClockObject
## was created, or since it was last reset.  This is generally the number of
## frames that have been rendered.

proc getFrameCount*(this: ClockObject): int {.importcpp: "#->get_frame_count()".} ## \
## Returns the number of times tick() has been called since the ClockObject
## was created, or since it was last reset.  This is generally the number of
## frames that have been rendered.

proc getNetFrameRate*(this: ClockObject, current_thread: Thread): float64 {.importcpp: "#->get_net_frame_rate(#)".} ## \
## Returns the average frame rate since the last reset.  This is simply the
## total number of frames divided by the total elapsed time.  This reports the
## virtual frame rate if the clock is in (or has been in) M_non_real_time
## mode.

proc getNetFrameRate*(this: ClockObject): float64 {.importcpp: "#->get_net_frame_rate()".} ## \
## Returns the average frame rate since the last reset.  This is simply the
## total number of frames divided by the total elapsed time.  This reports the
## virtual frame rate if the clock is in (or has been in) M_non_real_time
## mode.

proc getDt*(this: ClockObject, current_thread: Thread): float64 {.importcpp: "#->get_dt(#)".} ## \
## Returns the elapsed time for the previous frame: the number of seconds
## elapsed between the last two calls to tick().

proc getDt*(this: ClockObject): float64 {.importcpp: "#->get_dt()".} ## \
## Returns the elapsed time for the previous frame: the number of seconds
## elapsed between the last two calls to tick().

proc setDt*(this: ClockObject, dt: float64) {.importcpp: "#->set_dt(#)".} ## \
## In non-real-time mode, sets the number of seconds that should appear to
## elapse between frames.  In forced mode or limited mode, sets our target dt.
## In normal mode, this has no effect.
##
## Also see set_frame_rate(), which is a different way to specify the same
## quantity.

proc setFrameRate*(this: ClockObject, frame_rate: float64) {.importcpp: "#->set_frame_rate(#)".} ## \
## In non-real-time mode, sets the number of frames per second that we should
## appear to be running.  In forced mode or limited mode, sets our target
## frame rate.  In normal mode, this has no effect.
##
## Also see set_dt(), which is a different way to specify the same quantity.

proc getMaxDt*(this: ClockObject): float64 {.importcpp: "#->get_max_dt()".} ## \
## Returns the current maximum allowable time elapsed between any two frames.
## See set_max_dt().

proc setMaxDt*(this: ClockObject, max_dt: float64) {.importcpp: "#->set_max_dt(#)".} ## \
## Sets a limit on the value returned by get_dt().  If this value is less than
## zero, no limit is imposed; otherwise, this is the maximum value that will
## ever be returned by get_dt(), regardless of how much time has actually
## elapsed between frames.
##
## This limit is only imposed in real-time mode; in non-real-time mode, the dt
## is fixed anyway and max_dt is ignored.
##
## This is generally used to guarantee reasonable behavior even in the
## presence of a very slow or chuggy frame rame.

proc getDegradeFactor*(this: ClockObject): float64 {.importcpp: "#->get_degrade_factor()".} ## \
## In degrade mode, returns the ratio by which the performance is degraded.  A
## value of 2.0 causes the clock to be slowed down by a factor of two
## (reducing performance to 1/2 what would be otherwise).
##
## This has no effect if mode is not M_degrade.

proc setDegradeFactor*(this: ClockObject, degrade_factor: float64) {.importcpp: "#->set_degrade_factor(#)".} ## \
## In degrade mode, sets the ratio by which the performance is degraded.  A
## value of 2.0 causes the clock to be slowed down by a factor of two
## (reducing performance to 1/2 what would be otherwise).
##
## This has no effect if mode is not M_degrade.

proc setAverageFrameRateInterval*(this: ClockObject, time: float64) {.importcpp: "#->set_average_frame_rate_interval(#)".} ## \
## Specifies the interval of time (in seconds) over which
## get_average_frame_rate() averages the number of frames per second to
## compute the frame rate.  Changing this does not necessarily immediately
## change the result of get_average_frame_rate(), until this interval of time
## has elapsed again.
##
## Setting this to zero disables the computation of get_average_frame_rate().

proc getAverageFrameRateInterval*(this: ClockObject): float64 {.importcpp: "#->get_average_frame_rate_interval()".} ## \
## Returns the interval of time (in seconds) over which
## get_average_frame_rate() averages the number of frames per second to
## compute the frame rate.

proc getAverageFrameRate*(this: ClockObject, current_thread: Thread): float64 {.importcpp: "#->get_average_frame_rate(#)".} ## \
## Returns the average frame rate in number of frames per second over the last
## get_average_frame_rate_interval() seconds.  This measures the virtual frame
## rate if the clock is in M_non_real_time mode.

proc getAverageFrameRate*(this: ClockObject): float64 {.importcpp: "#->get_average_frame_rate()".} ## \
## Returns the average frame rate in number of frames per second over the last
## get_average_frame_rate_interval() seconds.  This measures the virtual frame
## rate if the clock is in M_non_real_time mode.

proc getMaxFrameDuration*(this: ClockObject, current_thread: Thread): float64 {.importcpp: "#->get_max_frame_duration(#)".} ## \
## Returns the maximum frame duration over the last
## get_average_frame_rate_interval() seconds.

proc getMaxFrameDuration*(this: ClockObject): float64 {.importcpp: "#->get_max_frame_duration()".} ## \
## Returns the maximum frame duration over the last
## get_average_frame_rate_interval() seconds.

proc calcFrameRateDeviation*(this: ClockObject, current_thread: Thread): float64 {.importcpp: "#->calc_frame_rate_deviation(#)".} ## \
## Returns the standard deviation of the frame times of the frames rendered
## over the past get_average_frame_rate_interval() seconds.  This number gives
## an estimate of the chugginess of the frame rate; if it is large, there is a
## large variation in the frame rate; if is small, all of the frames are
## consistent in length.
##
## A large value might also represent just a recent change in frame rate, for
## instance, because the camera has just rotated from looking at a simple
## scene to looking at a more complex scene.

proc calcFrameRateDeviation*(this: ClockObject): float64 {.importcpp: "#->calc_frame_rate_deviation()".} ## \
## Returns the standard deviation of the frame times of the frames rendered
## over the past get_average_frame_rate_interval() seconds.  This number gives
## an estimate of the chugginess of the frame rate; if it is large, there is a
## large variation in the frame rate; if is small, all of the frames are
## consistent in length.
##
## A large value might also represent just a recent change in frame rate, for
## instance, because the camera has just rotated from looking at a simple
## scene to looking at a more complex scene.

proc tick*(this: ClockObject, current_thread: Thread) {.importcpp: "#->tick(#)".} ## \
## Instructs the clock that a new frame has just begun.  In normal, real-time
## mode, get_frame_time() will henceforth report the time as of this instant
## as the current start-of-frame time.  In non-real-time mode,
## get_frame_time() will be incremented by the value of dt.

proc tick*(this: ClockObject) {.importcpp: "#->tick()".} ## \
## Instructs the clock that a new frame has just begun.  In normal, real-time
## mode, get_frame_time() will henceforth report the time as of this instant
## as the current start-of-frame time.  In non-real-time mode,
## get_frame_time() will be incremented by the value of dt.

proc syncFrameTime*(this: ClockObject, current_thread: Thread) {.importcpp: "#->sync_frame_time(#)".} ## \
## Resets the frame time to the current real time.  This is similar to tick(),
## except that it does not advance the frame counter and does not affect dt.
## This is intended to be used in the middle of a particularly long frame to
## compensate for the time that has already elapsed.
##
## In non-real-time mode, this function has no effect (because in this mode
## all frames take the same length of time).

proc syncFrameTime*(this: ClockObject) {.importcpp: "#->sync_frame_time()".} ## \
## Resets the frame time to the current real time.  This is similar to tick(),
## except that it does not advance the frame counter and does not affect dt.
## This is intended to be used in the middle of a particularly long frame to
## compensate for the time that has already elapsed.
##
## In non-real-time mode, this function has no effect (because in this mode
## all frames take the same length of time).

proc checkErrors*(this: ClockObject, current_thread: Thread): bool {.importcpp: "#->check_errors(#)".} ## \
## Returns true if a clock error was detected since the last time
## check_errors() was called.  A clock error means that something happened, an
## OS or BIOS bug, for instance, that makes the current value of the clock
## somewhat suspect, and an application may wish to resynchronize with any
## external clocks.

proc getGlobalClock*(_: typedesc[ClockObject]): ClockObject {.importcpp: "ClockObject::get_global_clock()", header: "clockObject.h".} ## \
## Returns a pointer to the global ClockObject.  This is the ClockObject that
## most code should use for handling scene graph rendering and animation.

converter getClassType*(_: typedesc[ClockObject]): TypeHandle {.importcpp: "ClockObject::get_class_type()", header: "clockObject.h".}

proc parseColorSpaceString*(str: string): ColorSpace {.importcpp: "parse_color_space_string(nimStringToStdString(#))", header: stringConversionCode.}

proc formatColorSpace*(cs: ColorSpace): string {.importcpp: "nimStringFromStdString(format_color_space(#))", header: stringConversionCode.}

proc getModelPath*(): ConfigVariableSearchPath {.importcpp: "get_model_path()".}

proc getPluginPath*(): ConfigVariableSearchPath {.importcpp: "get_plugin_path()".}

proc cacheRef*(this: CopyOnWriteObject) {.importcpp: "#->cache_ref()".} ## \
## @see CachedTypedWritableReferenceCount::cache_ref()

proc cacheUnref*(this: CopyOnWriteObject): bool {.importcpp: "#->cache_unref()".} ## \
## @see CachedTypedWritableReferenceCount::cache_unref()

converter getClassType*(_: typedesc[CopyOnWriteObject]): TypeHandle {.importcpp: "CopyOnWriteObject::get_class_type()", header: "copyOnWriteObject.h".}

converter upcastToDatagramSink*(this: DatagramBuffer): DatagramSink {.importcpp: "#.upcast_to_DatagramSink()".}

converter upcastToDatagramGenerator*(this: DatagramBuffer): DatagramGenerator {.importcpp: "#.upcast_to_DatagramGenerator()".}

proc initDatagramBuffer*(): DatagramBuffer {.importcpp: "DatagramBuffer()".} ## \
## Initializes an empty datagram buffer.

proc clear*(this: DatagramBuffer) {.importcpp: "#.clear()".} ## \
## Clears the internal buffer.

proc initDatagramInputFile*(): DatagramInputFile {.importcpp: "DatagramInputFile()".}

proc open*(this: DatagramInputFile, file: FileReference): bool {.importcpp: "#.open(#)".} ## \
## Opens the indicated filename for reading.  Returns true on success, false
## on failure.

proc open*(this: DatagramInputFile, filename: Filename): bool {.importcpp: "#.open(#)".} ## \
## Opens the indicated filename for reading.  Returns true on success, false
## on failure.

proc open*(this: DatagramInputFile, `in`: istream, filename: Filename): bool {.importcpp: "#.open(#, #)".} ## \
## Starts reading from the indicated stream.  Returns true on success, false
## on failure.  The DatagramInputFile does not take ownership of the stream;
## you are responsible for closing or deleting it when you are done.

proc open*(this: DatagramInputFile, `in`: istream): bool {.importcpp: "#.open(#)".} ## \
## Starts reading from the indicated stream.  Returns true on success, false
## on failure.  The DatagramInputFile does not take ownership of the stream;
## you are responsible for closing or deleting it when you are done.

proc getStream*(this: DatagramInputFile): istream {.importcpp: "#.get_stream()".} ## \
## Returns the istream represented by the input file.

proc close*(this: DatagramInputFile) {.importcpp: "#.close()".} ## \
## Closes the file.  This is also implicitly done when the DatagramInputFile
## destructs.

proc initDatagramOutputFile*(): DatagramOutputFile {.importcpp: "DatagramOutputFile()".}

proc open*(this: DatagramOutputFile, file: FileReference): bool {.importcpp: "#.open(#)".} ## \
## Opens the indicated filename for writing.  Returns true if successful,
## false on failure.

proc open*(this: DatagramOutputFile, filename: Filename): bool {.importcpp: "#.open(#)".} ## \
## Opens the indicated filename for writing.  Returns true on success, false
## on failure.

proc open*(this: DatagramOutputFile, `out`: ostream, filename: Filename): bool {.importcpp: "#.open(#, #)".} ## \
## Starts writing to the indicated stream.  Returns true on success, false on
## failure.  The DatagramOutputFile does not take ownership of the stream; you
## are responsible for closing or deleting it when you are done.

proc open*(this: DatagramOutputFile, `out`: ostream): bool {.importcpp: "#.open(#)".} ## \
## Starts writing to the indicated stream.  Returns true on success, false on
## failure.  The DatagramOutputFile does not take ownership of the stream; you
## are responsible for closing or deleting it when you are done.

proc close*(this: DatagramOutputFile) {.importcpp: "#.close()".} ## \
## Closes the file.  This is also implicitly done when the DatagramOutputFile
## destructs.

proc writeHeader*(this: DatagramOutputFile, header: string): bool {.importcpp: "#.write_header(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Writes a sequence of bytes to the beginning of the datagram file.  This may
## be called any number of times after the file has been opened and before the
## first datagram is written.  It may not be called once the first datagram is
## written.

proc lstick*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::lstick()", header: "gamepadButton.h".}

proc rstick*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::rstick()", header: "gamepadButton.h".}

proc lshoulder*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::lshoulder()", header: "gamepadButton.h".}

proc rshoulder*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::rshoulder()", header: "gamepadButton.h".}

proc ltrigger*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::ltrigger()", header: "gamepadButton.h".}

proc rtrigger*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::rtrigger()", header: "gamepadButton.h".}

proc lgrip*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::lgrip()", header: "gamepadButton.h".}

proc rgrip*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::rgrip()", header: "gamepadButton.h".}

proc dpadLeft*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::dpad_left()", header: "gamepadButton.h".}

proc dpadRight*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::dpad_right()", header: "gamepadButton.h".}

proc dpadUp*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::dpad_up()", header: "gamepadButton.h".}

proc dpadDown*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::dpad_down()", header: "gamepadButton.h".}

proc back*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::back()", header: "gamepadButton.h".}

proc guide*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::guide()", header: "gamepadButton.h".}

proc start*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::start()", header: "gamepadButton.h".}

proc next*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::next()", header: "gamepadButton.h".}

proc previous*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::previous()", header: "gamepadButton.h".}

proc faceA*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::face_a()", header: "gamepadButton.h".}

proc faceB*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::face_b()", header: "gamepadButton.h".}

proc faceC*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::face_c()", header: "gamepadButton.h".}

proc faceX*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::face_x()", header: "gamepadButton.h".}

proc faceY*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::face_y()", header: "gamepadButton.h".}

proc faceZ*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::face_z()", header: "gamepadButton.h".}

proc face1*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::face_1()", header: "gamepadButton.h".}

proc face2*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::face_2()", header: "gamepadButton.h".}

proc trigger*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::trigger()", header: "gamepadButton.h".} ## \
## Flight stick buttons, takes zero-based index.  First is always trigger.

proc joystick*(_: typedesc[GamepadButton], button_number: int): ButtonHandle {.importcpp: "#GamepadButton::joystick(#)", header: "gamepadButton.h".} ## \
## Returns the ButtonHandle associated with the particular numbered joystick
## button (zero-based), if there is one, or ButtonHandle::none() if there is
## not.

proc hatUp*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::hat_up()", header: "gamepadButton.h".}

proc hatDown*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::hat_down()", header: "gamepadButton.h".}

proc hatLeft*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::hat_left()", header: "gamepadButton.h".}

proc hatRight*(_: typedesc[GamepadButton]): ButtonHandle {.importcpp: "GamepadButton::hat_right()", header: "gamepadButton.h".}

proc initGamepadButton*(): GamepadButton {.importcpp: "GamepadButton()".}

proc initGamepadButton*(param0: GamepadButton): GamepadButton {.importcpp: "GamepadButton(#)".}

proc asciiKey*(_: typedesc[KeyboardButton], ascii_equivalent: char): ButtonHandle {.importcpp: "#KeyboardButton::ascii_key(#)", header: "keyboardButton.h".} ## \
## Returns the ButtonHandle associated with the particular ASCII character, if
## there is one, or ButtonHandle::none() if there is not.

proc space*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::space()", header: "keyboardButton.h".}

proc backspace*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::backspace()", header: "keyboardButton.h".}

proc tab*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::tab()", header: "keyboardButton.h".}

proc enter*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::enter()", header: "keyboardButton.h".}

proc escape*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::escape()", header: "keyboardButton.h".}

proc f1*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f1()", header: "keyboardButton.h".}

proc f2*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f2()", header: "keyboardButton.h".}

proc f3*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f3()", header: "keyboardButton.h".}

proc f4*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f4()", header: "keyboardButton.h".}

proc f5*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f5()", header: "keyboardButton.h".}

proc f6*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f6()", header: "keyboardButton.h".}

proc f7*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f7()", header: "keyboardButton.h".}

proc f8*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f8()", header: "keyboardButton.h".}

proc f9*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f9()", header: "keyboardButton.h".}

proc f10*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f10()", header: "keyboardButton.h".}

proc f11*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f11()", header: "keyboardButton.h".}

proc f12*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f12()", header: "keyboardButton.h".}

proc f13*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f13()", header: "keyboardButton.h".} ## \
## PC keyboards don't have these four buttons, but Macs do.

proc f14*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f14()", header: "keyboardButton.h".}

proc f15*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f15()", header: "keyboardButton.h".}

proc f16*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::f16()", header: "keyboardButton.h".}

proc left*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::left()", header: "keyboardButton.h".}

proc right*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::right()", header: "keyboardButton.h".}

proc up*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::up()", header: "keyboardButton.h".}

proc down*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::down()", header: "keyboardButton.h".}

proc pageUp*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::page_up()", header: "keyboardButton.h".}

proc pageDown*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::page_down()", header: "keyboardButton.h".}

proc home*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::home()", header: "keyboardButton.h".}

proc insert*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::insert()", header: "keyboardButton.h".}

proc del*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::del()", header: "keyboardButton.h".} ## \
## delete is a C++ keyword.

proc help*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::help()", header: "keyboardButton.h".} ## \
## delete is a C++ keyword.

proc menu*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::menu()", header: "keyboardButton.h".}

proc shift*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::shift()", header: "keyboardButton.h".}

proc control*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::control()", header: "keyboardButton.h".}

proc alt*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::alt()", header: "keyboardButton.h".}

proc meta*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::meta()", header: "keyboardButton.h".}

proc capsLock*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::caps_lock()", header: "keyboardButton.h".}

proc shiftLock*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::shift_lock()", header: "keyboardButton.h".}

proc numLock*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::num_lock()", header: "keyboardButton.h".}

proc scrollLock*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::scroll_lock()", header: "keyboardButton.h".}

proc printScreen*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::print_screen()", header: "keyboardButton.h".}

proc pause*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::pause()", header: "keyboardButton.h".}

proc lshift*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::lshift()", header: "keyboardButton.h".}

proc rshift*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::rshift()", header: "keyboardButton.h".}

proc lcontrol*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::lcontrol()", header: "keyboardButton.h".}

proc rcontrol*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::rcontrol()", header: "keyboardButton.h".}

proc lalt*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::lalt()", header: "keyboardButton.h".}

proc ralt*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::ralt()", header: "keyboardButton.h".}

proc lmeta*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::lmeta()", header: "keyboardButton.h".}

proc rmeta*(_: typedesc[KeyboardButton]): ButtonHandle {.importcpp: "KeyboardButton::rmeta()", header: "keyboardButton.h".}

proc initKeyboardButton*(): KeyboardButton {.importcpp: "KeyboardButton()".}

proc initKeyboardButton*(param0: KeyboardButton): KeyboardButton {.importcpp: "KeyboardButton(#)".}

proc loadPrcFile*(filename: Filename): ConfigPage {.importcpp: "load_prc_file(#)".} ## \
## A convenience function for loading explicit prc files from a disk file or
## from within a multifile (via the virtual file system).  Save the return
## value and pass it to unload_prc_file() if you ever want to unload this file
## later.
##
## The filename is first searched along the default prc search path, and then
## also along the model path, for convenience.
##
## This function is defined in putil instead of in dtool with the read of the
## prc stuff, so that it can take advantage of the virtual file system (which
## is defined in express), and the model path (which is in putil).

proc loadPrcFileData*(name: string, data: string): ConfigPage {.importcpp: "load_prc_file_data(nimStringToStdString(#), nimStringToStdString(#))", header: stringConversionCode.} ## \
## Another convenience function to load a prc file from an explicit string,
## which represents the contents of the prc file.
##
## The first parameter is an arbitrary name to assign to this in-memory prc
## file.  Supply a filename if the data was read from a file, or use any other
## name that is meaningful to you.  The name is only used when the set of
## loaded prc files is listed.

proc unloadPrcFile*(page: ConfigPage): bool {.importcpp: "unload_prc_file(#)".}

proc hashPrcVariables*(hash: HashVal) {.importcpp: "hash_prc_variables(#)".}

proc initModifierButtons*(): ModifierButtons {.importcpp: "ModifierButtons()".}

proc initModifierButtons*(copy: ModifierButtons): ModifierButtons {.importcpp: "ModifierButtons(#)".}

proc `==`*(this: ModifierButtons, other: ModifierButtons): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: ModifierButtons, other: ModifierButtons): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: ModifierButtons, other: ModifierButtons): bool {.importcpp: "#.operator <(#)".}

proc `&`*(this: ModifierButtons, other: ModifierButtons): ModifierButtons {.importcpp: "#.operator &(#)".}

proc `|`*(this: ModifierButtons, other: ModifierButtons): ModifierButtons {.importcpp: "#.operator |(#)".}

proc `&=`*(this: var ModifierButtons, other: ModifierButtons): ModifierButtons {.importcpp: "#.operator &=(#)".}

proc `|=`*(this: var ModifierButtons, other: ModifierButtons): ModifierButtons {.importcpp: "#.operator |=(#)".}

proc setButtonList*(this: ModifierButtons, other: ModifierButtons) {.importcpp: "#.set_button_list(#)".} ## \
## Sets the list of buttons to watch to be the same as that of the other
## ModifierButtons object.  This makes the lists pointer equivalent (until one
## or the other is later modified).
##
## This will preserve the state of any button that was on the original list
## and is also on the new lists.  Any other buttons will get reset to the
## default state of "up".

proc matches*(this: ModifierButtons, other: ModifierButtons): bool {.importcpp: "#.matches(#)".} ## \
## Returns true if the set of buttons indicated as down by this
## ModifierButtons object is the same set of buttons indicated as down by the
## other ModifierButtons object.  The buttons indicated as up are not
## relevant.

proc addButton*(this: ModifierButtons, button: ButtonHandle): bool {.importcpp: "#.add_button(#)".} ## \
## Adds the indicated button to the set of buttons that will be monitored for
## upness and downness.  Returns true if the button was added, false if it was
## already being monitored or if too many buttons are currently being
## monitored.

proc hasButton*(this: ModifierButtons, button: ButtonHandle): bool {.importcpp: "#.has_button(#)".} ## \
## Returns true if the indicated button is in the set of buttons being
## monitored, false otherwise.

proc removeButton*(this: ModifierButtons, button: ButtonHandle): bool {.importcpp: "#.remove_button(#)".} ## \
## Removes the indicated button from the set of buttons being monitored.
## Returns true if the button was removed, false if it was not being monitored
## in the first place.
##
## Unlike the other methods, you cannot remove a button by removing its alias;
## you have to remove exactly the button itself.

proc getNumButtons*(this: ModifierButtons): int {.importcpp: "#.get_num_buttons()".} ## \
## Returns the number of buttons that the ModifierButtons object is monitoring
## (e.g.  the number of buttons passed to add_button()).

proc getButton*(this: ModifierButtons, index: int): ButtonHandle {.importcpp: "#.get_button(#)".} ## \
## Returns the nth button that the ModifierButtons object is monitoring (the
## nth button passed to add_button()).  This must be in the range 0 <= index <
## get_num_buttons().

proc buttonDown*(this: ModifierButtons, button: ButtonHandle): bool {.importcpp: "#.button_down(#)".} ## \
## Records that a particular button has been pressed.  If the given button is
## one of the buttons that is currently being monitored, this will update the
## internal state appropriately; otherwise, it will do nothing.  Returns true
## if the button is one that was monitored, or false otherwise.

proc buttonUp*(this: ModifierButtons, button: ButtonHandle): bool {.importcpp: "#.button_up(#)".} ## \
## Records that a particular button has been released.  If the given button is
## one of the buttons that is currently being monitored, this will update the
## internal state appropriately; otherwise, it will do nothing.  Returns true
## if the button is one that was monitored, or false otherwise.

proc allButtonsUp*(this: ModifierButtons) {.importcpp: "#.all_buttons_up()".} ## \
## Marks all monitored buttons as being in the "up" state.

proc isDown*(this: ModifierButtons, button: ButtonHandle): bool {.importcpp: "#.is_down(#)".} ## \
## Returns true if the indicated button is known to be down, or false if it is
## known to be up or if it is not in the set of buttons being tracked.

proc isDown*(this: ModifierButtons, index: int): bool {.importcpp: "#.is_down(#)".} ## \
## Returns true if the indicated button is known to be down, or false if it is
## known to be up.

proc isAnyDown*(this: ModifierButtons): bool {.importcpp: "#.is_any_down()".} ## \
## Returns true if any of the tracked button are known to be down, or false if
## all of them are up.

proc getPrefix*(this: ModifierButtons): string {.importcpp: "nimStringFromStdString(#.get_prefix())", header: stringConversionCode.} ## \
## Returns a string which can be used to prefix any button name or event name
## with the unique set of modifier buttons currently being held.

proc output*(this: ModifierButtons, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## Writes a one-line summary of the buttons known to be down.

proc write*(this: ModifierButtons, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## Writes a multi-line summary including all of the buttons being monitored
## and which ones are known to be down.

proc button*(_: typedesc[MouseButton], button_number: int): ButtonHandle {.importcpp: "#MouseButton::button(#)", header: "mouseButton.h".} ## \
## Returns the ButtonHandle associated with the particular numbered mouse
## button (zero-based), if there is one, or ButtonHandle::none() if there is
## not.

proc one*(_: typedesc[MouseButton]): ButtonHandle {.importcpp: "MouseButton::one()", header: "mouseButton.h".} ## \
## Returns the ButtonHandle associated with the first mouse button.

proc two*(_: typedesc[MouseButton]): ButtonHandle {.importcpp: "MouseButton::two()", header: "mouseButton.h".} ## \
## Returns the ButtonHandle associated with the second mouse button.

proc three*(_: typedesc[MouseButton]): ButtonHandle {.importcpp: "MouseButton::three()", header: "mouseButton.h".} ## \
## Returns the ButtonHandle associated with the third mouse button.

proc four*(_: typedesc[MouseButton]): ButtonHandle {.importcpp: "MouseButton::four()", header: "mouseButton.h".} ## \
## Returns the ButtonHandle associated with the fourth mouse button.

proc five*(_: typedesc[MouseButton]): ButtonHandle {.importcpp: "MouseButton::five()", header: "mouseButton.h".} ## \
## Returns the ButtonHandle associated with the fifth mouse button.

proc wheelUp*(_: typedesc[MouseButton]): ButtonHandle {.importcpp: "MouseButton::wheel_up()", header: "mouseButton.h".} ## \
## Returns the ButtonHandle generated when the mouse wheel is rolled one notch
## upwards.

proc wheelDown*(_: typedesc[MouseButton]): ButtonHandle {.importcpp: "MouseButton::wheel_down()", header: "mouseButton.h".} ## \
## Returns the ButtonHandle generated when the mouse wheel is rolled one notch
## downwards.

proc wheelLeft*(_: typedesc[MouseButton]): ButtonHandle {.importcpp: "MouseButton::wheel_left()", header: "mouseButton.h".} ## \
## Returns the ButtonHandle generated when the mouse is scrolled to the left.
## Usually, you'll only find the horizontal scroll on laptops.

proc wheelRight*(_: typedesc[MouseButton]): ButtonHandle {.importcpp: "MouseButton::wheel_right()", header: "mouseButton.h".} ## \
## Returns the ButtonHandle generated when the mouse is scrolled to the right.
## Usually, you'll only find the horizontal scroll on laptops.

proc isMouseButton*(_: typedesc[MouseButton], button: ButtonHandle): bool {.importcpp: "#MouseButton::is_mouse_button(#)", header: "mouseButton.h".} ## \
## Returns true if the indicated ButtonHandle is a mouse button, false if it
## is some other kind of button.

proc initMouseButton*(): MouseButton {.importcpp: "MouseButton()".}

proc initMouseButton*(param0: MouseButton): MouseButton {.importcpp: "MouseButton(#)".}

proc getX*(this: PointerData): float64 {.importcpp: "#.get_x()".}

proc getY*(this: PointerData): float64 {.importcpp: "#.get_y()".}

proc getInWindow*(this: PointerData): bool {.importcpp: "#.get_in_window()".} ## \
## If this returns false, the pointer is not currently present in the window
## and the values returned by get_x() and get_y() may not be meaningful.

proc initPointerData*(): PointerData {.importcpp: "PointerData()".}

proc initPointerData*(param0: PointerData): PointerData {.importcpp: "PointerData(#)".}

proc getNodeRefCount*(this: NodeCachedReferenceCount): int {.importcpp: "#->get_node_ref_count()".} ## \
## Returns the current reference count.

proc nodeRef*(this: NodeCachedReferenceCount) {.importcpp: "#->node_ref()".} ## \
## Explicitly increments the reference count.
##
## This function is const, even though it changes the object, because
## generally fiddling with an object's reference count isn't considered part
## of fiddling with the object.  An object might be const in other ways, but
## we still need to accurately count the number of references to it.

proc nodeUnref*(this: NodeCachedReferenceCount): bool {.importcpp: "#->node_unref()".} ## \
## Explicitly decrements the node reference count and the normal reference
## count simultaneously.
##
## The return value is true if the new reference count is nonzero, false if it
## is zero.

proc testRefCountIntegrity*(this: NodeCachedReferenceCount): bool {.importcpp: "#->test_ref_count_integrity()".} ## \
## Does some easy checks to make sure that the reference count isn't
## completely bogus.

proc getReferencedBits*(this: NodeCachedReferenceCount): int {.importcpp: "#->get_referenced_bits()".} ## \
## Returns the union of the values defined in the Referenced enum that
## represents the various things that appear to be holding a pointer to this
## object.
##
## If R_node is included, at least one node is holding a pointer; if R_cache
## is included, at least one cache element is.

converter getClassType*(_: typedesc[NodeCachedReferenceCount]): TypeHandle {.importcpp: "NodeCachedReferenceCount::get_class_type()", header: "nodeCachedReferenceCount.h".}

proc initSparseArray*(): SparseArray {.importcpp: "SparseArray()".}

converter initSparseArray*(`from`: BitArray): SparseArray {.importcpp: "SparseArray(#)".}

proc initSparseArray*(param0: SparseArray): SparseArray {.importcpp: "SparseArray(#)".}

proc allOn*(_: typedesc[SparseArray]): SparseArray {.importcpp: "SparseArray::all_on()", header: "sparseArray.h".} ## \
## Returns a SparseArray with an infinite array of bits, all on.

proc allOff*(_: typedesc[SparseArray]): SparseArray {.importcpp: "SparseArray::all_off()", header: "sparseArray.h".} ## \
## Returns a SparseArray whose bits are all off.

proc lowerOn*(_: typedesc[SparseArray], on_bits: int): SparseArray {.importcpp: "#SparseArray::lower_on(#)", header: "sparseArray.h".} ## \
## Returns a SparseArray whose lower on_bits bits are on.

proc bit*(_: typedesc[SparseArray], index: int): SparseArray {.importcpp: "#SparseArray::bit(#)", header: "sparseArray.h".} ## \
## Returns a SparseArray with only the indicated bit on.

proc range*(_: typedesc[SparseArray], low_bit: int, size: int): SparseArray {.importcpp: "#SparseArray::range(#, #)", header: "sparseArray.h".} ## \
## Returns a SparseArray whose size bits, beginning at low_bit, are on.

proc hasMaxNumBits*(_: typedesc[SparseArray]): bool {.importcpp: "SparseArray::has_max_num_bits()", header: "sparseArray.h".} ## \
## Returns true if there is a maximum number of bits that may be stored in
## this structure, false otherwise.  If this returns true, the number may be
## queried in get_max_num_bits().
##
## This method always returns false.  The SparseArray has no maximum number of
## bits.  This method is defined so generic programming algorithms can use
## BitMask or SparseArray interchangeably.

proc getMaxNumBits*(_: typedesc[SparseArray]): int {.importcpp: "SparseArray::get_max_num_bits()", header: "sparseArray.h".} ## \
## If get_max_num_bits() returned true, this method may be called to return
## the maximum number of bits that may be stored in this structure.  It is an
## error to call this if get_max_num_bits() return false.
##
## It is always an error to call this method.  The SparseArray has no maximum
## number of bits.  This method is defined so generic programming algorithms
## can use BitMask or SparseArray interchangeably.

proc getNumBits*(this: SparseArray): int {.importcpp: "#.get_num_bits()".} ## \
## Returns the current number of possibly different bits in this array.  There
## are actually an infinite number of bits, but every bit higher than this bit
## will have the same value, either 0 or 1 (see get_highest_bits()).
##
## This number may grow and/or shrink automatically as needed.

proc getBit*(this: SparseArray, index: int): bool {.importcpp: "#.get_bit(#)".} ## \
## Returns true if the nth bit is set, false if it is cleared.  It is valid
## for n to increase beyond get_num_bits(), but the return value
## get_num_bits() will always be the same.

proc setBit*(this: SparseArray, index: int) {.importcpp: "#.set_bit(#)".} ## \
## Sets the nth bit on.  If n >= get_num_bits(), this automatically extends
## the array.

proc clearBit*(this: SparseArray, index: int) {.importcpp: "#.clear_bit(#)".} ## \
## Sets the nth bit off.  If n >= get_num_bits(), this automatically extends
## the array.

proc setBitTo*(this: SparseArray, index: int, value: bool) {.importcpp: "#.set_bit_to(#, #)".} ## \
## Sets the nth bit either on or off, according to the indicated bool value.

proc getHighestBits*(this: SparseArray): bool {.importcpp: "#.get_highest_bits()".} ## \
## Returns true if the infinite set of bits beyond get_num_bits() are all on,
## or false of they are all off.

proc isZero*(this: SparseArray): bool {.importcpp: "#.is_zero()".} ## \
## Returns true if the entire bitmask is zero, false otherwise.

proc isAllOn*(this: SparseArray): bool {.importcpp: "#.is_all_on()".} ## \
## Returns true if the entire bitmask is one, false otherwise.

proc hasAnyOf*(this: SparseArray, low_bit: int, size: int): bool {.importcpp: "#.has_any_of(#, #)".} ## \
## Returns true if any bit in the indicated range is set, false otherwise.

proc hasAllOf*(this: SparseArray, low_bit: int, size: int): bool {.importcpp: "#.has_all_of(#, #)".} ## \
## Returns true if all bits in the indicated range are set, false otherwise.

proc setRange*(this: SparseArray, low_bit: int, size: int) {.importcpp: "#.set_range(#, #)".} ## \
## Sets the indicated range of bits on.

proc clearRange*(this: SparseArray, low_bit: int, size: int) {.importcpp: "#.clear_range(#, #)".} ## \
## Sets the indicated range of bits off.

proc setRangeTo*(this: SparseArray, value: bool, low_bit: int, size: int) {.importcpp: "#.set_range_to(#, #, #)".} ## \
## Sets the indicated range of bits to either on or off.

proc getNumOnBits*(this: SparseArray): int {.importcpp: "#.get_num_on_bits()".} ## \
## Returns the number of bits that are set to 1 in the array.  Returns -1 if
## there are an infinite number of 1 bits.

proc getNumOffBits*(this: SparseArray): int {.importcpp: "#.get_num_off_bits()".} ## \
## Returns the number of bits that are set to 0 in the array.  Returns -1 if
## there are an infinite number of 0 bits.

proc getLowestOnBit*(this: SparseArray): int {.importcpp: "#.get_lowest_on_bit()".} ## \
## Returns the index of the lowest 1 bit in the array.  Returns -1 if there
## are no 1 bits or if there are an infinite number of 1 bits.

proc getLowestOffBit*(this: SparseArray): int {.importcpp: "#.get_lowest_off_bit()".} ## \
## Returns the index of the lowest 0 bit in the array.  Returns -1 if there
## are no 0 bits or if there are an infinite number of 1 bits.

proc getHighestOnBit*(this: SparseArray): int {.importcpp: "#.get_highest_on_bit()".} ## \
## Returns the index of the highest 1 bit in the array.  Returns -1 if there
## are no 1 bits or if there an infinite number of 1 bits.

proc getHighestOffBit*(this: SparseArray): int {.importcpp: "#.get_highest_off_bit()".} ## \
## Returns the index of the highest 0 bit in the array.  Returns -1 if there
## are no 0 bits or if there an infinite number of 1 bits.

proc getNextHigherDifferentBit*(this: SparseArray, low_bit: int): int {.importcpp: "#.get_next_higher_different_bit(#)".} ## \
## Returns the index of the next bit in the array, above low_bit, whose value
## is different that the value of low_bit.  Returns low_bit again if all bits
## higher than low_bit have the same value.
##
## This can be used to quickly iterate through all of the bits in the array.

proc invertInPlace*(this: SparseArray) {.importcpp: "#.invert_in_place()".} ## \
## Inverts all the bits in the SparseArray.  This is equivalent to array =
## ~array.

proc hasBitsInCommon*(this: SparseArray, other: SparseArray): bool {.importcpp: "#.has_bits_in_common(#)".} ## \
## Returns true if this SparseArray has any "one" bits in common with the
## other one, false otherwise.
##
## This is equivalent to (array & other) != 0, but may be faster.

proc clear*(this: SparseArray) {.importcpp: "#.clear()".} ## \
## Sets all the bits in the SparseArray off.

proc output*(this: SparseArray, `out`: ostream) {.importcpp: "#.output(#)".}

proc `==`*(this: SparseArray, other: SparseArray): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: SparseArray, other: SparseArray): bool {.importcpp: "#.operator !=(#)".}

proc `<`*(this: SparseArray, other: SparseArray): bool {.importcpp: "#.operator <(#)".}

proc compareTo*(this: SparseArray, other: SparseArray): int {.importcpp: "#.compare_to(#)".} ## \
## Returns a number less than zero if this SparseArray sorts before the
## indicated other SparseArray, greater than zero if it sorts after, or 0 if
## they are equivalent.  This is based on the same ordering defined by
## operator <.

proc `&`*(this: SparseArray, other: SparseArray): SparseArray {.importcpp: "#.operator &(#)".}

proc `|`*(this: SparseArray, other: SparseArray): SparseArray {.importcpp: "#.operator |(#)".}

proc `^`*(this: SparseArray, other: SparseArray): SparseArray {.importcpp: "#.operator ^(#)".}

proc `~`*(this: SparseArray): SparseArray {.importcpp: "#.operator ~()".}

proc `<<`*(this: SparseArray, shift: int): SparseArray {.importcpp: "#.operator <<(#)".}

proc `>>`*(this: SparseArray, shift: int): SparseArray {.importcpp: "#.operator >>(#)".}

proc `&=`*(this: var SparseArray, other: SparseArray): SparseArray {.importcpp: "#.operator &=(#)".}

proc `|=`*(this: var SparseArray, other: SparseArray): SparseArray {.importcpp: "#.operator |=(#)".}

proc `^=`*(this: var SparseArray, other: SparseArray): SparseArray {.importcpp: "#.operator ^=(#)".}

proc `<<=`*(this: var SparseArray, shift: int): SparseArray {.importcpp: "#.operator <<=(#)".}

proc `>>=`*(this: var SparseArray, shift: int): SparseArray {.importcpp: "#.operator >>=(#)".}

proc isInverse*(this: SparseArray): bool {.importcpp: "#.is_inverse()".} ## \
## If this is true, the SparseArray is actually defined as a list of subranges
## of integers that are \*not\* in the set.  If this is false (the default),
## then the subranges define the integers that \*are\* in the set.  This affects
## the interpretation of the values returned by iterating through
## get_num_subranges().

proc getNumSubranges*(this: SparseArray): clonglong {.importcpp: "#.get_num_subranges()".} ## \
## Returns the number of separate subranges stored in the SparseArray.  You
## can use this limit to iterate through the subranges, calling
## get_subrange_begin() and get_subrange_end() for each one.
##
## Also see is_inverse().

proc getSubrangeBegin*(this: SparseArray, n: clonglong): int {.importcpp: "#.get_subrange_begin(#)".} ## \
## Returns the first numeric element in the nth subrange.
##
## Also see is_inverse().

proc getSubrangeEnd*(this: SparseArray, n: clonglong): int {.importcpp: "#.get_subrange_end(#)".} ## \
## Returns the last numeric element, plus one, in the nth subrange.
##
## Also see is_inverse().

converter getClassType*(_: typedesc[SparseArray]): TypeHandle {.importcpp: "SparseArray::get_class_type()", header: "sparseArray.h".}

proc getValueType*(this: ParamValueBase): TypeHandle {.importcpp: "#->get_value_type()".} ## \
## Returns the type of the underlying value.

proc output*(this: ParamValueBase, `out`: ostream) {.importcpp: "#->output(#)".}

converter getClassType*(_: typedesc[ParamValueBase]): TypeHandle {.importcpp: "ParamValueBase::get_class_type()", header: "paramValue.h".}

proc newParamTypedRefCount*(value: TypedReferenceCount): ParamTypedRefCount {.importcpp: "new ParamTypedRefCount(#)".}

proc getValue*(this: ParamTypedRefCount): TypedReferenceCount {.importcpp: "#->get_value()".} ## \
## Retrieves the value stored in the parameter.

converter getClassType*(_: typedesc[ParamTypedRefCount]): TypeHandle {.importcpp: "ParamTypedRefCount::get_class_type()", header: "paramValue.h".}

converter getClassType*(_: typedesc[WritableConfigurable]): TypeHandle {.importcpp: "WritableConfigurable::get_class_type()", header: "writableConfigurable.h".}

proc initUniqueIdAllocator*(param0: UniqueIdAllocator): UniqueIdAllocator {.importcpp: "UniqueIdAllocator(#)".}

proc initUniqueIdAllocator*(min: int, max: int): UniqueIdAllocator {.importcpp: "UniqueIdAllocator(#, #)".} ## \
## Create a free id pool in the range [min:max].

proc initUniqueIdAllocator*(min: int): UniqueIdAllocator {.importcpp: "UniqueIdAllocator(#)".} ## \
## Create a free id pool in the range [min:max].

proc initUniqueIdAllocator*(): UniqueIdAllocator {.importcpp: "UniqueIdAllocator()".} ## \
## Create a free id pool in the range [min:max].

proc allocate*(this: UniqueIdAllocator): int {.importcpp: "#.allocate()".} ## \
## Returns an id between _min and _max (that were passed to the constructor).
## IndexEnd is returned if no ids are available.

proc initialReserveId*(this: UniqueIdAllocator, id: int) {.importcpp: "#.initial_reserve_id(#)".} ## \
## This may be called to mark a particular id as having already been allocated
## (for instance, by a prior pass).  The specified id is removed from the
## available pool.
##
## Because of the limitations of this algorithm, this is most efficient when
## it is called before the first call to allocate(), and when all the calls to
## initial_reserve_id() are made in descending order by id.  However, this is
## a performance warning only; if performance is not an issue, any id may be
## reserved at any time.

proc free*(this: UniqueIdAllocator, index: int) {.importcpp: "#.free(#)".} ## \
## Free an allocated index (index must be between _min and _max that were
## passed to the constructor).

proc fractionUsed*(this: UniqueIdAllocator): float32 {.importcpp: "#.fraction_used()".} ## \
## return the decimal fraction of the pool that is used.  The range is 0 to
## 1.0 (e.g.  75% would be 0.75).

proc output*(this: UniqueIdAllocator, `out`: ostream) {.importcpp: "#.output(#)".} ## \
## ...intended for debugging only.

proc write*(this: UniqueIdAllocator, `out`: ostream) {.importcpp: "#.write(#)".} ## \
## ...intended for debugging only.

proc newFilterProperties*(): FilterProperties {.importcpp: "new FilterProperties()".}

proc newFilterProperties*(param0: FilterProperties): FilterProperties {.importcpp: "new FilterProperties(#)".}

proc clear*(this: FilterProperties) {.importcpp: "#->clear()".} ## \
## Removes all DSP postprocessing.

proc addLowpass*(this: FilterProperties, cutoff_freq: float32, resonance_q: float32) {.importcpp: "#->add_lowpass(#, #)".} ## \
## Add a lowpass filter to the end of the DSP chain.

proc addHighpass*(this: FilterProperties, cutoff_freq: float32, resonance_q: float32) {.importcpp: "#->add_highpass(#, #)".} ## \
## Add a highpass filter to the end of the DSP chain.

proc addEcho*(this: FilterProperties, drymix: float32, wetmix: float32, delay: float32, decayratio: float32) {.importcpp: "#->add_echo(#, #, #, #)".} ## \
## Add a echo filter to the end of the DSP chain.

proc addFlange*(this: FilterProperties, drymix: float32, wetmix: float32, depth: float32, rate: float32) {.importcpp: "#->add_flange(#, #, #, #)".} ## \
## Add a flange filter to the end of the DSP chain.

proc addDistort*(this: FilterProperties, level: float32) {.importcpp: "#->add_distort(#)".} ## \
## Add a distort filter to the end of the DSP chain.

proc addNormalize*(this: FilterProperties, fadetime: float32, threshold: float32, maxamp: float32) {.importcpp: "#->add_normalize(#, #, #)".} ## \
## Add a normalize filter to the end of the DSP chain.

proc addParameq*(this: FilterProperties, center_freq: float32, bandwidth: float32, gain: float32) {.importcpp: "#->add_parameq(#, #, #)".} ## \
## Add a parameq filter to the end of the DSP chain.

proc addPitchshift*(this: FilterProperties, pitch: float32, fftsize: float32, overlap: float32) {.importcpp: "#->add_pitchshift(#, #, #)".} ## \
## Add a pitchshift filter to the end of the DSP chain.

proc addChorus*(this: FilterProperties, drymix: float32, wet1: float32, wet2: float32, wet3: float32, delay: float32, rate: float32, depth: float32) {.importcpp: "#->add_chorus(#, #, #, #, #, #, #)".} ## \
## Add a chorus filter to the end of the DSP chain.

proc addSfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32, decayhfratio: float32, reflectionslevel: float32, reflectionsdelay: float32, reverblevel: float32, reverbdelay: float32, diffusion: float32, density: float32, hfreference: float32, roomlf: float32, lfreference: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #, #, #, #, #, #, #, #, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc addSfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32, decayhfratio: float32, reflectionslevel: float32, reflectionsdelay: float32, reverblevel: float32, reverbdelay: float32, diffusion: float32, density: float32, hfreference: float32, roomlf: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #, #, #, #, #, #, #, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc addSfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32, decayhfratio: float32, reflectionslevel: float32, reflectionsdelay: float32, reverblevel: float32, reverbdelay: float32, diffusion: float32, density: float32, hfreference: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #, #, #, #, #, #, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc addSfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32, decayhfratio: float32, reflectionslevel: float32, reflectionsdelay: float32, reverblevel: float32, reverbdelay: float32, diffusion: float32, density: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #, #, #, #, #, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc addSfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32, decayhfratio: float32, reflectionslevel: float32, reflectionsdelay: float32, reverblevel: float32, reverbdelay: float32, diffusion: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #, #, #, #, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc addSfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32, decayhfratio: float32, reflectionslevel: float32, reflectionsdelay: float32, reverblevel: float32, reverbdelay: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #, #, #, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc addSfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32, decayhfratio: float32, reflectionslevel: float32, reflectionsdelay: float32, reverblevel: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #, #, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc addSfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32, decayhfratio: float32, reflectionslevel: float32, reflectionsdelay: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc addSfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32, decayhfratio: float32, reflectionslevel: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc addSfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32, decayhfratio: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc addSfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32, decaytime: float32) {.importcpp: "#->add_sfxreverb(#, #, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc addSfxreverb*(this: FilterProperties, drylevel: float32, room: float32, roomhf: float32) {.importcpp: "#->add_sfxreverb(#, #, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc addSfxreverb*(this: FilterProperties, drylevel: float32, room: float32) {.importcpp: "#->add_sfxreverb(#, #)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc addSfxreverb*(this: FilterProperties, drylevel: float32) {.importcpp: "#->add_sfxreverb(#)".} ## \
## Add a reverb filter to the end of the DSP chain.

proc addSfxreverb*(this: FilterProperties) {.importcpp: "#->add_sfxreverb()".} ## \
## Add a reverb filter to the end of the DSP chain.

proc addCompress*(this: FilterProperties, threshold: float32, attack: float32, release: float32, gainmakeup: float32) {.importcpp: "#->add_compress(#, #, #, #)".} ## \
## Add a compress filter to the end of the DSP chain.

converter getClassType*(_: typedesc[FilterProperties]): TypeHandle {.importcpp: "FilterProperties::get_class_type()", header: "filterProperties.h".}

proc play*(this: AudioSound) {.importcpp: "#->play()".} ## \
## For best compatibility, set the loop_count, volume, and balance, prior to
## calling play().  You may set them while they're playing, but it's
## implementation specific whether you get the results.  - Calling play() a
## second time on the same sound before it is finished will start the sound
## again (creating a skipping or stuttering effect).

proc stop*(this: AudioSound) {.importcpp: "#->stop()".}

proc setLoop*(this: AudioSound, loop: bool) {.importcpp: "#->set_loop(#)".} ## \
## loop: false = play once; true = play forever.  inits to false.

proc setLoop*(this: AudioSound) {.importcpp: "#->set_loop()".} ## \
## loop: false = play once; true = play forever.  inits to false.

proc getLoop*(this: AudioSound): bool {.importcpp: "#->get_loop()".}

proc setLoopCount*(this: AudioSound, loop_count: int) {.importcpp: "#->set_loop_count(#)".} ## \
## loop_count: 0 = forever; 1 = play once; n = play n times.  inits to 1.

proc setLoopCount*(this: AudioSound) {.importcpp: "#->set_loop_count()".} ## \
## loop_count: 0 = forever; 1 = play once; n = play n times.  inits to 1.

proc getLoopCount*(this: AudioSound): int {.importcpp: "#->get_loop_count()".}

proc setTime*(this: AudioSound, start_time: float32) {.importcpp: "#->set_time(#)".} ## \
## Control time position within the sound, in seconds.  This is similar (in
## concept) to the seek position within a file.  The value starts at 0.0 (the
## default) and ends at the value given by the length() method.
##
## The current time position will not change while the sound is playing; you
## must call play() again to effect the change.  To play the same sound from
## a time offset a second time, explicitly set the time position again.  When
## looping, the second and later loops will start from the beginning of the
## sound.
##
## If a sound is playing, calling get_time() repeatedly will return different
## results over time.  e.g.
## @code
## PN_stdfloat percent_complete = s.get_time() / s.length();
## @endcode

proc setTime*(this: AudioSound) {.importcpp: "#->set_time()".} ## \
## Control time position within the sound, in seconds.  This is similar (in
## concept) to the seek position within a file.  The value starts at 0.0 (the
## default) and ends at the value given by the length() method.
##
## The current time position will not change while the sound is playing; you
## must call play() again to effect the change.  To play the same sound from
## a time offset a second time, explicitly set the time position again.  When
## looping, the second and later loops will start from the beginning of the
## sound.
##
## If a sound is playing, calling get_time() repeatedly will return different
## results over time.  e.g.
## @code
## PN_stdfloat percent_complete = s.get_time() / s.length();
## @endcode

proc getTime*(this: AudioSound): float32 {.importcpp: "#->get_time()".}

proc setVolume*(this: AudioSound, volume: float32) {.importcpp: "#->set_volume(#)".} ## \
## 0 = minimum; 1.0 = maximum.  inits to 1.0.

proc setVolume*(this: AudioSound) {.importcpp: "#->set_volume()".} ## \
## 0 = minimum; 1.0 = maximum.  inits to 1.0.

proc getVolume*(this: AudioSound): float32 {.importcpp: "#->get_volume()".}

proc setBalance*(this: AudioSound, balance_right: float32) {.importcpp: "#->set_balance(#)".} ## \
## -1.0 is hard left 0.0 is centered 1.0 is hard right inits to 0.0.

proc setBalance*(this: AudioSound) {.importcpp: "#->set_balance()".} ## \
## -1.0 is hard left 0.0 is centered 1.0 is hard right inits to 0.0.

proc getBalance*(this: AudioSound): float32 {.importcpp: "#->get_balance()".}

proc setPlayRate*(this: AudioSound, play_rate: float32) {.importcpp: "#->set_play_rate(#)".} ## \
## play_rate is any positive PN_stdfloat value.  inits to 1.0.

proc setPlayRate*(this: AudioSound) {.importcpp: "#->set_play_rate()".} ## \
## play_rate is any positive PN_stdfloat value.  inits to 1.0.

proc getPlayRate*(this: AudioSound): float32 {.importcpp: "#->get_play_rate()".}

proc setActive*(this: AudioSound, flag: bool) {.importcpp: "#->set_active(#)".} ## \
## inits to manager's state.

proc setActive*(this: AudioSound) {.importcpp: "#->set_active()".} ## \
## inits to manager's state.

proc getActive*(this: AudioSound): bool {.importcpp: "#->get_active()".}

proc setFinishedEvent*(this: AudioSound, event: string) {.importcpp: "#->set_finished_event(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Set (or clear) the event that will be thrown when the sound finishes
## playing.  To clear the event, pass an empty string.

proc getFinishedEvent*(this: AudioSound): string {.importcpp: "nimStringFromStdString(#->get_finished_event())", header: stringConversionCode.}

proc getName*(this: AudioSound): string {.importcpp: "nimStringFromStdString(#->get_name())", header: stringConversionCode.} ## \
## There is no set_name(), this is intentional.

proc length*(this: AudioSound): float32 {.importcpp: "#->length()".} ## \
## return: playing time in seconds.

proc set3dAttributes*(this: AudioSound, px: float32, py: float32, pz: float32, vx: float32, vy: float32, vz: float32) {.importcpp: "#->set_3d_attributes(#, #, #, #, #, #)".} ## \
## Controls the position of this sound's emitter.  px, py and pz are the
## emitter's position.  vx, vy and vz are the emitter's velocity in UNITS
## PER SECOND (default: meters).

proc set3dMinDistance*(this: AudioSound, dist: float32) {.importcpp: "#->set_3d_min_distance(#)".} ## \
## Controls the distance (in units) that this sound begins to fall off.
## Also affects the rate it falls off.  Default is 1.0 CloserFaster, <1.0
## FartherSlower, >1.0

proc get3dMinDistance*(this: AudioSound): float32 {.importcpp: "#->get_3d_min_distance()".}

proc set3dMaxDistance*(this: AudioSound, dist: float32) {.importcpp: "#->set_3d_max_distance(#)".} ## \
## Controls the maximum distance (in units) that this sound stops falling
## off.  The sound does not stop at that point, it just doesn't get any
## quieter.  You should rarely need to adjust this.  Default is 1000000000.0

proc get3dMaxDistance*(this: AudioSound): float32 {.importcpp: "#->get_3d_max_distance()".}

proc getSpeakerMix*(this: AudioSound, speaker: int): float32 {.importcpp: "#->get_speaker_mix(#)".} ## \
## speaker_mix and speaker_level(s) serve the same purpose.
## speaker_mix is for use with FMOD. speaker_level(s) is for use with
## Miles.  Both interfaces exist because of a significant difference in the
## two APIs.  Hopefully the difference can be reconciled into a single
## interface at some point.

proc setSpeakerMix*(this: AudioSound, frontleft: float32, frontright: float32, center: float32, sub: float32, backleft: float32, backright: float32, sideleft: float32, sideright: float32) {.importcpp: "#->set_speaker_mix(#, #, #, #, #, #, #, #)".}

proc getSpeakerLevel*(this: AudioSound, index: int): float32 {.importcpp: "#->get_speaker_level(#)".}

proc setSpeakerLevels*(this: AudioSound, level1: float32, level2: float32, level3: float32, level4: float32, level5: float32, level6: float32, level7: float32, level8: float32, level9: float32) {.importcpp: "#->set_speaker_levels(#, #, #, #, #, #, #, #, #)".}

proc setSpeakerLevels*(this: AudioSound, level1: float32, level2: float32, level3: float32, level4: float32, level5: float32, level6: float32, level7: float32, level8: float32) {.importcpp: "#->set_speaker_levels(#, #, #, #, #, #, #, #)".}

proc setSpeakerLevels*(this: AudioSound, level1: float32, level2: float32, level3: float32, level4: float32, level5: float32, level6: float32, level7: float32) {.importcpp: "#->set_speaker_levels(#, #, #, #, #, #, #)".}

proc setSpeakerLevels*(this: AudioSound, level1: float32, level2: float32, level3: float32, level4: float32, level5: float32, level6: float32) {.importcpp: "#->set_speaker_levels(#, #, #, #, #, #)".}

proc setSpeakerLevels*(this: AudioSound, level1: float32, level2: float32, level3: float32, level4: float32, level5: float32) {.importcpp: "#->set_speaker_levels(#, #, #, #, #)".}

proc setSpeakerLevels*(this: AudioSound, level1: float32, level2: float32, level3: float32, level4: float32) {.importcpp: "#->set_speaker_levels(#, #, #, #)".}

proc setSpeakerLevels*(this: AudioSound, level1: float32, level2: float32, level3: float32) {.importcpp: "#->set_speaker_levels(#, #, #)".}

proc setSpeakerLevels*(this: AudioSound, level1: float32, level2: float32) {.importcpp: "#->set_speaker_levels(#, #)".}

proc setSpeakerLevels*(this: AudioSound, level1: float32) {.importcpp: "#->set_speaker_levels(#)".}

proc getPriority*(this: AudioSound): int {.importcpp: "#->get_priority()".}

proc setPriority*(this: AudioSound, priority: int) {.importcpp: "#->set_priority(#)".}

proc configureFilters*(this: AudioSound, config: FilterProperties): bool {.importcpp: "#->configure_filters(#)".}

proc output*(this: AudioSound, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: AudioSound, `out`: ostream) {.importcpp: "#->write(#)".}

converter getClassType*(_: typedesc[AudioSound]): TypeHandle {.importcpp: "AudioSound::get_class_type()", header: "audioSound.h".}

proc getSpeakerSetup*(this: AudioManager): int {.importcpp: "#->get_speaker_setup()".}

proc configureFilters*(this: AudioManager, config: FilterProperties): bool {.importcpp: "#->configure_filters(#)".}

proc createAudioManager*(_: typedesc[AudioManager]): AudioManager {.importcpp: "AudioManager::create_AudioManager()", header: "audioManager.h".}

proc shutdown*(this: AudioManager) {.importcpp: "#->shutdown()".}

proc isValid*(this: AudioManager): bool {.importcpp: "#->is_valid()".} ## \
## If you're interested in knowing whether this audio manager is valid,
## here's the call to do it.  It is not necessary to check whether the audio
## manager is valid before making other calls.  You are free to use an
## invalid sound manager, you may get silent sounds from it though.  The
## sound manager and the sounds it creates should not crash the application
## even when the objects are not valid.

proc getSound*(this: AudioManager, file_name: Filename, positional: bool, mode: int): AudioSound {.importcpp: "#->get_sound(#, #, #)".} ## \
## Get a sound:

proc getSound*(this: AudioManager, file_name: Filename, positional: bool): AudioSound {.importcpp: "#->get_sound(#, #)".} ## \
## Get a sound:

proc getSound*(this: AudioManager, file_name: Filename): AudioSound {.importcpp: "#->get_sound(#)".} ## \
## Get a sound:

proc getSound*(this: AudioManager, source: MovieAudio, positional: bool, mode: int): AudioSound {.importcpp: "#->get_sound(#, #, #)".}

proc getSound*(this: AudioManager, source: MovieAudio, positional: bool): AudioSound {.importcpp: "#->get_sound(#, #)".}

proc getSound*(this: AudioManager, source: MovieAudio): AudioSound {.importcpp: "#->get_sound(#)".}

proc getNullSound*(this: AudioManager): AudioSound {.importcpp: "#->get_null_sound()".}

proc uncacheSound*(this: AudioManager, file_name: Filename) {.importcpp: "#->uncache_sound(#)".} ## \
## Tell the AudioManager there is no need to keep this one cached.  This
## doesn't break any connection between AudioSounds that have already given
## by get_sound() from this manager.  It's only affecting whether the
## AudioManager keeps a copy of the sound in its poolcache.

proc clearCache*(this: AudioManager) {.importcpp: "#->clear_cache()".}

proc setCacheLimit*(this: AudioManager, count: int) {.importcpp: "#->set_cache_limit(#)".}

proc getCacheLimit*(this: AudioManager): int {.importcpp: "#->get_cache_limit()".}

proc setVolume*(this: AudioManager, volume: float32) {.importcpp: "#->set_volume(#)".} ## \
## Control volume: FYI: If you start a sound with the volume off and turn
## the volume up later, you'll hear the sound playing at that late point.  0
## = minimum; 1.0 = maximum.  inits to 1.0.

proc getVolume*(this: AudioManager): float32 {.importcpp: "#->get_volume()".}

proc setActive*(this: AudioManager, flag: bool) {.importcpp: "#->set_active(#)".} ## \
## Turn the manager on or off.  If you play a sound while the manager is
## inactive, it won't start.  If you deactivate the manager while sounds are
## playing, they'll stop.  If you activate the manager while looping sounds
## are playing (those that have a loop_count of zero), they will start
## playing from the beginning of their loop.  Defaults to true.

proc getActive*(this: AudioManager): bool {.importcpp: "#->get_active()".}

proc setConcurrentSoundLimit*(this: AudioManager, limit: int) {.importcpp: "#->set_concurrent_sound_limit(#)".} ## \
## This controls the number of sounds that you allow at once.  This is more
## of a user choice -- it avoids talk over and the creation of a cacophony.
## It can also be used to help performance.  0 == unlimited.  1 == mutually
## exclusive (one sound at a time).  Which is an example of: n == allow n
## sounds to be playing at the same time.

proc setConcurrentSoundLimit*(this: AudioManager) {.importcpp: "#->set_concurrent_sound_limit()".} ## \
## This controls the number of sounds that you allow at once.  This is more
## of a user choice -- it avoids talk over and the creation of a cacophony.
## It can also be used to help performance.  0 == unlimited.  1 == mutually
## exclusive (one sound at a time).  Which is an example of: n == allow n
## sounds to be playing at the same time.

proc getConcurrentSoundLimit*(this: AudioManager): int {.importcpp: "#->get_concurrent_sound_limit()".}

proc reduceSoundsPlayingTo*(this: AudioManager, count: int) {.importcpp: "#->reduce_sounds_playing_to(#)".} ## \
## This is likely to be a utility function for the concurrent_sound_limit
## options.  It is exposed as an API, because it's reasonable that it may be
## useful to be here.  It reduces the number of concurrently playing sounds
## to count by some implementation specific means.  If the number of sounds
## currently playing is at or below count then there is no effect.

proc stopAllSounds*(this: AudioManager) {.importcpp: "#->stop_all_sounds()".} ## \
## Stop playback on all sounds managed by this manager.  This is effectively
## the same as reduce_sounds_playing_to(0), but this call may be for
## efficient on some implementations.

proc update*(this: AudioManager) {.importcpp: "#->update()".} ## \
## This should be called every frame.  Failure to call could cause problems.

proc audio3dSetListenerAttributes*(this: AudioManager, px: float32, py: float32, pz: float32, vx: float32, vy: float32, vz: float32, fx: float32, fy: float32, fz: float32, ux: float32, uy: float32, uz: float32) {.importcpp: "#->audio_3d_set_listener_attributes(#, #, #, #, #, #, #, #, #, #, #, #)".} ## \
## This controls the "set of ears" that listens to 3D spacialized sound px,
## py, pz are position coordinates.  vx, vy, vz are a velocity vector in
## UNITS PER SECOND (default: meters). fx, fy and fz are the respective
## components of a unit forward-vector ux, uy and uz are the respective
## components of a unit up-vector

proc audio3dSetDistanceFactor*(this: AudioManager, factor: float32) {.importcpp: "#->audio_3d_set_distance_factor(#)".} ## \
## Control the "relative scale that sets the distance factor" units for 3D
## spacialized audio. This is a float in units-per-meter. Default value is
## 1.0, which means that Panda units are understood as meters; for e.g.
## feet, set 3.28. This factor is applied only to Fmod and OpenAL at the
## moment.

proc audio3dGetDistanceFactor*(this: AudioManager): float32 {.importcpp: "#->audio_3d_get_distance_factor()".}

proc audio3dSetDopplerFactor*(this: AudioManager, factor: float32) {.importcpp: "#->audio_3d_set_doppler_factor(#)".} ## \
## Control the presence of the Doppler effect.  Default is 1.0 Exaggerated
## Doppler, use >1.0 Diminshed Doppler, use <1.0

proc audio3dGetDopplerFactor*(this: AudioManager): float32 {.importcpp: "#->audio_3d_get_doppler_factor()".}

proc audio3dSetDropOffFactor*(this: AudioManager, factor: float32) {.importcpp: "#->audio_3d_set_drop_off_factor(#)".} ## \
## Exaggerate or diminish the effect of distance on sound.  Default is 1.0
## Valid range is 0 to 10 Faster drop off, use >1.0 Slower drop off, use
## <1.0

proc audio3dGetDropOffFactor*(this: AudioManager): float32 {.importcpp: "#->audio_3d_get_drop_off_factor()".}

proc getDlsPathname*(_: typedesc[AudioManager]): Filename {.importcpp: "AudioManager::get_dls_pathname()", header: "audioManager.h".}

proc output*(this: AudioManager, `out`: ostream) {.importcpp: "#->output(#)".}

proc write*(this: AudioManager, `out`: ostream) {.importcpp: "#->write(#)".}

proc setSpeakerConfiguration*(this: AudioManager, speaker1: LVecBase3, speaker2: LVecBase3, speaker3: LVecBase3, speaker4: LVecBase3, speaker5: LVecBase3, speaker6: LVecBase3, speaker7: LVecBase3, speaker8: LVecBase3, speaker9: LVecBase3) {.importcpp: "#->set_speaker_configuration(#, #, #, #, #, #, #, #, #)".} ## \
## set_speaker_configuration is a Miles only method.

proc setSpeakerConfiguration*(this: AudioManager, speaker1: LVecBase3, speaker2: LVecBase3, speaker3: LVecBase3, speaker4: LVecBase3, speaker5: LVecBase3, speaker6: LVecBase3, speaker7: LVecBase3, speaker8: LVecBase3) {.importcpp: "#->set_speaker_configuration(#, #, #, #, #, #, #, #)".} ## \
## set_speaker_configuration is a Miles only method.

proc setSpeakerConfiguration*(this: AudioManager, speaker1: LVecBase3, speaker2: LVecBase3, speaker3: LVecBase3, speaker4: LVecBase3, speaker5: LVecBase3, speaker6: LVecBase3, speaker7: LVecBase3) {.importcpp: "#->set_speaker_configuration(#, #, #, #, #, #, #)".} ## \
## set_speaker_configuration is a Miles only method.

proc setSpeakerConfiguration*(this: AudioManager, speaker1: LVecBase3, speaker2: LVecBase3, speaker3: LVecBase3, speaker4: LVecBase3, speaker5: LVecBase3, speaker6: LVecBase3) {.importcpp: "#->set_speaker_configuration(#, #, #, #, #, #)".} ## \
## set_speaker_configuration is a Miles only method.

proc setSpeakerConfiguration*(this: AudioManager, speaker1: LVecBase3, speaker2: LVecBase3, speaker3: LVecBase3, speaker4: LVecBase3, speaker5: LVecBase3) {.importcpp: "#->set_speaker_configuration(#, #, #, #, #)".} ## \
## set_speaker_configuration is a Miles only method.

proc setSpeakerConfiguration*(this: AudioManager, speaker1: LVecBase3, speaker2: LVecBase3, speaker3: LVecBase3, speaker4: LVecBase3) {.importcpp: "#->set_speaker_configuration(#, #, #, #)".} ## \
## set_speaker_configuration is a Miles only method.

proc setSpeakerConfiguration*(this: AudioManager, speaker1: LVecBase3, speaker2: LVecBase3, speaker3: LVecBase3) {.importcpp: "#->set_speaker_configuration(#, #, #)".} ## \
## set_speaker_configuration is a Miles only method.

proc setSpeakerConfiguration*(this: AudioManager, speaker1: LVecBase3, speaker2: LVecBase3) {.importcpp: "#->set_speaker_configuration(#, #)".} ## \
## set_speaker_configuration is a Miles only method.

proc setSpeakerConfiguration*(this: AudioManager, speaker1: LVecBase3) {.importcpp: "#->set_speaker_configuration(#)".} ## \
## set_speaker_configuration is a Miles only method.

converter getClassType*(_: typedesc[AudioManager]): TypeHandle {.importcpp: "AudioManager::get_class_type()", header: "audioManager.h".}

proc newAudioLoadRequest*(param0: AudioLoadRequest): AudioLoadRequest {.importcpp: "new AudioLoadRequest(#)".}

proc newAudioLoadRequest*(audio_manager: AudioManager, filename: string, positional: bool): AudioLoadRequest {.importcpp: "new AudioLoadRequest(#, nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Create a new AudioLoadRequest, and add it to the loader via load_async(),
## to begin an asynchronous load.

proc getAudioManager*(this: AudioLoadRequest): AudioManager {.importcpp: "#->get_audio_manager()".} ## \
## Returns the AudioManager that will serve this asynchronous
## AudioLoadRequest.

proc getFilename*(this: AudioLoadRequest): string {.importcpp: "nimStringFromStdString(#->get_filename())", header: stringConversionCode.} ## \
## Returns the filename associated with this asynchronous AudioLoadRequest.

proc getPositional*(this: AudioLoadRequest): bool {.importcpp: "#->get_positional()".} ## \
## Returns the positional flag associated with this asynchronous
## AudioLoadRequest.

proc isReady*(this: AudioLoadRequest): bool {.importcpp: "#->is_ready()".} ## \
## Returns true if this request has completed, false if it is still pending.
## When this returns true, you may retrieve the sound loaded by calling
## get_sound().
## Equivalent to `req.done() and not req.cancelled()`.
## @see done()

proc getSound*(this: AudioLoadRequest): AudioSound {.importcpp: "#->get_sound()".} ## \
## Returns the sound that was loaded asynchronously, if any, or nullptr if
## there was an error.  It is an error to call this unless done() returns
## true.
## @deprecated Use result() instead.

converter getClassType*(_: typedesc[AudioLoadRequest]): TypeHandle {.importcpp: "AudioLoadRequest::get_class_type()", header: "audioLoadRequest.h".}

proc initPGFrameStyle*(): PGFrameStyle {.importcpp: "PGFrameStyle()".}

proc initPGFrameStyle*(copy: PGFrameStyle): PGFrameStyle {.importcpp: "PGFrameStyle(#)".}

proc setColor*(this: PGFrameStyle, color: LColor) {.importcpp: "#.set_color(#)".} ## \
## Sets the dominant color of the frame.

proc setColor*(this: PGFrameStyle, r: float32, g: float32, b: float32, a: float32) {.importcpp: "#.set_color(#, #, #, #)".} ## \
## Sets the dominant color of the frame.

proc getColor*(this: PGFrameStyle): LColor {.importcpp: "#.get_color()".} ## \
## Returns the dominant color of the frame.

proc setTexture*(this: PGFrameStyle, texture: Texture) {.importcpp: "#.set_texture(#)".} ## \
## Specifies a texture that should be applied to the frame.

proc hasTexture*(this: PGFrameStyle): bool {.importcpp: "#.has_texture()".} ## \
## Returns true if a texture has been applied to the frame.

proc getTexture*(this: PGFrameStyle): Texture {.importcpp: "#.get_texture()".} ## \
## Returns the texture that has been applied to the frame, or NULL if no
## texture has been applied.

proc clearTexture*(this: PGFrameStyle) {.importcpp: "#.clear_texture()".} ## \
## Removes the texture from the frame.

proc setWidth*(this: PGFrameStyle, width: LVecBase2) {.importcpp: "#.set_width(#)".} ## \
## Sets the width parameter, which has meaning only for certain frame types.
## For instance, this is the width of the bevel for T_bevel_in or T_bevel_out.
## The units are in screen units.

proc setWidth*(this: PGFrameStyle, x: float32, y: float32) {.importcpp: "#.set_width(#, #)".} ## \
## Sets the width parameter, which has meaning only for certain frame types.
## For instance, this is the width of the bevel for T_bevel_in or T_bevel_out.
## The units are in screen units.

proc getWidth*(this: PGFrameStyle): LVecBase2 {.importcpp: "#.get_width()".} ## \
## Returns the width parameter, which has meaning only for certain frame
## types.  For instance, this is the width of the bevel for T_bevel_in or
## T_bevel_out.  The units are in screen units.

proc setUvWidth*(this: PGFrameStyle, uv_width: LVecBase2) {.importcpp: "#.set_uv_width(#)".} ## \
## Sets the uv_width parameter, which indicates the amount of the texture that
## is consumed by the inner bevel--the width in texture space of the amount
## indicated by set_width.

proc setUvWidth*(this: PGFrameStyle, u: float32, v: float32) {.importcpp: "#.set_uv_width(#, #)".} ## \
## Sets the uv_width parameter, which indicates the amount of the texture that
## is consumed by the inner bevel--the width in texture space of the amount
## indicated by set_width.

proc getUvWidth*(this: PGFrameStyle): LVecBase2 {.importcpp: "#.get_uv_width()".} ## \
## See set_uv_width().

proc setVisibleScale*(this: PGFrameStyle, visible_scale: LVecBase2) {.importcpp: "#.set_visible_scale(#)".} ## \
## Sets a scale factor on the visible representation of the frame, in the X
## and Y directions.  If this scale factor is other than 1, it will affect the
## size of the visible frame representation within the actual frame border.

proc setVisibleScale*(this: PGFrameStyle, x: float32, y: float32) {.importcpp: "#.set_visible_scale(#, #)".} ## \
## Sets a scale factor on the visible representation of the frame, in the X
## and Y directions.  If this scale factor is other than 1, it will affect the
## size of the visible frame representation within the actual frame border.

proc getVisibleScale*(this: PGFrameStyle): LVecBase2 {.importcpp: "#.get_visible_scale()".} ## \
## Returns the scale factor on the visible representation of the frame, in the
## X and Y directions.  If this scale factor is other than 1, it will affect
## the size of the visible frame representation within the actual frame
## border.

proc getInternalFrame*(this: PGFrameStyle, frame: LVecBase4): LVecBase4 {.importcpp: "#.get_internal_frame(#)".} ## \
## Computes the size of the internal frame, given the indicated external
## frame, appropriate for this kind of frame style.  This simply subtracts the
## border width for those frame styles that include a border.

proc output*(this: PGFrameStyle, `out`: ostream) {.importcpp: "#.output(#)".}

proc newPGItem*(name: string): PGItem {.importcpp: "new PGItem(nimStringToStdString(#))", header: stringConversionCode.}

proc setName*(this: PGItem, name: string) {.importcpp: "#->set_name(nimStringToStdString(#))", header: stringConversionCode.}

proc setFrame*(this: PGItem, frame: LVecBase4) {.importcpp: "#->set_frame(#)".} ## \
## Sets the bounding rectangle of the item, in local coordinates.  This is the
## region on screen within which the mouse will be considered to be within the
## item.  Normally, it should correspond to the bounding rectangle of the
## visible geometry of the item.

proc setFrame*(this: PGItem, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#->set_frame(#, #, #, #)".} ## \
## Sets the bounding rectangle of the item, in local coordinates.  This is the
## region on screen within which the mouse will be considered to be within the
## item.  Normally, it should correspond to the bounding rectangle of the
## visible geometry of the item.

proc getFrame*(this: PGItem): LVecBase4 {.importcpp: "#->get_frame()".} ## \
## Returns the bounding rectangle of the item.  See set_frame().  It is an
## error to call this if has_frame() returns false.

proc hasFrame*(this: PGItem): bool {.importcpp: "#->has_frame()".} ## \
## Returns true if the item has a bounding rectangle; see set_frame().

proc clearFrame*(this: PGItem) {.importcpp: "#->clear_frame()".} ## \
## Removes the bounding rectangle from the item.  It will no longer be
## possible to position the mouse within the item; see set_frame().

proc setState*(this: PGItem, state: int) {.importcpp: "#->set_state(#)".} ## \
## Sets the "state" of this particular PGItem.
##
## The PGItem node will render as if it were the subgraph assigned to the
## corresponding index via set_state_def().

proc getState*(this: PGItem): int {.importcpp: "#->get_state()".} ## \
## Returns the "state" of this particular PGItem.  See set_state().

proc setActive*(this: PGItem, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets whether the PGItem is active for mouse watching.  This is not
## necessarily related to the active/inactive appearance of the item, which is
## controlled by set_state(), but it does affect whether it responds to mouse
## events.

proc getActive*(this: PGItem): bool {.importcpp: "#->get_active()".} ## \
## Returns whether the PGItem is currently active for mouse events.  See
## set_active().

proc setFocus*(this: PGItem, focus: bool) {.importcpp: "#->set_focus(#)".} ## \
## Sets whether the PGItem currently has keyboard focus.  This simply means
## that the item may respond to keyboard events as well as to mouse events;
## precisely what this means is up to the individual item.
##
## Only one PGItem in the world is allowed to have focus at any given time.
## Setting the focus on any other item automatically disables the focus from
## the previous item.

proc getFocus*(this: PGItem): bool {.importcpp: "#->get_focus()".} ## \
## Returns whether the PGItem currently has focus for keyboard events.  See
## set_focus().

proc setBackgroundFocus*(this: PGItem, focus: bool) {.importcpp: "#->set_background_focus(#)".} ## \
## Sets the background_focus flag for this item.  When background_focus is
## enabled, the item will receive keypress events even if it is not in focus;
## in fact, even if it is not onscreen.  Unlike normal focus, many items may
## have background_focus simultaneously.

proc getBackgroundFocus*(this: PGItem): bool {.importcpp: "#->get_background_focus()".} ## \
## Returns whether background_focus is currently enabled.  See
## set_background_focus().

proc setSuppressFlags*(this: PGItem, suppress_flags: int) {.importcpp: "#->set_suppress_flags(#)".} ## \
## This is just an interface to set the suppress flags on the underlying
## MouseWatcherRegion.  See MouseWatcherRegion::set_suppress_flags().

proc getSuppressFlags*(this: PGItem): int {.importcpp: "#->get_suppress_flags()".} ## \
## This is just an interface to get the suppress flags on the underlying
## MouseWatcherRegion.  See MouseWatcherRegion::get_suppress_flags().

proc getNumStateDefs*(this: PGItem): int {.importcpp: "#->get_num_state_defs()".} ## \
## Returns one more than the highest-numbered state def that was ever assigned
## to the PGItem.  The complete set of state defs assigned may then be
## retrieved by indexing from 0 to (get_num_state_defs() - 1).
##
## This is only an upper limit on the actual number of state defs, since there
## may be holes in the list.

proc clearStateDef*(this: PGItem, state: int) {.importcpp: "#->clear_state_def(#)".} ## \
## Resets the NodePath assigned to the indicated state to its initial default,
## with only a frame representation if appropriate.

proc hasStateDef*(this: PGItem, state: int): bool {.importcpp: "#->has_state_def(#)".} ## \
## Returns true if get_state_def() has ever been called for the indicated
## state (thus defining a render subgraph for this state index), false
## otherwise.

proc getStateDef*(this: PGItem, state: int): NodePath {.importcpp: "#->get_state_def(#)".} ## \
## Returns the Node that is the root of the subgraph that will be drawn when
## the PGItem is in the indicated state.  The first time this is called for a
## particular state index, it may create the Node.

proc instanceToStateDef*(this: PGItem, state: int, path: NodePath): NodePath {.importcpp: "#->instance_to_state_def(#, #)".} ## \
## Parents an instance of the bottom node of the indicated NodePath to the
## indicated state index.

proc getFrameStyle*(this: PGItem, state: int): PGFrameStyle {.importcpp: "#->get_frame_style(#)".} ## \
## Returns the kind of frame that will be drawn behind the item when it is in
## the indicated state.

proc setFrameStyle*(this: PGItem, state: int, style: PGFrameStyle) {.importcpp: "#->set_frame_style(#, #)".} ## \
## Changes the kind of frame that will be drawn behind the item when it is in
## the indicated state.

proc getId*(this: PGItem): string {.importcpp: "nimStringFromStdString(#->get_id())", header: stringConversionCode.} ## \
## Returns the unique ID assigned to this PGItem.  This will be assigned to
## the region created with the MouseWatcher, and will thus be used to generate
## event names.

proc setId*(this: PGItem, id: string) {.importcpp: "#->set_id(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Set the unique ID assigned to this PGItem.  It is the user's responsibility
## to ensure that this ID is unique.
##
## Normally, this should not need to be called, as the PGItem will assign
## itself an ID when it is created, but this function allows the user to
## decide to redefine the ID to be something possibly more meaningful.

proc getEnterPrefix*(_: typedesc[PGItem]): string {.importcpp: "nimStringFromStdString(PGItem::get_enter_prefix())", header: "pgItem.h".} ## \
## Returns the prefix that is used to define the enter event for all PGItems.
## The enter event is the concatenation of this string followed by get_id().

proc getExitPrefix*(_: typedesc[PGItem]): string {.importcpp: "nimStringFromStdString(PGItem::get_exit_prefix())", header: "pgItem.h".} ## \
## Returns the prefix that is used to define the exit event for all PGItems.
## The exit event is the concatenation of this string followed by get_id().

proc getWithinPrefix*(_: typedesc[PGItem]): string {.importcpp: "nimStringFromStdString(PGItem::get_within_prefix())", header: "pgItem.h".} ## \
## Returns the prefix that is used to define the within event for all PGItems.
## The within event is the concatenation of this string followed by get_id().

proc getWithoutPrefix*(_: typedesc[PGItem]): string {.importcpp: "nimStringFromStdString(PGItem::get_without_prefix())", header: "pgItem.h".} ## \
## Returns the prefix that is used to define the without event for all
## PGItems.  The without event is the concatenation of this string followed by
## get_id().

proc getFocusInPrefix*(_: typedesc[PGItem]): string {.importcpp: "nimStringFromStdString(PGItem::get_focus_in_prefix())", header: "pgItem.h".} ## \
## Returns the prefix that is used to define the focus_in event for all
## PGItems.  The focus_in event is the concatenation of this string followed
## by get_id().
##
## Unlike most item events, this event is thrown with no parameters.

proc getFocusOutPrefix*(_: typedesc[PGItem]): string {.importcpp: "nimStringFromStdString(PGItem::get_focus_out_prefix())", header: "pgItem.h".} ## \
## Returns the prefix that is used to define the focus_out event for all
## PGItems.  The focus_out event is the concatenation of this string followed
## by get_id().
##
## Unlike most item events, this event is thrown with no parameters.

proc getPressPrefix*(_: typedesc[PGItem]): string {.importcpp: "nimStringFromStdString(PGItem::get_press_prefix())", header: "pgItem.h".} ## \
## Returns the prefix that is used to define the press event for all PGItems.
## The press event is the concatenation of this string followed by a button
## name, followed by a hyphen and get_id().

proc getRepeatPrefix*(_: typedesc[PGItem]): string {.importcpp: "nimStringFromStdString(PGItem::get_repeat_prefix())", header: "pgItem.h".} ## \
## Returns the prefix that is used to define the repeat event for all PGItems.
## The repeat event is the concatenation of this string followed by a button
## name, followed by a hyphen and get_id().

proc getReleasePrefix*(_: typedesc[PGItem]): string {.importcpp: "nimStringFromStdString(PGItem::get_release_prefix())", header: "pgItem.h".} ## \
## Returns the prefix that is used to define the release event for all
## PGItems.  The release event is the concatenation of this string followed by
## a button name, followed by a hyphen and get_id().

proc getKeystrokePrefix*(_: typedesc[PGItem]): string {.importcpp: "nimStringFromStdString(PGItem::get_keystroke_prefix())", header: "pgItem.h".} ## \
## Returns the prefix that is used to define the keystroke event for all
## PGItems.  The keystroke event is the concatenation of this string followed
## by a hyphen and get_id().

proc getEnterEvent*(this: PGItem): string {.importcpp: "nimStringFromStdString(#->get_enter_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the item is active and the
## mouse enters its frame, but not any nested frames.

proc getExitEvent*(this: PGItem): string {.importcpp: "nimStringFromStdString(#->get_exit_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the item is active and the
## mouse exits its frame, or enters a nested frame.

proc getWithinEvent*(this: PGItem): string {.importcpp: "nimStringFromStdString(#->get_within_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the item is active and the
## mouse moves within the boundaries of the frame.  This is different from the
## enter_event in that the mouse is considered within the frame even if it is
## also within a nested frame.

proc getWithoutEvent*(this: PGItem): string {.importcpp: "nimStringFromStdString(#->get_without_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the item is active and the
## mouse moves completely outside the boundaries of the frame.  This is
## different from the exit_event in that the mouse is considered within the
## frame even if it is also within a nested frame.

proc getFocusInEvent*(this: PGItem): string {.importcpp: "nimStringFromStdString(#->get_focus_in_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the item gets the keyboard
## focus.

proc getFocusOutEvent*(this: PGItem): string {.importcpp: "nimStringFromStdString(#->get_focus_out_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the item loses the keyboard
## focus.

proc getPressEvent*(this: PGItem, button: ButtonHandle): string {.importcpp: "nimStringFromStdString(#->get_press_event(#))", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the item is active and the
## indicated mouse or keyboard button is depressed while the mouse is within
## the frame.

proc getRepeatEvent*(this: PGItem, button: ButtonHandle): string {.importcpp: "nimStringFromStdString(#->get_repeat_event(#))", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the item is active and the
## indicated mouse or keyboard button is continuously held down while the
## mouse is within the frame.

proc getReleaseEvent*(this: PGItem, button: ButtonHandle): string {.importcpp: "nimStringFromStdString(#->get_release_event(#))", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the item is active and the
## indicated mouse or keyboard button, formerly clicked down is within the
## frame, is released.

proc getKeystrokeEvent*(this: PGItem): string {.importcpp: "nimStringFromStdString(#->get_keystroke_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the item is active and any
## key is pressed by the user.

proc getFrameInvXform*(this: PGItem): LMatrix4 {.importcpp: "#->get_frame_inv_xform()".} ## \
## Returns the inverse of the frame transform matrix

proc setSound*(this: PGItem, event: string, sound: AudioSound) {.importcpp: "#->set_sound(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Sets the sound that will be played whenever the indicated event occurs.

proc clearSound*(this: PGItem, event: string) {.importcpp: "#->clear_sound(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Removes the sound associated with the indicated event.

proc getSound*(this: PGItem, event: string): AudioSound {.importcpp: "#->get_sound(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the sound associated with the indicated event, or NULL if there is
## no associated sound.

proc hasSound*(this: PGItem, event: string): bool {.importcpp: "#->has_sound(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns true if there is a sound associated with the indicated event, or
## false otherwise.

proc getTextNode*(_: typedesc[PGItem]): TextNode {.importcpp: "PGItem::get_text_node()", header: "pgItem.h".} ## \
## Returns the TextNode object that will be used by all PGItems to generate
## default labels given a string.  This can be loaded with the default font,
## etc.

proc setTextNode*(_: typedesc[PGItem], node: TextNode) {.importcpp: "#PGItem::set_text_node(#)", header: "pgItem.h".} ## \
## Changes the TextNode object that will be used by all PGItems to generate
## default labels given a string.  This can be loaded with the default font,
## etc.

proc getFocusItem*(_: typedesc[PGItem]): PGItem {.importcpp: "PGItem::get_focus_item()", header: "pgItem.h".} ## \
## Returns the one PGItem in the world that currently has keyboard focus, if
## any, or NULL if no item has keyboard focus.  Use PGItem::set_focus() to
## activate or deactivate keyboard focus on a particular item.

converter getClassType*(_: typedesc[PGItem]): TypeHandle {.importcpp: "PGItem::get_class_type()", header: "pgItem.h".}

proc newPGButton*(name: string): PGButton {.importcpp: "new PGButton(nimStringToStdString(#))", header: stringConversionCode.}

proc setup*(this: PGButton, ready: NodePath) {.importcpp: "#->setup(#)".} ## \
## Sets up the button using the indicated NodePath as arbitrary geometry.

proc setup*(this: PGButton, ready: NodePath, depressed: NodePath) {.importcpp: "#->setup(#, #)".} ## \
## Sets up the button using the indicated NodePath as arbitrary geometry.

proc setup*(this: PGButton, ready: NodePath, depressed: NodePath, rollover: NodePath) {.importcpp: "#->setup(#, #, #)".} ## \
## Sets up the button using the indicated NodePath as arbitrary geometry.

proc setup*(this: PGButton, ready: NodePath, depressed: NodePath, rollover: NodePath, inactive: NodePath) {.importcpp: "#->setup(#, #, #, #)".} ## \
## Sets up the button using the indicated NodePath as arbitrary geometry.

proc setup*(this: PGButton, label: string, bevel: float32) {.importcpp: "#->setup(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Sets up the button as a default text button using the indicated label
## string.  The TextNode defined by PGItem::get_text_node() will be used to
## create the label geometry.  This automatically sets up the frame according
## to the size of the text.

proc setup*(this: PGButton, label: string) {.importcpp: "#->setup(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Sets up the button as a default text button using the indicated label
## string.  The TextNode defined by PGItem::get_text_node() will be used to
## create the label geometry.  This automatically sets up the frame according
## to the size of the text.

proc addClickButton*(this: PGButton, button: ButtonHandle): bool {.importcpp: "#->add_click_button(#)".} ## \
## Adds the indicated button to the set of buttons that can effectively
## "click" the PGButton.  Normally, this is just MouseButton::one().  Returns
## true if the button was added, or false if it was already there.

proc removeClickButton*(this: PGButton, button: ButtonHandle): bool {.importcpp: "#->remove_click_button(#)".} ## \
## Removes the indicated button from the set of buttons that can effectively
## "click" the PGButton.  Normally, this is just MouseButton::one().  Returns
## true if the button was removed, or false if it was not in the set.

proc hasClickButton*(this: PGButton, button: ButtonHandle): bool {.importcpp: "#->has_click_button(#)".} ## \
## Returns true if the indicated button is on the set of buttons that can
## effectively "click" the PGButton.  Normally, this is just
## MouseButton::one().

proc isButtonDown*(this: PGButton): bool {.importcpp: "#->is_button_down()".} ## \
## Returns true if the user is currently holding the mouse button down on the
## button, false otherwise.

proc getClickPrefix*(_: typedesc[PGButton]): string {.importcpp: "nimStringFromStdString(PGButton::get_click_prefix())", header: "pgButton.h".} ## \
## Returns the prefix that is used to define the click event for all
## PGButtons.  The click event is the concatenation of this string followed by
## get_id().

proc getClickEvent*(this: PGButton, button: ButtonHandle): string {.importcpp: "nimStringFromStdString(#->get_click_event(#))", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the button is clicked
## normally.

converter getClassType*(_: typedesc[PGButton]): TypeHandle {.importcpp: "PGButton::get_class_type()", header: "pgButton.h".}

proc newPGTop*(name: string): PGTop {.importcpp: "new PGTop(nimStringToStdString(#))", header: stringConversionCode.}

proc setMouseWatcher*(this: PGTop, watcher: MouseWatcher) {.importcpp: "#->set_mouse_watcher(#)".} ## \
## Sets the MouseWatcher pointer that the PGTop object registers its PG items
## with.  This must be set before the PG items are active.

proc getMouseWatcher*(this: PGTop): MouseWatcher {.importcpp: "#->get_mouse_watcher()".} ## \
## Returns the MouseWatcher pointer that the PGTop object registers its PG
## items with, or NULL if the MouseWatcher has not yet been set.

proc getGroup*(this: PGTop): MouseWatcherGroup {.importcpp: "#->get_group()".} ## \
## Returns the MouseWatcherGroup pointer that the PGTop object registers its
## PG items with, or NULL if the MouseWatcher has not yet been set.

proc setStartSort*(this: PGTop, start_sort: int) {.importcpp: "#->set_start_sort(#)".} ## \
## Specifies the sort index that is assigned during the traversal to the first
## PGItem that is discovered during traversal.  Subsequent PGItems will be
## assigned consecutively higher sort indexes.
##
## This number is used by the MouseWatcher system to rank the clickable mouse
## regions in the same order in which the items are rendered, so that items on
## top will receive mouse priority.
##
## Normally, it makes the most sense to leave this initial value at its
## default value of 0, unless you need the PGItems to have a particular sort
## value with respect to some other objects in the scene (particularly with a
## second PGTop node).

proc getStartSort*(this: PGTop): int {.importcpp: "#->get_start_sort()".} ## \
## Returns the sort index that is assigned during the traversal to the first
## PGItem that is discovered during traversal.  See set_start_sort().

converter getClassType*(_: typedesc[PGTop]): TypeHandle {.importcpp: "PGTop::get_class_type()", header: "pgTop.h".}

proc newPGEntry*(name: string): PGEntry {.importcpp: "new PGEntry(nimStringToStdString(#))", header: stringConversionCode.}

proc setup*(this: PGEntry, width: float32, num_lines: int) {.importcpp: "#->setup(#, #)".} ## \
## Sets up the entry for normal use.  The width is the maximum width of
## characters that will be typed, and num_lines is the integer number of lines
## of text of the entry.  Both of these together determine the size of the
## entry, based on the TextNode in effect.

proc setupMinimal*(this: PGEntry, width: float32, num_lines: int) {.importcpp: "#->setup_minimal(#, #)".} ## \
## Sets up the entry without creating any frame or other decoration.

proc setText*(this: PGEntry, text: string): bool {.importcpp: "#->set_text(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the text currently displayed within the entry.  This uses the
## Unicode encoding currently specified for the "focus" TextNode; therefore,
## the TextNode must exist before calling set_text().
##
## The return value is true if all the text is accepted, or false if some was
## truncated (see set_max_width(), etc.).

proc getPlainText*(this: PGEntry): string {.importcpp: "nimStringFromStdString(#->get_plain_text())", header: stringConversionCode.} ## \
## Returns the text currently displayed within the entry, without any embedded
## properties characters.
##
## This uses the Unicode encoding currently specified for the "focus"
## TextNode; therefore, the TextNode must exist before calling get_text().

proc getText*(this: PGEntry): string {.importcpp: "nimStringFromStdString(#->get_text())", header: stringConversionCode.} ## \
## Returns the text currently displayed within the entry.  This uses the
## Unicode encoding currently specified for the "focus" TextNode; therefore,
## the TextNode must exist before calling get_text().

proc getNumCharacters*(this: PGEntry): int {.importcpp: "#->get_num_characters()".} ## \
## Returns the number of characters of text in the entry.  This is the actual
## number of visible characters, not counting implicit newlines due to
## wordwrapping, or formatted characters for text properties changes.  If
## there is an embedded TextGraphic object, it counts as one character.
##
## This is also the length of the string returned by get_plain_text().

proc getCharacter*(this: PGEntry, n: int): int {.importcpp: "#->get_character(#)".} ## \
## Returns the character at the indicated position in the entry.  If the
## object at this position is a graphic object instead of a character, returns
## 0.

proc getGraphic*(this: PGEntry, n: int): TextGraphic {.importcpp: "#->get_graphic(#)".} ## \
## Returns the graphic object at the indicated position in the pre-wordwrapped
## string.  If the object at this position is a character instead of a graphic
## object, returns NULL.

proc getProperties*(this: PGEntry, n: int): TextProperties {.importcpp: "#->get_properties(#)".} ## \
## Returns the TextProperties in effect for the object at the indicated
## position in the pre-wordwrapped string.

proc setCursorPosition*(this: PGEntry, position: int) {.importcpp: "#->set_cursor_position(#)".} ## \
## Sets the current position of the cursor.  This is the position within the
## text at which the next letter typed by the user will be inserted; normally
## it is the same as the length of the text.

proc getCursorPosition*(this: PGEntry): int {.importcpp: "#->get_cursor_position()".} ## \
## Returns the current position of the cursor.

proc getCursorX*(this: PGEntry): float32 {.importcpp: "#->get_cursor_X()".}

proc getCursorY*(this: PGEntry): float32 {.importcpp: "#->get_cursor_Y()".}

proc setMaxChars*(this: PGEntry, max_chars: int) {.importcpp: "#->set_max_chars(#)".} ## \
## Sets the maximum number of characters that may be typed into the entry.
## This is a limit on the number of characters, as opposed to the width of the
## entry; see also set_max_width().
##
## If this is 0, there is no limit.

proc getMaxChars*(this: PGEntry): int {.importcpp: "#->get_max_chars()".} ## \
## Returns the current maximum number of characters that may be typed into the
## entry, or 0 if there is no limit.  See set_max_chars().

proc setMaxWidth*(this: PGEntry, max_width: float32) {.importcpp: "#->set_max_width(#)".} ## \
## Sets the maximum width of all characters that may be typed into the entry.
## This is a limit on the width of the formatted text, not a fixed limit on
## the number of characters; also set_max_chars().
##
## If this is 0, there is no limit.
##
## If _num_lines is more than 1, rather than being a fixed width on the whole
## entry, this becomes instead the wordwrap width (and the width limit on the
## entry is essentially _max_width \* _num_lines).

proc getMaxWidth*(this: PGEntry): float32 {.importcpp: "#->get_max_width()".} ## \
## Returns the current maximum width of the characters that may be typed into
## the entry, or 0 if there is no limit.  See set_max_width().

proc setNumLines*(this: PGEntry, num_lines: int) {.importcpp: "#->set_num_lines(#)".} ## \
## Sets the number of lines of text the PGEntry will use.  This only has
## meaning if _max_width is not 0; _max_width indicates the wordwrap width of
## each line.

proc getNumLines*(this: PGEntry): int {.importcpp: "#->get_num_lines()".} ## \
## Returns the number of lines of text the PGEntry will use, if _max_width is
## not 0.  See set_num_lines().

proc setBlinkRate*(this: PGEntry, blink_rate: float32) {.importcpp: "#->set_blink_rate(#)".} ## \
## Sets the number of times per second the cursor will blink while the entry
## has keyboard focus.
##
## If this is 0, the cursor does not blink, but is held steady.

proc getBlinkRate*(this: PGEntry): float32 {.importcpp: "#->get_blink_rate()".} ## \
## Returns the number of times per second the cursor will blink, or 0 if the
## cursor is not to blink.

proc getCursorDef*(this: PGEntry): NodePath {.importcpp: "#->get_cursor_def()".} ## \
## Returns the Node that will be rendered to represent the cursor.  You can
## attach suitable cursor geometry to this node.

proc clearCursorDef*(this: PGEntry) {.importcpp: "#->clear_cursor_def()".} ## \
## Removes all the children from the cursor_def node, in preparation for
## adding a new definition.

proc setCursorKeysActive*(this: PGEntry, flag: bool) {.importcpp: "#->set_cursor_keys_active(#)".} ## \
## Sets whether the arrow keys (and home/end) control movement of the cursor.
## If true, they are active; if false, they are ignored.

proc getCursorKeysActive*(this: PGEntry): bool {.importcpp: "#->get_cursor_keys_active()".} ## \
## Returns whether the arrow keys are currently set to control movement of the
## cursor; see set_cursor_keys_active().

proc setObscureMode*(this: PGEntry, flag: bool) {.importcpp: "#->set_obscure_mode(#)".} ## \
## Specifies whether obscure mode should be enabled.  In obscure mode, a
## string of asterisks is displayed instead of the literal text, e.g.  for
## entering passwords.
##
## In obscure mode, the width of the text is computed based on the width of
## the string of asterisks, not on the width of the actual text.  This has
## implications on the maximum length of text that may be entered if max_width
## is in effect.

proc getObscureMode*(this: PGEntry): bool {.importcpp: "#->get_obscure_mode()".} ## \
## Specifies whether obscure mode is enabled.  See set_obscure_mode().

proc setOverflowMode*(this: PGEntry, flag: bool) {.importcpp: "#->set_overflow_mode(#)".} ## \
## Specifies whether overflow mode should be enabled.  In overflow mode, text
## can overflow the boundaries of the Entry element horizontally.
##
## Overflow mode only works when the number of lines is 1.

proc getOverflowMode*(this: PGEntry): bool {.importcpp: "#->get_overflow_mode()".} ## \
## Specifies whether overflow mode is enabled.  See set_overflow_mode().

proc setCandidateActive*(this: PGEntry, candidate_active: string) {.importcpp: "#->set_candidate_active(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the name of the TextProperties structure added to the
## TextPropertiesManager that will be used to render candidate strings from
## the IME, used for typing characters in east Asian languages.  Each
## candidate string represents one possible way to interpret the sequence of
## keys the user has just entered; it should not be considered typed yet, but
## it is important for the user to be able to see what he is considering
## entering.
##
## This particular method sets the properties for the subset of the current
## candidate string that the user can actively scroll through.

proc getCandidateActive*(this: PGEntry): string {.importcpp: "nimStringFromStdString(#->get_candidate_active())", header: stringConversionCode.} ## \
## See set_candidate_active().

proc setCandidateInactive*(this: PGEntry, candidate_inactive: string) {.importcpp: "#->set_candidate_inactive(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Specifies the name of the TextProperties structure added to the
## TextPropertiesManager that will be used to render candidate strings from
## the IME, used for typing characters in east Asian languages.  Each
## candidate string represents one possible way to interpret the sequence of
## keys the user has just entered; it should not be considered typed yet, but
## it is important for the user to be able to see what he is considering
## entering.
##
## This particular method sets the properties for the subset of the current
## candidate string that the user is not actively scrolling through.

proc getCandidateInactive*(this: PGEntry): string {.importcpp: "nimStringFromStdString(#->get_candidate_inactive())", header: stringConversionCode.} ## \
## See set_candidate_inactive().

proc setTextDef*(this: PGEntry, state: int, node: TextNode) {.importcpp: "#->set_text_def(#, #)".} ## \
## Changes the TextNode that will be used to render the text within the entry
## when the entry is in the indicated state.  The default if nothing is
## specified is the same TextNode returned by PGItem::get_text_node().

proc getTextDef*(this: PGEntry, state: int): TextNode {.importcpp: "#->get_text_def(#)".} ## \
## Returns the TextNode that will be used to render the text within the entry
## when the entry is in the indicated state.  See set_text_def().

proc getAcceptPrefix*(_: typedesc[PGEntry]): string {.importcpp: "nimStringFromStdString(PGEntry::get_accept_prefix())", header: "pgEntry.h".} ## \
## Returns the prefix that is used to define the accept event for all
## PGEntries.  The accept event is the concatenation of this string followed
## by get_id().

proc getAcceptFailedPrefix*(_: typedesc[PGEntry]): string {.importcpp: "nimStringFromStdString(PGEntry::get_accept_failed_prefix())", header: "pgEntry.h".} ## \
## Returns the prefix that is used to define the accept failed event for all
## PGEntries.  This event is the concatenation of this string followed by
## get_id().

proc getOverflowPrefix*(_: typedesc[PGEntry]): string {.importcpp: "nimStringFromStdString(PGEntry::get_overflow_prefix())", header: "pgEntry.h".} ## \
## Returns the prefix that is used to define the overflow event for all
## PGEntries.  The overflow event is the concatenation of this string followed
## by get_id().

proc getTypePrefix*(_: typedesc[PGEntry]): string {.importcpp: "nimStringFromStdString(PGEntry::get_type_prefix())", header: "pgEntry.h".} ## \
## Returns the prefix that is used to define the type event for all PGEntries.
## The type event is the concatenation of this string followed by get_id().

proc getErasePrefix*(_: typedesc[PGEntry]): string {.importcpp: "nimStringFromStdString(PGEntry::get_erase_prefix())", header: "pgEntry.h".} ## \
## Returns the prefix that is used to define the erase event for all
## PGEntries.  The erase event is the concatenation of this string followed by
## get_id().

proc getCursormovePrefix*(_: typedesc[PGEntry]): string {.importcpp: "nimStringFromStdString(PGEntry::get_cursormove_prefix())", header: "pgEntry.h".} ## \
## Returns the prefix that is used to define the cursor event for all
## PGEntries.  The cursor event is the concatenation of this string followed
## by get_id().

proc getAcceptEvent*(this: PGEntry, button: ButtonHandle): string {.importcpp: "nimStringFromStdString(#->get_accept_event(#))", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the entry is accepted
## normally.

proc getAcceptFailedEvent*(this: PGEntry, button: ButtonHandle): string {.importcpp: "nimStringFromStdString(#->get_accept_failed_event(#))", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the entry cannot accept an
## input

proc getOverflowEvent*(this: PGEntry): string {.importcpp: "nimStringFromStdString(#->get_overflow_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when too much text is attempted
## to be entered into the PGEntry, exceeding either the limit set via
## set_max_chars() or via set_max_width().

proc getTypeEvent*(this: PGEntry): string {.importcpp: "nimStringFromStdString(#->get_type_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown whenever the user extends the
## text by typing.

proc getEraseEvent*(this: PGEntry): string {.importcpp: "nimStringFromStdString(#->get_erase_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown whenever the user erases
## characters in the text.

proc getCursormoveEvent*(this: PGEntry): string {.importcpp: "nimStringFromStdString(#->get_cursormove_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown whenever the cursor moves

proc setWtext*(this: PGEntry, wtext: string): bool {.importcpp: "#->set_wtext(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Changes the text currently displayed within the entry.
##
## The return value is true if all the text is accepted, or false if some was
## truncated (see set_max_width(), etc.).

proc getPlainWtext*(this: PGEntry): string {.importcpp: "nimStringFromStdString(#->get_plain_wtext())", header: stringConversionCode.} ## \
## Returns the text currently displayed within the entry, without any embedded
## properties characters.

proc getWtext*(this: PGEntry): string {.importcpp: "nimStringFromStdString(#->get_wtext())", header: stringConversionCode.} ## \
## Returns the text currently displayed within the entry.

proc setAcceptEnabled*(this: PGEntry, enabled: bool) {.importcpp: "#->set_accept_enabled(#)".} ## \
## Sets whether the input may be accepted--use to disable submission by the
## user

proc isWtext*(this: PGEntry): bool {.importcpp: "#->is_wtext()".} ## \
## Returns true if any of the characters in the string returned by get_wtext()
## are out of the range of an ASCII character (and, therefore, get_wtext()
## should be called in preference to get_text()).

converter getClassType*(_: typedesc[PGEntry]): TypeHandle {.importcpp: "PGEntry::get_class_type()", header: "pgEntry.h".}

converter upcastToTypedWritableReferenceCount*(this: PGMouseWatcherParameter): TypedWritableReferenceCount {.importcpp: "(PT(TypedWritableReferenceCount)(#))".}

converter upcastToMouseWatcherParameter*(this: PGMouseWatcherParameter): MouseWatcherParameter {.importcpp: "((MouseWatcherParameter *)(PGMouseWatcherParameter *)(#))".}

proc output*(this: PGMouseWatcherParameter, `out`: ostream) {.importcpp: "#->output(#)".}

converter getClassType*(_: typedesc[PGMouseWatcherParameter]): TypeHandle {.importcpp: "PGMouseWatcherParameter::get_class_type()", header: "pgMouseWatcherParameter.h".}

proc newPGMouseWatcherParameter*(param0: PGMouseWatcherParameter): PGMouseWatcherParameter {.importcpp: "new PGMouseWatcherParameter(#)".}

proc newPGMouseWatcherBackground*(): PGMouseWatcherBackground {.importcpp: "new PGMouseWatcherBackground()".}

proc newPGMouseWatcherBackground*(param0: PGMouseWatcherBackground): PGMouseWatcherBackground {.importcpp: "new PGMouseWatcherBackground(#)".}

converter getClassType*(_: typedesc[PGMouseWatcherBackground]): TypeHandle {.importcpp: "PGMouseWatcherBackground::get_class_type()", header: "pgMouseWatcherBackground.h".}

proc newPGVirtualFrame*(name: string): PGVirtualFrame {.importcpp: "new PGVirtualFrame(nimStringToStdString(#))", header: stringConversionCode.}

proc newPGVirtualFrame*(): PGVirtualFrame {.importcpp: "new PGVirtualFrame()".}

proc setup*(this: PGVirtualFrame, width: float32, height: float32) {.importcpp: "#->setup(#, #)".} ## \
## Creates a PGVirtualFrame with the indicated dimensions.

proc setClipFrame*(this: PGVirtualFrame, clip_frame: LVecBase4) {.importcpp: "#->set_clip_frame(#)".} ## \
## Sets the bounding rectangle of the clip frame.  This is the size of the
## small window through which we can see the virtual canvas.  Normally, this
## is the same size as the actual frame or smaller (typically it is smaller by
## the size of the bevel, or to make room for scroll bars).

proc setClipFrame*(this: PGVirtualFrame, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#->set_clip_frame(#, #, #, #)".} ## \
## Sets the bounding rectangle of the clip frame.  This is the size of the
## small window through which we can see the virtual canvas.  Normally, this
## is the same size as the actual frame or smaller (typically it is smaller by
## the size of the bevel, or to make room for scroll bars).

proc getClipFrame*(this: PGVirtualFrame): LVecBase4 {.importcpp: "#->get_clip_frame()".} ## \
## Returns the bounding rectangle of the clip frame.  See set_clip_frame().
## If has_clip_frame() is false, this returns the item's actual frame.

proc hasClipFrame*(this: PGVirtualFrame): bool {.importcpp: "#->has_clip_frame()".} ## \
## Returns true if the clip frame has been set; see set_clip_frame().  If it
## has not been set, objects in the virtual frame will not be clipped.

proc clearClipFrame*(this: PGVirtualFrame) {.importcpp: "#->clear_clip_frame()".} ## \
## Removes the clip frame from the item.  This disables clipping.

proc setCanvasTransform*(this: PGVirtualFrame, transform: TransformState) {.importcpp: "#->set_canvas_transform(#)".} ## \
## Changes the transform of the virtual canvas.  This transform is applied to
## all child nodes of the canvas_node.

proc getCanvasTransform*(this: PGVirtualFrame): TransformState {.importcpp: "deconstify(#->get_canvas_transform())", header: deconstifyCode.} ## \
## Returns the transform of the virtual canvas.  This transform is applied to
## all child nodes of the canvas_node.

proc getCanvasNode*(this: PGVirtualFrame): PandaNode {.importcpp: "#->get_canvas_node()".} ## \
## Returns the special node that holds all of the children that appear in the
## virtual canvas.

proc getCanvasParent*(this: PGVirtualFrame): PandaNode {.importcpp: "#->get_canvas_parent()".} ## \
## Returns the parent node of the canvas_node.

converter getClassType*(_: typedesc[PGVirtualFrame]): TypeHandle {.importcpp: "PGVirtualFrame::get_class_type()", header: "pgVirtualFrame.h".}

converter upcastToPGItem*(this: PGSliderBar): PGItem {.importcpp: "(PT(PGItem)(#))".}

proc newPGSliderBar*(name: string): PGSliderBar {.importcpp: "new PGSliderBar(nimStringToStdString(#))", header: stringConversionCode.}

proc newPGSliderBar*(): PGSliderBar {.importcpp: "new PGSliderBar()".}

proc setupScrollBar*(this: PGSliderBar, vertical: bool, length: float32, width: float32, bevel: float32) {.importcpp: "#->setup_scroll_bar(#, #, #, #)".} ## \
## Creates PGSliderBar that represents a vertical or horizontal scroll bar (if
## vertical is true or false, respectively), with additional buttons for
## scrolling, and a range of 0 .. 1.
##
## length here is the measurement along the scroll bar, and width is the
## measurement across the scroll bar, whether it is vertical or horizontal (so
## for a horizontal scroll bar, the length is actually the x dimension, and
## the width is the y dimension).

proc setupSlider*(this: PGSliderBar, vertical: bool, length: float32, width: float32, bevel: float32) {.importcpp: "#->setup_slider(#, #, #, #)".} ## \
## Creates PGSliderBar that represents a slider that the user can use to
## control an analog quantity.
##
## This is functionally the same as a scroll bar, but it has a distinctive
## look.

proc setAxis*(this: PGSliderBar, axis: LVector3) {.importcpp: "#->set_axis(#)".} ## \
## Specifies the axis of the slider bar's motion.  This should be only one of
## four vectors: (1, 0, 0), (0, 0, 1), (-1, 0, 0), or (0, 0, -1).
##
## This specifies the vector in which the thumb moves when it is moving from
## the minimum to the maximum value.
##
## The axis must be parallel to one of the screen axes, and it must be
## normalized.  Hence, it may only be one of the above four possibilities;
## anything else is an error and will result in indeterminate behavior.
##
## Normally, you should not try to set the axis directly.

proc getAxis*(this: PGSliderBar): LVector3 {.importcpp: "#->get_axis()".} ## \
## Returns the axis of the slider bar's motion.  See set_axis().

proc setRange*(this: PGSliderBar, min_value: float32, max_value: float32) {.importcpp: "#->set_range(#, #)".} ## \
## Sets the minimum and maxmimum value for the slider.

proc getMinValue*(this: PGSliderBar): float32 {.importcpp: "#->get_min_value()".} ## \
## Returns the value when the slider is all the way to the left.

proc getMaxValue*(this: PGSliderBar): float32 {.importcpp: "#->get_max_value()".} ## \
## Returns the value when the slider is all the way to the right.

proc setScrollSize*(this: PGSliderBar, scroll_size: float32) {.importcpp: "#->set_scroll_size(#)".} ## \
## Specifies the amount the slider will move when the user clicks on the left
## or right buttons.

proc getScrollSize*(this: PGSliderBar): float32 {.importcpp: "#->get_scroll_size()".} ## \
## Returns the value last set by set_scroll_size().

proc setPageSize*(this: PGSliderBar, page_size: float32) {.importcpp: "#->set_page_size(#)".} ## \
## Specifies the amount of data contained in a single page.  This indicates
## how much the thumb will jump when the trough is directly clicked; and if
## resize_thumb is true, it also controls the visible size of the thumb
## button.

proc getPageSize*(this: PGSliderBar): float32 {.importcpp: "#->get_page_size()".} ## \
## Returns the value last set by set_page_size().

proc setValue*(this: PGSliderBar, value: float32) {.importcpp: "#->set_value(#)".} ## \
## Sets the current value of the slider programmatically.  This should range
## between get_min_value() and get_max_value().

proc getValue*(this: PGSliderBar): float32 {.importcpp: "#->get_value()".} ## \
## Returns the current value of the slider.

proc setRatio*(this: PGSliderBar, ratio: float32) {.importcpp: "#->set_ratio(#)".} ## \
## Sets the current value of the slider, expressed in the range 0 .. 1.

proc getRatio*(this: PGSliderBar): float32 {.importcpp: "#->get_ratio()".} ## \
## Returns the current value of the slider, expressed in the range 0 .. 1.

proc isButtonDown*(this: PGSliderBar): bool {.importcpp: "#->is_button_down()".} ## \
## Returns true if the user is currently holding down the mouse button to
## manipulate the slider.  When true, calls to set_ratio() or set_value() will
## have no effect.

proc setResizeThumb*(this: PGSliderBar, resize_thumb: bool) {.importcpp: "#->set_resize_thumb(#)".} ## \
## Sets the resize_thumb flag.  When this is true, the thumb button's frame
## will be adjusted so that its width visually represents the page size.  When
## this is false, the thumb button will be left alone.

proc getResizeThumb*(this: PGSliderBar): bool {.importcpp: "#->get_resize_thumb()".} ## \
## Returns the resize_thumb flag.  See set_resize_thumb().

proc setManagePieces*(this: PGSliderBar, manage_pieces: bool) {.importcpp: "#->set_manage_pieces(#)".} ## \
## Sets the manage_pieces flag.  When this is true, the sub-pieces of the
## slider bar--that is, the thumb, and the left and right scroll buttons--are
## automatically positioned and/or resized when the slider bar's overall frame
## is changed.

proc getManagePieces*(this: PGSliderBar): bool {.importcpp: "#->get_manage_pieces()".} ## \
## Returns the manage_pieces flag.  See set_manage_pieces().

proc setThumbButton*(this: PGSliderBar, thumb_button: PGButton) {.importcpp: "#->set_thumb_button(#)".} ## \
## Sets the PGButton object that will serve as the thumb for this slider.
## This button visually represents the position of the slider, and can be
## dragged left and right by the user.
##
## It is the responsibility of the caller to ensure that the button object is
## parented to the PGSliderBar node.

proc clearThumbButton*(this: PGSliderBar) {.importcpp: "#->clear_thumb_button()".} ## \
## Removes the thumb button object from control of the frame.  It is your
## responsibility to actually remove or hide the button itself.

proc getThumbButton*(this: PGSliderBar): PGButton {.importcpp: "#->get_thumb_button()".} ## \
## Returns the PGButton that serves as the thumb for this slider, or NULL if
## it is not set.

proc setLeftButton*(this: PGSliderBar, left_button: PGButton) {.importcpp: "#->set_left_button(#)".} ## \
## Sets the PGButton object that will serve as the left scroll button for this
## slider.  This button is optional; if present, the user can click on it to
## move scroll_size units at a time to the left.
##
## It is the responsibility of the caller to ensure that the button object is
## parented to the PGSliderBar node.

proc clearLeftButton*(this: PGSliderBar) {.importcpp: "#->clear_left_button()".} ## \
## Removes the left button object from control of the frame.  It is your
## responsibility to actually remove or hide the button itself.

proc getLeftButton*(this: PGSliderBar): PGButton {.importcpp: "#->get_left_button()".} ## \
## Returns the PGButton that serves as the left scroll button for this slider,
## if any, or NULL if it is not set.

proc setRightButton*(this: PGSliderBar, right_button: PGButton) {.importcpp: "#->set_right_button(#)".} ## \
## Sets the PGButton object that will serve as the right scroll button for
## this slider.  This button is optional; if present, the user can click on it
## to move scroll_size units at a time to the right.
##
## It is the responsibility of the caller to ensure that the button object is
## parented to the PGSliderBar node.

proc clearRightButton*(this: PGSliderBar) {.importcpp: "#->clear_right_button()".} ## \
## Removes the right button object from control of the frame.  It is your
## responsibility to actually remove or hide the button itself.

proc getRightButton*(this: PGSliderBar): PGButton {.importcpp: "#->get_right_button()".} ## \
## Returns the PGButton that serves as the right scroll button for this
## slider, if any, or NULL if it is not set.

proc getAdjustPrefix*(_: typedesc[PGSliderBar]): string {.importcpp: "nimStringFromStdString(PGSliderBar::get_adjust_prefix())", header: "pgSliderBar.h".} ## \
## Returns the prefix that is used to define the adjust event for all
## PGSliderBars.  The adjust event is the concatenation of this string
## followed by get_id().

proc getAdjustEvent*(this: PGSliderBar): string {.importcpp: "nimStringFromStdString(#->get_adjust_event())", header: stringConversionCode.} ## \
## Returns the event name that will be thrown when the slider bar value is
## adjusted by the user or programmatically.

proc setActive*(this: PGSliderBar, active: bool) {.importcpp: "#->set_active(#)".} ## \
## Sets whether the PGItem is active for mouse watching.  This is not
## necessarily related to the active/inactive appearance of the item, which is
## controlled by set_state(), but it does affect whether it responds to mouse
## events.

proc remanage*(this: PGSliderBar) {.importcpp: "#->remanage()".} ## \
## Manages the position and size of the scroll bars and the thumb.  Normally
## this should not need to be called directly.

proc recompute*(this: PGSliderBar) {.importcpp: "#->recompute()".} ## \
## Recomputes the position and size of the thumb.  Normally this should not
## need to be called directly.

converter getClassType*(_: typedesc[PGSliderBar]): TypeHandle {.importcpp: "PGSliderBar::get_class_type()", header: "pgSliderBar.h".}

converter upcastToPGVirtualFrame*(this: PGScrollFrame): PGVirtualFrame {.importcpp: "(PT(PGVirtualFrame)(#))".}

proc newPGScrollFrame*(name: string): PGScrollFrame {.importcpp: "new PGScrollFrame(nimStringToStdString(#))", header: stringConversionCode.}

proc newPGScrollFrame*(): PGScrollFrame {.importcpp: "new PGScrollFrame()".}

proc setup*(this: PGScrollFrame, width: float32, height: float32, left: float32, right: float32, bottom: float32, top: float32, slider_width: float32, bevel: float32) {.importcpp: "#->setup(#, #, #, #, #, #, #, #)".} ## \
## Creates a PGScrollFrame with the indicated dimensions, and the indicated
## virtual frame.

proc setVirtualFrame*(this: PGScrollFrame, virtual_frame: LVecBase4) {.importcpp: "#->set_virtual_frame(#)".} ## \
## Sets the bounding rectangle of the virtual frame.  This is the size of the
## large, virtual canvas which we can see only a portion of at any given time.

proc setVirtualFrame*(this: PGScrollFrame, left: float32, right: float32, bottom: float32, top: float32) {.importcpp: "#->set_virtual_frame(#, #, #, #)".} ## \
## Sets the bounding rectangle of the virtual frame.  This is the size of the
## large, virtual canvas which we can see only a portion of at any given time.

proc getVirtualFrame*(this: PGScrollFrame): LVecBase4 {.importcpp: "#->get_virtual_frame()".} ## \
## Returns the bounding rectangle of the virtual frame.  See
## set_virtual_frame().  If has_virtual_frame() is false, this returns the
## item's clip frame.

proc hasVirtualFrame*(this: PGScrollFrame): bool {.importcpp: "#->has_virtual_frame()".} ## \
## Returns true if the virtual frame has a bounding rectangle; see
## set_virtual_frame().  Most PGScrollFrame objects will have a virtual frame.

proc clearVirtualFrame*(this: PGScrollFrame) {.importcpp: "#->clear_virtual_frame()".} ## \
## Removes the virtual frame from the item.  This effectively sets the virtual
## frame to the same size as the clip frame.  Scrolling will no longer be
## possible.

proc setManagePieces*(this: PGScrollFrame, manage_pieces: bool) {.importcpp: "#->set_manage_pieces(#)".} ## \
## Sets the manage_pieces flag.  When this is true, the sub-pieces of the
## scroll frame--that is, the two scroll bars--are automatically positioned
## and/or resized when the scroll frame's overall frame is changed.  They are
## also automatically resized to fill in the gap when one or the other is
## hidden.

proc getManagePieces*(this: PGScrollFrame): bool {.importcpp: "#->get_manage_pieces()".} ## \
## Returns the manage_pieces flag.  See set_manage_pieces().

proc setAutoHide*(this: PGScrollFrame, auto_hide: bool) {.importcpp: "#->set_auto_hide(#)".} ## \
## Sets the auto_hide flag.  When this is true, the two scroll bars are
## automatically hidden if they are not needed (that is, if the virtual frame
## would fit within the clip frame without them), and they are automatically
## shown when they are needed.
##
## Setting this flag true forces the manage_pieces flag to also be set true.

proc getAutoHide*(this: PGScrollFrame): bool {.importcpp: "#->get_auto_hide()".} ## \
## Returns the auto_hide flag.  See set_auto_hide().

proc setHorizontalSlider*(this: PGScrollFrame, horizontal_slider: PGSliderBar) {.importcpp: "#->set_horizontal_slider(#)".} ## \
## Sets the PGSliderBar object that will serve as the horizontal scroll bar
## for this frame.  It is your responsibility to parent this slider bar to the
## frame and move it to the appropriate place.

proc clearHorizontalSlider*(this: PGScrollFrame) {.importcpp: "#->clear_horizontal_slider()".} ## \
## Removes the horizontal scroll bar from control of the frame.  It is your
## responsibility to actually remove or hide the object itself.

proc getHorizontalSlider*(this: PGScrollFrame): PGSliderBar {.importcpp: "#->get_horizontal_slider()".} ## \
## Returns the PGSliderBar that serves as the horizontal scroll bar for this
## frame, if any, or NULL if it is not set.

proc setVerticalSlider*(this: PGScrollFrame, vertical_slider: PGSliderBar) {.importcpp: "#->set_vertical_slider(#)".} ## \
## Sets the PGSliderBar object that will serve as the vertical scroll bar for
## this frame.  It is your responsibility to parent this slider bar to the
## frame and move it to the appropriate place.

proc clearVerticalSlider*(this: PGScrollFrame) {.importcpp: "#->clear_vertical_slider()".} ## \
## Removes the vertical scroll bar from control of the frame.  It is your
## responsibility to actually remove or hide the object itself.

proc getVerticalSlider*(this: PGScrollFrame): PGSliderBar {.importcpp: "#->get_vertical_slider()".} ## \
## Returns the PGSliderBar that serves as the vertical scroll bar for this
## frame, if any, or NULL if it is not set.

proc remanage*(this: PGScrollFrame) {.importcpp: "#->remanage()".} ## \
## Manages the position and size of the scroll bars.  Normally this should not
## need to be called directly.

proc recompute*(this: PGScrollFrame) {.importcpp: "#->recompute()".} ## \
## Forces the PGScrollFrame to recompute itself right now.  Normally this
## should not be required.

converter getClassType*(_: typedesc[PGScrollFrame]): TypeHandle {.importcpp: "PGScrollFrame::get_class_type()", header: "pgScrollFrame.h".}

proc newPGWaitBar*(name: string): PGWaitBar {.importcpp: "new PGWaitBar(nimStringToStdString(#))", header: stringConversionCode.}

proc newPGWaitBar*(): PGWaitBar {.importcpp: "new PGWaitBar()".}

proc setup*(this: PGWaitBar, width: float32, height: float32, range: float32) {.importcpp: "#->setup(#, #, #)".} ## \
## Creates a PGWaitBar with the indicated dimensions, with the indicated
## maximum range.

proc setRange*(this: PGWaitBar, range: float32) {.importcpp: "#->set_range(#)".} ## \
## Sets the value at which the WaitBar indicates 100%.

proc getRange*(this: PGWaitBar): float32 {.importcpp: "#->get_range()".} ## \
## Returns the value at which the WaitBar indicates 100%.

proc setValue*(this: PGWaitBar, value: float32) {.importcpp: "#->set_value(#)".} ## \
## Sets the current value of the bar.  This should range between 0 and
## get_range().

proc getValue*(this: PGWaitBar): float32 {.importcpp: "#->get_value()".} ## \
## Returns the current value of the bar.

proc getPercent*(this: PGWaitBar): float32 {.importcpp: "#->get_percent()".} ## \
## Returns the percentage complete.

proc setBarStyle*(this: PGWaitBar, style: PGFrameStyle) {.importcpp: "#->set_bar_style(#)".} ## \
## Sets the kind of frame that is drawn on top of the WaitBar to represent the
## amount completed.

proc getBarStyle*(this: PGWaitBar): PGFrameStyle {.importcpp: "#->get_bar_style()".} ## \
## Returns the kind of frame that is drawn on top of the WaitBar to represent
## the amount completed.

converter getClassType*(_: typedesc[PGWaitBar]): TypeHandle {.importcpp: "PGWaitBar::get_class_type()", header: "pgWaitBar.h".}

proc initNetAddress*(): NetAddress {.importcpp: "NetAddress()".} ## \
## Constructs an unspecified address.

proc initNetAddress*(param0: NetAddress): NetAddress {.importcpp: "NetAddress(#)".}

converter initNetAddress*(`addr`: Socket_Address): NetAddress {.importcpp: "NetAddress(#)".} ## \
## Constructs an address from a given Socket_Address.  Normally, this
## constructor should not be used by user code; instead, create a default
## NetAddress and use one of the set_\*() functions to set up an address.

proc setAny*(this: NetAddress, port: int): bool {.importcpp: "#.set_any(#)".} ## \
## Sets the address up to refer to a particular port, but not to any
## particular IP.  Returns true if successful, false otherwise (currently,
## this only returns true).

proc setLocalhost*(this: NetAddress, port: int): bool {.importcpp: "#.set_localhost(#)".} ## \
## Sets the address up to refer to a particular port, on this host.

proc setBroadcast*(this: NetAddress, port: int): bool {.importcpp: "#.set_broadcast(#)".} ## \
## Sets the address to the broadcast address.

proc setHost*(this: NetAddress, hostname: string, port: int): bool {.importcpp: "#.set_host(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Sets the address up to refer to a particular port on a particular host.
## Returns true if the hostname is known, false otherwise.

proc clear*(this: NetAddress) {.importcpp: "#.clear()".} ## \
## Resets the NetAddress to its initial state.

proc getPort*(this: NetAddress): int {.importcpp: "#.get_port()".} ## \
## Returns the port number to which this address refers.

proc setPort*(this: NetAddress, port: int) {.importcpp: "#.set_port(#)".} ## \
## Resets the port number without otherwise changing the address.

proc getIpString*(this: NetAddress): string {.importcpp: "nimStringFromStdString(#.get_ip_string())", header: stringConversionCode.} ## \
## Returns the IP address to which this address refers, formatted as a string.

proc isAny*(this: NetAddress): bool {.importcpp: "#.is_any()".} ## \
## Returns true if the IP address has only zeroes.

proc getIp*(this: NetAddress): int {.importcpp: "#.get_ip()".} ## \
## Returns the IP address to which this address refers, as a 32-bit integer,
## in host byte order.
## @deprecated  Does not work with IPv6 addresses.

proc getIpComponent*(this: NetAddress, n: int): char {.importcpp: "#.get_ip_component(#)".} ## \
## Returns the nth 8-bit component of the IP address.  An IP address has four
## components; component 0 is the first (leftmost), and component 3 is the
## last (rightmost) in the dotted number convention.

proc getAddr*(this: NetAddress): Socket_Address {.importcpp: "#.get_addr()".} ## \
## Returns the Socket_Address for this address.

proc output*(this: NetAddress, `out`: ostream) {.importcpp: "#.output(#)".}

proc getHash*(this: NetAddress): clonglong {.importcpp: "#.get_hash()".}

proc `==`*(this: NetAddress, other: NetAddress): bool {.importcpp: "#.operator ==(#)".}

proc `!=`*(this: NetAddress, other: NetAddress): bool {.importcpp: "#.operator !=(#)".}

proc newConnection*(manager: ConnectionManager, socket: Socket_IP): Connection {.importcpp: "new Connection(#, #)".} ## \
## Creates a connection.  Normally this constructor should not be used
## directly by user code; use one of the methods in ConnectionManager to make
## a new connection.

proc getAddress*(this: Connection): NetAddress {.importcpp: "#->get_address()".} ## \
## Returns the address bound to this connection, if it is a TCP connection.

proc getManager*(this: Connection): ConnectionManager {.importcpp: "#->get_manager()".} ## \
## Returns a pointer to the ConnectionManager object that serves this
## connection.

proc getSocket*(this: Connection): Socket_IP {.importcpp: "#->get_socket()".} ## \
## Returns the internal Socket_IP that defines the connection.

proc setCollectTcp*(this: Connection, collect_tcp: bool) {.importcpp: "#->set_collect_tcp(#)".} ## \
## Enables or disables "collect-tcp" mode.  In this mode, individual TCP
## packets are not sent immediately, but rather they are collected together
## and accumulated to be sent periodically as one larger TCP packet.  This
## cuts down on overhead from the TCP/IP protocol, especially if many small
## packets need to be sent on the same connection, but it introduces
## additional latency (since packets must be held before they can be sent).
##
## See set_collect_tcp_interval() to specify the interval of time for which to
## hold packets before sending them.
##
## If you enable this mode, you may also need to periodically call
## consider_flush() to flush the queue if no packets have been sent recently.

proc getCollectTcp*(this: Connection): bool {.importcpp: "#->get_collect_tcp()".} ## \
## Returns the current setting of "collect-tcp" mode.  See set_collect_tcp().

proc setCollectTcpInterval*(this: Connection, interval: float64) {.importcpp: "#->set_collect_tcp_interval(#)".} ## \
## Specifies the interval in time, in seconds, for which to hold TCP packets
## before sending all of the recently received packets at once.  This only has
## meaning if "collect-tcp" mode is enabled; see set_collect_tcp().

proc getCollectTcpInterval*(this: Connection): float64 {.importcpp: "#->get_collect_tcp_interval()".} ## \
## Returns the interval in time, in seconds, for which to hold TCP packets
## before sending all of the recently received packets at once.  This only has
## meaning if "collect-tcp" mode is enabled; see set_collect_tcp().

proc considerFlush*(this: Connection): bool {.importcpp: "#->consider_flush()".} ## \
## Sends the most recently queued TCP datagram(s) if enough time has elapsed.
## This only has meaning if set_collect_tcp() has been set to true.

proc flush*(this: Connection): bool {.importcpp: "#->flush()".} ## \
## Sends the most recently queued TCP datagram(s) now.  This only has meaning
## if set_collect_tcp() has been set to true.

proc setLinger*(this: Connection, flag: bool, time: float64) {.importcpp: "#->set_linger(#, #)".} ## \
## Sets the time to linger on close if data is present.  If flag is false,
## when you close a socket with data available the system attempts to deliver
## the data to the peer (the default behavior).  If flag is false but time is
## zero, the system discards any undelivered data when you close the socket.
## If flag is false but time is nonzero, the system waits up to time seconds
## to deliver the data.

proc setReuseAddr*(this: Connection, flag: bool) {.importcpp: "#->set_reuse_addr(#)".} ## \
## Sets whether local address reuse is allowed.

proc setKeepAlive*(this: Connection, flag: bool) {.importcpp: "#->set_keep_alive(#)".} ## \
## Sets whether the connection is periodically tested to see if it is still
## alive.

proc setRecvBufferSize*(this: Connection, size: int) {.importcpp: "#->set_recv_buffer_size(#)".} ## \
## Sets the size of the receive buffer, in bytes.

proc setSendBufferSize*(this: Connection, size: int) {.importcpp: "#->set_send_buffer_size(#)".} ## \
## Sets the size of the send buffer, in bytes.

proc setIpTimeToLive*(this: Connection, ttl: int) {.importcpp: "#->set_ip_time_to_live(#)".} ## \
## Sets IP time-to-live.

proc setIpTypeOfService*(this: Connection, tos: int) {.importcpp: "#->set_ip_type_of_service(#)".} ## \
## Sets IP type-of-service and precedence.

proc setNoDelay*(this: Connection, flag: bool) {.importcpp: "#->set_no_delay(#)".} ## \
## If flag is true, this disables the Nagle algorithm, and prevents delaying
## of send to coalesce packets.

proc setMaxSegment*(this: Connection, size: int) {.importcpp: "#->set_max_segment(#)".} ## \
## Sets the maximum segment size.

proc addConnection*(this: ConnectionReader, connection: Connection): bool {.importcpp: "#->add_connection(#)".} ## \
## Adds a new socket to the list of sockets the ConnectionReader will monitor.
## A datagram that comes in on any of the monitored sockets will be reported.
## In the case of a ConnectionListener, this adds a new rendezvous socket; any
## activity on any of the monitored sockets will cause a connection to be
## accepted.
##
## The return value is true if the connection was added, false if it was
## already there.
##
## add_connection() is thread-safe, and may be called at will by any thread.

proc removeConnection*(this: ConnectionReader, connection: Connection): bool {.importcpp: "#->remove_connection(#)".} ## \
## Removes a socket from the list of sockets being monitored.  Returns true if
## the socket was correctly removed, false if it was not on the list in the
## first place.
##
## remove_connection() is thread-safe, and may be called at will by any
## thread.

proc isConnectionOk*(this: ConnectionReader, connection: Connection): bool {.importcpp: "#->is_connection_ok(#)".} ## \
## Returns true if the indicated connection has been added to the
## ConnectionReader and is being monitored properly, false if it is not known,
## or if there was some error condition detected on the connection.  (If there
## was an error condition, normally the ConnectionManager would have been
## informed and closed the connection.)

proc poll*(this: ConnectionReader) {.importcpp: "#->poll()".} ## \
## Explicitly polls the available sockets to see if any of them have any
## noise.  This function does nothing unless this is a polling-type
## ConnectionReader, i.e.  it was created with zero threads (and is_polling()
## will return true).
##
## It is not necessary to call this explicitly for a QueuedConnectionReader.

proc getManager*(this: ConnectionReader): ConnectionManager {.importcpp: "#->get_manager()".} ## \
## Returns a pointer to the ConnectionManager object that serves this
## ConnectionReader.

proc isPolling*(this: ConnectionReader): bool {.importcpp: "#->is_polling()".} ## \
## Returns true if the reader is a polling reader, i.e.  it has no threads.

proc getNumThreads*(this: ConnectionReader): int {.importcpp: "#->get_num_threads()".} ## \
## Returns the number of threads the ConnectionReader has been created with.

proc setRawMode*(this: ConnectionReader, mode: bool) {.importcpp: "#->set_raw_mode(#)".} ## \
## Sets the ConnectionReader into raw mode (or turns off raw mode).  In raw
## mode, datagram headers are not expected; instead, all the data available on
## the pipe is treated as a single datagram.
##
## This is similar to set_tcp_header_size(0), except that it also turns off
## headers for UDP packets.

proc getRawMode*(this: ConnectionReader): bool {.importcpp: "#->get_raw_mode()".} ## \
## Returns the current setting of the raw mode flag.  See set_raw_mode().

proc setTcpHeaderSize*(this: ConnectionReader, tcp_header_size: int) {.importcpp: "#->set_tcp_header_size(#)".} ## \
## Sets the header size of TCP packets.  At the present, legal values for this
## are 0, 2, or 4; this specifies the number of bytes to use encode the
## datagram length at the start of each TCP datagram.  Sender and receiver
## must independently agree on this.

proc getTcpHeaderSize*(this: ConnectionReader): int {.importcpp: "#->get_tcp_header_size()".} ## \
## Returns the current setting of TCP header size.  See set_tcp_header_size().

proc shutdown*(this: ConnectionReader) {.importcpp: "#->shutdown()".} ## \
## Terminates all threads cleanly.  Normally this is only called by the
## destructor, but it may be called explicitly before destruction.

proc initNetDatagram*(): NetDatagram {.importcpp: "NetDatagram()".} ## \
## Constructs an empty datagram.

converter initNetDatagram*(copy: Datagram): NetDatagram {.importcpp: "NetDatagram(#)".}

proc initNetDatagram*(copy: NetDatagram): NetDatagram {.importcpp: "NetDatagram(#)".}

proc setConnection*(this: NetDatagram, connection: Connection) {.importcpp: "#.set_connection(#)".} ## \
## Specifies the socket to which the datagram should be written.

proc getConnection*(this: NetDatagram): Connection {.importcpp: "#.get_connection()".} ## \
## Retrieves the socket from which the datagram was read, or to which it is
## scheduled to be written.

proc setAddress*(this: NetDatagram, address: NetAddress) {.importcpp: "#.set_address(#)".} ## \
## Specifies the host to which the datagram should be sent.

proc getAddress*(this: NetDatagram): NetAddress {.importcpp: "#.get_address()".} ## \
## Retrieves the host from which the datagram was read, or to which it is
## scheduled to be sent.

converter getClassType*(_: typedesc[NetDatagram]): TypeHandle {.importcpp: "NetDatagram::get_class_type()", header: "netDatagram.h".}

proc newConnectionManager*(): ConnectionManager {.importcpp: "new ConnectionManager()".}

proc openUDPConnection*(this: ConnectionManager, hostname: string, port: int, for_broadcast: bool): Connection {.importcpp: "#->open_UDP_connection(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Opens a socket for sending and/or receiving UDP packets.  If the port
## number is greater than zero, the UDP connection will be opened for
## listening on the indicated port; otherwise, it will be useful only for
## sending.
##
## This variant accepts both a hostname and port to listen on a particular
## interface; if the hostname is empty, all interfaces will be available,
## both IPv4 and IPv6.
##
## If for_broadcast is true, this UDP connection will be configured to send
## and/or receive messages on the broadcast address (255.255.255.255);
## otherwise, these messages may be automatically filtered by the OS.
##
## Use a ConnectionReader and ConnectionWriter to handle the actual
## communication.

proc openUDPConnection*(this: ConnectionManager, hostname: string, port: int): Connection {.importcpp: "#->open_UDP_connection(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Opens a socket for sending and/or receiving UDP packets.  If the port
## number is greater than zero, the UDP connection will be opened for
## listening on the indicated port; otherwise, it will be useful only for
## sending.
##
## This variant accepts both a hostname and port to listen on a particular
## interface; if the hostname is empty, all interfaces will be available,
## both IPv4 and IPv6.
##
## If for_broadcast is true, this UDP connection will be configured to send
## and/or receive messages on the broadcast address (255.255.255.255);
## otherwise, these messages may be automatically filtered by the OS.
##
## Use a ConnectionReader and ConnectionWriter to handle the actual
## communication.

proc openUDPConnection*(this: ConnectionManager, port: int): Connection {.importcpp: "#->open_UDP_connection(#)".} ## \
## Opens a socket for sending and/or receiving UDP packets.  If the port
## number is greater than zero, the UDP connection will be opened for
## listening on the indicated port; otherwise, it will be useful only for
## sending.
##
## Use a ConnectionReader and ConnectionWriter to handle the actual
## communication.

proc openUDPConnection*(this: ConnectionManager): Connection {.importcpp: "#->open_UDP_connection()".} ## \
## Opens a socket for sending and/or receiving UDP packets.  If the port
## number is greater than zero, the UDP connection will be opened for
## listening on the indicated port; otherwise, it will be useful only for
## sending.
##
## Use a ConnectionReader and ConnectionWriter to handle the actual
## communication.

proc openTCPServerRendezvous*(this: ConnectionManager, address: NetAddress, backlog: int): Connection {.importcpp: "#->open_TCP_server_rendezvous(#, #)".} ## \
## Creates a socket to be used as a rendezvous socket for a server to listen
## for TCP connections.  The socket returned by this call should only be added
## to a ConnectionListener (not to a generic ConnectionReader).
##
## This variant of this method accepts a NetAddress, which allows you to
## specify a specific interface to listen to.
##
## backlog is the maximum length of the queue of pending connections.

proc openTCPServerRendezvous*(this: ConnectionManager, hostname: string, port: int, backlog: int): Connection {.importcpp: "#->open_TCP_server_rendezvous(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Creates a socket to be used as a rendezvous socket for a server to listen
## for TCP connections.  The socket returned by this call should only be added
## to a ConnectionListener (not to a generic ConnectionReader).
##
## This variant of this method accepts a "hostname", which is usually just an
## IP address in dotted notation, and a port number.  It will listen on the
## interface indicated by the IP address.  If the IP address is empty string,
## it will listen on all interfaces.
##
## backlog is the maximum length of the queue of pending connections.

proc openTCPServerRendezvous*(this: ConnectionManager, port: int, backlog: int): Connection {.importcpp: "#->open_TCP_server_rendezvous(#, #)".} ## \
## Creates a socket to be used as a rendezvous socket for a server to listen
## for TCP connections.  The socket returned by this call should only be added
## to a ConnectionListener (not to a generic ConnectionReader).
##
## This variant of this method accepts a single port, and will listen to that
## port on all available interfaces, both IPv4 and IPv6.
##
## backlog is the maximum length of the queue of pending connections.

proc openTCPClientConnection*(this: ConnectionManager, address: NetAddress, timeout_ms: int): Connection {.importcpp: "#->open_TCP_client_connection(#, #)".} ## \
## Attempts to establish a TCP client connection to a server at the indicated
## address.  If the connection is not established within timeout_ms
## milliseconds, a null connection is returned.

proc openTCPClientConnection*(this: ConnectionManager, hostname: string, port: int, timeout_ms: int): Connection {.importcpp: "#->open_TCP_client_connection(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## This is a shorthand version of the function to directly establish
## communications to a named host and port.

proc closeConnection*(this: ConnectionManager, connection: Connection): bool {.importcpp: "#->close_connection(#)".} ## \
## Terminates a UDP or TCP socket previously opened.  This also removes it
## from any associated ConnectionReader or ConnectionListeners.
##
## The socket itself may not be immediately closed--it will not be closed
## until all outstanding pointers to it are cleared, including any pointers
## remaining in NetDatagrams recently received from the socket.
##
## The return value is true if the connection was marked to be closed, or
## false if close_connection() had already been called (or the connection did
## not belong to this ConnectionManager).  In neither case can you infer
## anything about whether the connection has \*actually\* been closed yet based
## on the return value.

proc waitForReaders*(this: ConnectionManager, timeout: float64): bool {.importcpp: "#->wait_for_readers(#)".} ## \
## Blocks the process for timeout number of seconds, or until any data is
## available on any of the non-threaded ConnectionReaders or
## ConnectionListeners, whichever comes first.  The return value is true if
## there is data available (but you have to iterate through all readers to
## find it), or false if the timeout occurred without any data.
##
## If the timeout value is negative, this will block forever or until data is
## available.
##
## This only works if all ConnectionReaders and ConnectionListeners are non-
## threaded.  If any threaded ConnectionReaders are part of the
## ConnectionManager, the timeout value is implicitly treated as 0.

proc getHostName*(_: typedesc[ConnectionManager]): string {.importcpp: "nimStringFromStdString(ConnectionManager::get_host_name())", header: "connectionManager.h".} ## \
## Returns the name of this particular machine on the network, if available,
## or the empty string if the hostname cannot be determined.

proc scanInterfaces*(this: ConnectionManager) {.importcpp: "#->scan_interfaces()".} ## \
## Repopulates the list reported by get_num_interface()/get_interface().  It
## is not necessary to call this explicitly, unless you want to re-determine
## the connected interfaces (for instance, if you suspect the hardware has
## recently changed).

proc getNumInterfaces*(this: ConnectionManager): clonglong {.importcpp: "#->get_num_interfaces()".} ## \
## This returns the number of usable network interfaces detected on this
## machine.  See scan_interfaces() to repopulate this list.

proc initConnectionWriter*(manager: ConnectionManager, num_threads: int, thread_name: string): ConnectionWriter {.importcpp: "ConnectionWriter(#, #, nimStringToStdString(#))", header: stringConversionCode.} ## \
## Creates a new ConnectionWriter with the indicated number of threads to
## handle output.
##
## If num_threads is 0, all datagrams will be sent immediately instead of
## queueing for later transmission by a thread.

proc initConnectionWriter*(manager: ConnectionManager, num_threads: int): ConnectionWriter {.importcpp: "ConnectionWriter(#, #)".} ## \
## Creates a new ConnectionWriter with the indicated number of threads to
## handle output.
##
## If num_threads is 0, all datagrams will be sent immediately instead of
## queueing for later transmission by a thread.

proc setMaxQueueSize*(this: ConnectionWriter, max_size: int) {.importcpp: "#.set_max_queue_size(#)".} ## \
## Limits the number of packets that may be pending on the outbound queue.
## This only has an effect when using threads; if num_threads is 0, then all
## packets are sent immediately.

proc getMaxQueueSize*(this: ConnectionWriter): int {.importcpp: "#.get_max_queue_size()".} ## \
## Returns the maximum size the queue is allowed to grow to.  See
## set_max_queue_size().

proc getCurrentQueueSize*(this: ConnectionWriter): int {.importcpp: "#.get_current_queue_size()".} ## \
## Returns the current number of things in the queue.

proc send*(this: ConnectionWriter, datagram: Datagram, connection: Connection, address: NetAddress, `block`: bool): bool {.importcpp: "#.send(#, #, #, #)".} ## \
## Enqueues a datagram for transmittal on the indicated socket.  This form of
## the function allows the specification of a destination host address, and so
## is appropriate for UDP packets.  Use the other send() method for sending
## TCP packets.
##
## Returns true if successful, false if there was an error.  In the normal,
## threaded case, this function only returns false if the send queue is
## filled; it's impossible to detect a transmission error at this point.
##
## If block is true, this will not return false if the send queue is filled;
## instead, it will wait until there is space available.

proc send*(this: ConnectionWriter, datagram: Datagram, connection: Connection, address: NetAddress): bool {.importcpp: "#.send(#, #, #)".} ## \
## Enqueues a datagram for transmittal on the indicated socket.  This form of
## the function allows the specification of a destination host address, and so
## is appropriate for UDP packets.  Use the other send() method for sending
## TCP packets.
##
## Returns true if successful, false if there was an error.  In the normal,
## threaded case, this function only returns false if the send queue is
## filled; it's impossible to detect a transmission error at this point.
##
## If block is true, this will not return false if the send queue is filled;
## instead, it will wait until there is space available.

proc send*(this: ConnectionWriter, datagram: Datagram, connection: Connection, `block`: bool): bool {.importcpp: "#.send(#, #, #)".} ## \
## Enqueues a datagram for transmittal on the indicated socket.  Since the
## host address is not specified with this form, this function should only be
## used for sending TCP packets.  Use the other send() method for sending UDP
## packets.
##
## Returns true if successful, false if there was an error.  In the normal,
## threaded case, this function only returns false if the send queue is
## filled; it's impossible to detect a transmission error at this point.
##
## If block is true, this will not return false if the send queue is filled;
## instead, it will wait until there is space available.

proc send*(this: ConnectionWriter, datagram: Datagram, connection: Connection): bool {.importcpp: "#.send(#, #)".} ## \
## Enqueues a datagram for transmittal on the indicated socket.  Since the
## host address is not specified with this form, this function should only be
## used for sending TCP packets.  Use the other send() method for sending UDP
## packets.
##
## Returns true if successful, false if there was an error.  In the normal,
## threaded case, this function only returns false if the send queue is
## filled; it's impossible to detect a transmission error at this point.
##
## If block is true, this will not return false if the send queue is filled;
## instead, it will wait until there is space available.

proc isValidForUdp*(this: ConnectionWriter, datagram: Datagram): bool {.importcpp: "#.is_valid_for_udp(#)".} ## \
## Returns true if the datagram is small enough to be sent over a UDP packet,
## false otherwise.

proc getManager*(this: ConnectionWriter): ConnectionManager {.importcpp: "#.get_manager()".} ## \
## Returns a pointer to the ConnectionManager object that serves this
## ConnectionWriter.

proc isImmediate*(this: ConnectionWriter): bool {.importcpp: "#.is_immediate()".} ## \
## Returns true if the writer is an immediate writer, i.e.  it has no threads.

proc getNumThreads*(this: ConnectionWriter): int {.importcpp: "#.get_num_threads()".} ## \
## Returns the number of threads the ConnectionWriter has been created with.

proc setRawMode*(this: ConnectionWriter, mode: bool) {.importcpp: "#.set_raw_mode(#)".} ## \
## Sets the ConnectionWriter into raw mode (or turns off raw mode).  In raw
## mode, datagrams are not sent along with their headers; the bytes in the
## datagram are simply sent down the pipe.
##
## Setting the ConnectionWriter to raw mode must be done with care.  This can
## only be done when the matching ConnectionReader is also set to raw mode, or
## when the ConnectionWriter is communicating to a process that does not
## expect datagrams.

proc getRawMode*(this: ConnectionWriter): bool {.importcpp: "#.get_raw_mode()".} ## \
## Returns the current setting of the raw mode flag.  See set_raw_mode().

proc setTcpHeaderSize*(this: ConnectionWriter, tcp_header_size: int) {.importcpp: "#.set_tcp_header_size(#)".} ## \
## Sets the header size of TCP packets.  At the present, legal values for this
## are 0, 2, or 4; this specifies the number of bytes to use encode the
## datagram length at the start of each TCP datagram.  Sender and receiver
## must independently agree on this.

proc getTcpHeaderSize*(this: ConnectionWriter): int {.importcpp: "#.get_tcp_header_size()".} ## \
## Returns the current setting of TCP header size.  See set_tcp_header_size().

proc shutdown*(this: ConnectionWriter) {.importcpp: "#.shutdown()".} ## \
## Stops all the threads and cleans them up.  This is called automatically by
## the destructor, but it may be called explicitly before destruction.

converter upcastToDatagramGenerator*(this: DatagramGeneratorNet): DatagramGenerator {.importcpp: "((DatagramGenerator *)(#))".}

converter upcastToConnectionReader*(this: DatagramGeneratorNet): ConnectionReader {.importcpp: "((ConnectionReader *)(#))".}

proc newDatagramGeneratorNet*(manager: ConnectionManager, num_threads: int): DatagramGeneratorNet {.importcpp: "new DatagramGeneratorNet(#, #)".} ## \
## Creates a new DatagramGeneratorNet with the indicated number of threads to
## handle requests.  Normally num_threads should be either 0 or 1 to guarantee
## that datagrams are generated in the same order in which they were received.

proc getDatagram*(this: DatagramGeneratorNet, data: Datagram): bool {.importcpp: "#->get_datagram(#)".} ## \
## Reads the next datagram from the stream.  Blocks until a datagram is
## available.  Returns true on success, false on stream closed or error.

proc isEof*(this: DatagramGeneratorNet): bool {.importcpp: "#->is_eof()".} ## \
## Returns true if the stream has been closed normally.  This test may only be
## made after a call to get_datagram() has failed.

proc isError*(this: DatagramGeneratorNet): bool {.importcpp: "#->is_error()".} ## \
## Returns true if the stream has an error condition.

converter upcastToDatagramSink*(this: DatagramSinkNet): DatagramSink {.importcpp: "#.upcast_to_DatagramSink()".}

converter upcastToConnectionWriter*(this: DatagramSinkNet): ConnectionWriter {.importcpp: "#.upcast_to_ConnectionWriter()".}

proc initDatagramSinkNet*(manager: ConnectionManager, num_threads: int): DatagramSinkNet {.importcpp: "DatagramSinkNet(#, #)".} ## \
## Creates a new DatagramSinkNet with the indicated number of threads to
## handle writing.  Normally num_threads should be either 0 or 1 to guarantee
## that datagrams are delivered in the same order in which they were sent.

proc setTarget*(this: DatagramSinkNet, connection: Connection) {.importcpp: "#.set_target(#)".} ## \
## Specifies the Connection that will receive all future Datagrams sent.

proc getTarget*(this: DatagramSinkNet): Connection {.importcpp: "#.get_target()".} ## \
## Returns the current target Connection, or NULL if the target has not yet
## been set.  See set_target().

proc putDatagram*(this: DatagramSinkNet, data: Datagram): bool {.importcpp: "#.put_datagram(#)".} ## \
## Sends the given datagram to the target.  Returns true on success, false if
## there is an error.  Blocks if necessary until the target is ready.

proc isError*(this: DatagramSinkNet): bool {.importcpp: "#.is_error()".} ## \
## Returns true if there is an error on the target connection, or if the
## target has never been set.

proc flush*(this: DatagramSinkNet) {.importcpp: "#.flush()".} ## \
## Ensures that all datagrams previously written will be visible on the
## stream.

converter upcastToConnectionListener*(this: QueuedConnectionListener): ConnectionListener {.importcpp: "((ConnectionListener *)(#))".}

proc newQueuedConnectionListener*(manager: ConnectionManager, num_threads: int): QueuedConnectionListener {.importcpp: "new QueuedConnectionListener(#, #)".}

proc newConnectionAvailable*(this: QueuedConnectionListener): bool {.importcpp: "#->new_connection_available()".} ## \
## Returns true if a new connection was recently established; the connection
## information may then be retrieved via get_new_connection().

converter upcastToConnectionManager*(this: QueuedConnectionManager): ConnectionManager {.importcpp: "((ConnectionManager *)(#))".}

proc newQueuedConnectionManager*(): QueuedConnectionManager {.importcpp: "new QueuedConnectionManager()".}

proc resetConnectionAvailable*(this: QueuedConnectionManager): bool {.importcpp: "#->reset_connection_available()".} ## \
## Returns true if one of the readers/writers/listeners reported a connection
## reset recently.  If so, the particular connection that has been reset can
## be extracted via get_reset_connection().
##
## Only connections which were externally reset are certain to appear in this
## list.  Those which were explicitly closed via a call to close_connection()
## may or may not be reported.  Furthermore, it is the responsibility of the
## caller to subsequently call close_connection() with any connection reported
## reset by this call.  (There is no harm in calling close_connection() more
## than once on a given socket.)

converter upcastToConnectionReader*(this: QueuedConnectionReader): ConnectionReader {.importcpp: "((ConnectionReader *)(#))".}

proc newQueuedConnectionReader*(manager: ConnectionManager, num_threads: int): QueuedConnectionReader {.importcpp: "new QueuedConnectionReader(#, #)".}

proc dataAvailable*(this: QueuedConnectionReader): bool {.importcpp: "#->data_available()".} ## \
## Returns true if a datagram is available on the queue; call get_data() to
## extract the datagram.

proc getData*(this: QueuedConnectionReader, result: Datagram): bool {.importcpp: "#->get_data(#)".} ## \
## This flavor of QueuedConnectionReader::get_data(), works like the other,
## except that it only fills a Datagram object, not a NetDatagram object.
## This means that the Datagram cannot be queried for its source Connection
## and/or NetAddress, but it is useful in all other respects.

proc getData*(this: QueuedConnectionReader, result: NetDatagram): bool {.importcpp: "#->get_data(#)".} ## \
## If a previous call to data_available() returned true, this function will
## return the datagram that has become available.
##
## The return value is true if a datagram was successfully returned, or false
## if there was, in fact, no datagram available.  (This may happen if there
## are multiple threads accessing the QueuedConnectionReader).

proc newRecentConnectionReader*(manager: ConnectionManager): RecentConnectionReader {.importcpp: "new RecentConnectionReader(#)".}

proc dataAvailable*(this: RecentConnectionReader): bool {.importcpp: "#->data_available()".} ## \
## Returns true if a datagram is available on the queue; call get_data() to
## extract the datagram.

proc getData*(this: RecentConnectionReader, result: Datagram): bool {.importcpp: "#->get_data(#)".} ## \
## This flavor of RecentConnectionReader::get_data(), works like the other,
## except that it only fills a Datagram object, not a NetDatagram object.
## This means that the Datagram cannot be queried for its source Connection
## and/or NetAddress, but it is useful in all other respects.

proc getData*(this: RecentConnectionReader, result: NetDatagram): bool {.importcpp: "#->get_data(#)".} ## \
## If a previous call to data_available() returned true, this function will
## return the datagram that has become available.
##
## The return value is true if a datagram was successfully returned, or false
## if there was, in fact, no datagram available.  (This may happen if there
## are multiple threads accessing the RecentConnectionReader).

proc newSocketAddress*(inaddr: Socket_Address): Socket_Address {.importcpp: "new Socket_Address(#)".}

proc newSocketAddress*(port: int): Socket_Address {.importcpp: "new Socket_Address(#)".} ## \
## Constructor that lets us set a port value

proc newSocketAddress*(): Socket_Address {.importcpp: "new Socket_Address()".} ## \
## Constructor that lets us set a port value

proc setAnyIP*(this: Socket_Address, port: int): bool {.importcpp: "#->set_any_IP(#)".} ## \
## Set to any address and a specified port

proc setAnyIPv6*(this: Socket_Address, port: int): bool {.importcpp: "#->set_any_IPv6(#)".} ## \
## Set to any IPv6 address and a specified port.

proc setPort*(this: Socket_Address, port: int): bool {.importcpp: "#->set_port(#)".} ## \
## Set to a specified port

proc setBroadcast*(this: Socket_Address, port: int): bool {.importcpp: "#->set_broadcast(#)".} ## \
## Set to the broadcast address and a specified port

proc setHost*(this: Socket_Address, hostname: string): bool {.importcpp: "#->set_host(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Initializes the address from a string specifying both the address and port,
## separated by a colon.  An IPv6 address must be enclosed in brackets.

proc setHost*(this: Socket_Address, hostname: string, port: int): bool {.importcpp: "#->set_host(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## This function will take a port and string-based TCP address and initialize
## the address with this information.  Returns true on success; on failure, it
## returns false and the address may be undefined.

proc setHost*(this: Socket_Address, ip4addr: int, port: int): bool {.importcpp: "#->set_host(#, #)".}

proc clear*(this: Socket_Address) {.importcpp: "#->clear()".} ## \
## Set the internal values to a suitable known value

proc getFamily*(this: Socket_Address): int {.importcpp: "#->get_family()".} ## \
## Returns AF_INET if this is an IPv4 address, or AF_INET6 if this is an IPv6
## address.

proc getPort*(this: Socket_Address): int {.importcpp: "#->get_port()".} ## \
## Get the port portion as an integer

proc getIp*(this: Socket_Address): string {.importcpp: "nimStringFromStdString(#->get_ip())", header: stringConversionCode.} ## \
## Return the IP address portion in dot notation string.

proc getIpPort*(this: Socket_Address): string {.importcpp: "nimStringFromStdString(#->get_ip_port())", header: stringConversionCode.} ## \
## Return the ip address/port in dot notation string.  If this is an IPv6
## address, it will be enclosed in square brackets.

proc GetIPAddressRaw*(this: Socket_Address): int {.importcpp: "#->GetIPAddressRaw()".} ## \
## Returns a raw 32-bit unsigned integer representing the IPv4 address.
## @deprecated  Does not work with IPv6 addresses.

proc `==`*(this: Socket_Address, `in`: Socket_Address): bool {.importcpp: "#->operator ==(#)".}

proc `!=`*(this: Socket_Address, `in`: Socket_Address): bool {.importcpp: "#->operator !=(#)".}

proc `<`*(this: Socket_Address, `in`: Socket_Address): bool {.importcpp: "#->operator <(#)".}

proc isAny*(this: Socket_Address): bool {.importcpp: "#->is_any()".} ## \
## True if the address is zero.

proc isMcastRange*(this: Socket_Address): bool {.importcpp: "#->is_mcast_range()".} ## \
## True if the address is in the multicast range.

proc initSocketIP*(): Socket_IP {.importcpp: "Socket_IP()".} ## \
## Def Constructor

converter initSocketIP*(`in`: int): Socket_IP {.importcpp: "Socket_IP(#)".} ## \
## Assigns an existing socket to this class

proc Close*(this: Socket_IP) {.importcpp: "#.Close()".} ## \
## Closes a socket if it is open (allocated).

proc GetLastError*(_: typedesc[Socket_IP]): int {.importcpp: "Socket_IP::GetLastError()", header: "socket_ip.h".} ## \
## Gets the last errcode from a socket operation.

proc SetNonBlocking*(this: Socket_IP): int {.importcpp: "#.SetNonBlocking()".} ## \
## this function will throw a socket into non-blocking mode

proc SetBlocking*(this: Socket_IP): int {.importcpp: "#.SetBlocking()".} ## \
## Set the socket to block on subsequent calls to socket functions that
## address this socket

proc SetReuseAddress*(this: Socket_IP, flag: bool): bool {.importcpp: "#.SetReuseAddress(#)".} ## \
## Informs a socket to reuse IP address as needed

proc SetReuseAddress*(this: Socket_IP): bool {.importcpp: "#.SetReuseAddress()".} ## \
## Informs a socket to reuse IP address as needed

proc SetV6Only*(this: Socket_IP, flag: bool): bool {.importcpp: "#.SetV6Only(#)".} ## \
## Sets a flag indicating whether this IPv6 socket should operate in
## dual-stack mode or not.

proc Active*(this: Socket_IP): bool {.importcpp: "#.Active()".} ## \
## Ask if the socket is open (allocated)

proc SetRecvBufferSize*(this: Socket_IP, size: int): int {.importcpp: "#.SetRecvBufferSize(#)".} ## \
## Ok it sets the recv buffer size for both tcp and UDP

proc SetSocket*(this: Socket_IP, ins: int) {.importcpp: "#.SetSocket(#)".} ## \
## Assigns an existing socket to this class

proc GetSocket*(this: Socket_IP): int {.importcpp: "#.GetSocket()".} ## \
## Gets the base socket type

proc GetPeerName*(this: Socket_IP): Socket_Address {.importcpp: "#.GetPeerName()".} ## \
## Wrapper on berkly getpeername...

proc InitNetworkDriver*(_: typedesc[Socket_IP]): int {.importcpp: "Socket_IP::InitNetworkDriver()", header: "socket_ip.h".}

converter getClassType*(_: typedesc[Socket_IP]): TypeHandle {.importcpp: "Socket_IP::get_class_type()", header: "socket_ip.h".}

proc initSocketTCP*(): Socket_TCP {.importcpp: "Socket_TCP()".}

converter initSocketTCP*(param0: int): Socket_TCP {.importcpp: "Socket_TCP(#)".}

proc SetNoDelay*(this: Socket_TCP, flag: bool): int {.importcpp: "#.SetNoDelay(#)".} ## \
## Disable Nagle algorithm.  Don't delay send to coalesce packets

proc SetNoDelay*(this: Socket_TCP): int {.importcpp: "#.SetNoDelay()".} ## \
## Disable Nagle algorithm.  Don't delay send to coalesce packets

proc SetLinger*(this: Socket_TCP, interval_seconds: int): int {.importcpp: "#.SetLinger(#)".} ## \
## will control the behavior of SO_LINGER for a TCP socket

proc SetLinger*(this: Socket_TCP): int {.importcpp: "#.SetLinger()".} ## \
## will control the behavior of SO_LINGER for a TCP socket

proc DontLinger*(this: Socket_TCP): int {.importcpp: "#.DontLinger()".} ## \
## Turn off the linger flag.  The socket will quickly release buffered items
## and free up OS resources.  You may lose a stream if you use this flag and
## do not negotiate the close at the application layer.

proc SetSendBufferSize*(this: Socket_TCP, insize: int): int {.importcpp: "#.SetSendBufferSize(#)".} ## \
## Just like it sounds.  Sets a buffered socket recv buffer size.  This
## function does not refuse ranges outside hard-coded OS limits

proc ActiveOpen*(this: Socket_TCP, theaddress: Socket_Address, setdelay: bool): bool {.importcpp: "#.ActiveOpen(#, #)".} ## \
## This function will try and set the socket up for active open to a specified
## address and port provided by the input parameter

proc ActiveOpenNonBlocking*(this: Socket_TCP, theaddress: Socket_Address): bool {.importcpp: "#.ActiveOpenNonBlocking(#)".} ## \
## This function will try and set the socket up for active open to a specified
## address and port provided by the input parameter (non-blocking version)

proc ErrorIsWouldBlocking*(this: Socket_TCP, err: int): bool {.importcpp: "#.ErrorIs_WouldBlocking(#)".}

proc ShutdownSend*(this: Socket_TCP): bool {.importcpp: "#.ShutdownSend()".}

proc SendData*(this: Socket_TCP, str: string): int {.importcpp: "#.SendData(nimStringToStdString(#))", header: stringConversionCode.}

proc RecvData*(this: Socket_TCP, max_len: int): string {.importcpp: "nimStringFromStdString(#.RecvData(#))", header: stringConversionCode.} ## \
## Read the data from the connection - if error 0 if socket closed for read or
## length is 0 + bytes read (May be smaller than requested)

converter getClassType*(_: typedesc[Socket_TCP]): TypeHandle {.importcpp: "Socket_TCP::get_class_type()", header: "socket_tcp.h".}

proc initSocketTCPListen*(): Socket_TCP_Listen {.importcpp: "Socket_TCP_Listen()".}

proc OpenForListen*(this: Socket_TCP_Listen, address: Socket_Address, backlog_size: int): bool {.importcpp: "#.OpenForListen(#, #)".} ## \
## This function will initialize a listening Socket

proc OpenForListen*(this: Socket_TCP_Listen, address: Socket_Address): bool {.importcpp: "#.OpenForListen(#)".} ## \
## This function will initialize a listening Socket

proc OpenForListen*(this: Socket_TCP_Listen, port: int, backlog_size: int): bool {.importcpp: "#.OpenForListen(#, #)".} ## \
## This function will initialize a listening Socket

proc OpenForListen*(this: Socket_TCP_Listen, port: int): bool {.importcpp: "#.OpenForListen(#)".} ## \
## This function will initialize a listening Socket

proc GetIncomingConnection*(this: Socket_TCP_Listen, newsession: Socket_TCP, address: Socket_Address): bool {.importcpp: "#.GetIncomingConnection(#, #)".}

converter getClassType*(_: typedesc[Socket_TCP_Listen]): TypeHandle {.importcpp: "Socket_TCP_Listen::get_class_type()", header: "socket_tcp_listen.h".}

proc initSocketUDPIncoming*(): Socket_UDP_Incoming {.importcpp: "Socket_UDP_Incoming()".}

proc OpenForInput*(this: Socket_UDP_Incoming, address: Socket_Address): bool {.importcpp: "#.OpenForInput(#)".} ## \
## Starts a UDP socket listening on a port

proc OpenForInput*(this: Socket_UDP_Incoming, port: int): bool {.importcpp: "#.OpenForInput(#)".} ## \
## Starts a UDP socket listening on a port

proc OpenForInputMCast*(this: Socket_UDP_Incoming, address: Socket_Address): bool {.importcpp: "#.OpenForInputMCast(#)".} ## \
## Starts a UDP socket listening on a port

proc SendTo*(this: Socket_UDP_Incoming, data: string, len: int, address: Socket_Address): bool {.importcpp: "#.SendTo(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## Send data to specified address

proc InitNoAddress*(this: Socket_UDP_Incoming): bool {.importcpp: "#.InitNoAddress()".} ## \
## Set this socket to work without a bound external address.

proc SetToBroadCast*(this: Socket_UDP_Incoming): bool {.importcpp: "#.SetToBroadCast()".} ## \
## Flips the OS bits that allow for brodcast packets to come in on this port.

converter getClassType*(_: typedesc[Socket_UDP_Incoming]): TypeHandle {.importcpp: "Socket_UDP_Incoming::get_class_type()", header: "socket_udp_incoming.h".}

proc initSocketUDPOutgoing*(): Socket_UDP_Outgoing {.importcpp: "Socket_UDP_Outgoing()".}

proc InitToAddress*(this: Socket_UDP_Outgoing, address: Socket_Address): bool {.importcpp: "#.InitToAddress(#)".} ## \
## Connects the Socket to a specified address

proc Send*(this: Socket_UDP_Outgoing, data: string): bool {.importcpp: "#.Send(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Send data to connected address

proc InitNoAddress*(this: Socket_UDP_Outgoing): bool {.importcpp: "#.InitNoAddress()".} ## \
## use this interface for a none tagreted UDP connection

proc SendTo*(this: Socket_UDP_Outgoing, data: string, address: Socket_Address): bool {.importcpp: "#.SendTo(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Send data to specified address

proc SetToBroadCast*(this: Socket_UDP_Outgoing): bool {.importcpp: "#.SetToBroadCast()".} ## \
## Ask the OS to let us receive broadcast packets on this port.

converter getClassType*(_: typedesc[Socket_UDP_Outgoing]): TypeHandle {.importcpp: "Socket_UDP_Outgoing::get_class_type()", header: "socket_udp_outgoing.h".}

proc initSocketFdset*(): Socket_fdset {.importcpp: "Socket_fdset()".} ## \
## The constructor

proc initSocketFdset*(param0: Socket_fdset): Socket_fdset {.importcpp: "Socket_fdset(#)".}

proc setForSocket*(this: Socket_fdset, incon: Socket_IP) {.importcpp: "#.setForSocket(#)".}

proc IsSetFor*(this: Socket_fdset, incon: Socket_IP): bool {.importcpp: "#.IsSetFor(#)".} ## \
## check to see if a socket object has been marked for reading

proc WaitForRead*(this: Socket_fdset, zeroFds: bool, sleep_time: int): int {.importcpp: "#.WaitForRead(#, #)".}

proc WaitForRead*(this: Socket_fdset, zeroFds: bool): int {.importcpp: "#.WaitForRead(#)".}

proc WaitForWrite*(this: Socket_fdset, zeroFds: bool, sleep_time: int): int {.importcpp: "#.WaitForWrite(#, #)".} ## \
## This is the function that will wait till one of the sockets is ready for
## writing

proc WaitForWrite*(this: Socket_fdset, zeroFds: bool): int {.importcpp: "#.WaitForWrite(#)".} ## \
## This is the function that will wait till one of the sockets is ready for
## writing

proc WaitForError*(this: Socket_fdset, zeroFds: bool, sleep_time: int): int {.importcpp: "#.WaitForError(#, #)".} ## \
## This is the function that will wait till one of the sockets is in error
## state

proc WaitForError*(this: Socket_fdset, zeroFds: bool): int {.importcpp: "#.WaitForError(#)".} ## \
## This is the function that will wait till one of the sockets is in error
## state

proc clear*(this: Socket_fdset) {.importcpp: "#.clear()".} ## \
## Marks the content as empty

proc GetMessage*(this: Buffered_DatagramConnection, val: Datagram): bool {.importcpp: "#.GetMessage(#)".} ## \
## Reads a message.  Returns false on failure.

proc DoConnect*(this: Buffered_DatagramConnection): bool {.importcpp: "#.DoConnect()".} ## \
## all the real state magic is in here

proc IsConnected*(this: Buffered_DatagramConnection): bool {.importcpp: "#.IsConnected()".} ## \
## all the real state magic is in here

proc initBufferedDatagramConnection*(rbufsize: int, wbufsize: int, write_flush_point: int): Buffered_DatagramConnection {.importcpp: "Buffered_DatagramConnection(#, #, #)".}

proc SendMessage*(this: Buffered_DatagramConnection, msg: Datagram): bool {.importcpp: "#.SendMessage(#)".} ## \
## the reason thsi all exists

proc Flush*(this: Buffered_DatagramConnection): bool {.importcpp: "#.Flush()".} ## \
## Flush all writes.

proc Reset*(this: Buffered_DatagramConnection) {.importcpp: "#.Reset()".} ## \
## Reset

proc WaitForNetworkReadEvent*(this: Buffered_DatagramConnection, MaxTime: float32) {.importcpp: "#.WaitForNetworkReadEvent(#)".}

proc AddressQueueSize*(this: Buffered_DatagramConnection): clonglong {.importcpp: "#.AddressQueueSize()".} ## \
## address queue stuff

proc AddAddress*(this: Buffered_DatagramConnection, inadr: Socket_Address) {.importcpp: "#.AddAddress(#)".} ## \
## must be called to set value to the server

proc ClearAddresses*(this: Buffered_DatagramConnection) {.importcpp: "#.ClearAddresses()".}

converter getClassType*(_: typedesc[Buffered_DatagramConnection]): TypeHandle {.importcpp: "Buffered_DatagramConnection::get_class_type()", header: "buffered_datagramconnection.h".}

proc initSocketUDP*(): Socket_UDP {.importcpp: "Socket_UDP()".}

proc InitToAddress*(this: Socket_UDP, address: Socket_Address): bool {.importcpp: "#.InitToAddress(#)".} ## \
## Connects the socket to a Specified address

proc Send*(this: Socket_UDP, data: string): bool {.importcpp: "#.Send(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Send data to connected address

proc SendTo*(this: Socket_UDP, data: string, address: Socket_Address): bool {.importcpp: "#.SendTo(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Send data to specified address

proc SetToBroadCast*(this: Socket_UDP): bool {.importcpp: "#.SetToBroadCast()".} ## \
## Ask the OS to let us receive broadcast packets on this port.

converter getClassType*(_: typedesc[Socket_UDP]): TypeHandle {.importcpp: "Socket_UDP::get_class_type()", header: "socket_udp.h".}

proc SetCondenseWhiteSpace*(_: typedesc[TiXmlBase], condense: bool) {.importcpp: "#TiXmlBase::SetCondenseWhiteSpace(#)", header: "tinyxml.h".} ## \
## The world does not agree on whether white space should be kept or
## not. In order to make everyone happy, these global, static functions
## are provided to set whether or not TinyXml will condense all white space
## into a single space or not. The default is to condense. Note changing this
## value is not thread safe.

proc IsWhiteSpaceCondensed*(_: typedesc[TiXmlBase]): bool {.importcpp: "TiXmlBase::IsWhiteSpaceCondensed()", header: "tinyxml.h".} ## \
## Return the current white space setting.

proc Row*(this: TiXmlBase): int {.importcpp: "#->Row()".} ## \
## Return the position, in the original source file, of this node or attribute.
## The row and column are 1-based. (That is the first row and first column is
## 1,1). If the returns values are 0 or less, then the parser does not have
## a row and column value.
##
## Generally, the row and column value will be set when the TiXmlDocument::Load(),
## TiXmlDocument::LoadFile(), or any TiXmlNode::Parse() is called. It will NOT be set
## when the DOM was created from operator>>.
##
## The values reflect the initial load. Once the DOM is modified programmatically
## (by adding or changing nodes and attributes) the new values will NOT update to
## reflect changes in the document.
##
## There is a minor performance cost to computing the row and column. Computation
## can be disabled if TiXmlDocument::SetTabSize() is called with 0 as the value.
##
## @sa TiXmlDocument::SetTabSize()

proc Column*(this: TiXmlBase): int {.importcpp: "#->Column()".} ## \
## See Row()

proc GetUserData*(this: TiXmlBase) {.importcpp: "#->GetUserData()".} ## \
## Get a pointer to arbitrary user data.

proc Value*(this: TiXmlNode): string {.importcpp: "nimStringFromStdString(#->Value())", header: stringConversionCode.} ## \
## The meaning of 'value' changes for the specific type of
## TiXmlNode.
## @verbatim
## Document:   filename of the xml file
## Element:    name of the element
## Comment:    the comment text
## Unknown:    the tag contents
## Text:       the text string
## @endverbatim
##
## The subclasses will wrap this function.

proc ValueStr*(this: TiXmlNode): string {.importcpp: "nimStringFromStdString(#->ValueStr())", header: stringConversionCode.} ## \
## Return Value() as a std::string. If you only use STL,
## this is more efficient than calling Value().
## Only available in STL mode.

proc ValueTStr*(this: TiXmlNode): string {.importcpp: "nimStringFromStdString(#->ValueTStr())", header: stringConversionCode.}

proc Clear*(this: TiXmlNode) {.importcpp: "#->Clear()".} ## \
## Delete all the children of this node. Does not affect 'this'.

proc Parent*(this: TiXmlNode): TiXmlNode {.importcpp: "#->Parent()".} ## \
## One step up the DOM.

proc FirstChild*(this: TiXmlNode): TiXmlNode {.importcpp: "#->FirstChild()".} ## \
## The first child of this node. Will be null if there are no children.

proc LastChild*(this: TiXmlNode): TiXmlNode {.importcpp: "#->LastChild()".} ## \
## The last child of this node. Will be null if there are no children.

proc IterateChildren*(this: TiXmlNode, previous: TiXmlNode): TiXmlNode {.importcpp: "#->IterateChildren(#)".}

proc InsertEndChild*(this: TiXmlNode, addThis: TiXmlNode): TiXmlNode {.importcpp: "#->InsertEndChild(#)".} ## \
## Add a new node related to this. Adds a child past the LastChild.
## Returns a pointer to the new object or NULL if an error occured.

proc InsertBeforeChild*(this: TiXmlNode, beforeThis: TiXmlNode, addThis: TiXmlNode): TiXmlNode {.importcpp: "#->InsertBeforeChild(#, #)".} ## \
## Add a new node related to this. Adds a child before the specified child.
## Returns a pointer to the new object or NULL if an error occured.

proc InsertAfterChild*(this: TiXmlNode, afterThis: TiXmlNode, addThis: TiXmlNode): TiXmlNode {.importcpp: "#->InsertAfterChild(#, #)".} ## \
## Add a new node related to this. Adds a child after the specified child.
## Returns a pointer to the new object or NULL if an error occured.

proc ReplaceChild*(this: TiXmlNode, replaceThis: TiXmlNode, withThis: TiXmlNode): TiXmlNode {.importcpp: "#->ReplaceChild(#, #)".} ## \
## Replace a child of this node.
## Returns a pointer to the new object or NULL if an error occured.

proc RemoveChild*(this: TiXmlNode, removeThis: TiXmlNode): bool {.importcpp: "#->RemoveChild(#)".} ## \
## Delete a child of this node.

proc PreviousSibling*(this: TiXmlNode): TiXmlNode {.importcpp: "#->PreviousSibling()".}

proc NextSibling*(this: TiXmlNode): TiXmlNode {.importcpp: "#->NextSibling()".}

proc NextSiblingElement*(this: TiXmlNode): TiXmlElement {.importcpp: "#->NextSiblingElement()".}

proc FirstChildElement*(this: TiXmlNode): TiXmlElement {.importcpp: "#->FirstChildElement()".}

proc Type*(this: TiXmlNode): int {.importcpp: "#->Type()".} ## \
## Query the type (as an enumerated value, above) of this node.
## The possible types are: DOCUMENT, ELEMENT, COMMENT,
## UNKNOWN, TEXT, and DECLARATION.

proc GetDocument*(this: TiXmlNode): TiXmlDocument {.importcpp: "#->GetDocument()".}

proc NoChildren*(this: TiXmlNode): bool {.importcpp: "#->NoChildren()".} ## \
## Returns true if this node has no children.

proc ToDocument*(this: TiXmlNode): TiXmlDocument {.importcpp: "#->ToDocument()".} ## \
## Cast to a more defined type. Will return null if not of the requested type.

proc ToElement*(this: TiXmlNode): TiXmlElement {.importcpp: "#->ToElement()".} ## \
## Cast to a more defined type. Will return null if not of the requested type.

proc ToComment*(this: TiXmlNode): TiXmlComment {.importcpp: "#->ToComment()".} ## \
## Cast to a more defined type. Will return null if not of the requested type.

proc ToUnknown*(this: TiXmlNode): TiXmlUnknown {.importcpp: "#->ToUnknown()".} ## \
## Cast to a more defined type. Will return null if not of the requested type.

proc ToText*(this: TiXmlNode): TiXmlText {.importcpp: "#->ToText()".} ## \
## Cast to a more defined type. Will return null if not of the requested type.

proc ToDeclaration*(this: TiXmlNode): TiXmlDeclaration {.importcpp: "#->ToDeclaration()".} ## \
## Cast to a more defined type. Will return null if not of the requested type.

proc Clone*(this: TiXmlNode): TiXmlNode {.importcpp: "#->Clone()".} ## \
## Create an exact duplicate of this node and return it. The memory must be deleted
## by the caller.

proc Accept*(this: TiXmlNode, visitor: TiXmlVisitor): bool {.importcpp: "#->Accept(#)".} ## \
## Accept a hierchical visit the nodes in the TinyXML DOM. Every node in the
## XML tree will be conditionally visited and the host will be called back
## via the TiXmlVisitor interface.
##
## This is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse
## the XML for the callbacks, so the performance of TinyXML is unchanged by using this
## interface versus any other.)
##
## The interface has been based on ideas from:
##
## - http://www.saxproject.org/
## - http://c2.com/cgi/wiki?HierarchicalVisitorPattern
##
## Which are both good references for "visiting".
##
## An example of using Accept():
## @verbatim
## TiXmlPrinter printer;
## tinyxmlDoc.Accept( &printer );
## const char\* xmlcstr = printer.CStr();
## @endverbatim

proc newTiXmlDeclaration*(): TiXmlDeclaration {.importcpp: "new TiXmlDeclaration()".} ## \
## Construct an empty declaration.

proc newTiXmlDeclaration*(copy: TiXmlDeclaration): TiXmlDeclaration {.importcpp: "new TiXmlDeclaration(#)".}

proc Version*(this: TiXmlDeclaration): string {.importcpp: "nimStringFromStdString(#->Version())", header: stringConversionCode.} ## \
## Version. Will return an empty string if none was found.

proc Encoding*(this: TiXmlDeclaration): string {.importcpp: "nimStringFromStdString(#->Encoding())", header: stringConversionCode.} ## \
## Encoding. Will return an empty string if none was found.

proc Standalone*(this: TiXmlDeclaration): string {.importcpp: "nimStringFromStdString(#->Standalone())", header: stringConversionCode.} ## \
## Is this a standalone document?

proc newTiXmlDocument*(): TiXmlDocument {.importcpp: "new TiXmlDocument()".} ## \
## Create an empty document, that has no name.

proc newTiXmlDocument*(copy: TiXmlDocument): TiXmlDocument {.importcpp: "new TiXmlDocument(#)".}

proc newTiXmlDocument*(documentName: string): TiXmlDocument {.importcpp: "new TiXmlDocument(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Create a document with a name. The name of the document is also the filename of the xml.

proc LoadFile*(this: TiXmlDocument, encoding: TiXmlEncoding): bool {.importcpp: "#->LoadFile(#)".} ## \
## Load a file using the current document value.
## Returns true if successful. Will delete any existing
## document data before loading.

proc LoadFile*(this: TiXmlDocument): bool {.importcpp: "#->LoadFile()".} ## \
## Load a file using the current document value.
## Returns true if successful. Will delete any existing
## document data before loading.

proc LoadFile*(this: TiXmlDocument, filename: string, encoding: TiXmlEncoding): bool {.importcpp: "#->LoadFile(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Load a file using the given filename. Returns true if successful.

proc LoadFile*(this: TiXmlDocument, filename: string): bool {.importcpp: "#->LoadFile(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Load a file using the given filename. Returns true if successful.

proc SaveFile*(this: TiXmlDocument): bool {.importcpp: "#->SaveFile()".} ## \
## Save a file using the current document value. Returns true if successful.

proc SaveFile*(this: TiXmlDocument, filename: string): bool {.importcpp: "#->SaveFile(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Save a file using the given filename. Returns true if successful.

proc RootElement*(this: TiXmlDocument): TiXmlElement {.importcpp: "#->RootElement()".}

proc Error*(this: TiXmlDocument): bool {.importcpp: "#->Error()".} ## \
## If an error occurs, Error will be set to true. Also,
## - The ErrorId() will contain the integer identifier of the error (not generally useful)
## - The ErrorDesc() method will return the name of the error. (very useful)
## - The ErrorRow() and ErrorCol() will return the location of the error (if known)

proc ErrorDesc*(this: TiXmlDocument): string {.importcpp: "nimStringFromStdString(#->ErrorDesc())", header: stringConversionCode.} ## \
## Contains a textual (english) description of the error if one occurs.

proc ErrorId*(this: TiXmlDocument): int {.importcpp: "#->ErrorId()".} ## \
## Generally, you probably want the error string ( ErrorDesc() ). But if you
## prefer the ErrorId, this function will fetch it.

proc ErrorRow*(this: TiXmlDocument): int {.importcpp: "#->ErrorRow()".} ## \
## Returns the location (if known) of the error. The first column is column 1,
## and the first row is row 1. A value of 0 means the row and column wasn't applicable
## (memory errors, for example, have no row/column) or the parser lost the error. (An
## error in the error reporting, in that case.)
##
## @sa SetTabSize, Row, Column

proc ErrorCol*(this: TiXmlDocument): int {.importcpp: "#->ErrorCol()".} ## \
## The column where the error occured. See ErrorRow()

proc TabSize*(this: TiXmlDocument): int {.importcpp: "#->TabSize()".}

proc ClearError*(this: TiXmlDocument) {.importcpp: "#->ClearError()".} ## \
## If you have handled the error, it can be reset with this call. The error
## state is automatically cleared if you Parse a new XML block.

proc Print*(this: TiXmlDocument) {.importcpp: "#->Print()".} ## \
## Write the document to standard out using formatted printing ("pretty print").

proc newTiXmlElement*(param0: TiXmlElement): TiXmlElement {.importcpp: "new TiXmlElement(#)".}

proc newTiXmlElement*(in_value: string): TiXmlElement {.importcpp: "new TiXmlElement(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Construct an element.

proc Attribute*(this: TiXmlElement, name: string): string {.importcpp: "nimStringFromStdString(#->Attribute(nimStringToStdString(#)))", header: stringConversionCode.} ## \
## Given an attribute name, Attribute() returns the value
## for the attribute of that name, or null if none exists.

proc SetAttribute*(this: TiXmlElement, name: string, value: int) {.importcpp: "#->SetAttribute(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Sets an attribute of name to a given value. The attribute
## will be created if it does not exist, or changed if it does.

proc SetDoubleAttribute*(this: TiXmlElement, name: string, value: float64) {.importcpp: "#->SetDoubleAttribute(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Sets an attribute of name to a given value. The attribute
## will be created if it does not exist, or changed if it does.

proc RemoveAttribute*(this: TiXmlElement, name: string) {.importcpp: "#->RemoveAttribute(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Deletes an attribute with the given name.

proc FirstAttribute*(this: TiXmlElement): TiXmlAttribute {.importcpp: "#->FirstAttribute()".} ## \
## Access the first attribute in this element.

proc LastAttribute*(this: TiXmlElement): TiXmlAttribute {.importcpp: "#->LastAttribute()".} ## \
## Access the last attribute in this element.

proc GetText*(this: TiXmlElement): string {.importcpp: "nimStringFromStdString(#->GetText())", header: stringConversionCode.} ## \
## Convenience function for easy access to the text inside an element. Although easy
## and concise, GetText() is limited compared to getting the TiXmlText child
## and accessing it directly.
##
## If the first child of 'this' is a TiXmlText, the GetText()
## returns the character string of the Text node, else null is returned.
##
## This is a convenient method for getting the text of simple contained text:
## @verbatim
## <foo>This is text</foo>
## const char\* str = fooElement->GetText();
## @endverbatim
##
## 'str' will be a pointer to "This is text".
##
## Note that this function can be misleading. If the element foo was created from
## this XML:
## @verbatim
## <foo><b>This is text</b></foo>
## @endverbatim
##
## then the value of str would be null. The first child node isn't a text node, it is
## another element. From this XML:
## @verbatim
## <foo>This is <b>text</b></foo>
## @endverbatim
## GetText() will return "This is ".
##
## WARNING: GetText() accesses a child node - don't become confused with the
## similarly named TiXmlHandle::Text() and TiXmlNode::ToText() which are
## safe type casts on the referenced node.

proc readXmlStream*(`in`: istream): TiXmlDocument {.importcpp: "read_xml_stream(#)".} ## \
## Reads an XML document from the indicated stream.
## @returns the document, or NULL on error.

proc writeXmlStream*(`out`: ostream, doc: TiXmlDocument) {.importcpp: "write_xml_stream(#, #)".}

proc printXml*(xnode: TiXmlNode) {.importcpp: "print_xml(#)".}

proc printXmlToFile*(filename: Filename, xnode: TiXmlNode) {.importcpp: "print_xml_to_file(#, #)".}

proc getTIXMLMAJORVERSION*(): int {.importcpp: "get_TIXML_MAJOR_VERSION()".}

proc getTIXMLMINORVERSION*(): int {.importcpp: "get_TIXML_MINOR_VERSION()".}

proc getTIXMLPATCHVERSION*(): int {.importcpp: "get_TIXML_PATCH_VERSION()".}

proc initTiXmlCursor*(param0: TiXmlCursor): TiXmlCursor {.importcpp: "TiXmlCursor(#)".}

proc VisitEnter*(this: TiXmlVisitor, param0: TiXmlDocument): bool {.importcpp: "#->VisitEnter(#)".} ## \
## doc

proc VisitEnter*(this: TiXmlVisitor, param0: TiXmlElement, param1: TiXmlAttribute): bool {.importcpp: "#->VisitEnter(#, #)".} ## \
## firstAttribute

proc VisitExit*(this: TiXmlVisitor, param0: TiXmlDocument): bool {.importcpp: "#->VisitExit(#)".} ## \
## doc

proc VisitExit*(this: TiXmlVisitor, param0: TiXmlElement): bool {.importcpp: "#->VisitExit(#)".} ## \
## element

proc Visit*(this: TiXmlVisitor, param0: TiXmlComment): bool {.importcpp: "#->Visit(#)".} ## \
## comment

proc Visit*(this: TiXmlVisitor, param0: TiXmlDeclaration): bool {.importcpp: "#->Visit(#)".} ## \
## declaration

proc Visit*(this: TiXmlVisitor, param0: TiXmlText): bool {.importcpp: "#->Visit(#)".} ## \
## text

proc Visit*(this: TiXmlVisitor, param0: TiXmlUnknown): bool {.importcpp: "#->Visit(#)".} ## \
## unknown

proc newTiXmlVisitor*(): TiXmlVisitor {.importcpp: "new TiXmlVisitor()".}

proc newTiXmlVisitor*(param0: TiXmlVisitor): TiXmlVisitor {.importcpp: "new TiXmlVisitor(#)".}

proc getTIXMLDEFAULTENCODING*(): TiXmlEncoding {.importcpp: "get_TIXML_DEFAULT_ENCODING()".}

proc initTiXmlAttribute*(): TiXmlAttribute {.importcpp: "TiXmlAttribute()".} ## \
## Construct an empty attribute.

proc Name*(this: TiXmlAttribute): string {.importcpp: "nimStringFromStdString(#.Name())", header: stringConversionCode.} ## \
## Return the name of this attribute.

proc Value*(this: TiXmlAttribute): string {.importcpp: "nimStringFromStdString(#.Value())", header: stringConversionCode.} ## \
## Return the value of this attribute.

proc ValueStr*(this: TiXmlAttribute): string {.importcpp: "nimStringFromStdString(#.ValueStr())", header: stringConversionCode.} ## \
## Return the value of this attribute.

proc IntValue*(this: TiXmlAttribute): int {.importcpp: "#.IntValue()".} ## \
## Return the value of this attribute, converted to an integer.

proc DoubleValue*(this: TiXmlAttribute): float64 {.importcpp: "#.DoubleValue()".} ## \
## Return the value of this attribute, converted to a double.

proc NameTStr*(this: TiXmlAttribute): string {.importcpp: "nimStringFromStdString(#.NameTStr())", header: stringConversionCode.} ## \
## Get the tinyxml string representation

proc Next*(this: TiXmlAttribute): TiXmlAttribute {.importcpp: "#.Next()".}

proc Previous*(this: TiXmlAttribute): TiXmlAttribute {.importcpp: "#.Previous()".}

proc `==`*(this: TiXmlAttribute, rhs: TiXmlAttribute): bool {.importcpp: "#.operator ==(#)".}

proc `<`*(this: TiXmlAttribute, rhs: TiXmlAttribute): bool {.importcpp: "#.operator <(#)".}

proc `>`*(this: TiXmlAttribute, rhs: TiXmlAttribute): bool {.importcpp: "#.operator >(#)".}

proc SetDocument*(this: TiXmlAttribute, doc: TiXmlDocument) {.importcpp: "#.SetDocument(#)".} ## \
## [internal use]
## Set the document pointer so the attribute can report errors.

proc initTiXmlAttributeSet*(): TiXmlAttributeSet {.importcpp: "TiXmlAttributeSet()".}

proc Add*(this: TiXmlAttributeSet, attribute: TiXmlAttribute) {.importcpp: "#.Add(#)".}

proc Remove*(this: TiXmlAttributeSet, attribute: TiXmlAttribute) {.importcpp: "#.Remove(#)".}

proc First*(this: TiXmlAttributeSet): TiXmlAttribute {.importcpp: "#.First()".}

proc Last*(this: TiXmlAttributeSet): TiXmlAttribute {.importcpp: "#.Last()".}

proc newTiXmlComment*(): TiXmlComment {.importcpp: "new TiXmlComment()".} ## \
## Constructs an empty comment.

proc newTiXmlComment*(param0: TiXmlComment): TiXmlComment {.importcpp: "new TiXmlComment(#)".}

proc newTiXmlText*(copy: TiXmlText): TiXmlText {.importcpp: "new TiXmlText(#)".}

proc newTiXmlText*(initValue: string): TiXmlText {.importcpp: "new TiXmlText(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Constructor for text element. By default, it is treated as
## normal, encoded text. If you want it be output as a CDATA text
## element, set the parameter _cdata to 'true'

proc CDATA*(this: TiXmlText): bool {.importcpp: "#->CDATA()".} ## \
## Queries whether this represents text using a CDATA section.

proc newTiXmlUnknown*(): TiXmlUnknown {.importcpp: "new TiXmlUnknown()".}

proc newTiXmlUnknown*(copy: TiXmlUnknown): TiXmlUnknown {.importcpp: "new TiXmlUnknown(#)".}

proc initTiXmlHandle*(`ref`: TiXmlHandle): TiXmlHandle {.importcpp: "TiXmlHandle(#)".} ## \
## Copy constructor

proc FirstChild*(this: TiXmlHandle): TiXmlHandle {.importcpp: "#.FirstChild()".} ## \
## Return a handle to the first child node.

proc FirstChild*(this: TiXmlHandle, value: string): TiXmlHandle {.importcpp: "#.FirstChild(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Return a handle to the first child node with the given name.

proc FirstChildElement*(this: TiXmlHandle): TiXmlHandle {.importcpp: "#.FirstChildElement()".} ## \
## Return a handle to the first child element.

proc FirstChildElement*(this: TiXmlHandle, value: string): TiXmlHandle {.importcpp: "#.FirstChildElement(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Return a handle to the first child element with the given name.

proc Child*(this: TiXmlHandle, value: string, index: int): TiXmlHandle {.importcpp: "#.Child(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Return a handle to the "index" child with the given name.
## The first child is 0, the second 1, etc.

proc Child*(this: TiXmlHandle, index: int): TiXmlHandle {.importcpp: "#.Child(#)".} ## \
## Return a handle to the "index" child.
## The first child is 0, the second 1, etc.

proc ChildElement*(this: TiXmlHandle, value: string, index: int): TiXmlHandle {.importcpp: "#.ChildElement(nimStringToStdString(#), #)", header: stringConversionCode.} ## \
## Return a handle to the "index" child element with the given name.
## The first child element is 0, the second 1, etc. Note that only TiXmlElements
## are indexed: other types are not counted.

proc ChildElement*(this: TiXmlHandle, index: int): TiXmlHandle {.importcpp: "#.ChildElement(#)".} ## \
## Return a handle to the "index" child element.
## The first child element is 0, the second 1, etc. Note that only TiXmlElements
## are indexed: other types are not counted.

proc ToNode*(this: TiXmlHandle): TiXmlNode {.importcpp: "#.ToNode()".} ## \
## Return the handle as a TiXmlNode. This may return null.

proc ToElement*(this: TiXmlHandle): TiXmlElement {.importcpp: "#.ToElement()".} ## \
## Return the handle as a TiXmlElement. This may return null.

proc ToText*(this: TiXmlHandle): TiXmlText {.importcpp: "#.ToText()".} ## \
## Return the handle as a TiXmlText. This may return null.

proc ToUnknown*(this: TiXmlHandle): TiXmlUnknown {.importcpp: "#.ToUnknown()".} ## \
## Return the handle as a TiXmlUnknown. This may return null.

proc Node*(this: TiXmlHandle): TiXmlNode {.importcpp: "#.Node()".} ## \
## @deprecated use ToNode.
## Return the handle as a TiXmlNode. This may return null.

proc Element*(this: TiXmlHandle): TiXmlElement {.importcpp: "#.Element()".} ## \
## @deprecated use ToElement.
## Return the handle as a TiXmlElement. This may return null.

proc Text*(this: TiXmlHandle): TiXmlText {.importcpp: "#.Text()".} ## \
## @deprecated use ToText()
## Return the handle as a TiXmlText. This may return null.

proc Unknown*(this: TiXmlHandle): TiXmlUnknown {.importcpp: "#.Unknown()".} ## \
## @deprecated use ToUnknown()
## Return the handle as a TiXmlUnknown. This may return null.

proc initTiXmlPrinter*(): TiXmlPrinter {.importcpp: "TiXmlPrinter()".}

proc initTiXmlPrinter*(param0: TiXmlPrinter): TiXmlPrinter {.importcpp: "TiXmlPrinter(#)".}

proc Indent*(this: TiXmlPrinter): string {.importcpp: "nimStringFromStdString(#.Indent())", header: stringConversionCode.} ## \
## Query the indention string.

proc LineBreak*(this: TiXmlPrinter): string {.importcpp: "nimStringFromStdString(#.LineBreak())", header: stringConversionCode.} ## \
## Query the current line breaking string.

proc SetStreamPrinting*(this: TiXmlPrinter) {.importcpp: "#.SetStreamPrinting()".} ## \
## Switch over to "stream printing" which is the most dense formatting without
## linebreaks. Common when the XML is needed for network transmission.

proc CStr*(this: TiXmlPrinter): string {.importcpp: "nimStringFromStdString(#.CStr())", header: stringConversionCode.} ## \
## Return the result.

proc Size*(this: TiXmlPrinter): clonglong {.importcpp: "#.Size()".} ## \
## Return the length of the result string.

proc Str*(this: TiXmlPrinter): string {.importcpp: "nimStringFromStdString(#.Str())", header: stringConversionCode.} ## \
## Return the result.

proc setPointSize*(this: FreetypeFont, point_size: float32): bool {.importcpp: "#.set_point_size(#)".} ## \
## Sets the point size of the font.  This controls the apparent size of the
## font onscreen.  By convention, a 10 point font is about 1 screen unit high.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

proc getPointSize*(this: FreetypeFont): float32 {.importcpp: "#.get_point_size()".} ## \
## Returns the point size of the font.

proc setPixelsPerUnit*(this: FreetypeFont, pixels_per_unit: float32): bool {.importcpp: "#.set_pixels_per_unit(#)".} ## \
## Set the resolution of the texture map, and hence the clarity of the
## resulting font.  This sets the number of pixels in the texture map that are
## used for each onscreen unit.
##
## Setting this number larger results in an easier to read font, but at the
## cost of more texture memory.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

proc getPixelsPerUnit*(this: FreetypeFont): float32 {.importcpp: "#.get_pixels_per_unit()".} ## \
## Returns the resolution of the texture map.  See set_pixels_per_unit().

proc setPixelSize*(this: FreetypeFont, pixel_size: float32): bool {.importcpp: "#.set_pixel_size(#)".} ## \
## Computes the appropriate pixels_per_unit value to set the size of the font
## in the texture to the indicated number of pixels.  This is just another way
## to specify pixels_per_unit().

proc getPixelSize*(this: FreetypeFont): float32 {.importcpp: "#.get_pixel_size()".} ## \
## Returns the size of the font in pixels, as it appears in the texture.

proc setScaleFactor*(this: FreetypeFont, scale_factor: float32): bool {.importcpp: "#.set_scale_factor(#)".} ## \
## Sets the factor by which the font is rendered larger by the FreeType
## library before being filtered down to its actual size in the texture as
## specified by set_pixels_per_unit().  This may be set to a number larger
## than 1.0 to improve the font's antialiasing (since FreeType doesn't really
## do a swell job of antialiasing by itself).  There is some performance
## implication for setting this different than 1.0.
##
## This should only be called before any characters have been requested out of
## the font, or immediately after calling clear().

proc getScaleFactor*(this: FreetypeFont): float32 {.importcpp: "#.get_scale_factor()".} ## \
## Returns the antialiasing scale factor.  See set_scale_factor().

proc setNativeAntialias*(this: FreetypeFont, native_antialias: bool) {.importcpp: "#.set_native_antialias(#)".} ## \
## Sets whether the Freetype library's built-in antialias mode is enabled.
## There are two unrelated ways to achieve antialiasing: with Freetype's
## native antialias mode, and with the use of a scale_factor greater than one.
## By default, both modes are enabled.
##
## At low resolutions, some fonts may do better with one mode or the other.
## In general, Freetype's native antialiasing will produce less blurry
## results, but may introduce more artifacts.

proc getNativeAntialias*(this: FreetypeFont): bool {.importcpp: "#.get_native_antialias()".} ## \
## Returns whether Freetype's built-in antialias mode is enabled.  See
## set_native_antialias().

proc getFontPixelSize*(this: FreetypeFont): int {.importcpp: "#.get_font_pixel_size()".} ## \
## This is used to report whether the requested pixel size is being only
## approximated by a fixed-pixel-size font.  This returns 0 in the normal
## case, in which a scalable font is used, or the fixed-pixel-size font has
## exactly the requested pixel size.
##
## If this returns non-zero, it is the pixel size of the font that we are
## using to approximate our desired size.

proc getLineHeight*(this: FreetypeFont): float32 {.importcpp: "#.get_line_height()".} ## \
## Returns the number of units high each line of text is.

proc getSpaceAdvance*(this: FreetypeFont): float32 {.importcpp: "#.get_space_advance()".} ## \
## Returns the number of units wide a space is.

proc getPointsPerUnit*(_: typedesc[FreetypeFont]): float32 {.importcpp: "FreetypeFont::get_points_per_unit()", header: "freetypeFont.h".} ## \
## Returns the point size of the font that is one Panda unit high.  This is an
## arbitrary Panda convention for text, and is set to 10.0.

proc getPointsPerInch*(_: typedesc[FreetypeFont]): float32 {.importcpp: "FreetypeFont::get_points_per_inch()", header: "freetypeFont.h".} ## \
## Returns the number of points in one inch.  This is a universal typographic
## convention.

proc initPNMTextGlyph*(param0: PNMTextGlyph): PNMTextGlyph {.importcpp: "PNMTextGlyph(#)".}

proc initPNMTextGlyph*(advance: float64): PNMTextGlyph {.importcpp: "PNMTextGlyph(#)".}

proc getAdvance*(this: PNMTextGlyph): int {.importcpp: "#.get_advance()".} ## \
## Returns the number of pixels by which the pen should be advanced after
## rendering this glyph.

proc place*(this: PNMTextGlyph, dest_image: PNMImage, xp: int, yp: int, fg: LColor) {.importcpp: "#.place(#, #, #, #)".} ## \
## Copies the glyph to the indicated destination image at the indicated
## origin.  It colors the glyph pixels the indicated foreground color, blends
## antialiased pixels with the appropriate amount of the foreground color and
## the existing background color, and leaves other pixels alone.

proc place*(this: PNMTextGlyph, dest_image: PNMImage, xp: int, yp: int, fg: LColor, interior: LColor) {.importcpp: "#.place(#, #, #, #, #)".} ## \
## This flavor of place() also fills in the interior color.  This requires
## that determine_interior was called earlier.

proc getLeft*(this: PNMTextGlyph): int {.importcpp: "#.get_left()".} ## \
## Returns the x coordinate of the leftmost pixel in the glyph.

proc getRight*(this: PNMTextGlyph): int {.importcpp: "#.get_right()".} ## \
## Returns the x coordinate of the rightmost pixel in the glyph.

proc getBottom*(this: PNMTextGlyph): int {.importcpp: "#.get_bottom()".} ## \
## Returns the y coordinate of the bottommost pixel in the glyph.

proc getTop*(this: PNMTextGlyph): int {.importcpp: "#.get_top()".} ## \
## Returns the y coordinate of the topmost pixel in the glyph.

proc getHeight*(this: PNMTextGlyph): int {.importcpp: "#.get_height()".} ## \
## Returns the height of the glyph in pixels.

proc getWidth*(this: PNMTextGlyph): int {.importcpp: "#.get_width()".} ## \
## Returns the width of the glyph in pixels.

proc getValue*(this: PNMTextGlyph, x: int, y: int): float64 {.importcpp: "#.get_value(#, #)".} ## \
## Returns the value of the indicated pixel of the glyph.  The result is in
## the range [0, 1], where 0 indicates the pixel is not part of the glyph, and
## 1 indicates it is.  Intermediate values are used to represent antialiasing.

proc getInteriorFlag*(this: PNMTextGlyph, x: int, y: int): bool {.importcpp: "#.get_interior_flag(#, #)".} ## \
## Returns true if the indicated pixel represents a pixel in the interior of a
## hollow font, false otherwise.

proc initPNMTextMaker*(font_filename: Filename, face_index: int): PNMTextMaker {.importcpp: "PNMTextMaker(#, #)".} ## \
## The constructor expects the name of some font file that FreeType can read,
## along with face_index, indicating which font within the file to load
## (usually 0).

proc initPNMTextMaker*(copy: FreetypeFont): PNMTextMaker {.importcpp: "PNMTextMaker(#)".}

proc initPNMTextMaker*(copy: PNMTextMaker): PNMTextMaker {.importcpp: "PNMTextMaker(#)".}

proc initPNMTextMaker*(font_data: string, data_length: int, face_index: int): PNMTextMaker {.importcpp: "PNMTextMaker(nimStringToStdString(#), #, #)", header: stringConversionCode.} ## \
## This constructor works as above, but it takes the font data from an in-
## memory buffer instead of from a named file.

proc isValid*(this: PNMTextMaker): bool {.importcpp: "#.is_valid()".} ## \
## Returns true if the PNMTextMaker is valid and ready to generate text, false
## otherwise.

proc setInteriorFlag*(this: PNMTextMaker, interior_flag: bool) {.importcpp: "#.set_interior_flag(#)".} ## \
## Sets the flag that indicates whether the interior of hollow fonts is
## identified as a preprocess as each glyph is loaded.  If this flag is true,
## you may specify an interior color along with a fg and bg color when you
## place text; if the flag is false, the interior color is ignored.
##
## It is generally best to set_native_antialias(0) when using this feature.
## Also, this works best when the pixel size is not very small.

proc getInteriorFlag*(this: PNMTextMaker): bool {.importcpp: "#.get_interior_flag()".}

proc setFg*(this: PNMTextMaker, fg: LColor) {.importcpp: "#.set_fg(#)".} ## \
## Sets the foreground color of text that will be generated by future calls to
## generate_into().  This is the color that all of the "on" pixels in the font
## will show as.

proc getFg*(this: PNMTextMaker): LColor {.importcpp: "#.get_fg()".} ## \
## Returns the foreground color of text that will be generated by future calls
## to generate_into().

proc setInterior*(this: PNMTextMaker, interior: LColor) {.importcpp: "#.set_interior(#)".} ## \
## Sets the color that will be used to render the interior portions of hollow
## fonts in future calls to generate_into().  This is respected only if
## interior_flag is true.

proc getInterior*(this: PNMTextMaker): LColor {.importcpp: "#.get_interior()".} ## \
## Returns the color that will be used to render the interior portions of
## hollow fonts.

proc setDistanceFieldRadius*(this: PNMTextMaker, radius: int) {.importcpp: "#.set_distance_field_radius(#)".} ## \
## If this is set to something other than 0, Panda will generate a signed
## distance field with the given radius.

proc getDistanceFieldRadius*(this: PNMTextMaker): int {.importcpp: "#.get_distance_field_radius()".} ## \
## Returns the radius previously set with set_distance_field_radius, or 0
## otherwise.

proc generateInto*(this: PNMTextMaker, text: string, dest_image: PNMImage, x: int, y: int): int {.importcpp: "#.generate_into(nimStringToStdString(#), #, #, #)", header: stringConversionCode.} ## \
## Generates a single line of text into the indicated image at the indicated
## position; the return value is the total width in pixels.

proc calcWidth*(this: PNMTextMaker, text: string): int {.importcpp: "#.calc_width(nimStringToStdString(#))", header: stringConversionCode.} ## \
## Returns the width in pixels of the indicated line of text.

proc getGlyph*(this: PNMTextMaker, character: int): PNMTextGlyph {.importcpp: "#.get_glyph(#)".} ## \
## Returns the glyph for the indicated index, or NULL if it is not defined in
## the font.


converter initFilename*(fn: string): Filename {.importcpp: "Filename(([](NimStringDesc *desc) {return std::string(desc->data, desc->len);})(#))".}

proc setText*(this: TextEncoder, text: string) {.importcpp: "#->set_text(nimStringToStdString(#))", header: stringConversionCode.}
func text*(this: TextEncoder) : string {.importcpp: "nimStringFromStdString(#->get_text())", header: stringConversionCode.}
func `text=`*(this: TextEncoder, text: string) {.importcpp: "#->set_text(nimStringToStdString(#))", header: stringConversionCode.}

func time*(this: AsyncTask): float {.importcpp: "#->get_elapsed_time()".}

proc initLVecBase2f*(): LVecBase2f = LVecBase2f(x: 0, y: 0)
proc initLVecBase2f*(copy: LVecBase2f): LVecBase2f = LVecBase2f(x: copy.x, y: copy.y)
proc initLVecBase2f*(fill_value: float32): LVecBase2f = LVecBase2f(x: fill_value, y: fill_value)
proc initLVecBase2f*(x: float32, y: float32): LVecBase2f = LVecBase2f(x: x, y: y)
converter initLVecBase2f*(args: tuple[x: float32, y: float32]): LVecBase2f = LVecBase2f(x: args.x, y: args.y)
converter initLVecBase2f*(args: tuple[x: float64, y: float64]): LVecBase2f = LVecBase2f(x: args.x, y: args.y)

proc initLVecBase2d*(): LVecBase2d = LVecBase2d(x: 0, y: 0)
proc initLVecBase2d*(copy: LVecBase2d): LVecBase2d = LVecBase2d(x: copy.x, y: copy.y)
proc initLVecBase2d*(fill_value: float64): LVecBase2d = LVecBase2d(x: fill_value, y: fill_value)
converter initLVecBase2d*(args: tuple[x: float64, y: float64]): LVecBase2d = LVecBase2d(x: args.x, y: args.y)
proc initLVecBase2d*(x: float32, y: float32): LVecBase2d = LVecBase2d(x: x, y: y)
proc initLVecBase2d*(x: float64, y: float64): LVecBase2d = LVecBase2d(x: x, y: y)

proc initLVecBase2i*(): LVecBase2i = LVecBase2i(x: 0, y: 0)
proc initLVecBase2i*(copy: LVecBase2i): LVecBase2i = LVecBase2i(x: copy.x, y: copy.y)
proc initLVecBase2i*(fill_value: int32): LVecBase2i = LVecBase2i(x: fill_value, y: fill_value)
proc initLVecBase2i*(x: int32, y: int32): LVecBase2i = LVecBase2i(x: x, y: y)
converter initLVecBase2i*(args: tuple[x: int32, y: int32]): LVecBase2i = LVecBase2i(x: args.x, y: args.y)

proc initLVecBase3f*(): LVecBase3f = LVecBase3f(x: 0, y: 0, z: 0)
proc initLVecBase3f*(copy: LVecBase2f, z: float32): LVecBase3f = LVecBase3f(x: copy.x, y: copy.y, z: z)
proc initLVecBase3f*(copy: LVecBase3f): LVecBase3f = LVecBase3f(x: copy.x, y: copy.y, z: copy.z)
proc initLVecBase3f*(fill_value: float32): LVecBase3f = LVecBase3f(x: fill_value, y: fill_value, z: fill_value)
proc initLVecBase3f*(x: float32, y: float32, z: float32): LVecBase3f = LVecBase3f(x: x, y: y, z: z)
converter initLVecBase3f*(args: tuple[x: float32, y: float32, z: float32]): LVecBase3f = LVecBase3f(x: args.x, y: args.y, z: args.z)
converter initLVecBase3f*(args: tuple[x: float64, y: float64, z: float64]): LVecBase3f = LVecBase3f(x: args.x, y: args.y, z: args.z)

proc initLVecBase3d*(): LVecBase3d = LVecBase3d(x: 0, y: 0, z: 0)
proc initLVecBase3d*(copy: LVecBase2d, z: float64): LVecBase3d = LVecBase3d(x: copy.x, y: copy.y, z: z)
proc initLVecBase3d*(copy: LVecBase3d): LVecBase3d = LVecBase3d(x: copy.x, y: copy.y, z: copy.z)
proc initLVecBase3d*(fill_value: float64): LVecBase3d = LVecBase3d(x: fill_value, y: fill_value, z: fill_value)
proc initLVecBase3d*(x: float64, y: float64, z: float64): LVecBase3d = LVecBase3d(x: x, y: y, z: z)
converter initLVecBase3d*(args: tuple[x: float32, y: float32, z: float32]): LVecBase3d = LVecBase3d(x: args.x, y: args.y, z: args.z)
converter initLVecBase3d*(args: tuple[x: float64, y: float64, z: float64]): LVecBase3d = LVecBase3d(x: args.x, y: args.y, z: args.z)

proc initLVecBase3i*(): LVecBase3i = LVecBase3i(x: 0, y: 0, z: 0)
proc initLVecBase3i*(copy: LVecBase2i, z: int32): LVecBase3i = LVecBase3i(x: copy.x, y: copy.y, z: z)
proc initLVecBase3i*(copy: LVecBase3i): LVecBase3i = LVecBase3i(x: copy.x, y: copy.y, z: copy.z)
proc initLVecBase3i*(fill_value: int32): LVecBase3i = LVecBase3i(x: fill_value, y: fill_value, z: fill_value)
proc initLVecBase3i*(x: int32, y: int32, z: int32): LVecBase3i = LVecBase3i(x: x, y: y, z: z)
converter initLVecBase3i*(args: tuple[x: int32, y: int32, z: int32]): LVecBase3i = LVecBase3i(x: args.x, y: args.y, z: args.z)

proc initLVecBase4f*(): LVecBase4f = LVecBase4f(x: 0, y: 0, z: 0, w: 0)
proc initLVecBase4f*(copy: LVecBase3f, w: float32): LVecBase4f = LVecBase4f(x: copy.x, y: copy.y, z: copy.z, w: w)
proc initLVecBase4f*(copy: LVecBase4f): LVecBase4f = LVecBase4f(x: copy.x, y: copy.y, z: copy.z, w: copy.w)
proc initLVecBase4f*(fill_value: float32): LVecBase4f = LVecBase4f(x: fill_value, y: fill_value, z: fill_value, w: fill_value)
proc initLVecBase4f*(x: float32, y: float32, z: float32, w: float32): LVecBase4f = LVecBase4f(x: x, y: y, z: z, w: w)
converter initLVecBase4f*(args: tuple[x: float32, y: float32, z: float32, w: float32]): LVecBase4f = LVecBase4f(x: args.x, y: args.y, z: args.z)
converter initLVecBase4f*(args: tuple[x: float64, y: float64, z: float64, w: float64]): LVecBase4f = LVecBase4f(x: args.x, y: args.y, z: args.z)
converter initLVecBase4f*(copy: UnalignedLVecBase4f): LVecBase4f = LVecBase4f(x: copy.x, y: copy.y, z: copy.z, w: copy.w)
converter initLVecBase4f*(point: LPoint3f): LVecBase4f = LVecBase4f(x: point.x, y: point.y, z: point.z, w: 1)
converter initLVecBase4f*(vector: LVector3f): LVecBase4f = LVecBase4f(x: vector.x, y: vector.y, z: vector.z, w: 0)

proc initLVecBase4d*(): LVecBase4d = LVecBase4d(x: 0, y: 0, z: 0, w: 0)
proc initLVecBase4d*(copy: LVecBase3d, w: float64): LVecBase4d = LVecBase4d(x: copy.x, y: copy.y, z: copy.z, w: w)
proc initLVecBase4d*(copy: LVecBase4d): LVecBase4d = LVecBase4d(x: copy.x, y: copy.y, z: copy.z, w: copy.w)
proc initLVecBase4d*(fill_value: float64): LVecBase4d = LVecBase4d(x: fill_value, y: fill_value, z: fill_value, w: fill_value)
proc initLVecBase4d*(x: float64, y: float64, z: float64, w: float64): LVecBase4d = LVecBase4d(x: x, y: y, z: z, w: w)
converter initLVecBase4d*(args: tuple[x: float32, y: float32, z: float32, w: float32]): LVecBase4d = LVecBase4d(x: args.x, y: args.y, z: args.z, w: args.w)
converter initLVecBase4d*(args: tuple[x: float64, y: float64, z: float64, w: float64]): LVecBase4d = LVecBase4d(x: args.x, y: args.y, z: args.z, w: args.w)
converter initLVecBase4d*(copy: UnalignedLVecBase4d): LVecBase4d = LVecBase4d(x: copy.x, y: copy.y, z: copy.z, w: copy.w)
converter initLVecBase4d*(point: LPoint3d): LVecBase4d = LVecBase4d(x: point.x, y: point.y, z: point.z, w: 1)
converter initLVecBase4d*(vector: LVector3d): LVecBase4d = LVecBase4d(x: vector.x, y: vector.y, z: vector.z, w: 0)

proc initLVecBase4i*(): LVecBase4i = LVecBase4i(x: 0, y: 0, z: 0, w: 0)
proc initLVecBase4i*(copy: LVecBase3i, w: int32): LVecBase4i = LVecBase4i(x: copy.x, y: copy.y, z: copy.z, w: w)
proc initLVecBase4i*(copy: LVecBase4i): LVecBase4i = LVecBase4i(x: copy.x, y: copy.y, z: copy.z, w: copy.w)
proc initLVecBase4i*(fill_value: int32): LVecBase4i = LVecBase4i(x: fill_value, y: fill_value, z: fill_value, w: fill_value)
proc initLVecBase4i*(x: int32, y: int32, z: int32, w: int32): LVecBase4i = LVecBase4i(x: x, y: y, z: z, w: w)
converter initLVecBase4i*(args: tuple[x: int32, y: int32, z: int32, w: int32]): LVecBase4i = LVecBase4i(x: args.x, y: args.y, z: args.z, w: args.w)
converter initLVecBase4i*(copy: UnalignedLVecBase4i): LVecBase4i = LVecBase4i(x: copy.x, y: copy.y, z: copy.z, w: copy.w)
converter initLVecBase4i*(point: LPoint3i): LVecBase4i = LVecBase4i(x: point.x, y: point.y, z: point.z, w: 1)
converter initLVecBase4i*(vector: LVector3i): LVecBase4i = LVecBase4i(x: vector.x, y: vector.y, z: vector.z, w: 0)

proc initUnalignedLVecBase4f*(): UnalignedLVecBase4f = UnalignedLVecBase4f(x: 0, y: 0, z: 0, w: 0)
proc initUnalignedLVecBase4f*(copy: UnalignedLVecBase4f): UnalignedLVecBase4f = UnalignedLVecBase4f(x: copy.x, y: copy.y, z: copy.z, w: copy.w)
proc initUnalignedLVecBase4f*(fill_value: float32): UnalignedLVecBase4f = UnalignedLVecBase4f(x: fill_value, y: fill_value, z: fill_value, w: fill_value)
proc initUnalignedLVecBase4f*(x: float32, y: float32, z: float32, w: float32): UnalignedLVecBase4f = UnalignedLVecBase4f(x: x, y: y, z: z, w: w)
converter initUnalignedLVecBase4f*(args: tuple[x: float32, y: float32, z: float32, w: float32]): UnalignedLVecBase4f = UnalignedLVecBase4f(x: args.x, y: args.y, z: args.z)
converter initUnalignedLVecBase4f*(args: tuple[x: float64, y: float64, z: float64, w: float64]): UnalignedLVecBase4f = UnalignedLVecBase4f(x: args.x, y: args.y, z: args.z)
converter initUnalignedLVecBase4f*(copy: LVecBase4f): UnalignedLVecBase4f = UnalignedLVecBase4f(x: copy.x, y: copy.y, z: copy.z, w: copy.w)

proc initUnalignedLVecBase4d*(): UnalignedLVecBase4d = UnalignedLVecBase4d(x: 0, y: 0, z: 0, w: 0)
proc initUnalignedLVecBase4d*(copy: UnalignedLVecBase4d): UnalignedLVecBase4d = UnalignedLVecBase4d(x: copy.x, y: copy.y, z: copy.z, w: copy.w)
proc initUnalignedLVecBase4d*(fill_value: float64): UnalignedLVecBase4d = UnalignedLVecBase4d(x: fill_value, y: fill_value, z: fill_value, w: fill_value)
proc initUnalignedLVecBase4d*(x: float64, y: float64, z: float64, w: float64): UnalignedLVecBase4d = UnalignedLVecBase4d(x: x, y: y, z: z, w: w)
converter initUnalignedLVecBase4d*(args: tuple[x: float32, y: float32, z: float32, w: float32]): UnalignedLVecBase4d = UnalignedLVecBase4d(x: args.x, y: args.y, z: args.z, w: args.w)
converter initUnalignedLVecBase4d*(args: tuple[x: float64, y: float64, z: float64, w: float64]): UnalignedLVecBase4d = UnalignedLVecBase4d(x: args.x, y: args.y, z: args.z, w: args.w)
converter initUnalignedLVecBase4d*(copy: LVecBase4d): UnalignedLVecBase4d = UnalignedLVecBase4d(x: copy.x, y: copy.y, z: copy.z, w: copy.w)

proc initUnalignedLVecBase4i*(): UnalignedLVecBase4i = UnalignedLVecBase4i(x: 0, y: 0, z: 0, w: 0)
proc initUnalignedLVecBase4i*(copy: UnalignedLVecBase4i): UnalignedLVecBase4i = UnalignedLVecBase4i(x: copy.x, y: copy.y, z: copy.z, w: copy.w)
proc initUnalignedLVecBase4i*(fill_value: int32): UnalignedLVecBase4i = UnalignedLVecBase4i(x: fill_value, y: fill_value, z: fill_value, w: fill_value)
proc initUnalignedLVecBase4i*(x: int32, y: int32, z: int32, w: int32): UnalignedLVecBase4i = UnalignedLVecBase4i(x: x, y: y, z: z, w: w)
converter initUnalignedLVecBase4i*(args: tuple[x: int32, y: int32, z: int32, w: int32]): UnalignedLVecBase4i = UnalignedLVecBase4i(x: args.x, y: args.y, z: args.z, w: args.w)
converter initUnalignedLVecBase4i*(copy: LVecBase4i): UnalignedLVecBase4i = UnalignedLVecBase4i(x: copy.x, y: copy.y, z: copy.z, w: copy.w)

func xx*(this: LVecBase2f): LVecBase2f = LVecBase2f(x: this.x, y: this.x)
func xxx*(this: LVecBase2f): LVecBase3f = LVecBase3f(x: this.x, y: this.x, z: this.x)
func xxxx*(this: LVecBase2f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.x, w: this.x)
func xxxy*(this: LVecBase2f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.x, w: this.y)
func xxy*(this: LVecBase2f): LVecBase3f = LVecBase3f(x: this.x, y: this.x, z: this.y)
func xxyx*(this: LVecBase2f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.y, w: this.x)
func xxyy*(this: LVecBase2f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.y, w: this.y)
func xy*(this: LVecBase2f): LVecBase2f = LVecBase2f(x: this.x, y: this.y)
func xyx*(this: LVecBase2f): LVecBase3f = LVecBase3f(x: this.x, y: this.y, z: this.x)
func xyxx*(this: LVecBase2f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.x, w: this.x)
func xyxy*(this: LVecBase2f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.x, w: this.y)
func xyy*(this: LVecBase2f): LVecBase3f = LVecBase3f(x: this.x, y: this.y, z: this.y)
func xyyx*(this: LVecBase2f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.y, w: this.x)
func xyyy*(this: LVecBase2f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.y, w: this.y)
func yx*(this: LVecBase2f): LVecBase2f = LVecBase2f(x: this.y, y: this.x)
func yxx*(this: LVecBase2f): LVecBase3f = LVecBase3f(x: this.y, y: this.x, z: this.x)
func yxxx*(this: LVecBase2f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.x, w: this.x)
func yxxy*(this: LVecBase2f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.x, w: this.y)
func yxy*(this: LVecBase2f): LVecBase3f = LVecBase3f(x: this.y, y: this.x, z: this.y)
func yxyx*(this: LVecBase2f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.y, w: this.x)
func yxyy*(this: LVecBase2f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.y, w: this.y)
func yy*(this: LVecBase2f): LVecBase2f = LVecBase2f(x: this.y, y: this.y)
func yyx*(this: LVecBase2f): LVecBase3f = LVecBase3f(x: this.y, y: this.y, z: this.x)
func yyxx*(this: LVecBase2f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.x, w: this.x)
func yyxy*(this: LVecBase2f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.x, w: this.y)
func yyy*(this: LVecBase2f): LVecBase3f = LVecBase3f(x: this.y, y: this.y, z: this.y)
func yyyx*(this: LVecBase2f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.y, w: this.x)
func yyyy*(this: LVecBase2f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.y, w: this.y)

func xx*(this: LVecBase3f): LVecBase2f = LVecBase2f(x: this.x, y: this.x)
func xxx*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.x, y: this.x, z: this.x)
func xxxx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.x, w: this.x)
func xxxy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.x, w: this.y)
func xxxz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.x, w: this.z)
func xxy*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.x, y: this.x, z: this.y)
func xxyx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.y, w: this.x)
func xxyy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.y, w: this.y)
func xxyz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.y, w: this.z)
func xxz*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.x, y: this.x, z: this.z)
func xxzx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.z, w: this.x)
func xxzy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.z, w: this.y)
func xxzz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.z, w: this.z)
func xy*(this: LVecBase3f): LVecBase2f = LVecBase2f(x: this.x, y: this.y)
func xyx*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.x, y: this.y, z: this.x)
func xyxx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.x, w: this.x)
func xyxy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.x, w: this.y)
func xyxz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.x, w: this.z)
func xyy*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.x, y: this.y, z: this.y)
func xyyx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.y, w: this.x)
func xyyy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.y, w: this.y)
func xyyz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.y, w: this.z)
func xyz*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.x, y: this.y, z: this.z)
func xyzx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.z, w: this.x)
func xyzy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.z, w: this.y)
func xyzz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.z, w: this.z)
func xz*(this: LVecBase3f): LVecBase2f = LVecBase2f(x: this.x, y: this.z)
func xzx*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.x, y: this.z, z: this.x)
func xzxx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.x, w: this.x)
func xzxy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.x, w: this.y)
func xzxz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.x, w: this.z)
func xzy*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.x, y: this.z, z: this.y)
func xzyx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.y, w: this.x)
func xzyy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.y, w: this.y)
func xzyz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.y, w: this.z)
func xzz*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.x, y: this.z, z: this.z)
func xzzx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.z, w: this.x)
func xzzy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.z, w: this.y)
func xzzz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.z, w: this.z)
func yx*(this: LVecBase3f): LVecBase2f = LVecBase2f(x: this.y, y: this.x)
func yxx*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.y, y: this.x, z: this.x)
func yxxx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.x, w: this.x)
func yxxy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.x, w: this.y)
func yxxz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.x, w: this.z)
func yxy*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.y, y: this.x, z: this.y)
func yxyx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.y, w: this.x)
func yxyy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.y, w: this.y)
func yxyz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.y, w: this.z)
func yxz*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.y, y: this.x, z: this.z)
func yxzx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.z, w: this.x)
func yxzy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.z, w: this.y)
func yxzz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.z, w: this.z)
func yy*(this: LVecBase3f): LVecBase2f = LVecBase2f(x: this.y, y: this.y)
func yyx*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.y, y: this.y, z: this.x)
func yyxx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.x, w: this.x)
func yyxy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.x, w: this.y)
func yyxz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.x, w: this.z)
func yyy*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.y, y: this.y, z: this.y)
func yyyx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.y, w: this.x)
func yyyy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.y, w: this.y)
func yyyz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.y, w: this.z)
func yyz*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.y, y: this.y, z: this.z)
func yyzx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.z, w: this.x)
func yyzy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.z, w: this.y)
func yyzz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.z, w: this.z)
func yz*(this: LVecBase3f): LVecBase2f = LVecBase2f(x: this.y, y: this.z)
func yzx*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.y, y: this.z, z: this.x)
func yzxx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.x, w: this.x)
func yzxy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.x, w: this.y)
func yzxz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.x, w: this.z)
func yzy*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.y, y: this.z, z: this.y)
func yzyx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.y, w: this.x)
func yzyy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.y, w: this.y)
func yzyz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.y, w: this.z)
func yzz*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.y, y: this.z, z: this.z)
func yzzx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.z, w: this.x)
func yzzy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.z, w: this.y)
func yzzz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.z, w: this.z)
func zx*(this: LVecBase3f): LVecBase2f = LVecBase2f(x: this.z, y: this.x)
func zxx*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.z, y: this.x, z: this.x)
func zxxx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.x, w: this.x)
func zxxy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.x, w: this.y)
func zxxz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.x, w: this.z)
func zxy*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.z, y: this.x, z: this.y)
func zxyx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.y, w: this.x)
func zxyy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.y, w: this.y)
func zxyz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.y, w: this.z)
func zxz*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.z, y: this.x, z: this.z)
func zxzx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.z, w: this.x)
func zxzy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.z, w: this.y)
func zxzz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.z, w: this.z)
func zy*(this: LVecBase3f): LVecBase2f = LVecBase2f(x: this.z, y: this.y)
func zyx*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.z, y: this.y, z: this.x)
func zyxx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.x, w: this.x)
func zyxy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.x, w: this.y)
func zyxz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.x, w: this.z)
func zyy*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.z, y: this.y, z: this.y)
func zyyx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.y, w: this.x)
func zyyy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.y, w: this.y)
func zyyz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.y, w: this.z)
func zyz*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.z, y: this.y, z: this.z)
func zyzx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.z, w: this.x)
func zyzy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.z, w: this.y)
func zyzz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.z, w: this.z)
func zz*(this: LVecBase3f): LVecBase2f = LVecBase2f(x: this.z, y: this.z)
func zzx*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.z, y: this.z, z: this.x)
func zzxx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.x, w: this.x)
func zzxy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.x, w: this.y)
func zzxz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.x, w: this.z)
func zzy*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.z, y: this.z, z: this.y)
func zzyx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.y, w: this.x)
func zzyy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.y, w: this.y)
func zzyz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.y, w: this.z)
func zzz*(this: LVecBase3f): LVecBase3f = LVecBase3f(x: this.z, y: this.z, z: this.z)
func zzzx*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.z, w: this.x)
func zzzy*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.z, w: this.y)
func zzzz*(this: LVecBase3f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.z, w: this.z)

func xx*(this: LVecBase4f): LVecBase2f = LVecBase2f(x: this.x, y: this.x)
func xxx*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.x, y: this.x, z: this.x)
func xxxx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.x, w: this.x)
func xxxy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.x, w: this.y)
func xxxz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.x, w: this.z)
func xxxw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.x, w: this.w)
func xxy*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.x, y: this.x, z: this.y)
func xxyx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.y, w: this.x)
func xxyy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.y, w: this.y)
func xxyz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.y, w: this.z)
func xxyw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.y, w: this.w)
func xxz*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.x, y: this.x, z: this.z)
func xxzx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.z, w: this.x)
func xxzy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.z, w: this.y)
func xxzz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.z, w: this.z)
func xxzw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.z, w: this.w)
func xxw*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.x, y: this.x, z: this.w)
func xxwx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.w, w: this.x)
func xxwy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.w, w: this.y)
func xxwz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.w, w: this.z)
func xxww*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.x, z: this.w, w: this.w)
func xy*(this: LVecBase4f): LVecBase2f = LVecBase2f(x: this.x, y: this.y)
func xyx*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.x, y: this.y, z: this.x)
func xyxx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.x, w: this.x)
func xyxy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.x, w: this.y)
func xyxz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.x, w: this.z)
func xyxw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.x, w: this.w)
func xyy*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.x, y: this.y, z: this.y)
func xyyx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.y, w: this.x)
func xyyy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.y, w: this.y)
func xyyz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.y, w: this.z)
func xyyw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.y, w: this.w)
func xyz*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.x, y: this.y, z: this.z)
func xyzx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.z, w: this.x)
func xyzy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.z, w: this.y)
func xyzz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.z, w: this.z)
func xyzw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.z, w: this.w)
func xyw*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.x, y: this.y, z: this.w)
func xywx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.w, w: this.x)
func xywy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.w, w: this.y)
func xywz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.w, w: this.z)
func xyww*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.y, z: this.w, w: this.w)
func xz*(this: LVecBase4f): LVecBase2f = LVecBase2f(x: this.x, y: this.z)
func xzx*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.x, y: this.z, z: this.x)
func xzxx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.x, w: this.x)
func xzxy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.x, w: this.y)
func xzxz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.x, w: this.z)
func xzxw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.x, w: this.w)
func xzy*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.x, y: this.z, z: this.y)
func xzyx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.y, w: this.x)
func xzyy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.y, w: this.y)
func xzyz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.y, w: this.z)
func xzyw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.y, w: this.w)
func xzz*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.x, y: this.z, z: this.z)
func xzzx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.z, w: this.x)
func xzzy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.z, w: this.y)
func xzzz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.z, w: this.z)
func xzzw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.z, w: this.w)
func xzw*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.x, y: this.z, z: this.w)
func xzwx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.w, w: this.x)
func xzwy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.w, w: this.y)
func xzwz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.w, w: this.z)
func xzww*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.z, z: this.w, w: this.w)
func xw*(this: LVecBase4f): LVecBase2f = LVecBase2f(x: this.x, y: this.w)
func xwx*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.x, y: this.w, z: this.x)
func xwxx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.w, z: this.x, w: this.x)
func xwxy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.w, z: this.x, w: this.y)
func xwxz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.w, z: this.x, w: this.z)
func xwxw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.w, z: this.x, w: this.w)
func xwy*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.x, y: this.w, z: this.y)
func xwyx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.w, z: this.y, w: this.x)
func xwyy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.w, z: this.y, w: this.y)
func xwyz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.w, z: this.y, w: this.z)
func xwyw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.w, z: this.y, w: this.w)
func xwz*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.x, y: this.w, z: this.z)
func xwzx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.w, z: this.z, w: this.x)
func xwzy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.w, z: this.z, w: this.y)
func xwzz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.w, z: this.z, w: this.z)
func xwzw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.w, z: this.z, w: this.w)
func xww*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.x, y: this.w, z: this.w)
func xwwx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.w, z: this.w, w: this.x)
func xwwy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.w, z: this.w, w: this.y)
func xwwz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.w, z: this.w, w: this.z)
func xwww*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.x, y: this.w, z: this.w, w: this.w)
func yx*(this: LVecBase4f): LVecBase2f = LVecBase2f(x: this.y, y: this.x)
func yxx*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.y, y: this.x, z: this.x)
func yxxx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.x, w: this.x)
func yxxy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.x, w: this.y)
func yxxz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.x, w: this.z)
func yxxw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.x, w: this.w)
func yxy*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.y, y: this.x, z: this.y)
func yxyx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.y, w: this.x)
func yxyy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.y, w: this.y)
func yxyz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.y, w: this.z)
func yxyw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.y, w: this.w)
func yxz*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.y, y: this.x, z: this.z)
func yxzx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.z, w: this.x)
func yxzy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.z, w: this.y)
func yxzz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.z, w: this.z)
func yxzw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.z, w: this.w)
func yxw*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.y, y: this.x, z: this.w)
func yxwx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.w, w: this.x)
func yxwy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.w, w: this.y)
func yxwz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.w, w: this.z)
func yxww*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.x, z: this.w, w: this.w)
func yy*(this: LVecBase4f): LVecBase2f = LVecBase2f(x: this.y, y: this.y)
func yyx*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.y, y: this.y, z: this.x)
func yyxx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.x, w: this.x)
func yyxy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.x, w: this.y)
func yyxz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.x, w: this.z)
func yyxw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.x, w: this.w)
func yyy*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.y, y: this.y, z: this.y)
func yyyx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.y, w: this.x)
func yyyy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.y, w: this.y)
func yyyz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.y, w: this.z)
func yyyw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.y, w: this.w)
func yyz*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.y, y: this.y, z: this.z)
func yyzx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.z, w: this.x)
func yyzy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.z, w: this.y)
func yyzz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.z, w: this.z)
func yyzw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.z, w: this.w)
func yyw*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.y, y: this.y, z: this.w)
func yywx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.w, w: this.x)
func yywy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.w, w: this.y)
func yywz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.w, w: this.z)
func yyww*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.y, z: this.w, w: this.w)
func yz*(this: LVecBase4f): LVecBase2f = LVecBase2f(x: this.y, y: this.z)
func yzx*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.y, y: this.z, z: this.x)
func yzxx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.x, w: this.x)
func yzxy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.x, w: this.y)
func yzxz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.x, w: this.z)
func yzxw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.x, w: this.w)
func yzy*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.y, y: this.z, z: this.y)
func yzyx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.y, w: this.x)
func yzyy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.y, w: this.y)
func yzyz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.y, w: this.z)
func yzyw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.y, w: this.w)
func yzz*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.y, y: this.z, z: this.z)
func yzzx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.z, w: this.x)
func yzzy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.z, w: this.y)
func yzzz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.z, w: this.z)
func yzzw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.z, w: this.w)
func yzw*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.y, y: this.z, z: this.w)
func yzwx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.w, w: this.x)
func yzwy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.w, w: this.y)
func yzwz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.w, w: this.z)
func yzww*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.z, z: this.w, w: this.w)
func yw*(this: LVecBase4f): LVecBase2f = LVecBase2f(x: this.y, y: this.w)
func ywx*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.y, y: this.w, z: this.x)
func ywxx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.w, z: this.x, w: this.x)
func ywxy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.w, z: this.x, w: this.y)
func ywxz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.w, z: this.x, w: this.z)
func ywxw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.w, z: this.x, w: this.w)
func ywy*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.y, y: this.w, z: this.y)
func ywyx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.w, z: this.y, w: this.x)
func ywyy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.w, z: this.y, w: this.y)
func ywyz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.w, z: this.y, w: this.z)
func ywyw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.w, z: this.y, w: this.w)
func ywz*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.y, y: this.w, z: this.z)
func ywzx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.w, z: this.z, w: this.x)
func ywzy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.w, z: this.z, w: this.y)
func ywzz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.w, z: this.z, w: this.z)
func ywzw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.w, z: this.z, w: this.w)
func yww*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.y, y: this.w, z: this.w)
func ywwx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.w, z: this.w, w: this.x)
func ywwy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.w, z: this.w, w: this.y)
func ywwz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.w, z: this.w, w: this.z)
func ywww*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.y, y: this.w, z: this.w, w: this.w)
func zx*(this: LVecBase4f): LVecBase2f = LVecBase2f(x: this.z, y: this.x)
func zxx*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.z, y: this.x, z: this.x)
func zxxx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.x, w: this.x)
func zxxy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.x, w: this.y)
func zxxz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.x, w: this.z)
func zxxw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.x, w: this.w)
func zxy*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.z, y: this.x, z: this.y)
func zxyx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.y, w: this.x)
func zxyy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.y, w: this.y)
func zxyz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.y, w: this.z)
func zxyw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.y, w: this.w)
func zxz*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.z, y: this.x, z: this.z)
func zxzx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.z, w: this.x)
func zxzy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.z, w: this.y)
func zxzz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.z, w: this.z)
func zxzw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.z, w: this.w)
func zxw*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.z, y: this.x, z: this.w)
func zxwx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.w, w: this.x)
func zxwy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.w, w: this.y)
func zxwz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.w, w: this.z)
func zxww*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.x, z: this.w, w: this.w)
func zy*(this: LVecBase4f): LVecBase2f = LVecBase2f(x: this.z, y: this.y)
func zyx*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.z, y: this.y, z: this.x)
func zyxx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.x, w: this.x)
func zyxy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.x, w: this.y)
func zyxz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.x, w: this.z)
func zyxw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.x, w: this.w)
func zyy*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.z, y: this.y, z: this.y)
func zyyx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.y, w: this.x)
func zyyy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.y, w: this.y)
func zyyz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.y, w: this.z)
func zyyw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.y, w: this.w)
func zyz*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.z, y: this.y, z: this.z)
func zyzx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.z, w: this.x)
func zyzy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.z, w: this.y)
func zyzz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.z, w: this.z)
func zyzw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.z, w: this.w)
func zyw*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.z, y: this.y, z: this.w)
func zywx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.w, w: this.x)
func zywy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.w, w: this.y)
func zywz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.w, w: this.z)
func zyww*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.y, z: this.w, w: this.w)
func zz*(this: LVecBase4f): LVecBase2f = LVecBase2f(x: this.z, y: this.z)
func zzx*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.z, y: this.z, z: this.x)
func zzxx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.x, w: this.x)
func zzxy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.x, w: this.y)
func zzxz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.x, w: this.z)
func zzxw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.x, w: this.w)
func zzy*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.z, y: this.z, z: this.y)
func zzyx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.y, w: this.x)
func zzyy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.y, w: this.y)
func zzyz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.y, w: this.z)
func zzyw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.y, w: this.w)
func zzz*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.z, y: this.z, z: this.z)
func zzzx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.z, w: this.x)
func zzzy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.z, w: this.y)
func zzzz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.z, w: this.z)
func zzzw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.z, w: this.w)
func zzw*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.z, y: this.z, z: this.w)
func zzwx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.w, w: this.x)
func zzwy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.w, w: this.y)
func zzwz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.w, w: this.z)
func zzww*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.z, z: this.w, w: this.w)
func zw*(this: LVecBase4f): LVecBase2f = LVecBase2f(x: this.z, y: this.w)
func zwx*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.z, y: this.w, z: this.x)
func zwxx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.w, z: this.x, w: this.x)
func zwxy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.w, z: this.x, w: this.y)
func zwxz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.w, z: this.x, w: this.z)
func zwxw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.w, z: this.x, w: this.w)
func zwy*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.z, y: this.w, z: this.y)
func zwyx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.w, z: this.y, w: this.x)
func zwyy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.w, z: this.y, w: this.y)
func zwyz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.w, z: this.y, w: this.z)
func zwyw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.w, z: this.y, w: this.w)
func zwz*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.z, y: this.w, z: this.z)
func zwzx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.w, z: this.z, w: this.x)
func zwzy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.w, z: this.z, w: this.y)
func zwzz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.w, z: this.z, w: this.z)
func zwzw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.w, z: this.z, w: this.w)
func zww*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.z, y: this.w, z: this.w)
func zwwx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.w, z: this.w, w: this.x)
func zwwy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.w, z: this.w, w: this.y)
func zwwz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.w, z: this.w, w: this.z)
func zwww*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.z, y: this.w, z: this.w, w: this.w)
func wx*(this: LVecBase4f): LVecBase2f = LVecBase2f(x: this.w, y: this.x)
func wxx*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.w, y: this.x, z: this.x)
func wxxx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.x, z: this.x, w: this.x)
func wxxy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.x, z: this.x, w: this.y)
func wxxz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.x, z: this.x, w: this.z)
func wxxw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.x, z: this.x, w: this.w)
func wxy*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.w, y: this.x, z: this.y)
func wxyx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.x, z: this.y, w: this.x)
func wxyy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.x, z: this.y, w: this.y)
func wxyz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.x, z: this.y, w: this.z)
func wxyw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.x, z: this.y, w: this.w)
func wxz*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.w, y: this.x, z: this.z)
func wxzx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.x, z: this.z, w: this.x)
func wxzy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.x, z: this.z, w: this.y)
func wxzz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.x, z: this.z, w: this.z)
func wxzw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.x, z: this.z, w: this.w)
func wxw*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.w, y: this.x, z: this.w)
func wxwx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.x, z: this.w, w: this.x)
func wxwy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.x, z: this.w, w: this.y)
func wxwz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.x, z: this.w, w: this.z)
func wxww*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.x, z: this.w, w: this.w)
func wy*(this: LVecBase4f): LVecBase2f = LVecBase2f(x: this.w, y: this.y)
func wyx*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.w, y: this.y, z: this.x)
func wyxx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.y, z: this.x, w: this.x)
func wyxy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.y, z: this.x, w: this.y)
func wyxz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.y, z: this.x, w: this.z)
func wyxw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.y, z: this.x, w: this.w)
func wyy*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.w, y: this.y, z: this.y)
func wyyx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.y, z: this.y, w: this.x)
func wyyy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.y, z: this.y, w: this.y)
func wyyz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.y, z: this.y, w: this.z)
func wyyw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.y, z: this.y, w: this.w)
func wyz*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.w, y: this.y, z: this.z)
func wyzx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.y, z: this.z, w: this.x)
func wyzy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.y, z: this.z, w: this.y)
func wyzz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.y, z: this.z, w: this.z)
func wyzw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.y, z: this.z, w: this.w)
func wyw*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.w, y: this.y, z: this.w)
func wywx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.y, z: this.w, w: this.x)
func wywy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.y, z: this.w, w: this.y)
func wywz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.y, z: this.w, w: this.z)
func wyww*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.y, z: this.w, w: this.w)
func wz*(this: LVecBase4f): LVecBase2f = LVecBase2f(x: this.w, y: this.z)
func wzx*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.w, y: this.z, z: this.x)
func wzxx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.z, z: this.x, w: this.x)
func wzxy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.z, z: this.x, w: this.y)
func wzxz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.z, z: this.x, w: this.z)
func wzxw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.z, z: this.x, w: this.w)
func wzy*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.w, y: this.z, z: this.y)
func wzyx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.z, z: this.y, w: this.x)
func wzyy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.z, z: this.y, w: this.y)
func wzyz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.z, z: this.y, w: this.z)
func wzyw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.z, z: this.y, w: this.w)
func wzz*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.w, y: this.z, z: this.z)
func wzzx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.z, z: this.z, w: this.x)
func wzzy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.z, z: this.z, w: this.y)
func wzzz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.z, z: this.z, w: this.z)
func wzzw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.z, z: this.z, w: this.w)
func wzw*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.w, y: this.z, z: this.w)
func wzwx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.z, z: this.w, w: this.x)
func wzwy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.z, z: this.w, w: this.y)
func wzwz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.z, z: this.w, w: this.z)
func wzww*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.z, z: this.w, w: this.w)
func ww*(this: LVecBase4f): LVecBase2f = LVecBase2f(x: this.w, y: this.w)
func wwx*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.w, y: this.w, z: this.x)
func wwxx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.w, z: this.x, w: this.x)
func wwxy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.w, z: this.x, w: this.y)
func wwxz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.w, z: this.x, w: this.z)
func wwxw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.w, z: this.x, w: this.w)
func wwy*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.w, y: this.w, z: this.y)
func wwyx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.w, z: this.y, w: this.x)
func wwyy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.w, z: this.y, w: this.y)
func wwyz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.w, z: this.y, w: this.z)
func wwyw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.w, z: this.y, w: this.w)
func wwz*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.w, y: this.w, z: this.z)
func wwzx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.w, z: this.z, w: this.x)
func wwzy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.w, z: this.z, w: this.y)
func wwzz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.w, z: this.z, w: this.z)
func wwzw*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.w, z: this.z, w: this.w)
func www*(this: LVecBase4f): LVecBase3f = LVecBase3f(x: this.w, y: this.w, z: this.w)
func wwwx*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.w, z: this.w, w: this.x)
func wwwy*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.w, z: this.w, w: this.y)
func wwwz*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.w, z: this.w, w: this.z)
func wwww*(this: LVecBase4f): LVecBase4f = LVecBase4f(x: this.w, y: this.w, z: this.w, w: this.w)

func xx*(this: LVecBase2d): LVecBase2d = LVecBase2d(x: this.x, y: this.x)
func xxx*(this: LVecBase2d): LVecBase3d = LVecBase3d(x: this.x, y: this.x, z: this.x)
func xxxx*(this: LVecBase2d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.x, w: this.x)
func xxxy*(this: LVecBase2d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.x, w: this.y)
func xxy*(this: LVecBase2d): LVecBase3d = LVecBase3d(x: this.x, y: this.x, z: this.y)
func xxyx*(this: LVecBase2d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.y, w: this.x)
func xxyy*(this: LVecBase2d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.y, w: this.y)
func xy*(this: LVecBase2d): LVecBase2d = LVecBase2d(x: this.x, y: this.y)
func xyx*(this: LVecBase2d): LVecBase3d = LVecBase3d(x: this.x, y: this.y, z: this.x)
func xyxx*(this: LVecBase2d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.x, w: this.x)
func xyxy*(this: LVecBase2d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.x, w: this.y)
func xyy*(this: LVecBase2d): LVecBase3d = LVecBase3d(x: this.x, y: this.y, z: this.y)
func xyyx*(this: LVecBase2d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.y, w: this.x)
func xyyy*(this: LVecBase2d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.y, w: this.y)
func yx*(this: LVecBase2d): LVecBase2d = LVecBase2d(x: this.y, y: this.x)
func yxx*(this: LVecBase2d): LVecBase3d = LVecBase3d(x: this.y, y: this.x, z: this.x)
func yxxx*(this: LVecBase2d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.x, w: this.x)
func yxxy*(this: LVecBase2d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.x, w: this.y)
func yxy*(this: LVecBase2d): LVecBase3d = LVecBase3d(x: this.y, y: this.x, z: this.y)
func yxyx*(this: LVecBase2d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.y, w: this.x)
func yxyy*(this: LVecBase2d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.y, w: this.y)
func yy*(this: LVecBase2d): LVecBase2d = LVecBase2d(x: this.y, y: this.y)
func yyx*(this: LVecBase2d): LVecBase3d = LVecBase3d(x: this.y, y: this.y, z: this.x)
func yyxx*(this: LVecBase2d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.x, w: this.x)
func yyxy*(this: LVecBase2d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.x, w: this.y)
func yyy*(this: LVecBase2d): LVecBase3d = LVecBase3d(x: this.y, y: this.y, z: this.y)
func yyyx*(this: LVecBase2d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.y, w: this.x)
func yyyy*(this: LVecBase2d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.y, w: this.y)

func xx*(this: LVecBase3d): LVecBase2d = LVecBase2d(x: this.x, y: this.x)
func xxx*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.x, y: this.x, z: this.x)
func xxxx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.x, w: this.x)
func xxxy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.x, w: this.y)
func xxxz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.x, w: this.z)
func xxy*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.x, y: this.x, z: this.y)
func xxyx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.y, w: this.x)
func xxyy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.y, w: this.y)
func xxyz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.y, w: this.z)
func xxz*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.x, y: this.x, z: this.z)
func xxzx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.z, w: this.x)
func xxzy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.z, w: this.y)
func xxzz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.z, w: this.z)
func xy*(this: LVecBase3d): LVecBase2d = LVecBase2d(x: this.x, y: this.y)
func xyx*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.x, y: this.y, z: this.x)
func xyxx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.x, w: this.x)
func xyxy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.x, w: this.y)
func xyxz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.x, w: this.z)
func xyy*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.x, y: this.y, z: this.y)
func xyyx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.y, w: this.x)
func xyyy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.y, w: this.y)
func xyyz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.y, w: this.z)
func xyz*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.x, y: this.y, z: this.z)
func xyzx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.z, w: this.x)
func xyzy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.z, w: this.y)
func xyzz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.z, w: this.z)
func xz*(this: LVecBase3d): LVecBase2d = LVecBase2d(x: this.x, y: this.z)
func xzx*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.x, y: this.z, z: this.x)
func xzxx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.x, w: this.x)
func xzxy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.x, w: this.y)
func xzxz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.x, w: this.z)
func xzy*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.x, y: this.z, z: this.y)
func xzyx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.y, w: this.x)
func xzyy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.y, w: this.y)
func xzyz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.y, w: this.z)
func xzz*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.x, y: this.z, z: this.z)
func xzzx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.z, w: this.x)
func xzzy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.z, w: this.y)
func xzzz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.z, w: this.z)
func yx*(this: LVecBase3d): LVecBase2d = LVecBase2d(x: this.y, y: this.x)
func yxx*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.y, y: this.x, z: this.x)
func yxxx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.x, w: this.x)
func yxxy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.x, w: this.y)
func yxxz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.x, w: this.z)
func yxy*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.y, y: this.x, z: this.y)
func yxyx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.y, w: this.x)
func yxyy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.y, w: this.y)
func yxyz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.y, w: this.z)
func yxz*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.y, y: this.x, z: this.z)
func yxzx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.z, w: this.x)
func yxzy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.z, w: this.y)
func yxzz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.z, w: this.z)
func yy*(this: LVecBase3d): LVecBase2d = LVecBase2d(x: this.y, y: this.y)
func yyx*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.y, y: this.y, z: this.x)
func yyxx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.x, w: this.x)
func yyxy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.x, w: this.y)
func yyxz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.x, w: this.z)
func yyy*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.y, y: this.y, z: this.y)
func yyyx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.y, w: this.x)
func yyyy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.y, w: this.y)
func yyyz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.y, w: this.z)
func yyz*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.y, y: this.y, z: this.z)
func yyzx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.z, w: this.x)
func yyzy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.z, w: this.y)
func yyzz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.z, w: this.z)
func yz*(this: LVecBase3d): LVecBase2d = LVecBase2d(x: this.y, y: this.z)
func yzx*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.y, y: this.z, z: this.x)
func yzxx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.x, w: this.x)
func yzxy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.x, w: this.y)
func yzxz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.x, w: this.z)
func yzy*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.y, y: this.z, z: this.y)
func yzyx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.y, w: this.x)
func yzyy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.y, w: this.y)
func yzyz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.y, w: this.z)
func yzz*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.y, y: this.z, z: this.z)
func yzzx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.z, w: this.x)
func yzzy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.z, w: this.y)
func yzzz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.z, w: this.z)
func zx*(this: LVecBase3d): LVecBase2d = LVecBase2d(x: this.z, y: this.x)
func zxx*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.z, y: this.x, z: this.x)
func zxxx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.x, w: this.x)
func zxxy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.x, w: this.y)
func zxxz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.x, w: this.z)
func zxy*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.z, y: this.x, z: this.y)
func zxyx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.y, w: this.x)
func zxyy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.y, w: this.y)
func zxyz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.y, w: this.z)
func zxz*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.z, y: this.x, z: this.z)
func zxzx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.z, w: this.x)
func zxzy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.z, w: this.y)
func zxzz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.z, w: this.z)
func zy*(this: LVecBase3d): LVecBase2d = LVecBase2d(x: this.z, y: this.y)
func zyx*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.z, y: this.y, z: this.x)
func zyxx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.x, w: this.x)
func zyxy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.x, w: this.y)
func zyxz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.x, w: this.z)
func zyy*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.z, y: this.y, z: this.y)
func zyyx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.y, w: this.x)
func zyyy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.y, w: this.y)
func zyyz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.y, w: this.z)
func zyz*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.z, y: this.y, z: this.z)
func zyzx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.z, w: this.x)
func zyzy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.z, w: this.y)
func zyzz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.z, w: this.z)
func zz*(this: LVecBase3d): LVecBase2d = LVecBase2d(x: this.z, y: this.z)
func zzx*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.z, y: this.z, z: this.x)
func zzxx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.x, w: this.x)
func zzxy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.x, w: this.y)
func zzxz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.x, w: this.z)
func zzy*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.z, y: this.z, z: this.y)
func zzyx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.y, w: this.x)
func zzyy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.y, w: this.y)
func zzyz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.y, w: this.z)
func zzz*(this: LVecBase3d): LVecBase3d = LVecBase3d(x: this.z, y: this.z, z: this.z)
func zzzx*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.z, w: this.x)
func zzzy*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.z, w: this.y)
func zzzz*(this: LVecBase3d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.z, w: this.z)

func xx*(this: LVecBase4d): LVecBase2d = LVecBase2d(x: this.x, y: this.x)
func xxx*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.x, y: this.x, z: this.x)
func xxxx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.x, w: this.x)
func xxxy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.x, w: this.y)
func xxxz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.x, w: this.z)
func xxxw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.x, w: this.w)
func xxy*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.x, y: this.x, z: this.y)
func xxyx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.y, w: this.x)
func xxyy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.y, w: this.y)
func xxyz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.y, w: this.z)
func xxyw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.y, w: this.w)
func xxz*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.x, y: this.x, z: this.z)
func xxzx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.z, w: this.x)
func xxzy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.z, w: this.y)
func xxzz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.z, w: this.z)
func xxzw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.z, w: this.w)
func xxw*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.x, y: this.x, z: this.w)
func xxwx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.w, w: this.x)
func xxwy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.w, w: this.y)
func xxwz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.w, w: this.z)
func xxww*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.x, z: this.w, w: this.w)
func xy*(this: LVecBase4d): LVecBase2d = LVecBase2d(x: this.x, y: this.y)
func xyx*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.x, y: this.y, z: this.x)
func xyxx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.x, w: this.x)
func xyxy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.x, w: this.y)
func xyxz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.x, w: this.z)
func xyxw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.x, w: this.w)
func xyy*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.x, y: this.y, z: this.y)
func xyyx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.y, w: this.x)
func xyyy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.y, w: this.y)
func xyyz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.y, w: this.z)
func xyyw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.y, w: this.w)
func xyz*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.x, y: this.y, z: this.z)
func xyzx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.z, w: this.x)
func xyzy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.z, w: this.y)
func xyzz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.z, w: this.z)
func xyzw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.z, w: this.w)
func xyw*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.x, y: this.y, z: this.w)
func xywx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.w, w: this.x)
func xywy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.w, w: this.y)
func xywz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.w, w: this.z)
func xyww*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.y, z: this.w, w: this.w)
func xz*(this: LVecBase4d): LVecBase2d = LVecBase2d(x: this.x, y: this.z)
func xzx*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.x, y: this.z, z: this.x)
func xzxx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.x, w: this.x)
func xzxy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.x, w: this.y)
func xzxz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.x, w: this.z)
func xzxw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.x, w: this.w)
func xzy*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.x, y: this.z, z: this.y)
func xzyx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.y, w: this.x)
func xzyy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.y, w: this.y)
func xzyz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.y, w: this.z)
func xzyw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.y, w: this.w)
func xzz*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.x, y: this.z, z: this.z)
func xzzx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.z, w: this.x)
func xzzy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.z, w: this.y)
func xzzz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.z, w: this.z)
func xzzw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.z, w: this.w)
func xzw*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.x, y: this.z, z: this.w)
func xzwx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.w, w: this.x)
func xzwy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.w, w: this.y)
func xzwz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.w, w: this.z)
func xzww*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.z, z: this.w, w: this.w)
func xw*(this: LVecBase4d): LVecBase2d = LVecBase2d(x: this.x, y: this.w)
func xwx*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.x, y: this.w, z: this.x)
func xwxx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.w, z: this.x, w: this.x)
func xwxy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.w, z: this.x, w: this.y)
func xwxz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.w, z: this.x, w: this.z)
func xwxw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.w, z: this.x, w: this.w)
func xwy*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.x, y: this.w, z: this.y)
func xwyx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.w, z: this.y, w: this.x)
func xwyy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.w, z: this.y, w: this.y)
func xwyz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.w, z: this.y, w: this.z)
func xwyw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.w, z: this.y, w: this.w)
func xwz*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.x, y: this.w, z: this.z)
func xwzx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.w, z: this.z, w: this.x)
func xwzy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.w, z: this.z, w: this.y)
func xwzz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.w, z: this.z, w: this.z)
func xwzw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.w, z: this.z, w: this.w)
func xww*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.x, y: this.w, z: this.w)
func xwwx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.w, z: this.w, w: this.x)
func xwwy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.w, z: this.w, w: this.y)
func xwwz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.w, z: this.w, w: this.z)
func xwww*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.x, y: this.w, z: this.w, w: this.w)
func yx*(this: LVecBase4d): LVecBase2d = LVecBase2d(x: this.y, y: this.x)
func yxx*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.y, y: this.x, z: this.x)
func yxxx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.x, w: this.x)
func yxxy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.x, w: this.y)
func yxxz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.x, w: this.z)
func yxxw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.x, w: this.w)
func yxy*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.y, y: this.x, z: this.y)
func yxyx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.y, w: this.x)
func yxyy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.y, w: this.y)
func yxyz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.y, w: this.z)
func yxyw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.y, w: this.w)
func yxz*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.y, y: this.x, z: this.z)
func yxzx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.z, w: this.x)
func yxzy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.z, w: this.y)
func yxzz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.z, w: this.z)
func yxzw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.z, w: this.w)
func yxw*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.y, y: this.x, z: this.w)
func yxwx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.w, w: this.x)
func yxwy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.w, w: this.y)
func yxwz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.w, w: this.z)
func yxww*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.x, z: this.w, w: this.w)
func yy*(this: LVecBase4d): LVecBase2d = LVecBase2d(x: this.y, y: this.y)
func yyx*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.y, y: this.y, z: this.x)
func yyxx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.x, w: this.x)
func yyxy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.x, w: this.y)
func yyxz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.x, w: this.z)
func yyxw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.x, w: this.w)
func yyy*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.y, y: this.y, z: this.y)
func yyyx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.y, w: this.x)
func yyyy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.y, w: this.y)
func yyyz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.y, w: this.z)
func yyyw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.y, w: this.w)
func yyz*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.y, y: this.y, z: this.z)
func yyzx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.z, w: this.x)
func yyzy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.z, w: this.y)
func yyzz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.z, w: this.z)
func yyzw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.z, w: this.w)
func yyw*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.y, y: this.y, z: this.w)
func yywx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.w, w: this.x)
func yywy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.w, w: this.y)
func yywz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.w, w: this.z)
func yyww*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.y, z: this.w, w: this.w)
func yz*(this: LVecBase4d): LVecBase2d = LVecBase2d(x: this.y, y: this.z)
func yzx*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.y, y: this.z, z: this.x)
func yzxx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.x, w: this.x)
func yzxy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.x, w: this.y)
func yzxz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.x, w: this.z)
func yzxw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.x, w: this.w)
func yzy*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.y, y: this.z, z: this.y)
func yzyx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.y, w: this.x)
func yzyy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.y, w: this.y)
func yzyz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.y, w: this.z)
func yzyw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.y, w: this.w)
func yzz*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.y, y: this.z, z: this.z)
func yzzx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.z, w: this.x)
func yzzy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.z, w: this.y)
func yzzz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.z, w: this.z)
func yzzw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.z, w: this.w)
func yzw*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.y, y: this.z, z: this.w)
func yzwx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.w, w: this.x)
func yzwy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.w, w: this.y)
func yzwz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.w, w: this.z)
func yzww*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.z, z: this.w, w: this.w)
func yw*(this: LVecBase4d): LVecBase2d = LVecBase2d(x: this.y, y: this.w)
func ywx*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.y, y: this.w, z: this.x)
func ywxx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.w, z: this.x, w: this.x)
func ywxy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.w, z: this.x, w: this.y)
func ywxz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.w, z: this.x, w: this.z)
func ywxw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.w, z: this.x, w: this.w)
func ywy*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.y, y: this.w, z: this.y)
func ywyx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.w, z: this.y, w: this.x)
func ywyy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.w, z: this.y, w: this.y)
func ywyz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.w, z: this.y, w: this.z)
func ywyw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.w, z: this.y, w: this.w)
func ywz*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.y, y: this.w, z: this.z)
func ywzx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.w, z: this.z, w: this.x)
func ywzy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.w, z: this.z, w: this.y)
func ywzz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.w, z: this.z, w: this.z)
func ywzw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.w, z: this.z, w: this.w)
func yww*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.y, y: this.w, z: this.w)
func ywwx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.w, z: this.w, w: this.x)
func ywwy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.w, z: this.w, w: this.y)
func ywwz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.w, z: this.w, w: this.z)
func ywww*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.y, y: this.w, z: this.w, w: this.w)
func zx*(this: LVecBase4d): LVecBase2d = LVecBase2d(x: this.z, y: this.x)
func zxx*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.z, y: this.x, z: this.x)
func zxxx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.x, w: this.x)
func zxxy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.x, w: this.y)
func zxxz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.x, w: this.z)
func zxxw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.x, w: this.w)
func zxy*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.z, y: this.x, z: this.y)
func zxyx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.y, w: this.x)
func zxyy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.y, w: this.y)
func zxyz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.y, w: this.z)
func zxyw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.y, w: this.w)
func zxz*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.z, y: this.x, z: this.z)
func zxzx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.z, w: this.x)
func zxzy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.z, w: this.y)
func zxzz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.z, w: this.z)
func zxzw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.z, w: this.w)
func zxw*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.z, y: this.x, z: this.w)
func zxwx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.w, w: this.x)
func zxwy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.w, w: this.y)
func zxwz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.w, w: this.z)
func zxww*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.x, z: this.w, w: this.w)
func zy*(this: LVecBase4d): LVecBase2d = LVecBase2d(x: this.z, y: this.y)
func zyx*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.z, y: this.y, z: this.x)
func zyxx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.x, w: this.x)
func zyxy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.x, w: this.y)
func zyxz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.x, w: this.z)
func zyxw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.x, w: this.w)
func zyy*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.z, y: this.y, z: this.y)
func zyyx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.y, w: this.x)
func zyyy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.y, w: this.y)
func zyyz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.y, w: this.z)
func zyyw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.y, w: this.w)
func zyz*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.z, y: this.y, z: this.z)
func zyzx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.z, w: this.x)
func zyzy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.z, w: this.y)
func zyzz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.z, w: this.z)
func zyzw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.z, w: this.w)
func zyw*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.z, y: this.y, z: this.w)
func zywx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.w, w: this.x)
func zywy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.w, w: this.y)
func zywz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.w, w: this.z)
func zyww*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.y, z: this.w, w: this.w)
func zz*(this: LVecBase4d): LVecBase2d = LVecBase2d(x: this.z, y: this.z)
func zzx*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.z, y: this.z, z: this.x)
func zzxx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.x, w: this.x)
func zzxy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.x, w: this.y)
func zzxz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.x, w: this.z)
func zzxw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.x, w: this.w)
func zzy*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.z, y: this.z, z: this.y)
func zzyx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.y, w: this.x)
func zzyy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.y, w: this.y)
func zzyz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.y, w: this.z)
func zzyw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.y, w: this.w)
func zzz*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.z, y: this.z, z: this.z)
func zzzx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.z, w: this.x)
func zzzy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.z, w: this.y)
func zzzz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.z, w: this.z)
func zzzw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.z, w: this.w)
func zzw*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.z, y: this.z, z: this.w)
func zzwx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.w, w: this.x)
func zzwy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.w, w: this.y)
func zzwz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.w, w: this.z)
func zzww*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.z, z: this.w, w: this.w)
func zw*(this: LVecBase4d): LVecBase2d = LVecBase2d(x: this.z, y: this.w)
func zwx*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.z, y: this.w, z: this.x)
func zwxx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.w, z: this.x, w: this.x)
func zwxy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.w, z: this.x, w: this.y)
func zwxz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.w, z: this.x, w: this.z)
func zwxw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.w, z: this.x, w: this.w)
func zwy*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.z, y: this.w, z: this.y)
func zwyx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.w, z: this.y, w: this.x)
func zwyy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.w, z: this.y, w: this.y)
func zwyz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.w, z: this.y, w: this.z)
func zwyw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.w, z: this.y, w: this.w)
func zwz*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.z, y: this.w, z: this.z)
func zwzx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.w, z: this.z, w: this.x)
func zwzy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.w, z: this.z, w: this.y)
func zwzz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.w, z: this.z, w: this.z)
func zwzw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.w, z: this.z, w: this.w)
func zww*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.z, y: this.w, z: this.w)
func zwwx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.w, z: this.w, w: this.x)
func zwwy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.w, z: this.w, w: this.y)
func zwwz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.w, z: this.w, w: this.z)
func zwww*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.z, y: this.w, z: this.w, w: this.w)
func wx*(this: LVecBase4d): LVecBase2d = LVecBase2d(x: this.w, y: this.x)
func wxx*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.w, y: this.x, z: this.x)
func wxxx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.x, z: this.x, w: this.x)
func wxxy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.x, z: this.x, w: this.y)
func wxxz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.x, z: this.x, w: this.z)
func wxxw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.x, z: this.x, w: this.w)
func wxy*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.w, y: this.x, z: this.y)
func wxyx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.x, z: this.y, w: this.x)
func wxyy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.x, z: this.y, w: this.y)
func wxyz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.x, z: this.y, w: this.z)
func wxyw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.x, z: this.y, w: this.w)
func wxz*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.w, y: this.x, z: this.z)
func wxzx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.x, z: this.z, w: this.x)
func wxzy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.x, z: this.z, w: this.y)
func wxzz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.x, z: this.z, w: this.z)
func wxzw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.x, z: this.z, w: this.w)
func wxw*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.w, y: this.x, z: this.w)
func wxwx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.x, z: this.w, w: this.x)
func wxwy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.x, z: this.w, w: this.y)
func wxwz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.x, z: this.w, w: this.z)
func wxww*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.x, z: this.w, w: this.w)
func wy*(this: LVecBase4d): LVecBase2d = LVecBase2d(x: this.w, y: this.y)
func wyx*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.w, y: this.y, z: this.x)
func wyxx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.y, z: this.x, w: this.x)
func wyxy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.y, z: this.x, w: this.y)
func wyxz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.y, z: this.x, w: this.z)
func wyxw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.y, z: this.x, w: this.w)
func wyy*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.w, y: this.y, z: this.y)
func wyyx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.y, z: this.y, w: this.x)
func wyyy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.y, z: this.y, w: this.y)
func wyyz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.y, z: this.y, w: this.z)
func wyyw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.y, z: this.y, w: this.w)
func wyz*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.w, y: this.y, z: this.z)
func wyzx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.y, z: this.z, w: this.x)
func wyzy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.y, z: this.z, w: this.y)
func wyzz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.y, z: this.z, w: this.z)
func wyzw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.y, z: this.z, w: this.w)
func wyw*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.w, y: this.y, z: this.w)
func wywx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.y, z: this.w, w: this.x)
func wywy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.y, z: this.w, w: this.y)
func wywz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.y, z: this.w, w: this.z)
func wyww*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.y, z: this.w, w: this.w)
func wz*(this: LVecBase4d): LVecBase2d = LVecBase2d(x: this.w, y: this.z)
func wzx*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.w, y: this.z, z: this.x)
func wzxx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.z, z: this.x, w: this.x)
func wzxy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.z, z: this.x, w: this.y)
func wzxz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.z, z: this.x, w: this.z)
func wzxw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.z, z: this.x, w: this.w)
func wzy*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.w, y: this.z, z: this.y)
func wzyx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.z, z: this.y, w: this.x)
func wzyy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.z, z: this.y, w: this.y)
func wzyz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.z, z: this.y, w: this.z)
func wzyw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.z, z: this.y, w: this.w)
func wzz*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.w, y: this.z, z: this.z)
func wzzx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.z, z: this.z, w: this.x)
func wzzy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.z, z: this.z, w: this.y)
func wzzz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.z, z: this.z, w: this.z)
func wzzw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.z, z: this.z, w: this.w)
func wzw*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.w, y: this.z, z: this.w)
func wzwx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.z, z: this.w, w: this.x)
func wzwy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.z, z: this.w, w: this.y)
func wzwz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.z, z: this.w, w: this.z)
func wzww*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.z, z: this.w, w: this.w)
func ww*(this: LVecBase4d): LVecBase2d = LVecBase2d(x: this.w, y: this.w)
func wwx*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.w, y: this.w, z: this.x)
func wwxx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.w, z: this.x, w: this.x)
func wwxy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.w, z: this.x, w: this.y)
func wwxz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.w, z: this.x, w: this.z)
func wwxw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.w, z: this.x, w: this.w)
func wwy*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.w, y: this.w, z: this.y)
func wwyx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.w, z: this.y, w: this.x)
func wwyy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.w, z: this.y, w: this.y)
func wwyz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.w, z: this.y, w: this.z)
func wwyw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.w, z: this.y, w: this.w)
func wwz*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.w, y: this.w, z: this.z)
func wwzx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.w, z: this.z, w: this.x)
func wwzy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.w, z: this.z, w: this.y)
func wwzz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.w, z: this.z, w: this.z)
func wwzw*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.w, z: this.z, w: this.w)
func www*(this: LVecBase4d): LVecBase3d = LVecBase3d(x: this.w, y: this.w, z: this.w)
func wwwx*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.w, z: this.w, w: this.x)
func wwwy*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.w, z: this.w, w: this.y)
func wwwz*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.w, z: this.w, w: this.z)
func wwww*(this: LVecBase4d): LVecBase4d = LVecBase4d(x: this.w, y: this.w, z: this.w, w: this.w)

func xx*(this: LVecBase2i): LVecBase2i = LVecBase2i(x: this.x, y: this.x)
func xxx*(this: LVecBase2i): LVecBase3i = LVecBase3i(x: this.x, y: this.x, z: this.x)
func xxxx*(this: LVecBase2i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.x, w: this.x)
func xxxy*(this: LVecBase2i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.x, w: this.y)
func xxy*(this: LVecBase2i): LVecBase3i = LVecBase3i(x: this.x, y: this.x, z: this.y)
func xxyx*(this: LVecBase2i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.y, w: this.x)
func xxyy*(this: LVecBase2i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.y, w: this.y)
func xy*(this: LVecBase2i): LVecBase2i = LVecBase2i(x: this.x, y: this.y)
func xyx*(this: LVecBase2i): LVecBase3i = LVecBase3i(x: this.x, y: this.y, z: this.x)
func xyxx*(this: LVecBase2i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.x, w: this.x)
func xyxy*(this: LVecBase2i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.x, w: this.y)
func xyy*(this: LVecBase2i): LVecBase3i = LVecBase3i(x: this.x, y: this.y, z: this.y)
func xyyx*(this: LVecBase2i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.y, w: this.x)
func xyyy*(this: LVecBase2i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.y, w: this.y)
func yx*(this: LVecBase2i): LVecBase2i = LVecBase2i(x: this.y, y: this.x)
func yxx*(this: LVecBase2i): LVecBase3i = LVecBase3i(x: this.y, y: this.x, z: this.x)
func yxxx*(this: LVecBase2i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.x, w: this.x)
func yxxy*(this: LVecBase2i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.x, w: this.y)
func yxy*(this: LVecBase2i): LVecBase3i = LVecBase3i(x: this.y, y: this.x, z: this.y)
func yxyx*(this: LVecBase2i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.y, w: this.x)
func yxyy*(this: LVecBase2i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.y, w: this.y)
func yy*(this: LVecBase2i): LVecBase2i = LVecBase2i(x: this.y, y: this.y)
func yyx*(this: LVecBase2i): LVecBase3i = LVecBase3i(x: this.y, y: this.y, z: this.x)
func yyxx*(this: LVecBase2i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.x, w: this.x)
func yyxy*(this: LVecBase2i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.x, w: this.y)
func yyy*(this: LVecBase2i): LVecBase3i = LVecBase3i(x: this.y, y: this.y, z: this.y)
func yyyx*(this: LVecBase2i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.y, w: this.x)
func yyyy*(this: LVecBase2i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.y, w: this.y)

func xx*(this: LVecBase3i): LVecBase2i = LVecBase2i(x: this.x, y: this.x)
func xxx*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.x, y: this.x, z: this.x)
func xxxx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.x, w: this.x)
func xxxy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.x, w: this.y)
func xxxz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.x, w: this.z)
func xxy*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.x, y: this.x, z: this.y)
func xxyx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.y, w: this.x)
func xxyy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.y, w: this.y)
func xxyz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.y, w: this.z)
func xxz*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.x, y: this.x, z: this.z)
func xxzx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.z, w: this.x)
func xxzy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.z, w: this.y)
func xxzz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.z, w: this.z)
func xy*(this: LVecBase3i): LVecBase2i = LVecBase2i(x: this.x, y: this.y)
func xyx*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.x, y: this.y, z: this.x)
func xyxx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.x, w: this.x)
func xyxy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.x, w: this.y)
func xyxz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.x, w: this.z)
func xyy*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.x, y: this.y, z: this.y)
func xyyx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.y, w: this.x)
func xyyy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.y, w: this.y)
func xyyz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.y, w: this.z)
func xyz*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.x, y: this.y, z: this.z)
func xyzx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.z, w: this.x)
func xyzy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.z, w: this.y)
func xyzz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.z, w: this.z)
func xz*(this: LVecBase3i): LVecBase2i = LVecBase2i(x: this.x, y: this.z)
func xzx*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.x, y: this.z, z: this.x)
func xzxx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.x, w: this.x)
func xzxy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.x, w: this.y)
func xzxz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.x, w: this.z)
func xzy*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.x, y: this.z, z: this.y)
func xzyx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.y, w: this.x)
func xzyy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.y, w: this.y)
func xzyz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.y, w: this.z)
func xzz*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.x, y: this.z, z: this.z)
func xzzx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.z, w: this.x)
func xzzy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.z, w: this.y)
func xzzz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.z, w: this.z)
func yx*(this: LVecBase3i): LVecBase2i = LVecBase2i(x: this.y, y: this.x)
func yxx*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.y, y: this.x, z: this.x)
func yxxx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.x, w: this.x)
func yxxy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.x, w: this.y)
func yxxz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.x, w: this.z)
func yxy*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.y, y: this.x, z: this.y)
func yxyx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.y, w: this.x)
func yxyy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.y, w: this.y)
func yxyz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.y, w: this.z)
func yxz*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.y, y: this.x, z: this.z)
func yxzx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.z, w: this.x)
func yxzy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.z, w: this.y)
func yxzz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.z, w: this.z)
func yy*(this: LVecBase3i): LVecBase2i = LVecBase2i(x: this.y, y: this.y)
func yyx*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.y, y: this.y, z: this.x)
func yyxx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.x, w: this.x)
func yyxy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.x, w: this.y)
func yyxz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.x, w: this.z)
func yyy*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.y, y: this.y, z: this.y)
func yyyx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.y, w: this.x)
func yyyy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.y, w: this.y)
func yyyz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.y, w: this.z)
func yyz*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.y, y: this.y, z: this.z)
func yyzx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.z, w: this.x)
func yyzy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.z, w: this.y)
func yyzz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.z, w: this.z)
func yz*(this: LVecBase3i): LVecBase2i = LVecBase2i(x: this.y, y: this.z)
func yzx*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.y, y: this.z, z: this.x)
func yzxx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.x, w: this.x)
func yzxy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.x, w: this.y)
func yzxz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.x, w: this.z)
func yzy*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.y, y: this.z, z: this.y)
func yzyx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.y, w: this.x)
func yzyy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.y, w: this.y)
func yzyz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.y, w: this.z)
func yzz*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.y, y: this.z, z: this.z)
func yzzx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.z, w: this.x)
func yzzy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.z, w: this.y)
func yzzz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.z, w: this.z)
func zx*(this: LVecBase3i): LVecBase2i = LVecBase2i(x: this.z, y: this.x)
func zxx*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.z, y: this.x, z: this.x)
func zxxx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.x, w: this.x)
func zxxy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.x, w: this.y)
func zxxz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.x, w: this.z)
func zxy*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.z, y: this.x, z: this.y)
func zxyx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.y, w: this.x)
func zxyy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.y, w: this.y)
func zxyz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.y, w: this.z)
func zxz*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.z, y: this.x, z: this.z)
func zxzx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.z, w: this.x)
func zxzy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.z, w: this.y)
func zxzz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.z, w: this.z)
func zy*(this: LVecBase3i): LVecBase2i = LVecBase2i(x: this.z, y: this.y)
func zyx*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.z, y: this.y, z: this.x)
func zyxx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.x, w: this.x)
func zyxy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.x, w: this.y)
func zyxz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.x, w: this.z)
func zyy*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.z, y: this.y, z: this.y)
func zyyx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.y, w: this.x)
func zyyy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.y, w: this.y)
func zyyz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.y, w: this.z)
func zyz*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.z, y: this.y, z: this.z)
func zyzx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.z, w: this.x)
func zyzy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.z, w: this.y)
func zyzz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.z, w: this.z)
func zz*(this: LVecBase3i): LVecBase2i = LVecBase2i(x: this.z, y: this.z)
func zzx*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.z, y: this.z, z: this.x)
func zzxx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.x, w: this.x)
func zzxy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.x, w: this.y)
func zzxz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.x, w: this.z)
func zzy*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.z, y: this.z, z: this.y)
func zzyx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.y, w: this.x)
func zzyy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.y, w: this.y)
func zzyz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.y, w: this.z)
func zzz*(this: LVecBase3i): LVecBase3i = LVecBase3i(x: this.z, y: this.z, z: this.z)
func zzzx*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.z, w: this.x)
func zzzy*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.z, w: this.y)
func zzzz*(this: LVecBase3i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.z, w: this.z)

func xx*(this: LVecBase4i): LVecBase2i = LVecBase2i(x: this.x, y: this.x)
func xxx*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.x, y: this.x, z: this.x)
func xxxx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.x, w: this.x)
func xxxy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.x, w: this.y)
func xxxz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.x, w: this.z)
func xxxw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.x, w: this.w)
func xxy*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.x, y: this.x, z: this.y)
func xxyx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.y, w: this.x)
func xxyy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.y, w: this.y)
func xxyz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.y, w: this.z)
func xxyw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.y, w: this.w)
func xxz*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.x, y: this.x, z: this.z)
func xxzx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.z, w: this.x)
func xxzy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.z, w: this.y)
func xxzz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.z, w: this.z)
func xxzw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.z, w: this.w)
func xxw*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.x, y: this.x, z: this.w)
func xxwx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.w, w: this.x)
func xxwy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.w, w: this.y)
func xxwz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.w, w: this.z)
func xxww*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.x, z: this.w, w: this.w)
func xy*(this: LVecBase4i): LVecBase2i = LVecBase2i(x: this.x, y: this.y)
func xyx*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.x, y: this.y, z: this.x)
func xyxx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.x, w: this.x)
func xyxy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.x, w: this.y)
func xyxz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.x, w: this.z)
func xyxw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.x, w: this.w)
func xyy*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.x, y: this.y, z: this.y)
func xyyx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.y, w: this.x)
func xyyy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.y, w: this.y)
func xyyz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.y, w: this.z)
func xyyw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.y, w: this.w)
func xyz*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.x, y: this.y, z: this.z)
func xyzx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.z, w: this.x)
func xyzy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.z, w: this.y)
func xyzz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.z, w: this.z)
func xyzw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.z, w: this.w)
func xyw*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.x, y: this.y, z: this.w)
func xywx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.w, w: this.x)
func xywy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.w, w: this.y)
func xywz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.w, w: this.z)
func xyww*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.y, z: this.w, w: this.w)
func xz*(this: LVecBase4i): LVecBase2i = LVecBase2i(x: this.x, y: this.z)
func xzx*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.x, y: this.z, z: this.x)
func xzxx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.x, w: this.x)
func xzxy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.x, w: this.y)
func xzxz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.x, w: this.z)
func xzxw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.x, w: this.w)
func xzy*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.x, y: this.z, z: this.y)
func xzyx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.y, w: this.x)
func xzyy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.y, w: this.y)
func xzyz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.y, w: this.z)
func xzyw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.y, w: this.w)
func xzz*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.x, y: this.z, z: this.z)
func xzzx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.z, w: this.x)
func xzzy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.z, w: this.y)
func xzzz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.z, w: this.z)
func xzzw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.z, w: this.w)
func xzw*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.x, y: this.z, z: this.w)
func xzwx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.w, w: this.x)
func xzwy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.w, w: this.y)
func xzwz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.w, w: this.z)
func xzww*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.z, z: this.w, w: this.w)
func xw*(this: LVecBase4i): LVecBase2i = LVecBase2i(x: this.x, y: this.w)
func xwx*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.x, y: this.w, z: this.x)
func xwxx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.w, z: this.x, w: this.x)
func xwxy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.w, z: this.x, w: this.y)
func xwxz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.w, z: this.x, w: this.z)
func xwxw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.w, z: this.x, w: this.w)
func xwy*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.x, y: this.w, z: this.y)
func xwyx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.w, z: this.y, w: this.x)
func xwyy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.w, z: this.y, w: this.y)
func xwyz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.w, z: this.y, w: this.z)
func xwyw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.w, z: this.y, w: this.w)
func xwz*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.x, y: this.w, z: this.z)
func xwzx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.w, z: this.z, w: this.x)
func xwzy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.w, z: this.z, w: this.y)
func xwzz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.w, z: this.z, w: this.z)
func xwzw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.w, z: this.z, w: this.w)
func xww*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.x, y: this.w, z: this.w)
func xwwx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.w, z: this.w, w: this.x)
func xwwy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.w, z: this.w, w: this.y)
func xwwz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.w, z: this.w, w: this.z)
func xwww*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.x, y: this.w, z: this.w, w: this.w)
func yx*(this: LVecBase4i): LVecBase2i = LVecBase2i(x: this.y, y: this.x)
func yxx*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.y, y: this.x, z: this.x)
func yxxx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.x, w: this.x)
func yxxy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.x, w: this.y)
func yxxz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.x, w: this.z)
func yxxw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.x, w: this.w)
func yxy*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.y, y: this.x, z: this.y)
func yxyx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.y, w: this.x)
func yxyy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.y, w: this.y)
func yxyz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.y, w: this.z)
func yxyw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.y, w: this.w)
func yxz*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.y, y: this.x, z: this.z)
func yxzx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.z, w: this.x)
func yxzy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.z, w: this.y)
func yxzz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.z, w: this.z)
func yxzw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.z, w: this.w)
func yxw*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.y, y: this.x, z: this.w)
func yxwx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.w, w: this.x)
func yxwy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.w, w: this.y)
func yxwz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.w, w: this.z)
func yxww*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.x, z: this.w, w: this.w)
func yy*(this: LVecBase4i): LVecBase2i = LVecBase2i(x: this.y, y: this.y)
func yyx*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.y, y: this.y, z: this.x)
func yyxx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.x, w: this.x)
func yyxy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.x, w: this.y)
func yyxz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.x, w: this.z)
func yyxw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.x, w: this.w)
func yyy*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.y, y: this.y, z: this.y)
func yyyx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.y, w: this.x)
func yyyy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.y, w: this.y)
func yyyz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.y, w: this.z)
func yyyw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.y, w: this.w)
func yyz*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.y, y: this.y, z: this.z)
func yyzx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.z, w: this.x)
func yyzy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.z, w: this.y)
func yyzz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.z, w: this.z)
func yyzw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.z, w: this.w)
func yyw*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.y, y: this.y, z: this.w)
func yywx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.w, w: this.x)
func yywy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.w, w: this.y)
func yywz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.w, w: this.z)
func yyww*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.y, z: this.w, w: this.w)
func yz*(this: LVecBase4i): LVecBase2i = LVecBase2i(x: this.y, y: this.z)
func yzx*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.y, y: this.z, z: this.x)
func yzxx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.x, w: this.x)
func yzxy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.x, w: this.y)
func yzxz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.x, w: this.z)
func yzxw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.x, w: this.w)
func yzy*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.y, y: this.z, z: this.y)
func yzyx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.y, w: this.x)
func yzyy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.y, w: this.y)
func yzyz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.y, w: this.z)
func yzyw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.y, w: this.w)
func yzz*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.y, y: this.z, z: this.z)
func yzzx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.z, w: this.x)
func yzzy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.z, w: this.y)
func yzzz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.z, w: this.z)
func yzzw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.z, w: this.w)
func yzw*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.y, y: this.z, z: this.w)
func yzwx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.w, w: this.x)
func yzwy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.w, w: this.y)
func yzwz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.w, w: this.z)
func yzww*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.z, z: this.w, w: this.w)
func yw*(this: LVecBase4i): LVecBase2i = LVecBase2i(x: this.y, y: this.w)
func ywx*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.y, y: this.w, z: this.x)
func ywxx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.w, z: this.x, w: this.x)
func ywxy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.w, z: this.x, w: this.y)
func ywxz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.w, z: this.x, w: this.z)
func ywxw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.w, z: this.x, w: this.w)
func ywy*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.y, y: this.w, z: this.y)
func ywyx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.w, z: this.y, w: this.x)
func ywyy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.w, z: this.y, w: this.y)
func ywyz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.w, z: this.y, w: this.z)
func ywyw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.w, z: this.y, w: this.w)
func ywz*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.y, y: this.w, z: this.z)
func ywzx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.w, z: this.z, w: this.x)
func ywzy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.w, z: this.z, w: this.y)
func ywzz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.w, z: this.z, w: this.z)
func ywzw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.w, z: this.z, w: this.w)
func yww*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.y, y: this.w, z: this.w)
func ywwx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.w, z: this.w, w: this.x)
func ywwy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.w, z: this.w, w: this.y)
func ywwz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.w, z: this.w, w: this.z)
func ywww*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.y, y: this.w, z: this.w, w: this.w)
func zx*(this: LVecBase4i): LVecBase2i = LVecBase2i(x: this.z, y: this.x)
func zxx*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.z, y: this.x, z: this.x)
func zxxx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.x, w: this.x)
func zxxy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.x, w: this.y)
func zxxz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.x, w: this.z)
func zxxw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.x, w: this.w)
func zxy*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.z, y: this.x, z: this.y)
func zxyx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.y, w: this.x)
func zxyy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.y, w: this.y)
func zxyz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.y, w: this.z)
func zxyw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.y, w: this.w)
func zxz*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.z, y: this.x, z: this.z)
func zxzx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.z, w: this.x)
func zxzy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.z, w: this.y)
func zxzz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.z, w: this.z)
func zxzw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.z, w: this.w)
func zxw*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.z, y: this.x, z: this.w)
func zxwx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.w, w: this.x)
func zxwy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.w, w: this.y)
func zxwz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.w, w: this.z)
func zxww*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.x, z: this.w, w: this.w)
func zy*(this: LVecBase4i): LVecBase2i = LVecBase2i(x: this.z, y: this.y)
func zyx*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.z, y: this.y, z: this.x)
func zyxx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.x, w: this.x)
func zyxy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.x, w: this.y)
func zyxz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.x, w: this.z)
func zyxw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.x, w: this.w)
func zyy*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.z, y: this.y, z: this.y)
func zyyx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.y, w: this.x)
func zyyy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.y, w: this.y)
func zyyz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.y, w: this.z)
func zyyw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.y, w: this.w)
func zyz*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.z, y: this.y, z: this.z)
func zyzx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.z, w: this.x)
func zyzy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.z, w: this.y)
func zyzz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.z, w: this.z)
func zyzw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.z, w: this.w)
func zyw*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.z, y: this.y, z: this.w)
func zywx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.w, w: this.x)
func zywy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.w, w: this.y)
func zywz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.w, w: this.z)
func zyww*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.y, z: this.w, w: this.w)
func zz*(this: LVecBase4i): LVecBase2i = LVecBase2i(x: this.z, y: this.z)
func zzx*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.z, y: this.z, z: this.x)
func zzxx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.x, w: this.x)
func zzxy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.x, w: this.y)
func zzxz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.x, w: this.z)
func zzxw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.x, w: this.w)
func zzy*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.z, y: this.z, z: this.y)
func zzyx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.y, w: this.x)
func zzyy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.y, w: this.y)
func zzyz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.y, w: this.z)
func zzyw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.y, w: this.w)
func zzz*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.z, y: this.z, z: this.z)
func zzzx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.z, w: this.x)
func zzzy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.z, w: this.y)
func zzzz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.z, w: this.z)
func zzzw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.z, w: this.w)
func zzw*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.z, y: this.z, z: this.w)
func zzwx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.w, w: this.x)
func zzwy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.w, w: this.y)
func zzwz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.w, w: this.z)
func zzww*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.z, z: this.w, w: this.w)
func zw*(this: LVecBase4i): LVecBase2i = LVecBase2i(x: this.z, y: this.w)
func zwx*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.z, y: this.w, z: this.x)
func zwxx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.w, z: this.x, w: this.x)
func zwxy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.w, z: this.x, w: this.y)
func zwxz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.w, z: this.x, w: this.z)
func zwxw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.w, z: this.x, w: this.w)
func zwy*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.z, y: this.w, z: this.y)
func zwyx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.w, z: this.y, w: this.x)
func zwyy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.w, z: this.y, w: this.y)
func zwyz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.w, z: this.y, w: this.z)
func zwyw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.w, z: this.y, w: this.w)
func zwz*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.z, y: this.w, z: this.z)
func zwzx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.w, z: this.z, w: this.x)
func zwzy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.w, z: this.z, w: this.y)
func zwzz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.w, z: this.z, w: this.z)
func zwzw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.w, z: this.z, w: this.w)
func zww*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.z, y: this.w, z: this.w)
func zwwx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.w, z: this.w, w: this.x)
func zwwy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.w, z: this.w, w: this.y)
func zwwz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.w, z: this.w, w: this.z)
func zwww*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.z, y: this.w, z: this.w, w: this.w)
func wx*(this: LVecBase4i): LVecBase2i = LVecBase2i(x: this.w, y: this.x)
func wxx*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.w, y: this.x, z: this.x)
func wxxx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.x, z: this.x, w: this.x)
func wxxy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.x, z: this.x, w: this.y)
func wxxz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.x, z: this.x, w: this.z)
func wxxw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.x, z: this.x, w: this.w)
func wxy*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.w, y: this.x, z: this.y)
func wxyx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.x, z: this.y, w: this.x)
func wxyy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.x, z: this.y, w: this.y)
func wxyz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.x, z: this.y, w: this.z)
func wxyw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.x, z: this.y, w: this.w)
func wxz*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.w, y: this.x, z: this.z)
func wxzx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.x, z: this.z, w: this.x)
func wxzy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.x, z: this.z, w: this.y)
func wxzz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.x, z: this.z, w: this.z)
func wxzw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.x, z: this.z, w: this.w)
func wxw*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.w, y: this.x, z: this.w)
func wxwx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.x, z: this.w, w: this.x)
func wxwy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.x, z: this.w, w: this.y)
func wxwz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.x, z: this.w, w: this.z)
func wxww*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.x, z: this.w, w: this.w)
func wy*(this: LVecBase4i): LVecBase2i = LVecBase2i(x: this.w, y: this.y)
func wyx*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.w, y: this.y, z: this.x)
func wyxx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.y, z: this.x, w: this.x)
func wyxy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.y, z: this.x, w: this.y)
func wyxz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.y, z: this.x, w: this.z)
func wyxw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.y, z: this.x, w: this.w)
func wyy*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.w, y: this.y, z: this.y)
func wyyx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.y, z: this.y, w: this.x)
func wyyy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.y, z: this.y, w: this.y)
func wyyz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.y, z: this.y, w: this.z)
func wyyw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.y, z: this.y, w: this.w)
func wyz*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.w, y: this.y, z: this.z)
func wyzx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.y, z: this.z, w: this.x)
func wyzy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.y, z: this.z, w: this.y)
func wyzz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.y, z: this.z, w: this.z)
func wyzw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.y, z: this.z, w: this.w)
func wyw*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.w, y: this.y, z: this.w)
func wywx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.y, z: this.w, w: this.x)
func wywy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.y, z: this.w, w: this.y)
func wywz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.y, z: this.w, w: this.z)
func wyww*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.y, z: this.w, w: this.w)
func wz*(this: LVecBase4i): LVecBase2i = LVecBase2i(x: this.w, y: this.z)
func wzx*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.w, y: this.z, z: this.x)
func wzxx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.z, z: this.x, w: this.x)
func wzxy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.z, z: this.x, w: this.y)
func wzxz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.z, z: this.x, w: this.z)
func wzxw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.z, z: this.x, w: this.w)
func wzy*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.w, y: this.z, z: this.y)
func wzyx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.z, z: this.y, w: this.x)
func wzyy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.z, z: this.y, w: this.y)
func wzyz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.z, z: this.y, w: this.z)
func wzyw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.z, z: this.y, w: this.w)
func wzz*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.w, y: this.z, z: this.z)
func wzzx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.z, z: this.z, w: this.x)
func wzzy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.z, z: this.z, w: this.y)
func wzzz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.z, z: this.z, w: this.z)
func wzzw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.z, z: this.z, w: this.w)
func wzw*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.w, y: this.z, z: this.w)
func wzwx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.z, z: this.w, w: this.x)
func wzwy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.z, z: this.w, w: this.y)
func wzwz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.z, z: this.w, w: this.z)
func wzww*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.z, z: this.w, w: this.w)
func ww*(this: LVecBase4i): LVecBase2i = LVecBase2i(x: this.w, y: this.w)
func wwx*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.w, y: this.w, z: this.x)
func wwxx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.w, z: this.x, w: this.x)
func wwxy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.w, z: this.x, w: this.y)
func wwxz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.w, z: this.x, w: this.z)
func wwxw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.w, z: this.x, w: this.w)
func wwy*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.w, y: this.w, z: this.y)
func wwyx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.w, z: this.y, w: this.x)
func wwyy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.w, z: this.y, w: this.y)
func wwyz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.w, z: this.y, w: this.z)
func wwyw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.w, z: this.y, w: this.w)
func wwz*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.w, y: this.w, z: this.z)
func wwzx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.w, z: this.z, w: this.x)
func wwzy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.w, z: this.z, w: this.y)
func wwzz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.w, z: this.z, w: this.z)
func wwzw*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.w, z: this.z, w: this.w)
func www*(this: LVecBase4i): LVecBase3i = LVecBase3i(x: this.w, y: this.w, z: this.w)
func wwwx*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.w, z: this.w, w: this.x)
func wwwy*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.w, z: this.w, w: this.y)
func wwwz*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.w, z: this.w, w: this.z)
func wwww*(this: LVecBase4i): LVecBase4i = LVecBase4i(x: this.w, y: this.w, z: this.w, w: this.w)
